id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp:88,Testability,test,test,88,"// It should still be possible to run the inliner as a stand-alone module; // pass, for test scenarios. In that case, we default to the; // DefaultInlineAdvisor, which doesn't need to keep state between module; // pass runs. It also uses just the default InlineParams. In this case, we; // need to use the provided FAM, which is valid for the duration of the; // inliner pass, and thus the lifetime of the owned advisor. The one we; // would get from the MAM can be invalidated as a result of the inliner's; // activity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp:512,Modifiability,refactor,refactoring,512,"// In the module inliner, a priority-based worklist is used for calls across; // the entire Module. With this module inliner, the inline order is not; // limited to bottom-up order. More globally scope inline order is enabled.; // Also, the inline deferral logic become unnecessary in this module inliner.; // It is possible to use other priority heuristics, e.g. profile-based; // heuristic.; //; // TODO: Here is a huge amount duplicate code between the module inliner and; // the SCC inliner, which need some refactoring.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp:257,Testability,log,logic,257,"// In the module inliner, a priority-based worklist is used for calls across; // the entire Module. With this module inliner, the inline order is not; // limited to bottom-up order. More globally scope inline order is enabled.; // Also, the inline deferral logic become unnecessary in this module inliner.; // It is possible to use other priority heuristics, e.g. profile-based; // heuristic.; //; // TODO: Here is a huge amount duplicate code between the module inliner and; // the SCC inliner, which need some refactoring.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp:147,Safety,avoid,avoid,147,"// When inlining a callee produces new call sites, we want to keep track of; // the fact that they were inlined from the callee. This allows us to avoid; // infinite inlining in some obscure cases. To represent this, we use an; // index into the InlineHistory vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp:144,Deployability,update,updates,144,// Track the dead functions to delete once finished with inlining calls. We; // defer deleting these to make it easier to handle the call graph updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp:86,Integrability,rout,routine,86,// Setup the data structure used to plumb customization into the; // `InlineFunction` routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp:153,Energy Efficiency,reduce,reduce,153,"// For local functions, check whether this makes the callee trivially; // dead. In that case, we can drop the body of the function eagerly; // which may reduce the number of callers of other functions to one,; // changing inline cost thresholds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp:131,Availability,error,error,131,"// Clear the body and queue the function itself for deletion when we; // finish inlining.; // Note that after this point, it is an error to do anything other; // than use the callee's address or delete it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp:22,Performance,queue,queue,22,"// Clear the body and queue the function itself for deletion when we; // finish inlining.; // Note that after this point, it is an error to do anything other; // than use the callee's address or delete it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp:3,Usability,Clear,Clear,3,"// Clear the body and queue the function itself for deletion when we; // finish inlining.; // Note that after this point, it is an error to do anything other; // than use the callee's address or delete it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp:17,Performance,cache,cached,17,// Clear out any cached analyses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp:3,Usability,Clear,Clear,3,// Clear out any cached analyses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:58,Performance,optimiz,optimizations,58,"//===-- IPO/OpenMPOpt.cpp - Collection of OpenMP specific optimizations ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // OpenMP specific optimizations:; //; // - Deduplication of runtime calls, e.g., omp_get_thread_num.; // - Replacing globalized device memory with stack memory.; // - Replacing globalized device memory with shared memory.; // - Parallel region merging.; // - Transforming generic-mode device kernels to SPMD mode.; // - Specializing the state machine for generic-mode device kernels.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:399,Performance,optimiz,optimizations,399,"//===-- IPO/OpenMPOpt.cpp - Collection of OpenMP specific optimizations ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // OpenMP specific optimizations:; //; // - Deduplication of runtime calls, e.g., omp_get_thread_num.; // - Replacing globalized device memory with stack memory.; // - Replacing globalized device memory with shared memory.; // - Parallel region merging.; // - Transforming generic-mode device kernels to SPMD mode.; // - Specializing the state machine for generic-mode device kernels.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:10,Deployability,Configurat,ConfigurationEnvironmentTy,10,// struct ConfigurationEnvironmentTy {; // uint8_t UseGenericStateMachine;; // uint8_t MayUseNestedParallelism;; // llvm::omp::OMPTgtExecModeFlags ExecMode;; // int32_t MinThreads;; // int32_t MaxThreads;; // int32_t MinTeams;; // int32_t MaxTeams;; // };; // struct DynamicEnvironmentTy {; // uint16_t DebugIndentionLevel;; // };; // struct KernelEnvironmentTy {; // ConfigurationEnvironmentTy Configuration;; // IdentTy *Ident;; // DynamicEnvironmentTy *DynamicEnv;; // };,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:368,Deployability,Configurat,ConfigurationEnvironmentTy,368,// struct ConfigurationEnvironmentTy {; // uint8_t UseGenericStateMachine;; // uint8_t MayUseNestedParallelism;; // llvm::omp::OMPTgtExecModeFlags ExecMode;; // int32_t MinThreads;; // int32_t MaxThreads;; // int32_t MinTeams;; // int32_t MaxTeams;; // };; // struct DynamicEnvironmentTy {; // uint16_t DebugIndentionLevel;; // };; // struct KernelEnvironmentTy {; // ConfigurationEnvironmentTy Configuration;; // IdentTy *Ident;; // DynamicEnvironmentTy *DynamicEnv;; // };,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:395,Deployability,Configurat,Configuration,395,// struct ConfigurationEnvironmentTy {; // uint8_t UseGenericStateMachine;; // uint8_t MayUseNestedParallelism;; // llvm::omp::OMPTgtExecModeFlags ExecMode;; // int32_t MinThreads;; // int32_t MaxThreads;; // int32_t MinTeams;; // int32_t MaxTeams;; // };; // struct DynamicEnvironmentTy {; // uint16_t DebugIndentionLevel;; // };; // struct KernelEnvironmentTy {; // ConfigurationEnvironmentTy Configuration;; // IdentTy *Ident;; // DynamicEnvironmentTy *DynamicEnv;; // };,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:10,Modifiability,Config,ConfigurationEnvironmentTy,10,// struct ConfigurationEnvironmentTy {; // uint8_t UseGenericStateMachine;; // uint8_t MayUseNestedParallelism;; // llvm::omp::OMPTgtExecModeFlags ExecMode;; // int32_t MinThreads;; // int32_t MaxThreads;; // int32_t MinTeams;; // int32_t MaxTeams;; // };; // struct DynamicEnvironmentTy {; // uint16_t DebugIndentionLevel;; // };; // struct KernelEnvironmentTy {; // ConfigurationEnvironmentTy Configuration;; // IdentTy *Ident;; // DynamicEnvironmentTy *DynamicEnv;; // };,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:368,Modifiability,Config,ConfigurationEnvironmentTy,368,// struct ConfigurationEnvironmentTy {; // uint8_t UseGenericStateMachine;; // uint8_t MayUseNestedParallelism;; // llvm::omp::OMPTgtExecModeFlags ExecMode;; // int32_t MinThreads;; // int32_t MaxThreads;; // int32_t MinTeams;; // int32_t MaxTeams;; // };; // struct DynamicEnvironmentTy {; // uint16_t DebugIndentionLevel;; // };; // struct KernelEnvironmentTy {; // ConfigurationEnvironmentTy Configuration;; // IdentTy *Ident;; // DynamicEnvironmentTy *DynamicEnv;; // };,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:395,Modifiability,Config,Configuration,395,// struct ConfigurationEnvironmentTy {; // uint8_t UseGenericStateMachine;; // uint8_t MayUseNestedParallelism;; // llvm::omp::OMPTgtExecModeFlags ExecMode;; // int32_t MinThreads;; // int32_t MaxThreads;; // int32_t MinTeams;; // int32_t MaxTeams;; // };; // struct DynamicEnvironmentTy {; // uint16_t DebugIndentionLevel;; // };; // struct KernelEnvironmentTy {; // ConfigurationEnvironmentTy Configuration;; // IdentTy *Ident;; // DynamicEnvironmentTy *DynamicEnv;; // };,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:59,Modifiability,variab,variable,59,/// Generic information that describes an internal control variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:16,Modifiability,variab,variable,16,/// Environment variable associated with this ICV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:23,Availability,avail,available,23,/// The declaration if available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:4,Usability,Clear,Clear,4,/// Clear UsesMap for runtime function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:46,Modifiability,variab,variable,46,/// Helper to initialize all internal control variable information for those; /// defined in OMPKinds.def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:22,Modifiability,inherit,inherit,22,// Helper function to inherit the calling convention of the function callee.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:89,Safety,abort,abort,89,"/// The __kmpc_target_init call in this kernel, if any. If we find more than; /// one we abort as the kernel is malformed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:91,Safety,abort,abort,91,"/// The __kmpc_target_deinit call in this kernel, if any. If we find more than; /// one we abort as the kernel is malformed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:19,Integrability,interface,interface,19,/// Abstract State interface; ///{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:19,Performance,optimiz,optimizations,19,/// Run all OpenMP optimizations on the underlying SCC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:33,Testability,test,testing,33,/// Print initial ICV values for testing.; /// FIXME: This should be done from the Attributor once it is added.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:33,Testability,test,testing,33,/// Print OpenMP GPU kernels for testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:38,Safety,safe,safe,38,/// Merge parallel regions when it is safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:133,Integrability,synchroniz,synchronization,133,"/// Create a sequential execution region within a merged parallel region,; /// encapsulated in a master construct with a barrier for synchronization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:52,Deployability,update,update,52,// Emit a store instruction in the sequential BB to update the; // value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:10,Performance,load,load,10,// Emit a load instruction and replace the use of the output value; // with it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:146,Availability,redundant,redundantly,146,// Helper to merge the __kmpc_fork_call calls in MergableCIs. They are all; // contained in BB and only separated by instructions that can be; // redundantly executed in parallel. The block BB is split before the first; // call (in MergableCIs) and after the last so the entire region we merge; // into a single parallel region is contained in a single basic block; // without any other instructions. We use the OpenMPIRBuilder to outline; // that block and call the resulting function via __kmpc_fork_call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:146,Safety,redund,redundantly,146,// Helper to merge the __kmpc_fork_call calls in MergableCIs. They are all; // contained in BB and only separated by instructions that can be; // redundantly executed in parallel. The block BB is split before the first; // call (in MergableCIs) and after the last so the entire region we merge; // into a single parallel region is contained in a single basic block; // without any other instructions. We use the OpenMPIRBuilder to outline; // that block and call the resulting function via __kmpc_fork_call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:20,Integrability,interface,interface,20,"// TODO: Change the interface to allow single CIs expanded, e.g, to; // include an outer loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:71,Safety,avoid,avoid,71,"// Create the merged parallel region with default proc binding, to; // avoid overriding binding settings, and without explicit cancellation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:3,Performance,Perform,Perform,3,// Perform the actual outlining.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:68,Safety,safe,safe,68,"// Find mergable parallel regions within a basic block that are; // safe to merge, that is any in-between instructions can safely; // execute in parallel after merging.; // TODO: support merging across basic-blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:123,Safety,safe,safely,123,"// Find mergable parallel regions within a basic block that are; // safe to merge, that is any in-between instructions can safely; // execute in parallel after merging.; // TODO: support merging across basic-blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:277,Safety,detect,detect,277,// Return false (unmergable) if the call before the parallel; // region calls an explicit affinity (proc_bind) or number of; // threads (num_threads) compiler-generated function. Those settings; // may be incompatible with following parallel regions.; // TODO: ICV tracking to detect compatibility.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:55,Safety,safe,safe,55,// Find maximal number of parallel region CIs that are safe to merge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:125,Performance,optimiz,optimized,125,// The RPC client symbol is defined in `libc` and indicates that something; // required an RPC server. If its users were all optimized out then we can; // safely remove it.; // TODO: This should be somewhere more common in the future.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:155,Safety,safe,safely,155,// The RPC client symbol is defined in `libc` and indicates that something; // required an RPC server. If its users were all optimized out then we can; // safely remove it.; // TODO: This should be somewhere more common in the future.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:235,Availability,down,downards,235,"/// Tries to hide the latency of runtime calls that involve host to; /// device memory transfers by splitting them into their ""issue"" and ""wait""; /// versions. The ""issue"" is moved upwards as much as possible. The ""wait"" is; /// moved downards as much as possible. The ""issue"" issues the memory transfer; /// asynchronously, returning a handle. The ""wait"" waits in the returned; /// handle for the memory transfer to finish.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:22,Performance,latency,latency,22,"/// Tries to hide the latency of runtime calls that involve host to; /// device memory transfers by splitting them into their ""issue"" and ""wait""; /// versions. The ""issue"" is moved upwards as much as possible. The ""wait"" is; /// moved downards as much as possible. The ""issue"" issues the memory transfer; /// asynchronously, returning a handle. The ""wait"" waits in the returned; /// handle for the memory transfer to finish.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:255,Energy Efficiency,allocate,allocate,255,"// A runtime call that involves memory offloading looks something like:; // call void @__tgt_target_data_begin_mapper(arg0, arg1,; // i8** %offload_baseptrs, i8** %offload_ptrs, i64* %offload_sizes,; // ...); // So, the idea is to access the allocas that allocate space for these; // offload arrays, offload_baseptrs, offload_ptrs, offload_sizes.; // Therefore:; // i8** %offload_baseptrs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:231,Security,access,access,231,"// A runtime call that involves memory offloading looks something like:; // call void @__tgt_target_data_begin_mapper(arg0, arg1,; // i8** %offload_baseptrs, i8** %offload_ptrs, i64* %offload_sizes,; // ...); // So, the idea is to access the allocas that allocate space for these; // offload arrays, offload_baseptrs, offload_ptrs, offload_sizes.; // Therefore:; // i8** %offload_baseptrs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:226,Availability,avail,available,226,/// Prints the values in the OffloadArrays \p OAs using LLVM_DEBUG.; /// For now this is a way to test that the function getValuesInOffloadArrays; /// is working properly.; /// TODO: Move this to a unittest when unittests are available for OpenMPOpt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:98,Testability,test,test,98,/// Prints the values in the OffloadArrays \p OAs using LLVM_DEBUG.; /// For now this is a way to test that the function getValuesInOffloadArrays; /// is working properly.; /// TODO: Move this to a unittest when unittests are available for OpenMPOpt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:17,Safety,detect,detect,17,// TODO: Once we detect the regions to be offloaded we should use the; // alias analysis manager to check if CurrentI may modify one of; // the offloaded regions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:16,Energy Efficiency,allocate,allocated,16,"// Create stack allocated handle (__tgt_async_info) at the beginning of the; // function. Used for storing information of the async transfer, allowing to; // wait on it later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:28,Performance,perform,perform,28,// TODO: Below we basically perform a fixpoint iteration with a pessimistic; // initialization. We could define an AbstractAttribute instead and; // run the Attributor here once it can be run as an SCC pass.; // Helper to check the argument \p ArgNo at all call sites of \p F for; // a GTId.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:140,Modifiability,extend,extended,140,// Transitively search for more arguments by looking at the users of the; // ones we know already. During the search the GTIdArgs vector is extended; // so we cannot cache the size nor can we use a range based for.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:166,Performance,cache,cache,166,// Transitively search for more arguments by looking at the users of the; // ones we know already. During the search the GTIdArgs vector is extended; // so we cannot cache the size nor can we use a range based for.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:18,Performance,optimiz,optimizations,18,/// Kernel (=GPU) optimizations and utility functions; ///; ///{{; /// Cache to remember the unique kernel for a function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:71,Performance,Cache,Cache,71,/// Kernel (=GPU) optimizations and utility functions; ///; ///{{; /// Cache to remember the unique kernel for a function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:4,Modifiability,Rewrite,Rewrite,4,/// Rewrite the device (=GPU) code state machine create in non-SPMD mode in; /// the cases we can avoid taking the address of a function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:98,Safety,avoid,avoid,98,/// Rewrite the device (=GPU) code state machine create in non-SPMD mode in; /// the cases we can avoid taking the address of a function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:176,Performance,Optimiz,OptimizationRemark,176,///; ///}}; /// Emit a remark generically; ///; /// This template function can be used to generically emit a remark. The; /// RemarkKind should be one of the following:; /// - OptimizationRemark to indicate a successful optimization attempt; /// - OptimizationRemarkMissed to report a failed optimization attempt; /// - OptimizationRemarkAnalysis to provide additional information about an; /// optimization attempt; ///; /// The remark is built using a callback function provided by the caller that; /// takes a RemarkKind as input and returns a RemarkKind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:220,Performance,optimiz,optimization,220,///; ///}}; /// Emit a remark generically; ///; /// This template function can be used to generically emit a remark. The; /// RemarkKind should be one of the following:; /// - OptimizationRemark to indicate a successful optimization attempt; /// - OptimizationRemarkMissed to report a failed optimization attempt; /// - OptimizationRemarkAnalysis to provide additional information about an; /// optimization attempt; ///; /// The remark is built using a callback function provided by the caller that; /// takes a RemarkKind as input and returns a RemarkKind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:248,Performance,Optimiz,OptimizationRemarkMissed,248,///; ///}}; /// Emit a remark generically; ///; /// This template function can be used to generically emit a remark. The; /// RemarkKind should be one of the following:; /// - OptimizationRemark to indicate a successful optimization attempt; /// - OptimizationRemarkMissed to report a failed optimization attempt; /// - OptimizationRemarkAnalysis to provide additional information about an; /// optimization attempt; ///; /// The remark is built using a callback function provided by the caller that; /// takes a RemarkKind as input and returns a RemarkKind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:292,Performance,optimiz,optimization,292,///; ///}}; /// Emit a remark generically; ///; /// This template function can be used to generically emit a remark. The; /// RemarkKind should be one of the following:; /// - OptimizationRemark to indicate a successful optimization attempt; /// - OptimizationRemarkMissed to report a failed optimization attempt; /// - OptimizationRemarkAnalysis to provide additional information about an; /// optimization attempt; ///; /// The remark is built using a callback function provided by the caller that; /// takes a RemarkKind as input and returns a RemarkKind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:320,Performance,Optimiz,OptimizationRemarkAnalysis,320,///; ///}}; /// Emit a remark generically; ///; /// This template function can be used to generically emit a remark. The; /// RemarkKind should be one of the following:; /// - OptimizationRemark to indicate a successful optimization attempt; /// - OptimizationRemarkMissed to report a failed optimization attempt; /// - OptimizationRemarkAnalysis to provide additional information about an; /// optimization attempt; ///; /// The remark is built using a callback function provided by the caller that; /// takes a RemarkKind as input and returns a RemarkKind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:395,Performance,optimiz,optimization,395,///; ///}}; /// Emit a remark generically; ///; /// This template function can be used to generically emit a remark. The; /// RemarkKind should be one of the following:; /// - OptimizationRemark to indicate a successful optimization attempt; /// - OptimizationRemarkMissed to report a failed optimization attempt; /// - OptimizationRemarkAnalysis to provide additional information about an; /// optimization attempt; ///; /// The remark is built using a callback function provided by the caller that; /// takes a RemarkKind as input and returns a RemarkKind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:16,Deployability,update,update,16,"/// Callback to update the call graph, the first argument is a removed call,; /// the second an optional replacement call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:23,Performance,Optimiz,OptimizationRemarkEmitter,23,/// Callback to get an OptimizationRemarkEmitter from a Function *,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:32,Performance,cache,cache,32,/// OpenMP-specific information cache. Also Used for Attributor runs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:43,Performance,Cache,CachedKernel,43,// Use a scope to keep the lifetime of the CachedKernel short.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:149,Energy Efficiency,power,powerful,149,"// TODO: We should use an AA to create an (optimistic and callback; // call-aware) call graph. For now we stick to simple patterns that; // are less powerful, basically the worst fixpoint.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:115,Usability,simpl,simple,115,"// TODO: We should use an AA to create an (optimistic and callback; // call-aware) call graph. For now we stick to simple patterns that; // are less powerful, basically the worst fixpoint.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:39,Performance,Optimiz,OptimizationRemarks,39,// See https://openmp.llvm.org/remarks/OptimizationRemarks.html,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:3,Performance,Cache,Cache,3,// Cache the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:8,Integrability,wrap,wrapper,8,// Find wrapper functions that represent parallel kernels.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:131,Usability,clear,clear,131,"/// Return an assumed unique ICV value if a single candidate is found. If; /// there cannot be one, return a nullptr. If it is not clear yet, return; /// std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:30,Safety,avoid,avoid,30,/// TODO: Figure out a way to avoid adding entry in; /// ICVReplacementValuesMap,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:103,Safety,avoid,avoid,103,// If we actually eliminated a barrier we need to eliminate the associated; // llvm.assumes as well to avoid creating UB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:10,Integrability,interface,interface,10,"/// Query interface, see AAExecutionDomain; ///{",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:65,Safety,detect,detection,65,// Delayed decision on the forward pass to allow aligned barrier detection; // in the backwards traversal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:10,Deployability,update,update,10,"// First, update the barrier ED kept in the separate CEDMap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:3,Deployability,Update,Update,3,// Update the state with the new value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:3,Deployability,Update,Update,3,// Update free call users of found malloc calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:41,Usability,simpl,simple,41,"/// The callee value is tracked beyond a simple stripPointerCasts, so we allow; /// unknown callees.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:157,Safety,avoid,avoid,157,// This is a high-level transform that might change the constant arguments; // of the init and dinit calls. We need to tell the Attributor about this; // to avoid other parts using the current constant value for simpliication.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:212,Usability,simpl,simpliication,212,// This is a high-level transform that might change the constant arguments; // of the init and dinit calls. We need to tell the Attributor about this; // to avoid other parts using the current constant value for simpliication.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:18,Performance,perform,perform,18,"// For kernels we perform more initialization work, first we find the init; // and deinit calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:30,Deployability,update,updates,30,// Add a dependence to ensure updates if the state changes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:9,Integrability,depend,dependence,9,// Add a dependence to ensure updates if the state changes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:26,Modifiability,rewrite,rewrite,26,// Not needed if we can't rewrite due to an invalid state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:16,Performance,perform,perform,16,// If we do not perform SPMDzation we do not need the virtual uses below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:15,Performance,perform,perform,15,// Whenever we perform SPMDzation we will insert; // __kmpc_get_hardware_thread_id_in_block calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:15,Performance,perform,perform,15,"// Whenever we perform SPMDzation with guarding we will insert; // __kmpc_simple_barrier_spmd calls. If SPMDzation failed, there is; // nothing to guard, or there are no parallel regions, we don't need; // the calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:4,Security,Sanitiz,Sanitize,4,/// Sanitize the string \p S such that it is a suitable global symbol name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:12,Deployability,update,update,12,"// At last, update the KernelEnvc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:458,Performance,load,load,458,// Create all the blocks and logic.; // ParentBB:; // goto RegionCheckTidBB; // RegionCheckTidBB:; // Tid = __kmpc_hardware_thread_id(); // if (Tid != 0); // goto RegionBarrierBB; // RegionStartBB:; // <execute instructions guarded>; // goto RegionEndBB; // RegionEndBB:; // <store escaping values to shared mem>; // goto RegionBarrierBB; // RegionBarrierBB:; // __kmpc_simple_barrier_spmd(); // // second barrier is omitted if lacking escaping values.; // <load escaping values from shared mem>; // __kmpc_simple_barrier_spmd(); // goto RegionExitBB; // RegionExitBB:; // <execute rest of instructions>,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:29,Testability,log,logic,29,// Create all the blocks and logic.; // ParentBB:; // goto RegionCheckTidBB; // RegionCheckTidBB:; // Tid = __kmpc_hardware_thread_id(); // if (Tid != 0); // goto RegionBarrierBB; // RegionStartBB:; // <execute instructions guarded>; // goto RegionEndBB; // RegionEndBB:; // <store escaping values to shared mem>; // goto RegionBarrierBB; // RegionBarrierBB:; // __kmpc_simple_barrier_spmd(); // // second barrier is omitted if lacking escaping values.; // <load escaping values from shared mem>; // __kmpc_simple_barrier_spmd(); // goto RegionExitBB; // RegionExitBB:; // <execute rest of instructions>,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:17,Modifiability,variab,variable,17,// Emit a global variable in shared memory to store the broadcasted; // value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:31,Deployability,update,update,31,// Emit a store instruction to update the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:10,Performance,load,load,10,// Emit a load instruction and replace uses of the output value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:62,Deployability,update,updated,62,"// First barrier for synchronization, ensures main thread has updated; // values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:21,Integrability,synchroniz,synchronization,21,"// First barrier for synchronization, ensures main thread has updated; // values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:40,Deployability,update,update,40,// If instruction I needs to be guarded update the guarded region; // bounds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:65,Availability,avail,availible,65,// We cannot change to SPMD mode if the runtime functions aren't availible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:89,Integrability,wrap,wrapper,89,"// Get the actual kernel, could be the caller of the anchor scope if we have; // a debug wrapper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:37,Modifiability,rewrite,rewrites,37,"// If we have disabled state machine rewrites, don't make a custom one",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:9,Modifiability,rewrite,rewrite,9,// Don't rewrite the state machine if we are not in a valid state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:24,Deployability,configurat,configuration,24,// Check if the current configuration is non-SPMD and generic state machine.; // If we already have SPMD mode or a custom state machine we do not need to; // go any further. If it is anything but a constant something is weird and; // we give up.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:24,Modifiability,config,configuration,24,// Check if the current configuration is non-SPMD and generic state machine.; // If we already have SPMD mode or a custom state machine we do not need to; // go any further. If it is anything but a constant something is weird and; // we give up.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:92,Usability,simpl,simply,92,"// If we don't actually need a state machine we are done here. This can; // happen if there simply are no parallel regions. In the resulting kernel; // all worker threads will simply exit right away, leaving the main thread; // to do the work alone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:176,Usability,simpl,simply,176,"// If we don't actually need a state machine we are done here. This can; // happen if there simply are no parallel regions. In the resulting kernel; // all worker threads will simply exit right away, leaving the main thread; // to do the work alone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:23,Deployability,update,update,23,/// Fixpoint iteration update function. Will be called every time a dependence; /// changed its state (and in the beginning).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:68,Integrability,depend,dependence,68,/// Fixpoint iteration update function. Will be called every time a dependence; /// changed its state (and in the beginning).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:85,Deployability,update,updated,85,// When we leave this function this RAII will make sure the member; // KernelEnvC is updated properly depending on the state. That member is; // used for simplification of values and needs to be up to date at all; // times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:102,Integrability,depend,depending,102,// When we leave this function this RAII will make sure the member; // KernelEnvC is updated properly depending on the state. That member is; // used for simplification of values and needs to be up to date at all; // times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:154,Usability,simpl,simplification,154,// When we leave this function this RAII will make sure the member; // KernelEnvC is updated properly depending on the state. That member is; // used for simplification of values and needs to be up to date at all; // times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:4,Deployability,Update,Update,4,/// Update info regarding reaching kernels.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:4,Deployability,Update,Update,4,/// Update info regarding parallel levels.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:119,Deployability,update,updated,119,"// Any function that is called by `__kmpc_parallel_51` will not be; // folded as the parallel level in the function is updated. In order to; // get it right, all the analysis would depend on the implentation. That; // said, if in the future any change to the implementation, the analysis; // could be wrong. As a consequence, we are just conservative here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:181,Integrability,depend,depend,181,"// Any function that is called by `__kmpc_parallel_51` will not be; // folded as the parallel level in the function is updated. In order to; // get it right, all the analysis would depend on the implentation. That; // said, if in the future any change to the implementation, the analysis; // could be wrong. As a consequence, we are just conservative here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:150,Usability,simpl,simply,150,"/// The call site kernel info abstract attribute, basically, what can we say; /// about a call site with regards to the KernelInfoState. For now this simply; /// forwards the information from the callee.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:287,Deployability,update,updateImpl,287,"// Next we check if we know the callee. If it is a known OpenMP function; // we will handle them explicitly in the switch below. If it is not, we; // will use an AAKernelInfo object on the callee to gather information and; // merge that into the current state. The latter happens in the updateImpl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:11,Deployability,update,updated,11,"// We have updated the state for this unknown call properly, there; // won't be any change so we indicate a fixpoint.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:58,Deployability,update,update,58,"// If the callee is known and can be used in IPO, we will update the; // state based on the callee state in updateImpl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:108,Deployability,update,updateImpl,108,"// If the callee is known and can be used in IPO, we will update the; // state based on the callee state in updateImpl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:13,Energy Efficiency,schedul,schedule,13,// Check the schedule and allow static schedule in SPMD mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:39,Energy Efficiency,schedul,schedule,39,// Check the schedule and allow static schedule in SPMD mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:56,Deployability,update,updateImpl,56,"// Return without setting a fixpoint, to be resolved in updateImpl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:214,Deployability,update,update,214,// All other OpenMP runtime calls will not reach parallel regions so they; // can be safely ignored for now. Since it is a known OpenMP runtime call; // we have now modeled all effects and there is no need for any update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:85,Safety,safe,safely,85,// All other OpenMP runtime calls will not reach parallel regions so they; // can be safely ignored for now. Since it is a known OpenMP runtime call; // we have now modeled all effects and there is no need for any update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:32,Energy Efficiency,allocate,allocates,32,"// F is a runtime function that allocates or frees memory, check; // AAHeapToStack and AAHeapToShared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:42,Deployability,Update,Update,42,// All reaching kernels are in SPMD mode. Update all function calls to; // __kmpc_is_spmd_exec_mode to 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:46,Deployability,Update,Update,46,// All reaching kernels are in non-SPMD mode. Update all function; // calls to __kmpc_is_spmd_exec_mode to 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:123,Usability,Simpl,SimplifiedValue,123,"// We have empty reaching kernels, therefore we cannot tell if the; // associated call site can be folded. At this moment, SimplifiedValue; // must be none.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:158,Usability,simpl,simplified,158,"/// An optional value the associated value is assumed to fold to. That is, we; /// assume the associated value (which is a call) can be replaced by this; /// simplified value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:3,Deployability,Update,UpdateAfterInit,3,/* UpdateAfterInit */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:77,Deployability,update,update,77,// Ensure we create the AAKernelInfo AAs first and without triggering an; // update. This will make sure we register all value simplification; // callbacks before any other AA has the chance to create an AAValueSimplify; // or similar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:127,Usability,simpl,simplification,127,// Ensure we create the AAKernelInfo AAs first and without triggering an; // update. This will make sure we register all value simplification; // callbacks before any other AA has the chance to create an AAValueSimplify; // or similar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:3,Deployability,Update,UpdateAfterInit,3,/* UpdateAfterInit */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:61,Performance,perform,performance,61,// Optionally inline device functions for potentially better performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:393,Performance,perform,performs,393,"//===- PartialInlining.cpp - Inline parts of functions --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs partial inlining, typically by inlining an if statement; // that surrounds the body of the function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:68,Modifiability,variab,variables,68,// Command line option to force outlining in regions with live exit variables.; // The default is false:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:29,Testability,test,testing,29,// This is an option used by testing:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:173,Energy Efficiency,reduce,reduces,173,// Used to determine if a cold region is worth outlining based on; // its inlining cost compared to the original function. Default is set at 10%.; // ie. if the cold region reduces the inlining cost of the original function by; // at least 10%.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:11,Performance,tune,tune,11,// Used to tune the minimum number of execution counts needed in the predecessor; // block to the cold edge. ie. confidence interval.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:282,Deployability,update,update,282,"// Do function outlining for region after early return block(s).; // NOTE: For vararg functions that do the vararg handling in the outlined; // function, we temporarily generate IR that does not properly; // forward varargs to the outlined function. Calling InlineFunction; // will update calls to the outlined functions to properly forward; // the varargs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:182,Usability,clear,clear,182,"// Compute the 'InlineCost' of block BB. InlineCost is a proxy used to; // approximate both the size and runtime cost (Note that in the current; // inline cost analysis, there is no clear distinction there either).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:257,Energy Efficiency,reduce,reduced,257,// Use Depth First Search on the basic blocks to find CFG edges that are; // considered cold.; // Cold regions considered must also have its inline cost compared to the; // overall inline cost of the original function. The region is outlined only; // if it reduced the inline cost of the function by 'MinOutlineRegionCost' or; // more.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:198,Modifiability,variab,variables,198,"// For now, ignore blocks that belong to a SISE region that is a; // candidate for outlining. In the future, we may want to look; // at inner regions because the outer region may have live-exit; // variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:3,Safety,Detect,Detect,3,// Detect a triangular shape:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:16,Deployability,update,update,16,// Now grow and update OutlininigInfo:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:28,Availability,avail,available,28,"// When profile data is not available, we need to be conservative in; // estimating the overall savings. Static branch prediction can usually; // guess the branch direction right (taken/non-taken), but the guessed; // branch probability is usually not biased enough. In case when the; // outlined region is predicted to be likely, its probability needs; // to be made higher (more biased) to not under-estimate the cost of; // function outlining. On the other hand, if the outlined region; // is predicted to be less likely, the predicted probablity is usually; // higher than the actual. For instance, the actual probability of the; // less likely target is only 5%, but the guessed probablity can be; // 40%. In the latter case, there is no need for further adjustment.; // FIXME: add an option for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:119,Safety,predict,prediction,119,"// When profile data is not available, we need to be conservative in; // estimating the overall savings. Static branch prediction can usually; // guess the branch direction right (taken/non-taken), but the guessed; // branch probability is usually not biased enough. In case when the; // outlined region is predicted to be likely, its probability needs; // to be made higher (more biased) to not under-estimate the cost of; // function outlining. On the other hand, if the outlined region; // is predicted to be less likely, the predicted probablity is usually; // higher than the actual. For instance, the actual probability of the; // less likely target is only 5%, but the guessed probablity can be; // 40%. In the latter case, there is no need for further adjustment.; // FIXME: add an option for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:307,Safety,predict,predicted,307,"// When profile data is not available, we need to be conservative in; // estimating the overall savings. Static branch prediction can usually; // guess the branch direction right (taken/non-taken), but the guessed; // branch probability is usually not biased enough. In case when the; // outlined region is predicted to be likely, its probability needs; // to be made higher (more biased) to not under-estimate the cost of; // function outlining. On the other hand, if the outlined region; // is predicted to be less likely, the predicted probablity is usually; // higher than the actual. For instance, the actual probability of the; // less likely target is only 5%, but the guessed probablity can be; // 40%. In the latter case, there is no need for further adjustment.; // FIXME: add an option for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:496,Safety,predict,predicted,496,"// When profile data is not available, we need to be conservative in; // estimating the overall savings. Static branch prediction can usually; // guess the branch direction right (taken/non-taken), but the guessed; // branch probability is usually not biased enough. In case when the; // outlined region is predicted to be likely, its probability needs; // to be made higher (more biased) to not under-estimate the cost of; // function outlining. On the other hand, if the outlined region; // is predicted to be less likely, the predicted probablity is usually; // higher than the actual. For instance, the actual probability of the; // less likely target is only 5%, but the guessed probablity can be; // 40%. In the latter case, there is no need for further adjustment.; // FIXME: add an option for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:529,Safety,predict,predicted,529,"// When profile data is not available, we need to be conservative in; // estimating the overall savings. Static branch prediction can usually; // guess the branch direction right (taken/non-taken), but the guessed; // branch probability is usually not biased enough. In case when the; // outlined region is predicted to be likely, its probability needs; // to be made higher (more biased) to not under-estimate the cost of; // function outlining. On the other hand, if the outlined region; // is predicted to be less likely, the predicted probablity is usually; // higher than the actual. For instance, the actual probability of the; // less likely target is only 5%, but the guessed probablity can be; // 40%. In the latter case, there is no need for further adjustment.; // FIXME: add an option for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:87,Usability,simpl,simplified,87,// TODO: Ideally we should share Inliner's InlineCost Analysis code.; // For now use a simplified version. The returned 'InlineCost' will be used; // to esimate the size cost as well as runtime cost of the BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:53,Testability,stub,stub,53,// The code extractor introduces a new root and exit stub blocks with; // additional unconditional branches. Those branches will be eliminated; // later with bb layout. The cost should be adjusted accordingly:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:65,Deployability,update,update,65,"// Create the callsite to profile count map which is; // used to update the original function's entry count,; // after the function is partially inlined into the callsite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:16,Deployability,update,update,16,"// Go ahead and update all uses to the duplicate, so that we can just; // use the inliner functionality when we're done hacking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:48,Deployability,update,update,48,// Go through all Outline Candidate Regions and update all BasicBlock; // information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:16,Deployability,update,update,16,"// Go ahead and update all uses to the duplicate, so that we can just; // use the inliner functionality when we're done hacking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:105,Usability,simpl,simplicity,105,"// Special hackery is needed with PHI nodes that have inputs from more than; // one extracted block. For simplicity, just split the PHIs into a two-level; // sequence of PHIs, some of which will go in the extracted region, and some; // of which will go outside.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:198,Performance,load,load,198,"// After incoming values splitting, the old phi may become trivial.; // Keeping the trivial phi can introduce definition inside the outline; // region which is live-out, causing necessary overhead (load, store; // arg passing etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:3,Performance,Cache,Cache,3,// Cache and recycle the CodeExtractor analysis to avoid O(n^2) compile-time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:51,Safety,avoid,avoid,51,// Cache and recycle the CodeExtractor analysis to avoid O(n^2) compile-time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:46,Modifiability,variab,variables,46,// Do not extract regions that have live exit variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:54,Modifiability,rewrite,rewrite,54,"// Ditch the duplicate, since we're done with it, and rewrite all remaining; // users (function pointers, etc.) back to the original function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:7,Deployability,update,update,7,// Now update the entry count:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:3,Deployability,Update,Update,3,// Update the stats,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleContextTracker.cpp:52,Deployability,update,update,52,"// Walk through nodes in the moved the subtree, and update; // FunctionSamples' context as for the context promotion.; // We also need to set new parant link for all children.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleContextTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleContextTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleContextTracker.cpp:238,Performance,load,loader,238,"// We may have inlined callees during pre-LTO compilation, in which case; // we need to rely on the inline stack from !dbg to mark context profile; // as inlined, instead of `MarkContextSamplesInlined` during inlining.; // Sample profile loader walks through all instructions to get profile,; // which calls this function. So once that is done, all previously inlined; // context profile should be marked properly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleContextTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleContextTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleContextTracker.cpp:13,Deployability,release,release,13,// Unused in release build.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleContextTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleContextTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:41,Performance,optimiz,optimization,41,"// Local to global var promotion used by optimization like thinlto; // will rename the var and add suffix like "".llvm.xxx"" to the; // original local name. In sample profile, the suffixes of function; // names are all stripped. Since it is possible that the mapper is; // built in post-thin-link phase and var promotion has been done,; // we need to add the substring of function name without the suffix; // into the GUIDToFuncNameMap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:416,Usability,GUID,GUIDToFuncNameMap,416,"// Local to global var promotion used by optimization like thinlto; // will rename the var and add suffix like "".llvm.xxx"" to the; // original local name. In sample profile, the suffixes of function; // names are all stripped. Since it is possible that the mapper is; // built in post-thin-link phase and var promotion has been done,; // we need to add the substring of function name without the suffix; // into the GUIDToFuncNameMap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:3,Deployability,Update,Update,3,// Update GUIDToFuncNameMap for each function including inlinees.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:10,Usability,GUID,GUIDToFuncNameMap,10,// Update GUIDToFuncNameMap for each function including inlinees.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:9,Usability,GUID,GUIDToFuncNameMap,9,// Reset GUIDToFuncNameMap for of each function as they're no; // longer valid at this point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:50,Usability,guid,guide,50,"// Prorated callsite count, which will be used to guide inlining. For example,; // if a callsite is duplicated in LTO prelink, then in LTO postlink the two; // copies will get their own distribution factors and their prorated counts; // will be used to decide if they should be inlined independently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:21,Usability,GUID,GUID,21,// Tie breaker using GUID so we have stable/deterministic inlining order,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:238,Usability,GUID,GUIDs,238,"/// Flag indicating which LTO/ThinLTO phase the pass is invoked in.; ///; /// We need to know the LTO phase because for example in ThinLTOPrelink; /// phase, in annotation, we should not promote indirect calls. Instead,; /// we will mark GUIDs that needs to be annotated to the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:3,Usability,GUID,GUIDToFuncNameMap,3,"// GUIDToFuncNameMap saves the mapping from GUID to the symbol name, for; // all the function symbols defined or declared in current module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:44,Usability,GUID,GUID,44,"// GUIDToFuncNameMap saves the mapping from GUID to the symbol name, for; // all the function symbols defined or declared in current module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:92,Integrability,depend,depends,92,"// MD5 version of NamesInProfile. Either NamesInProfile or GUIDsInProfile is; // populated, depends on whether the profile uses MD5. Because the name table; // generally contains several magnitude more entries than the number of; // functions, we do not want to convert all names from one form to another.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:59,Usability,GUID,GUIDsInProfile,59,"// MD5 version of NamesInProfile. Either NamesInProfile or GUIDsInProfile is; // populated, depends on whether the profile uses MD5. Because the name table; // generally contains several magnitude more entries than the number of; // functions, we do not want to convert all names from one form to another.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:4,Deployability,Update,Update,4,"/// Update indirect call target profile metadata for \p Inst.; /// Usually \p Sum is the sum of counts of all the targets for \p Inst.; /// If it is 0, it means updateIDTMetaData is used to mark a; /// certain target to be promoted already. If it is not zero,; /// we expect to use it to update the total count in the value profile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:161,Deployability,update,updateIDTMetaData,161,"/// Update indirect call target profile metadata for \p Inst.; /// Usually \p Sum is the sum of counts of all the targets for \p Inst.; /// If it is 0, it means updateIDTMetaData is used to mark a; /// certain target to be promoted already. If it is not zero,; /// we expect to use it to update the total count in the value profile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:288,Deployability,update,update,288,"/// Update indirect call target profile metadata for \p Inst.; /// Usually \p Sum is the sum of counts of all the targets for \p Inst.; /// If it is 0, it means updateIDTMetaData is used to mark a; /// certain target to be promoted already. If it is not zero,; /// we expect to use it to update the total count in the value profile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:121,Deployability,update,updateIDTMetaData,121,// Bail out early if MaxNumPromotions is zero.; // This prevents allocating an array of zero length below.; //; // Note `updateIDTMetaData` is called in two places so check; // `MaxNumPromotions` inside it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:438,Security,expose,exposed,438,/// Attempt to promote indirect call and also inline the promoted call.; ///; /// \param F Caller function.; /// \param Candidate ICP and inline candidate.; /// \param SumOrigin Original sum of target counts for indirect call before; /// promoting given candidate.; /// \param Sum Prorated sum of remaining target counts for indirect call; /// after promoting given candidate.; /// \param InlinedCallSite Output vector for new call sites exposed after; /// inlining.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:28,Performance,load,loader,28,// Bail out early if sample-loader inliner is disabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:337,Usability,simpl,simply,337,"// R->getValue() != &F is to prevent promoting a recursive call.; // If it is a recursive call, we do not inline it as it could bloat; // the code exponentially. There is way to better handle this, e.g.; // clone the caller first, and inline the cloned caller if it is; // recursive. As llvm does not inline recursive calls, we will; // simply ignore it instead of handling it explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:111,Availability,down,down,111,"// Do not prorate the indirect callsite distribution since the original; // distribution will be used to scale down non-promoted profile target; // counts later. By doing this we lose track of the real callsite count; // for the leftover indirect callsite as a trade off for accurate call; // target counts.; // TODO: Ideally we would have two separate factors, one for call site; // counts and one is used to prorate call target counts.; // Do not update the promoted direct callsite distribution at this; // point since the original distribution combined with the callee profile; // will be used to prorate callsites from the callee if inlined. Once not; // inlined, the direct callsite distribution should be prorated so that; // the it will reflect the real callsite counts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:449,Deployability,update,update,449,"// Do not prorate the indirect callsite distribution since the original; // distribution will be used to scale down non-promoted profile target; // counts later. By doing this we lose track of the real callsite count; // for the leftover indirect callsite as a trade off for accurate call; // target counts.; // TODO: Ideally we would have two separate factors, one for call site; // counts and one is used to prorate call target counts.; // Do not update the promoted direct callsite distribution at this; // point since the original distribution combined with the callee profile; // will be used to prorate callsites from the callee if inlined. Once not; // inlined, the direct callsite distribution should be prorated so that; // the it will reflect the real callsite counts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:78,Usability,GUID,GUID,78,"// Samples may not exist for replayed function, if so; // just add the direct GUID and move on",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:102,Performance,queue,queue,102,"// In some rare cases, call instruction could be changed after being pushed; // into inline candidate queue, this is because earlier inlining may expose; // constant propagation which can change indirect call to direct call. When; // this happens, we may fail to find matching function samples for the; // candidate later, even if a match was found when the candidate was enqueued.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:146,Security,expose,expose,146,"// In some rare cases, call instruction could be changed after being pushed; // into inline candidate queue, this is because earlier inlining may expose; // constant propagation which can change indirect call to direct call. When; // this happens, we may fail to find matching function samples for the; // candidate later, even if a match was found when the candidate was enqueued.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:44,Availability,avail,available,44,"// Import hot CallTargets, which may not be available in IR because full; // profile annotation cannot be done until backend compilation in ThinLTO.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:765,Deployability,update,updated,765,"/// Iteratively inline hot callsites of a function.; ///; /// Iteratively traverse all callsites of the function \p F, so as to; /// find out callsites with corresponding inline instances.; ///; /// For such callsites,; /// - If it is hot enough, inline the callsites and adds callsites of the callee; /// into the caller. If the call is an indirect call, first promote; /// it to direct call. Each indirect call is limited with a single target.; ///; /// - If a callsite is not inlined, merge the its profile to the outline; /// version (if --sample-profile-merge-inlinee is true), or scale the; /// counters of standalone function based on the profile of inlined; /// instances (if --sample-profile-merge-inlinee is false).; ///; /// Later passes may consume the updated profiles.; ///; /// \param F function to perform iterative inlining.; /// \param InlinedGUIDs a set to be updated to include all GUIDs that are; /// inlined in the profiled binary.; ///; /// \returns True if there is any inline happened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:879,Deployability,update,updated,879,"/// Iteratively inline hot callsites of a function.; ///; /// Iteratively traverse all callsites of the function \p F, so as to; /// find out callsites with corresponding inline instances.; ///; /// For such callsites,; /// - If it is hot enough, inline the callsites and adds callsites of the callee; /// into the caller. If the call is an indirect call, first promote; /// it to direct call. Each indirect call is limited with a single target.; ///; /// - If a callsite is not inlined, merge the its profile to the outline; /// version (if --sample-profile-merge-inlinee is true), or scale the; /// counters of standalone function based on the profile of inlined; /// instances (if --sample-profile-merge-inlinee is false).; ///; /// Later passes may consume the updated profiles.; ///; /// \param F function to perform iterative inlining.; /// \param InlinedGUIDs a set to be updated to include all GUIDs that are; /// inlined in the profiled binary.; ///; /// \returns True if there is any inline happened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:814,Performance,perform,perform,814,"/// Iteratively inline hot callsites of a function.; ///; /// Iteratively traverse all callsites of the function \p F, so as to; /// find out callsites with corresponding inline instances.; ///; /// For such callsites,; /// - If it is hot enough, inline the callsites and adds callsites of the callee; /// into the caller. If the call is an indirect call, first promote; /// it to direct call. Each indirect call is limited with a single target.; ///; /// - If a callsite is not inlined, merge the its profile to the outline; /// version (if --sample-profile-merge-inlinee is true), or scale the; /// counters of standalone function based on the profile of inlined; /// instances (if --sample-profile-merge-inlinee is false).; ///; /// Later passes may consume the updated profiles.; ///; /// \param F function to perform iterative inlining.; /// \param InlinedGUIDs a set to be updated to include all GUIDs that are; /// inlined in the profiled binary.; ///; /// \returns True if there is any inline happened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:902,Usability,GUID,GUIDs,902,"/// Iteratively inline hot callsites of a function.; ///; /// Iteratively traverse all callsites of the function \p F, so as to; /// find out callsites with corresponding inline instances.; ///; /// For such callsites,; /// - If it is hot enough, inline the callsites and adds callsites of the callee; /// into the caller. If the call is an indirect call, first promote; /// it to direct call. Each indirect call is limited with a single target.; ///; /// - If a callsite is not inlined, merge the its profile to the outline; /// version (if --sample-profile-merge-inlinee is true), or scale the; /// counters of standalone function based on the profile of inlined; /// instances (if --sample-profile-merge-inlinee is false).; ///; /// Later passes may consume the updated profiles.; ///; /// \param F function to perform iterative inlining.; /// \param InlinedGUIDs a set to be updated to include all GUIDs that are; /// inlined in the profiled binary.; ///; /// \returns True if there is any inline happened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:54,Testability,assert,assertion,54,// ProfAccForSymsInList is used in callsiteIsHot. The assertion makes sure; // Profile symbol list is ignored when profile-sample-accurate is on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:64,Performance,load,loader-inlining,64,// Do not attempt to inline a candidate if; // --disable-sample-loader-inlining is true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:34,Security,expose,exposed,34,// Now populate the list of newly exposed call sites.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:54,Testability,assert,assertion,54,// ProfAccForSymsInList is used in callsiteIsHot. The assertion makes sure; // Profile symbol list is ignored when profile-sample-accurate is on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:169,Availability,down,down,169,"// Cap the size growth from profile guided inlining. This is needed even; // though cost of each inline candidate already accounts for callee size,; // because with top-down inlining, we can grow inliner size significantly; // with large number of smaller inlinees each pass the cost check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:36,Usability,guid,guided,36,"// Cap the size growth from profile guided inlining. This is needed even; // though cost of each inline candidate already accounts for callee size,; // because with top-down inlining, we can grow inliner size significantly; // with large number of smaller inlinees each pass the cost check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:3,Performance,Perform,Perform,3,// Perform iterative BFS call site prioritized inlining,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:61,Deployability,update,update,61,"// Attach function profile for promoted indirect callee, and update; // call site count for the promoted inline candidate too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:40,Performance,optimiz,optimizations,40,// A function call can be replicated by optimizations like callsite; // splitting or jump threading and the replicates end up sharing the; // sample nested callee profile instead of slicing the original; // inlinee's profile. We want to do merge exactly once by filtering out; // callee profiles with a non-zero head sample count.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:147,Availability,down,down,147,// Note that we have to do the merge right after processing function.; // This allows OutlineFS's profile to be used for annotation during; // top-down processing of functions' annotation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:75,Usability,clear,clear,75,// Set profile metadata (possibly annotated by LTO prelink) to zero or; // clear it for cold code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:47,Availability,error,errors,47,// Weight is added by one to avoid propagation errors introduced by; // 0 weights.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:29,Safety,avoid,avoid,29,// Weight is added by one to avoid propagation errors introduced by; // 0 weights.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:491,Usability,clear,cleared,491,"// Only set weights if there is at least one non-zero weight.; // In any other case, let the analyzer set weights.; // Do not set weights if the weights are present unless under; // OverwriteExistingWeights. In ThinLTO, the profile annotation is done; // twice. If the first annotation already set the weights, the second pass; // does not need to set it. With OverwriteExistingWeights, Blocks with zero; // weight should have their existing metadata (possibly annotated by LTO; // prelink) cleared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:63,Availability,down,down,63,"// Disable ProfileMergeInlinee if profile is not loaded in top down order,; // because the profile for a function may be used for the profile; // annotation of its outline copy before the profile merging of its; // non-inlined inline instances, and that is not the way how; // ProfileMergeInlinee is supposed to work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:49,Performance,load,loaded,49,"// Disable ProfileMergeInlinee if profile is not loaded in top down order,; // because the profile for a function may be used for the profile; // annotation of its outline copy before the profile merging of its; // non-inlined inline instances, and that is not the way how; // ProfileMergeInlinee is supposed to work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:46,Availability,down,down,46,"// Use profiled call edges to augment the top-down order. There are cases; // that the top-down order computed based on the static call graph doesn't; // reflect real execution order. For example; //; // 1. Incomplete static call graph due to unknown indirect call targets.; // Adjusting the order by considering indirect call edges from the; // profile can enable the inlining of indirect call targets by allowing; // the caller processed before them.; // 2. Mutual call edges in an SCC. The static processing order computed for; // an SCC may not reflect the call contexts in the context-sensitive; // profile, thus may cause potential inlining to be overlooked. The; // function order in one SCC is being adjusted to a top-down order based; // on the profile to favor more inlining. This is only a problem with CS; // profile.; // 3. Transitive indirect call edges due to inlining. When a callee function; // (say B) is inlined into a caller function (say A) in LTO prelink,; // every call edge originated from the callee B will be transferred to; // the caller A. If any transferred edge (say A->C) is indirect, the; // original profiled indirect edge B->C, even if considered, would not; // enforce a top-down order from the caller A to the potential indirect; // call target C in LTO postlink since the inlined callee B is gone from; // the static call graph.; // 4. #3 can happen even for direct call targets, due to functions defined; // in header files. A header function (say A), when included into source; // files, is defined multiple times but only one definition survives due; // to ODR. Therefore, the LTO prelink inlining done on those dropped; // definitions can be useless based on a local file scope. More; // importantly, the inlinee (say B), once fully inlined to a; // to-be-dropped A, will have no profile to consume when its outlined; // version is compiled. This can lead to a profile-less prelink; // compilation for the outlined version of B which may be called from; // ext",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:91,Availability,down,down,91,"// Use profiled call edges to augment the top-down order. There are cases; // that the top-down order computed based on the static call graph doesn't; // reflect real execution order. For example; //; // 1. Incomplete static call graph due to unknown indirect call targets.; // Adjusting the order by considering indirect call edges from the; // profile can enable the inlining of indirect call targets by allowing; // the caller processed before them.; // 2. Mutual call edges in an SCC. The static processing order computed for; // an SCC may not reflect the call contexts in the context-sensitive; // profile, thus may cause potential inlining to be overlooked. The; // function order in one SCC is being adjusted to a top-down order based; // on the profile to favor more inlining. This is only a problem with CS; // profile.; // 3. Transitive indirect call edges due to inlining. When a callee function; // (say B) is inlined into a caller function (say A) in LTO prelink,; // every call edge originated from the callee B will be transferred to; // the caller A. If any transferred edge (say A->C) is indirect, the; // original profiled indirect edge B->C, even if considered, would not; // enforce a top-down order from the caller A to the potential indirect; // call target C in LTO postlink since the inlined callee B is gone from; // the static call graph.; // 4. #3 can happen even for direct call targets, due to functions defined; // in header files. A header function (say A), when included into source; // files, is defined multiple times but only one definition survives due; // to ODR. Therefore, the LTO prelink inlining done on those dropped; // definitions can be useless based on a local file scope. More; // importantly, the inlinee (say B), once fully inlined to a; // to-be-dropped A, will have no profile to consume when its outlined; // version is compiled. This can lead to a profile-less prelink; // compilation for the outlined version of B which may be called from; // ext",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:726,Availability,down,down,726,"// Use profiled call edges to augment the top-down order. There are cases; // that the top-down order computed based on the static call graph doesn't; // reflect real execution order. For example; //; // 1. Incomplete static call graph due to unknown indirect call targets.; // Adjusting the order by considering indirect call edges from the; // profile can enable the inlining of indirect call targets by allowing; // the caller processed before them.; // 2. Mutual call edges in an SCC. The static processing order computed for; // an SCC may not reflect the call contexts in the context-sensitive; // profile, thus may cause potential inlining to be overlooked. The; // function order in one SCC is being adjusted to a top-down order based; // on the profile to favor more inlining. This is only a problem with CS; // profile.; // 3. Transitive indirect call edges due to inlining. When a callee function; // (say B) is inlined into a caller function (say A) in LTO prelink,; // every call edge originated from the callee B will be transferred to; // the caller A. If any transferred edge (say A->C) is indirect, the; // original profiled indirect edge B->C, even if considered, would not; // enforce a top-down order from the caller A to the potential indirect; // call target C in LTO postlink since the inlined callee B is gone from; // the static call graph.; // 4. #3 can happen even for direct call targets, due to functions defined; // in header files. A header function (say A), when included into source; // files, is defined multiple times but only one definition survives due; // to ODR. Therefore, the LTO prelink inlining done on those dropped; // definitions can be useless based on a local file scope. More; // importantly, the inlinee (say B), once fully inlined to a; // to-be-dropped A, will have no profile to consume when its outlined; // version is compiled. This can lead to a profile-less prelink; // compilation for the outlined version of B which may be called from; // ext",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:1210,Availability,down,down,1210,"e static call graph due to unknown indirect call targets.; // Adjusting the order by considering indirect call edges from the; // profile can enable the inlining of indirect call targets by allowing; // the caller processed before them.; // 2. Mutual call edges in an SCC. The static processing order computed for; // an SCC may not reflect the call contexts in the context-sensitive; // profile, thus may cause potential inlining to be overlooked. The; // function order in one SCC is being adjusted to a top-down order based; // on the profile to favor more inlining. This is only a problem with CS; // profile.; // 3. Transitive indirect call edges due to inlining. When a callee function; // (say B) is inlined into a caller function (say A) in LTO prelink,; // every call edge originated from the callee B will be transferred to; // the caller A. If any transferred edge (say A->C) is indirect, the; // original profiled indirect edge B->C, even if considered, would not; // enforce a top-down order from the caller A to the potential indirect; // call target C in LTO postlink since the inlined callee B is gone from; // the static call graph.; // 4. #3 can happen even for direct call targets, due to functions defined; // in header files. A header function (say A), when included into source; // files, is defined multiple times but only one definition survives due; // to ODR. Therefore, the LTO prelink inlining done on those dropped; // definitions can be useless based on a local file scope. More; // importantly, the inlinee (say B), once fully inlined to a; // to-be-dropped A, will have no profile to consume when its outlined; // version is compiled. This can lead to a profile-less prelink; // compilation for the outlined version of B which may be called from; // external modules. while this isn't easy to fix, we rely on the; // postlink AutoFDO pipeline to optimize B. Since the survived copy of; // the A can be inlined in its local scope in prelink, it may not exist; // in the",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:2300,Availability,down,down,2300,"LTO prelink,; // every call edge originated from the callee B will be transferred to; // the caller A. If any transferred edge (say A->C) is indirect, the; // original profiled indirect edge B->C, even if considered, would not; // enforce a top-down order from the caller A to the potential indirect; // call target C in LTO postlink since the inlined callee B is gone from; // the static call graph.; // 4. #3 can happen even for direct call targets, due to functions defined; // in header files. A header function (say A), when included into source; // files, is defined multiple times but only one definition survives due; // to ODR. Therefore, the LTO prelink inlining done on those dropped; // definitions can be useless based on a local file scope. More; // importantly, the inlinee (say B), once fully inlined to a; // to-be-dropped A, will have no profile to consume when its outlined; // version is compiled. This can lead to a profile-less prelink; // compilation for the outlined version of B which may be called from; // external modules. while this isn't easy to fix, we rely on the; // postlink AutoFDO pipeline to optimize B. Since the survived copy of; // the A can be inlined in its local scope in prelink, it may not exist; // in the merged IR in postlink, and we'll need the profiled call edges; // to enforce a top-down order for the rest of the functions.; //; // Considering those cases, a profiled call graph completely independent of; // the static call graph is constructed based on profile data, where; // function objects are not even needed to handle case #3 and case 4.; //; // Note that static callgraph edges are completely ignored since they; // can be conflicting with profiled edges for cyclic SCCs and may result in; // an SCC order incompatible with profile-defined one. Using strictly; // profile order ensures a maximum inlining experience. On the other hand,; // static call edges are not so important when they don't correspond to a; // context in the profile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:2082,Deployability,pipeline,pipeline,2082,"LTO prelink,; // every call edge originated from the callee B will be transferred to; // the caller A. If any transferred edge (say A->C) is indirect, the; // original profiled indirect edge B->C, even if considered, would not; // enforce a top-down order from the caller A to the potential indirect; // call target C in LTO postlink since the inlined callee B is gone from; // the static call graph.; // 4. #3 can happen even for direct call targets, due to functions defined; // in header files. A header function (say A), when included into source; // files, is defined multiple times but only one definition survives due; // to ODR. Therefore, the LTO prelink inlining done on those dropped; // definitions can be useless based on a local file scope. More; // importantly, the inlinee (say B), once fully inlined to a; // to-be-dropped A, will have no profile to consume when its outlined; // version is compiled. This can lead to a profile-less prelink; // compilation for the outlined version of B which may be called from; // external modules. while this isn't easy to fix, we rely on the; // postlink AutoFDO pipeline to optimize B. Since the survived copy of; // the A can be inlined in its local scope in prelink, it may not exist; // in the merged IR in postlink, and we'll need the profiled call edges; // to enforce a top-down order for the rest of the functions.; //; // Considering those cases, a profiled call graph completely independent of; // the static call graph is constructed based on profile data, where; // function objects are not even needed to handle case #3 and case 4.; //; // Note that static callgraph edges are completely ignored since they; // can be conflicting with profiled edges for cyclic SCCs and may result in; // an SCC order incompatible with profile-defined one. Using strictly; // profile order ensures a maximum inlining experience. On the other hand,; // static call edges are not so important when they don't correspond to a; // context in the profile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:2094,Performance,optimiz,optimize,2094,"LTO prelink,; // every call edge originated from the callee B will be transferred to; // the caller A. If any transferred edge (say A->C) is indirect, the; // original profiled indirect edge B->C, even if considered, would not; // enforce a top-down order from the caller A to the potential indirect; // call target C in LTO postlink since the inlined callee B is gone from; // the static call graph.; // 4. #3 can happen even for direct call targets, due to functions defined; // in header files. A header function (say A), when included into source; // files, is defined multiple times but only one definition survives due; // to ODR. Therefore, the LTO prelink inlining done on those dropped; // definitions can be useless based on a local file scope. More; // importantly, the inlinee (say B), once fully inlined to a; // to-be-dropped A, will have no profile to consume when its outlined; // version is compiled. This can lead to a profile-less prelink; // compilation for the outlined version of B which may be called from; // external modules. while this isn't easy to fix, we rely on the; // postlink AutoFDO pipeline to optimize B. Since the survived copy of; // the A can be inlined in its local scope in prelink, it may not exist; // in the merged IR in postlink, and we'll need the profiled call edges; // to enforce a top-down order for the rest of the functions.; //; // Considering those cases, a profiled call graph completely independent of; // the static call graph is constructed based on profile data, where; // function objects are not even needed to handle case #3 and case 4.; //; // Note that static callgraph edges are completely ignored since they; // can be conflicting with profiled edges for cyclic SCCs and may result in; // an SCC order incompatible with profile-defined one. Using strictly; // profile order ensures a maximum inlining experience. On the other hand,; // static call edges are not so important when they don't correspond to a; // context in the profile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:63,Availability,avail,available,63,// Apply tweaks if context-sensitive or probe-based profile is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:172,Availability,avail,available,172,"// Enable stale profile matching by default for probe-based profile.; // Currently the matching relies on if the checksum mismatch is detected,; // which is currently only available for pseudo-probe mode. Removing the; // checksum check could cause regressions for some cases, so further tuning; // might be needed if we want to enable it for all cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:134,Safety,detect,detected,134,"// Enable stale profile matching by default for probe-based profile.; // Currently the matching relies on if the checksum mismatch is detected,; // which is currently only available for pseudo-probe mode. Removing the; // checksum check could cause regressions for some cases, so further tuning; // might be needed if we want to enable it for all cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:113,Security,checksum,checksum,113,"// Enable stale profile matching by default for probe-based profile.; // Currently the matching relies on if the checksum mismatch is detected,; // which is currently only available for pseudo-probe mode. Removing the; // checksum check could cause regressions for some cases, so further tuning; // might be needed if we want to enable it for all cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:222,Security,checksum,checksum,222,"// Enable stale profile matching by default for probe-based profile.; // Currently the matching relies on if the checksum mismatch is detected,; // which is currently only available for pseudo-probe mode. Removing the; // checksum check could cause regressions for some cases, so further tuning; // might be needed if we want to enable it for all cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:3,Performance,Load,Load,3,// Load pseudo probe descriptors for probe-based function samples.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:21,Availability,recover,recover,21,"// For inlined code, recover the original callsite and callee by finding the; // top-level inline frame. e.g. For frame stack ""main:1 @ foo:2 @ bar:3"", the; // top-level frame is ""main:1"", the callsite is ""1"" and the callee is ""foo"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:21,Safety,recover,recover,21,"// For inlined code, recover the original callsite and callee by finding the; // top-level inline frame. e.g. For frame stack ""main:1 @ foo:2 @ bar:3"", the; // top-level frame is ""main:1"", the callsite is ""1"" and the callee is ""foo"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:136,Energy Efficiency,reduce,reduce,136,"// Since indirect call does not have CalleeName, check conservatively if; // callsite in the profile is a callsite location. This is to reduce num of; // false positive since otherwise all the indirect call samples will be; // reported as mismatching.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:3,Safety,Detect,Detect,3,// Detect profile mismatch for profile staleness metrics report.; // Skip reporting the metrics for imported functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:28,Security,checksum,checksum,28,"// Run profile matching for checksum mismatched profile, currently only; // support for pseudo-probe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:219,Safety,avoid,avoid,219,"// Failiing to insert means there is already an entry in SymbolMap,; // thus there are multiple functions that are mapped to the same; // stripped name. In this case of name conflicting, set the value; // to nullptr to avoid confusion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:156,Safety,avoid,avoid,156,"// By default the entry count is initialized to -1, which will be treated; // conservatively by getEntryCount as the same as unknown (None). This is; // to avoid newly added code to be treated as cold. If we have samples; // this will be overwritten in emitAnnotations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:37,Testability,assert,assertion,37,"// profile-sample-accurate is a user assertion which has a higher precedence; // than symbol list. When profile-sample-accurate is on, ignore symbol list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:115,Performance,perform,performance,115,"// Function in the symbol list but without sample will be regarded as; // cold. To minimize the potential negative performance impact it could; // have, we want to be a little conservative here saying if a function; // shows up in the profile, no matter as outline function, inline instance; // or call targets, treat the function as not being cold. This will handle; // the cases such as most callsites of a function are inlined in sampled; // binary but not inlined in current build (because of source code drift,; // imprecise debug information, or the callsites are all cold individually; // but not cold accumulatively...), so the outline function showing up as; // cold in sampled binary will actually not be cold after current build.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp:3,Deployability,Update,Update,3,// Update,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp:11,Security,Hash,Hash,11,"// Compute Hash value for the CFG: the lower 32 bits are CRC32 of the index; // value of each BB in the CFG. The higher 32 bits record the number of edges; // preceded by the number of indirect calls.; // This is derived from FuncPGOInstrumentation<Edge, BBInfo>::computeCFGHash().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp:58,Energy Efficiency,reduce,reduce,58,// Insert pseudo probe to non-cold blocks only. This will reduce IR size as; // well as the binary size while retaining the profile quality.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp:13,Usability,GUID,GUID,13,"// Since the GUID from probe desc and inline stack are computed seperately, we; // need to make sure their names are consistent, so here also use the name; // from debug info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp:351,Performance,optimiz,optimizations,351,"// Insert a probe before an instruction with a valid debug line number which; // will be assigned to the probe. The line number will be used later to; // model the inline context when the probe is inlined into other functions.; // Debug instructions, phi nodes and lifetime markers do not have an valid; // line number. Real instructions generated by optimizations may not come; // with a line number either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp:135,Deployability,pipeline,pipeline,135,// Reset the dwarf discriminator if the debug location comes with any. The; // discriminator field may be used by FS-AFDO later in the pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp:196,Deployability,pipeline,pipeline,196,// Levarge the 32-bit discriminator field of debug data to store the ID; // and type of a callsite probe. This gets rid of the dependency on; // plumbing a customized metadata through the codegen pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp:127,Integrability,depend,dependency,127,// Levarge the 32-bit discriminator field of debug data to store the ID; // and type of a callsite probe. This gets rid of the dependency on; // plumbing a customized metadata through the codegen pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp:56,Modifiability,variab,variables,56,"// Determine if we can track any of the module's global variables. If so, add; // the global variables we can track to the solver's set of tracked global; // variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp:93,Modifiability,variab,variables,93,"// Determine if we can track any of the module's global variables. If so, add; // the global variables we can track to the solver's set of tracked global; // variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp:158,Modifiability,variab,variables,158,"// Determine if we can track any of the module's global variables. If so, add; // the global variables we can track to the solver's set of tracked global; // variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp:109,Deployability,Update,Update,109,"// If we replaced an argument, we may now also access a global (currently; // classified as ""other"" memory). Update memory attribute to reflect this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp:47,Security,access,access,47,"// If we replaced an argument, we may now also access a global (currently; // classified as ""other"" memory). Update memory attribute to reflect this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp:610,Performance,optimiz,optimizable,610,"// If we inferred constant or undef return values for a function, we replaced; // all call uses with the inferred value. This means we don't need to bother; // actually returning anything from the function. Replace all return; // instructions with return undef.; //; // Do this in two stages: first identify the functions we should process, then; // actually zap their returns. This is important because we can only do this; // if the address of the function isn't taken. In cases where a return is the; // last use of a function, the order of processing functions would affect; // whether other functions are optimizable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp:55,Modifiability,variab,variables,55,"// If we inferred constant or undef values for globals variables, we can; // delete the global and any stores that remain to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp:60,Modifiability,variab,variable,60,// Try to create a debug constant expression for the global variable; // initializer value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripDeadPrototypes.cpp:580,Availability,avail,available,580,"//===-- StripDeadPrototypes.cpp - Remove unused function declarations ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass loops over all of the functions in the input module, looking for; // dead declarations and removes them. Dead declarations are declarations of; // functions for which no implementation is available (i.e., declarations for; // unused library functions).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/StripDeadPrototypes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripDeadPrototypes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp:120,Availability,resilien,resilient,120,"// Find all debug info in F. This is actually overkill in terms of what we; // want to do, but we want to try and be as resilient as possible in the face; // of potential debug info changes by using the formal interfaces given to us; // as much as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp:210,Integrability,interface,interfaces,210,"// Find all debug info in F. This is actually overkill in terms of what we; // want to do, but we want to try and be as resilient as possible in the face; // of potential debug info changes by using the formal interfaces given to us; // as much as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp:54,Modifiability,variab,variables,54,"// For each compile unit, find the live set of global variables/functions and; // replace the current list of potentially dead global variables/functions; // with the live list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp:134,Modifiability,variab,variables,134,"// For each compile unit, find the live set of global variables/functions and; // replace the current list of potentially dead global variables/functions; // with the live list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp:26,Modifiability,variab,variable,26,// Create our live global variable list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp:39,Modifiability,variab,variable,39,// Make sure we only visit each global variable only once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp:15,Modifiability,variab,variable,15,"// If a global variable references DIG, the global variable is live.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp:51,Modifiability,variab,variable,51,"// If a global variable references DIG, the global variable is live.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp:27,Modifiability,variab,variables,27,"// If we found dead global variables, replace the current global; // variable list with our new live global variable list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp:69,Modifiability,variab,variable,69,"// If we found dead global variables, replace the current global; // variable list with our new live global variable list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp:108,Modifiability,variab,variable,108,"// If we found dead global variables, replace the current global; // variable list with our new live global variable list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SyntheticCountsPropagation.cpp:1010,Availability,down,down,1010,"//=- SyntheticCountsPropagation.cpp - Propagate function counts --*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a transformation that synthesizes entry counts for; // functions and attaches !prof metadata to functions with the synthesized; // counts. The presence of !prof metadata with counter name set to; // 'synthesized_function_entry_count' indicate that the value of the counter is; // an estimation of the likely execution count of the function. This transform; // is applied only in non PGO mode as functions get 'real' profile-based; // function entry counts in the PGO mode.; //; // The transformation works by first assigning some initial values to the entry; // counts of all functions and then doing a top-down traversal of the; // callgraph-scc to propagate the counts. For each function the set of callsites; // and their relative block frequency is gathered. The relative block frequency; // multiplied by the entry count of the caller and added to the callee's entry; // count. For non-trivial SCCs, the new counts are computed from the previous; // counts and updated in one shot.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SyntheticCountsPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SyntheticCountsPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SyntheticCountsPropagation.cpp:1369,Deployability,update,updated,1369,"//=- SyntheticCountsPropagation.cpp - Propagate function counts --*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a transformation that synthesizes entry counts for; // functions and attaches !prof metadata to functions with the synthesized; // counts. The presence of !prof metadata with counter name set to; // 'synthesized_function_entry_count' indicate that the value of the counter is; // an estimation of the likely execution count of the function. This transform; // is applied only in non PGO mode as functions get 'real' profile-based; // function entry counts in the PGO mode.; //; // The transformation works by first assigning some initial values to the entry; // counts of all functions and then doing a top-down traversal of the; // callgraph-scc to propagate the counts. For each function the set of callsites; // and their relative block frequency is gathered. The relative block frequency; // multiplied by the entry count of the caller and added to the callee's entry; // count. For non-trivial SCCs, the new counts are computed from the previous; // counts and updated in one shot.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/SyntheticCountsPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SyntheticCountsPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp:60,Safety,safe,safe,60,// Promotion aliases are used only in inline assembly. It's safe to; // simply skip unusual names. Subset of MCAsmInfo::isAcceptableChar(); // and MCAsmInfoXCOFF::isAcceptableChar().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp:72,Usability,simpl,simply,72,// Promotion aliases are used only in inline assembly. It's safe to; // simply skip unusual names. Subset of MCAsmInfo::isAcceptableChar(); // and MCAsmInfoXCOFF::isAcceptableChar().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp:50,Safety,avoid,avoid,50,// Create a local alias with the original name to avoid breaking; // references from inline assembly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp:47,Modifiability,variab,variable,47,"// Finally, add them to a llvm[.compiler].used variable in DestM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp:543,Performance,optimiz,optimized,543,"// Collect the set of virtual functions that are eligible for virtual constant; // propagation. Each eligible function must not access memory, must return; // an integer of width <=64 bits, must take at least one argument, must not; // use its first argument (assumed to be ""this"") and all arguments other than; // the first one must be of <=64 bit integer type.; //; // Note that we test whether this copy of the function is readnone, rather; // than testing function attributes, which must hold for any copy of the; // function, even a less optimized version substituted at link time. This is; // sound because the virtual constant propagation optimizations effectively; // inline all implementations of the virtual function into each call site,; // rather than using function attributes to perform local optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp:646,Performance,optimiz,optimizations,646,"// Collect the set of virtual functions that are eligible for virtual constant; // propagation. Each eligible function must not access memory, must return; // an integer of width <=64 bits, must take at least one argument, must not; // use its first argument (assumed to be ""this"") and all arguments other than; // the first one must be of <=64 bit integer type.; //; // Note that we test whether this copy of the function is readnone, rather; // than testing function attributes, which must hold for any copy of the; // function, even a less optimized version substituted at link time. This is; // sound because the virtual constant propagation optimizations effectively; // inline all implementations of the virtual function into each call site,; // rather than using function attributes to perform local optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp:793,Performance,perform,perform,793,"// Collect the set of virtual functions that are eligible for virtual constant; // propagation. Each eligible function must not access memory, must return; // an integer of width <=64 bits, must take at least one argument, must not; // use its first argument (assumed to be ""this"") and all arguments other than; // the first one must be of <=64 bit integer type.; //; // Note that we test whether this copy of the function is readnone, rather; // than testing function attributes, which must hold for any copy of the; // function, even a less optimized version substituted at link time. This is; // sound because the virtual constant propagation optimizations effectively; // inline all implementations of the virtual function into each call site,; // rather than using function attributes to perform local optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp:807,Performance,optimiz,optimization,807,"// Collect the set of virtual functions that are eligible for virtual constant; // propagation. Each eligible function must not access memory, must return; // an integer of width <=64 bits, must take at least one argument, must not; // use its first argument (assumed to be ""this"") and all arguments other than; // the first one must be of <=64 bit integer type.; //; // Note that we test whether this copy of the function is readnone, rather; // than testing function attributes, which must hold for any copy of the; // function, even a less optimized version substituted at link time. This is; // sound because the virtual constant propagation optimizations effectively; // inline all implementations of the virtual function into each call site,; // rather than using function attributes to perform local optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp:128,Security,access,access,128,"// Collect the set of virtual functions that are eligible for virtual constant; // propagation. Each eligible function must not access memory, must return; // an integer of width <=64 bits, must take at least one argument, must not; // use its first argument (assumed to be ""this"") and all arguments other than; // the first one must be of <=64 bit integer type.; //; // Note that we test whether this copy of the function is readnone, rather; // than testing function attributes, which must hold for any copy of the; // function, even a less optimized version substituted at link time. This is; // sound because the virtual constant propagation optimizations effectively; // inline all implementations of the virtual function into each call site,; // rather than using function attributes to perform local optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp:384,Testability,test,test,384,"// Collect the set of virtual functions that are eligible for virtual constant; // propagation. Each eligible function must not access memory, must return; // an integer of width <=64 bits, must take at least one argument, must not; // use its first argument (assumed to be ""this"") and all arguments other than; // the first one must be of <=64 bit integer type.; //; // Note that we test whether this copy of the function is readnone, rather; // than testing function attributes, which must hold for any copy of the; // function, even a less optimized version substituted at link time. This is; // sound because the virtual constant propagation optimizations effectively; // inline all implementations of the virtual function into each call site,; // rather than using function attributes to perform local optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp:452,Testability,test,testing,452,"// Collect the set of virtual functions that are eligible for virtual constant; // propagation. Each eligible function must not access memory, must return; // an integer of width <=64 bits, must take at least one argument, must not; // use its first argument (assumed to be ""this"") and all arguments other than; // the first one must be of <=64 bit integer type.; //; // Note that we test whether this copy of the function is readnone, rather; // than testing function attributes, which must hold for any copy of the; // function, even a less optimized version substituted at link time. This is; // sound because the virtual constant propagation optimizations effectively; // inline all implementations of the virtual function into each call site,; // rather than using function attributes to perform local optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp:19,Security,hash,hash,19,"// Save the module hash produced for the full bitcode, which will; // be used in the backends, and use that in the minimized bitcode; // produced for the full link.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp:66,Security,hash,hash,66,"// Write it out as an unsplit ThinLTO module.; // Save the module hash produced for the full bitcode, which will; // be used in the backends, and use that in the minimized bitcode; // produced for the full link.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:1633,Deployability,pipeline,pipelines,1633,"at callee.; // - Virtual constant propagation: if the virtual function's return type is an; // integer <=64 bits and all possible callees are readnone, for each class and; // each list of constant arguments: evaluate the function, store the return; // value alongside the virtual table, and rewrite each virtual call as a load; // from the virtual table.; // - Uniform return value optimization: if the conditions for virtual constant; // propagation hold and each function returns the same constant value, replace; // each virtual call with that constant.; // - Unique return value optimization for i1 return values: if the conditions; // for virtual constant propagation hold and a single vtable's function; // returns 0, or a single vtable's function returns 1, replace each virtual; // call with a comparison of the vptr against that vtable's address.; //; // This pass is intended to be used during the regular and thin LTO pipelines:; //; // During regular LTO, the pass determines the best optimization for each; // virtual call and applies the resolutions directly to virtual calls that are; // eligible for virtual call optimization (i.e. calls that use either of the; // llvm.assume(llvm.type.test) or llvm.type.checked.load intrinsics).; //; // During hybrid Regular/ThinLTO, the pass operates in two phases:; // - Export phase: this is run during the thin link over a single merged module; // that contains all vtables with !type metadata that participate in the link.; // The pass computes a resolution for each virtual call and stores it in the; // type identifier summary.; // - Import phase: this is run during the thin backends over the individual; // modules. The pass applies the resolutions previously computed during the; // import phase to each eligible virtual call.; //; // During ThinLTO, the pass operates in two phases:; // - Export phase: this is run during the thin link over the index which; // contains a summary of all vtables with !type metadata that participate in; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:995,Modifiability,rewrite,rewrite,995,"//===- WholeProgramDevirt.cpp - Whole program virtual call optimization ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements whole program optimization of virtual calls in cases; // where we know (via !type metadata) that the list of callees is fixed. This; // includes the following:; // - Single implementation devirtualization: if a virtual call has a single; // possible callee, replace all calls with a direct call to that callee.; // - Virtual constant propagation: if the virtual function's return type is an; // integer <=64 bits and all possible callees are readnone, for each class and; // each list of constant arguments: evaluate the function, store the return; // value alongside the virtual table, and rewrite each virtual call as a load; // from the virtual table.; // - Uniform return value optimization: if the conditions for virtual constant; // propagation hold and each function returns the same constant value, replace; // each virtual call with that constant.; // - Unique return value optimization for i1 return values: if the conditions; // for virtual constant propagation hold and a single vtable's function; // returns 0, or a single vtable's function returns 1, replace each virtual; // call with a comparison of the vptr against that vtable's address.; //; // This pass is intended to be used during the regular and thin LTO pipelines:; //; // During regular LTO, the pass determines the best optimization for each; // virtual call and applies the resolutions directly to virtual calls that are; // eligible for virtual call optimization (i.e. calls that use either of the; // llvm.assume(llvm.type.test) or llvm.type.checked.load intrinsics).; //; // During hybrid Regular/ThinLTO, the pass o",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:59,Performance,optimiz,optimization,59,"//===- WholeProgramDevirt.cpp - Whole program virtual call optimization ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements whole program optimization of virtual calls in cases; // where we know (via !type metadata) that the list of callees is fixed. This; // includes the following:; // - Single implementation devirtualization: if a virtual call has a single; // possible callee, replace all calls with a direct call to that callee.; // - Virtual constant propagation: if the virtual function's return type is an; // integer <=64 bits and all possible callees are readnone, for each class and; // each list of constant arguments: evaluate the function, store the return; // value alongside the virtual table, and rewrite each virtual call as a load; // from the virtual table.; // - Uniform return value optimization: if the conditions for virtual constant; // propagation hold and each function returns the same constant value, replace; // each virtual call with that constant.; // - Unique return value optimization for i1 return values: if the conditions; // for virtual constant propagation hold and a single vtable's function; // returns 0, or a single vtable's function returns 1, replace each virtual; // call with a comparison of the vptr against that vtable's address.; //; // This pass is intended to be used during the regular and thin LTO pipelines:; //; // During regular LTO, the pass determines the best optimization for each; // virtual call and applies the resolutions directly to virtual calls that are; // eligible for virtual call optimization (i.e. calls that use either of the; // llvm.assume(llvm.type.test) or llvm.type.checked.load intrinsics).; //; // During hybrid Regular/ThinLTO, the pass o",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:418,Performance,optimiz,optimization,418,"//===- WholeProgramDevirt.cpp - Whole program virtual call optimization ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements whole program optimization of virtual calls in cases; // where we know (via !type metadata) that the list of callees is fixed. This; // includes the following:; // - Single implementation devirtualization: if a virtual call has a single; // possible callee, replace all calls with a direct call to that callee.; // - Virtual constant propagation: if the virtual function's return type is an; // integer <=64 bits and all possible callees are readnone, for each class and; // each list of constant arguments: evaluate the function, store the return; // value alongside the virtual table, and rewrite each virtual call as a load; // from the virtual table.; // - Uniform return value optimization: if the conditions for virtual constant; // propagation hold and each function returns the same constant value, replace; // each virtual call with that constant.; // - Unique return value optimization for i1 return values: if the conditions; // for virtual constant propagation hold and a single vtable's function; // returns 0, or a single vtable's function returns 1, replace each virtual; // call with a comparison of the vptr against that vtable's address.; //; // This pass is intended to be used during the regular and thin LTO pipelines:; //; // During regular LTO, the pass determines the best optimization for each; // virtual call and applies the resolutions directly to virtual calls that are; // eligible for virtual call optimization (i.e. calls that use either of the; // llvm.assume(llvm.type.test) or llvm.type.checked.load intrinsics).; //; // During hybrid Regular/ThinLTO, the pass o",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:1026,Performance,load,load,1026,"//===- WholeProgramDevirt.cpp - Whole program virtual call optimization ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements whole program optimization of virtual calls in cases; // where we know (via !type metadata) that the list of callees is fixed. This; // includes the following:; // - Single implementation devirtualization: if a virtual call has a single; // possible callee, replace all calls with a direct call to that callee.; // - Virtual constant propagation: if the virtual function's return type is an; // integer <=64 bits and all possible callees are readnone, for each class and; // each list of constant arguments: evaluate the function, store the return; // value alongside the virtual table, and rewrite each virtual call as a load; // from the virtual table.; // - Uniform return value optimization: if the conditions for virtual constant; // propagation hold and each function returns the same constant value, replace; // each virtual call with that constant.; // - Unique return value optimization for i1 return values: if the conditions; // for virtual constant propagation hold and a single vtable's function; // returns 0, or a single vtable's function returns 1, replace each virtual; // call with a comparison of the vptr against that vtable's address.; //; // This pass is intended to be used during the regular and thin LTO pipelines:; //; // During regular LTO, the pass determines the best optimization for each; // virtual call and applies the resolutions directly to virtual calls that are; // eligible for virtual call optimization (i.e. calls that use either of the; // llvm.assume(llvm.type.test) or llvm.type.checked.load intrinsics).; //; // During hybrid Regular/ThinLTO, the pass o",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:1086,Performance,optimiz,optimization,1086,"ptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements whole program optimization of virtual calls in cases; // where we know (via !type metadata) that the list of callees is fixed. This; // includes the following:; // - Single implementation devirtualization: if a virtual call has a single; // possible callee, replace all calls with a direct call to that callee.; // - Virtual constant propagation: if the virtual function's return type is an; // integer <=64 bits and all possible callees are readnone, for each class and; // each list of constant arguments: evaluate the function, store the return; // value alongside the virtual table, and rewrite each virtual call as a load; // from the virtual table.; // - Uniform return value optimization: if the conditions for virtual constant; // propagation hold and each function returns the same constant value, replace; // each virtual call with that constant.; // - Unique return value optimization for i1 return values: if the conditions; // for virtual constant propagation hold and a single vtable's function; // returns 0, or a single vtable's function returns 1, replace each virtual; // call with a comparison of the vptr against that vtable's address.; //; // This pass is intended to be used during the regular and thin LTO pipelines:; //; // During regular LTO, the pass determines the best optimization for each; // virtual call and applies the resolutions directly to virtual calls that are; // eligible for virtual call optimization (i.e. calls that use either of the; // llvm.assume(llvm.type.test) or llvm.type.checked.load intrinsics).; //; // During hybrid Regular/ThinLTO, the pass operates in two phases:; // - Export phase: this is run during the thin link over a single merged module; // that contains all vtables with !type metadata that",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:1287,Performance,optimiz,optimization,1287," program optimization of virtual calls in cases; // where we know (via !type metadata) that the list of callees is fixed. This; // includes the following:; // - Single implementation devirtualization: if a virtual call has a single; // possible callee, replace all calls with a direct call to that callee.; // - Virtual constant propagation: if the virtual function's return type is an; // integer <=64 bits and all possible callees are readnone, for each class and; // each list of constant arguments: evaluate the function, store the return; // value alongside the virtual table, and rewrite each virtual call as a load; // from the virtual table.; // - Uniform return value optimization: if the conditions for virtual constant; // propagation hold and each function returns the same constant value, replace; // each virtual call with that constant.; // - Unique return value optimization for i1 return values: if the conditions; // for virtual constant propagation hold and a single vtable's function; // returns 0, or a single vtable's function returns 1, replace each virtual; // call with a comparison of the vptr against that vtable's address.; //; // This pass is intended to be used during the regular and thin LTO pipelines:; //; // During regular LTO, the pass determines the best optimization for each; // virtual call and applies the resolutions directly to virtual calls that are; // eligible for virtual call optimization (i.e. calls that use either of the; // llvm.assume(llvm.type.test) or llvm.type.checked.load intrinsics).; //; // During hybrid Regular/ThinLTO, the pass operates in two phases:; // - Export phase: this is run during the thin link over a single merged module; // that contains all vtables with !type metadata that participate in the link.; // The pass computes a resolution for each virtual call and stores it in the; // type identifier summary.; // - Import phase: this is run during the thin backends over the individual; // modules. The pass applies the resolut",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:1701,Performance,optimiz,optimization,1701,"at callee.; // - Virtual constant propagation: if the virtual function's return type is an; // integer <=64 bits and all possible callees are readnone, for each class and; // each list of constant arguments: evaluate the function, store the return; // value alongside the virtual table, and rewrite each virtual call as a load; // from the virtual table.; // - Uniform return value optimization: if the conditions for virtual constant; // propagation hold and each function returns the same constant value, replace; // each virtual call with that constant.; // - Unique return value optimization for i1 return values: if the conditions; // for virtual constant propagation hold and a single vtable's function; // returns 0, or a single vtable's function returns 1, replace each virtual; // call with a comparison of the vptr against that vtable's address.; //; // This pass is intended to be used during the regular and thin LTO pipelines:; //; // During regular LTO, the pass determines the best optimization for each; // virtual call and applies the resolutions directly to virtual calls that are; // eligible for virtual call optimization (i.e. calls that use either of the; // llvm.assume(llvm.type.test) or llvm.type.checked.load intrinsics).; //; // During hybrid Regular/ThinLTO, the pass operates in two phases:; // - Export phase: this is run during the thin link over a single merged module; // that contains all vtables with !type metadata that participate in the link.; // The pass computes a resolution for each virtual call and stores it in the; // type identifier summary.; // - Import phase: this is run during the thin backends over the individual; // modules. The pass applies the resolutions previously computed during the; // import phase to each eligible virtual call.; //; // During ThinLTO, the pass operates in two phases:; // - Export phase: this is run during the thin link over the index which; // contains a summary of all vtables with !type metadata that participate in; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:1833,Performance,optimiz,optimization,1833,"at callee.; // - Virtual constant propagation: if the virtual function's return type is an; // integer <=64 bits and all possible callees are readnone, for each class and; // each list of constant arguments: evaluate the function, store the return; // value alongside the virtual table, and rewrite each virtual call as a load; // from the virtual table.; // - Uniform return value optimization: if the conditions for virtual constant; // propagation hold and each function returns the same constant value, replace; // each virtual call with that constant.; // - Unique return value optimization for i1 return values: if the conditions; // for virtual constant propagation hold and a single vtable's function; // returns 0, or a single vtable's function returns 1, replace each virtual; // call with a comparison of the vptr against that vtable's address.; //; // This pass is intended to be used during the regular and thin LTO pipelines:; //; // During regular LTO, the pass determines the best optimization for each; // virtual call and applies the resolutions directly to virtual calls that are; // eligible for virtual call optimization (i.e. calls that use either of the; // llvm.assume(llvm.type.test) or llvm.type.checked.load intrinsics).; //; // During hybrid Regular/ThinLTO, the pass operates in two phases:; // - Export phase: this is run during the thin link over a single merged module; // that contains all vtables with !type metadata that participate in the link.; // The pass computes a resolution for each virtual call and stores it in the; // type identifier summary.; // - Import phase: this is run during the thin backends over the individual; // modules. The pass applies the resolutions previously computed during the; // import phase to each eligible virtual call.; //; // During ThinLTO, the pass operates in two phases:; // - Export phase: this is run during the thin link over the index which; // contains a summary of all vtables with !type metadata that participate in; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:1934,Performance,load,load,1934,"he return; // value alongside the virtual table, and rewrite each virtual call as a load; // from the virtual table.; // - Uniform return value optimization: if the conditions for virtual constant; // propagation hold and each function returns the same constant value, replace; // each virtual call with that constant.; // - Unique return value optimization for i1 return values: if the conditions; // for virtual constant propagation hold and a single vtable's function; // returns 0, or a single vtable's function returns 1, replace each virtual; // call with a comparison of the vptr against that vtable's address.; //; // This pass is intended to be used during the regular and thin LTO pipelines:; //; // During regular LTO, the pass determines the best optimization for each; // virtual call and applies the resolutions directly to virtual calls that are; // eligible for virtual call optimization (i.e. calls that use either of the; // llvm.assume(llvm.type.test) or llvm.type.checked.load intrinsics).; //; // During hybrid Regular/ThinLTO, the pass operates in two phases:; // - Export phase: this is run during the thin link over a single merged module; // that contains all vtables with !type metadata that participate in the link.; // The pass computes a resolution for each virtual call and stores it in the; // type identifier summary.; // - Import phase: this is run during the thin backends over the individual; // modules. The pass applies the resolutions previously computed during the; // import phase to each eligible virtual call.; //; // During ThinLTO, the pass operates in two phases:; // - Export phase: this is run during the thin link over the index which; // contains a summary of all vtables with !type metadata that participate in; // the link. It computes a resolution for each virtual call and stores it in; // the type identifier summary. Only single implementation devirtualization; // is supported.; // - Import phase: (same as with hybrid case above).; //; //===---",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:1907,Testability,test,test,1907,"aluate the function, store the return; // value alongside the virtual table, and rewrite each virtual call as a load; // from the virtual table.; // - Uniform return value optimization: if the conditions for virtual constant; // propagation hold and each function returns the same constant value, replace; // each virtual call with that constant.; // - Unique return value optimization for i1 return values: if the conditions; // for virtual constant propagation hold and a single vtable's function; // returns 0, or a single vtable's function returns 1, replace each virtual; // call with a comparison of the vptr against that vtable's address.; //; // This pass is intended to be used during the regular and thin LTO pipelines:; //; // During regular LTO, the pass determines the best optimization for each; // virtual call and applies the resolutions directly to virtual calls that are; // eligible for virtual call optimization (i.e. calls that use either of the; // llvm.assume(llvm.type.test) or llvm.type.checked.load intrinsics).; //; // During hybrid Regular/ThinLTO, the pass operates in two phases:; // - Export phase: this is run during the thin link over a single merged module; // that contains all vtables with !type metadata that participate in the link.; // The pass computes a resolution for each virtual call and stores it in the; // type identifier summary.; // - Import phase: this is run during the thin backends over the individual; // modules. The pass applies the resolutions previously computed during the; // import phase to each eligible virtual call.; //; // During ThinLTO, the pass operates in two phases:; // - Export phase: this is run during the thin link over the index which; // contains a summary of all vtables with !type metadata that participate in; // the link. It computes a resolution for each virtual call and stores it in; // the type identifier summary. Only single implementation devirtualization; // is supported.; // - Import phase: (same as with hybr",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:62,Testability,test,tests,62,/// Provide a way to force enable whole program visibility in tests.; /// This is needed to support legacy tests that don't contain; /// !vcall_visibility metadata (the mere presense of type tests; /// previously implied hidden visibility).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:107,Testability,test,tests,107,/// Provide a way to force enable whole program visibility in tests.; /// This is needed to support legacy tests that don't contain; /// !vcall_visibility metadata (the mere presense of type tests; /// previously implied hidden visibility).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:191,Testability,test,tests,191,/// Provide a way to force enable whole program visibility in tests.; /// This is needed to support legacy tests that don't contain; /// !vcall_visibility metadata (the mere presense of type tests; /// previously implied hidden visibility).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:229,Availability,failure,failures,229,"/// Mechanism to add runtime checking of devirtualization decisions, optionally; /// trapping or falling back to indirect call on any that are not correct.; /// Trapping mode is useful for debugging undefined behavior leading to failures; /// with WPD. Fallback mode is useful for ensuring safety when whole program; /// visibility may be compromised.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:290,Safety,safe,safety,290,"/// Mechanism to add runtime checking of devirtualization decisions, optionally; /// trapping or falling back to indirect call on any that are not correct.; /// Trapping mode is useful for debugging undefined behavior leading to failures; /// with WPD. Fallback mode is useful for ensuring safety when whole program; /// visibility may be compromised.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:332,Energy Efficiency,allocate,allocated,332,"// Build a vector of arrays of bytes covering, for each target, a slice of the; // used region (see AccumBitVector::BytesUsed in; // llvm/Transforms/IPO/WholeProgramDevirt.h) starting at MinByte. Effectively,; // this aligns the used regions to start at MinByte.; //; // In this example, A, B and C are vtables, # is a byte already allocated for; // a virtual function pointer, AAAA... (etc.) are the used regions for the; // vtables and Offset(X) is the value computed for the Offset variable below; // for X.; //; // Offset(A); // | |; // |MinByte; // A: ################AAAAAAAA|AAAAAAAA; // B: ########BBBBBBBBBBBBBBBB|BBBB; // C: ########################|CCCCCCCCCCCCCCCC; // | Offset(B) |; //; // This code produces the slices of A, B and C that appear after the divider; // at MinByte.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:485,Modifiability,variab,variable,485,"// Build a vector of arrays of bytes covering, for each target, a slice of the; // used region (see AccumBitVector::BytesUsed in; // llvm/Transforms/IPO/WholeProgramDevirt.h) starting at MinByte. Effectively,; // this aligns the used regions to start at MinByte.; //; // In this example, A, B and C are vtables, # is a byte already allocated for; // a virtual function pointer, AAAA... (etc.) are the used regions for the; // vtables and Offset(X) is the value computed for the Offset variable below; // for X.; //; // Offset(A); // | |; // |MinByte; // A: ################AAAAAAAA|AAAAAAAA; // B: ########BBBBBBBBBBBBBBBB|BBBB; // C: ########################|CCCCCCCCCCCCCCCC; // | Offset(B) |; //; // This code produces the slices of A, B and C that appear after the divider; // at MinByte.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:320,Usability,GUID,GUID,320,"// end namespace llvm; // Returns true if the function must be unreachable based on ValueInfo.; //; // In particular, identifies a function as unreachable in the following; // conditions; // 1) All summaries are live.; // 2) All function summaries indicate it's unreachable; // 3) There is no non-function with the same GUID (which is rare)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:50,Usability,GUID,GUID,50,// Be conservative if a non-function has the same GUID (which is rare).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:38,Performance,load,loaded,38,"// A virtual call site. VTable is the loaded virtual table pointer, and CS is; // the indirect virtual call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:52,Safety,unsafe,unsafe,52,"// If non-null, this field points to the associated unsafe use count stored in; // the DevirtModule::NumUnsafeUsesForTypeTest map below. See the description; // of that field for details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:25,Safety,unsafe,unsafe,25,// This use is no longer unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:191,Testability,test,test,191,// These fields are used during the export phase of ThinLTO and reflect; // information collected from function summaries.; /// Whether any function summary contains an llvm.assume(llvm.type.test) for; /// this slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:105,Performance,load,load,105,"/// CFI-specific: a vector containing the list of function summaries that use; /// the llvm.type.checked.load intrinsic and therefore will require; /// resolutions for llvm.type.test in order to implement CFI checks if; /// devirtualization was unsuccessful. If devirtualization was successful, the; /// pass will clear this vector by calling markDevirt(). If at the end of the; /// pass the vector is non-empty, we will need to add a use of llvm.type.test; /// to each of the function summaries in the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:178,Testability,test,test,178,"/// CFI-specific: a vector containing the list of function summaries that use; /// the llvm.type.checked.load intrinsic and therefore will require; /// resolutions for llvm.type.test in order to implement CFI checks if; /// devirtualization was unsuccessful. If devirtualization was successful, the; /// pass will clear this vector by calling markDevirt(). If at the end of the; /// pass the vector is non-empty, we will need to add a use of llvm.type.test; /// to each of the function summaries in the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:452,Testability,test,test,452,"/// CFI-specific: a vector containing the list of function summaries that use; /// the llvm.type.checked.load intrinsic and therefore will require; /// resolutions for llvm.type.test in order to implement CFI checks if; /// devirtualization was unsuccessful. If devirtualization was successful, the; /// pass will clear this vector by calling markDevirt(). If at the end of the; /// pass the vector is non-empty, we will need to add a use of llvm.type.test; /// to each of the function summaries in the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:314,Usability,clear,clear,314,"/// CFI-specific: a vector containing the list of function summaries that use; /// the llvm.type.checked.load intrinsic and therefore will require; /// resolutions for llvm.type.test in order to implement CFI checks if; /// devirtualization was unsuccessful. If devirtualization was successful, the; /// pass will clear this vector by calling markDevirt(). If at the end of the; /// pass the vector is non-empty, we will need to add a use of llvm.type.test; /// to each of the function summaries in the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:32,Performance,optimiz,optimized,32,// Calls that have already been optimized. We may add a call to multiple; // VTableSlotInfos if vtable loads are coalesced and need to make sure not to; // optimize a call more than once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:103,Performance,load,loads,103,// Calls that have already been optimized. We may add a call to multiple; // VTableSlotInfos if vtable loads are coalesced and need to make sure not to; // optimize a call more than once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:156,Performance,optimiz,optimize,156,// Calls that have already been optimized. We may add a call to multiple; // VTableSlotInfos if vtable loads are coalesced and need to make sure not to; // optimize a call more than once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:99,Performance,optimiz,optimization,99,// Store calls that had their ptrauth bundle removed. They are to be deleted; // at the end of the optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:60,Performance,load,loaded,60,"// This map keeps track of the number of ""unsafe"" uses of a loaded function; // pointer. The key is the associated llvm.type.test intrinsic call generated; // by this pass. An unsafe use is one that calls the loaded function pointer; // directly. Every time we eliminate an unsafe use (for example, by; // devirtualizing it or by applying virtual constant propagation), we; // decrement the value stored in this map. If a value reaches zero, we can; // eliminate the type check by RAUWing the associated llvm.type.test call with; // true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:209,Performance,load,loaded,209,"// This map keeps track of the number of ""unsafe"" uses of a loaded function; // pointer. The key is the associated llvm.type.test intrinsic call generated; // by this pass. An unsafe use is one that calls the loaded function pointer; // directly. Every time we eliminate an unsafe use (for example, by; // devirtualizing it or by applying virtual constant propagation), we; // decrement the value stored in this map. If a value reaches zero, we can; // eliminate the type check by RAUWing the associated llvm.type.test call with; // true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:42,Safety,unsafe,unsafe,42,"// This map keeps track of the number of ""unsafe"" uses of a loaded function; // pointer. The key is the associated llvm.type.test intrinsic call generated; // by this pass. An unsafe use is one that calls the loaded function pointer; // directly. Every time we eliminate an unsafe use (for example, by; // devirtualizing it or by applying virtual constant propagation), we; // decrement the value stored in this map. If a value reaches zero, we can; // eliminate the type check by RAUWing the associated llvm.type.test call with; // true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:176,Safety,unsafe,unsafe,176,"// This map keeps track of the number of ""unsafe"" uses of a loaded function; // pointer. The key is the associated llvm.type.test intrinsic call generated; // by this pass. An unsafe use is one that calls the loaded function pointer; // directly. Every time we eliminate an unsafe use (for example, by; // devirtualizing it or by applying virtual constant propagation), we; // decrement the value stored in this map. If a value reaches zero, we can; // eliminate the type check by RAUWing the associated llvm.type.test call with; // true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:274,Safety,unsafe,unsafe,274,"// This map keeps track of the number of ""unsafe"" uses of a loaded function; // pointer. The key is the associated llvm.type.test intrinsic call generated; // by this pass. An unsafe use is one that calls the loaded function pointer; // directly. Every time we eliminate an unsafe use (for example, by; // devirtualizing it or by applying virtual constant propagation), we; // decrement the value stored in this map. If a value reaches zero, we can; // eliminate the type check by RAUWing the associated llvm.type.test call with; // true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:125,Testability,test,test,125,"// This map keeps track of the number of ""unsafe"" uses of a loaded function; // pointer. The key is the associated llvm.type.test intrinsic call generated; // by this pass. An unsafe use is one that calls the loaded function pointer; // directly. Every time we eliminate an unsafe use (for example, by; // devirtualizing it or by applying virtual constant propagation), we; // decrement the value stored in this map. If a value reaches zero, we can; // eliminate the type check by RAUWing the associated llvm.type.test call with; // true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:514,Testability,test,test,514,"// This map keeps track of the number of ""unsafe"" uses of a loaded function; // pointer. The key is the associated llvm.type.test intrinsic call generated; // by this pass. An unsafe use is one that calls the loaded function pointer; // directly. Every time we eliminate an unsafe use (for example, by; // devirtualizing it or by applying virtual constant propagation), we; // decrement the value stored in this map. If a value reaches zero, we can; // eliminate the type check by RAUWing the associated llvm.type.test call with; // true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:67,Performance,load,load,67,"// If we were able to eliminate all unsafe uses for a type checked load,; // eliminate the associated type tests by replacing them with true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:36,Safety,unsafe,unsafe,36,"// If we were able to eliminate all unsafe uses for a type checked load,; // eliminate the associated type tests by replacing them with true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:107,Testability,test,tests,107,"// If we were able to eliminate all unsafe uses for a type checked load,; // eliminate the associated type tests by replacing them with true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:91,Testability,test,testing,91,// Lower the module using the action and summary passed as command line; // arguments. For testing purposes only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:30,Usability,GUID,GUIDs,30,"// The set in which to record GUIDs exported from their module by; // devirtualization, used by client to ensure they are not internalized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:47,Deployability,upgrade,upgrade,47,"/// If whole program visibility asserted, then upgrade all public vcall; /// visibility metadata on vtable definitions to linkage unit visibility in; /// Module IR (for regular or hybrid LTO).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:32,Testability,assert,asserted,32,"/// If whole program visibility asserted, then upgrade all public vcall; /// visibility metadata on vtable definitions to linkage unit visibility in; /// Module IR (for regular or hybrid LTO).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:38,Modifiability,variab,variable,38,"// Add linkage unit visibility to any variable with type metadata, which are; // the vtable definitions. We won't have an existing vcall_visibility; // metadata on vtable definitions with public visibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:9,Deployability,upgrade,upgrade,9,"// Don't upgrade the visibility for symbols exported to the dynamic; // linker, as we have no information on their eventual use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:8,Security,validat,validation,8,"// With validation enabled, we want to exclude symbols visible to; // regular objects. Local symbols will be in this group due to the; // current implementation but those with VCallVisibilityTranslationUnit; // will have already been marked in clang so are unaffected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:54,Usability,GUID,GUIDS,54,"/// Based on typeID string, get all associated vtable GUIDS that are; /// visible to regular objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:47,Deployability,upgrade,upgrade,47,"/// If whole program visibility asserted, then upgrade all public vcall; /// visibility metadata on vtable definition summaries to linkage unit; /// visibility in Module summary index (for ThinLTO).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:32,Testability,assert,asserted,32,"/// If whole program visibility asserted, then upgrade all public vcall; /// visibility metadata on vtable definition summaries to linkage unit; /// visibility in Module summary index (for ThinLTO).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:9,Deployability,upgrade,upgrade,9,"// Don't upgrade the visibility for symbols exported to the dynamic; // linker, as we have no information on their eventual use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:8,Security,validat,validation,8,"// With validation enabled, we want to exclude symbols visible to regular; // objects. Local symbols will be in this group due to the current; // implementation but those with VCallVisibilityTranslationUnit will have; // already been marked in clang so are unaffected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:61,Performance,perform,performing,61,"// Check that summary index contains regular LTO module when performing; // export to prevent occasional use of index from pure ThinLTO compilation; // (-fno-split-lto-module). This kind of summary index is passed to; // DevirtIndex::run, not to DevirtModule::run used by opt/runForTesting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:103,Availability,error,errors,103,"// Handle the command-line summary arguments. This code is for testing; // purposes only, so we handle errors directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:63,Testability,test,testing,63,"// Handle the command-line summary arguments. This code is for testing; // purposes only, so we handle errors directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:13,Performance,perform,perform,13,// We cannot perform whole program devirtualization analysis on a vtable; // with public LTO visibility.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:296,Availability,error,error,296,"// Find a representative copy of the vtable initializer.; // We can have multiple available_externally, linkonce_odr and weak_odr; // vtable initializers. We can also have multiple external vtable; // initializers in the case of comdats, which we cannot check here.; // The linker should give an error in this case.; //; // Also, handle the case of same-named local Vtables with the same path; // and therefore the same GUID. This can happen if there isn't enough; // distinguishing path when compiling the source file. In that case we; // conservatively return false early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:420,Usability,GUID,GUID,420,"// Find a representative copy of the vtable initializer.; // We can have multiple available_externally, linkonce_odr and weak_odr; // vtable initializers. We can also have multiple external vtable; // initializers in the case of comdats, which we cannot check here.; // The linker should give an error in this case.; //; // Also, handle the case of same-named local Vtables with the same path; // and therefore the same GUID. This can happen if there isn't enough; // distinguishing path when compiling the source file. In that case we; // conservatively return false early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:403,Safety,avoid,avoid,403,"// Previously clang did not attach the necessary type metadata to; // available_externally vtables, in which case there would not; // be any vtable functions listed in the summary and we need; // to treat this case conservatively (in case the bitcode is old).; // However, we will also not have any vtable functions in the; // case of a pure virtual base class. In that case we do want; // to set VS to avoid treating it conservatively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:13,Performance,perform,perform,13,// We cannot perform whole program devirtualization analysis on a vtable; // with public LTO visibility.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:120,Performance,perform,perform,120,// There will be no VS if all copies are available_externally having no; // type metadata. In that case we can't safely perform WPD.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:113,Safety,safe,safely,113,// There will be no VS if all copies are available_externally having no; // type metadata. In that case we can't safely perform WPD.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:144,Performance,perform,perform,144,"// If trap checking is enabled, add support to compare the virtual; // function pointer to the devirtualized target. In case of a mismatch,; // perform a debug trap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:46,Usability,clear,clear,46,"// Since the new call site is direct, we must clear metadata that; // is only appropriate for indirect calls. This includes !prof and; // !callees metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:104,Performance,perform,perform,104,"// Additionally, we should remove them from the fallback indirect call,; // so that we don't attempt to perform indirect call promotion later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:46,Usability,clear,clear,46,"// Since the call site is now direct, we must clear metadata that; // is only appropriate for indirect calls. This includes !prof and; // !callees metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:3,Energy Efficiency,Schedul,Schedule,3,// Schedule for deletion at the end of pass run.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:25,Safety,unsafe,unsafe,25,// This use is no longer unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:127,Testability,test,tests,127,"// Insert calls into the summary index so that the devirtualized targets; // are eligible for import.; // FIXME: Annotate type tests with hotness. For now, mark these as hot; // to better ensure we have the opportunity to inline them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:10,Deployability,update,update,10,"// If so, update each call site to call that implementation directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:136,Performance,load,load,136,"// When finding devirtualizable calls, it's possible to find the same; // vtable passed to multiple llvm.type.test or llvm.type.checked.load; // calls, which can cause duplicate call sites to be recorded in; // [Const]CallSites. If we've already found one of these; // call instances, just ignore it. It will be replaced later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:110,Testability,test,test,110,"// When finding devirtualizable calls, it's possible to find the same; // vtable passed to multiple llvm.type.test or llvm.type.checked.load; // calls, which can cause duplicate call sites to be recorded in; // [Const]CallSites. If we've already found one of these; // call instances, just ignore it. It will be replaced later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:25,Safety,unsafe,unsafe,25,// This use is no longer unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:159,Testability,test,test,159,"// Don't mark as devirtualized because there may be callers compiled without; // retpoline mitigation, which would mean that they are lowered to; // llvm.type.test and therefore require an llvm.type.test resolution for the; // type identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:199,Testability,test,test,199,"// Don't mark as devirtualized because there may be callers compiled without; // retpoline mitigation, which would mean that they are lowered to; // llvm.type.test and therefore require an llvm.type.test resolution for the; // type identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:165,Performance,optimiz,optimization,165,"// TODO: Skip for now if the vtable symbol was an alias to a function,; // need to evaluate whether it would be correct to analyze the aliasee; // function for this optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:24,Performance,optimiz,optimization,24,"// Uniform return value optimization. If all functions return the same; // constant, replace all calls with that constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:3,Deployability,Update,Update,3,// Update devirtualization statistics for targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:165,Performance,optimiz,optimization,165,"// TODO: Skip for now if the vtable symbol was an alias to a function,; // need to evaluate whether it would be correct to analyze the aliasee; // function for this optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:376,Performance,optimiz,optimized,376,"// Make sure that each function is defined, does not access memory, takes at; // least one argument, does not use its first argument (which we assume is; // 'this'), and has the same return type.; //; // Note that we test whether this copy of the function is readnone, rather; // than testing function attributes, which must hold for any copy of the; // function, even a less optimized version substituted at link time. This is; // sound because the virtual constant propagation optimizations effectively; // inline all implementations of the virtual function into each call site,; // rather than using function attributes to perform local optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:479,Performance,optimiz,optimizations,479,"// Make sure that each function is defined, does not access memory, takes at; // least one argument, does not use its first argument (which we assume is; // 'this'), and has the same return type.; //; // Note that we test whether this copy of the function is readnone, rather; // than testing function attributes, which must hold for any copy of the; // function, even a less optimized version substituted at link time. This is; // sound because the virtual constant propagation optimizations effectively; // inline all implementations of the virtual function into each call site,; // rather than using function attributes to perform local optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:626,Performance,perform,perform,626,"// Make sure that each function is defined, does not access memory, takes at; // least one argument, does not use its first argument (which we assume is; // 'this'), and has the same return type.; //; // Note that we test whether this copy of the function is readnone, rather; // than testing function attributes, which must hold for any copy of the; // function, even a less optimized version substituted at link time. This is; // sound because the virtual constant propagation optimizations effectively; // inline all implementations of the virtual function into each call site,; // rather than using function attributes to perform local optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:640,Performance,optimiz,optimization,640,"// Make sure that each function is defined, does not access memory, takes at; // least one argument, does not use its first argument (which we assume is; // 'this'), and has the same return type.; //; // Note that we test whether this copy of the function is readnone, rather; // than testing function attributes, which must hold for any copy of the; // function, even a less optimized version substituted at link time. This is; // sound because the virtual constant propagation optimizations effectively; // inline all implementations of the virtual function into each call site,; // rather than using function attributes to perform local optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:53,Security,access,access,53,"// Make sure that each function is defined, does not access memory, takes at; // least one argument, does not use its first argument (which we assume is; // 'this'), and has the same return type.; //; // Note that we test whether this copy of the function is readnone, rather; // than testing function attributes, which must hold for any copy of the; // function, even a less optimized version substituted at link time. This is; // sound because the virtual constant propagation optimizations effectively; // inline all implementations of the virtual function into each call site,; // rather than using function attributes to perform local optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:217,Testability,test,test,217,"// Make sure that each function is defined, does not access memory, takes at; // least one argument, does not use its first argument (which we assume is; // 'this'), and has the same return type.; //; // Note that we test whether this copy of the function is readnone, rather; // than testing function attributes, which must hold for any copy of the; // function, even a less optimized version substituted at link time. This is; // sound because the virtual constant propagation optimizations effectively; // inline all implementations of the virtual function into each call site,; // rather than using function attributes to perform local optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:285,Testability,test,testing,285,"// Make sure that each function is defined, does not access memory, takes at; // least one argument, does not use its first argument (which we assume is; // 'this'), and has the same return type.; //; // Note that we test whether this copy of the function is readnone, rather; // than testing function attributes, which must hold for any copy of the; // function, even a less optimized version substituted at link time. This is; // sound because the virtual constant propagation optimizations effectively; // inline all implementations of the virtual function into each call site,; // rather than using function attributes to perform local optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:165,Performance,optimiz,optimization,165,"// TODO: Skip for now if the vtable symbol was an alias to a function,; // need to evaluate whether it would be correct to analyze the aliasee; // function for this optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite each call to a load from OffsetByte/OffsetBit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:26,Performance,load,load,26,// Rewrite each call to a load from OffsetByte/OffsetBit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:115,Testability,test,test,115,"// Find all virtual calls via a virtual table pointer %p under an assumption; // of the form llvm.assume(llvm.type.test(%p, %md)). This indicates that %p; // points to a member of the type identifier %md. Group calls by (type ID,; // offset) pair (effectively the identity of the virtual function) and store; // to CallSlots.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:45,Testability,test,test,45,// We no longer need the assumes or the type test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:205,Energy Efficiency,efficient,efficient,205,"// At this point we could remove all type test assume sequences, as they; // were originally inserted for WPD. However, we can keep these in the; // code stream for later analysis (e.g. to help drive more efficient ICP; // sequences). They will eventually be removed by a second LowerTypeTests; // invocation that cleans them up. In order to do this correctly, the first; // LowerTypeTests invocation needs to know that they have ""Unknown"" type; // test resolution, so that they aren't treated as Unsat and lowered to; // False, which will break any uses on assumes. Below we remove any type; // test assumes that will not be treated as Unknown by LTT.; // The type test assumes will be treated by LTT as Unsat if the type id is; // not used on a global (in which case it has no entry in the TypeIdMap).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:42,Testability,test,test,42,"// At this point we could remove all type test assume sequences, as they; // were originally inserted for WPD. However, we can keep these in the; // code stream for later analysis (e.g. to help drive more efficient ICP; // sequences). They will eventually be removed by a second LowerTypeTests; // invocation that cleans them up. In order to do this correctly, the first; // LowerTypeTests invocation needs to know that they have ""Unknown"" type; // test resolution, so that they aren't treated as Unsat and lowered to; // False, which will break any uses on assumes. Below we remove any type; // test assumes that will not be treated as Unknown by LTT.; // The type test assumes will be treated by LTT as Unsat if the type id is; // not used on a global (in which case it has no entry in the TypeIdMap).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:449,Testability,test,test,449,"// At this point we could remove all type test assume sequences, as they; // were originally inserted for WPD. However, we can keep these in the; // code stream for later analysis (e.g. to help drive more efficient ICP; // sequences). They will eventually be removed by a second LowerTypeTests; // invocation that cleans them up. In order to do this correctly, the first; // LowerTypeTests invocation needs to know that they have ""Unknown"" type; // test resolution, so that they aren't treated as Unsat and lowered to; // False, which will break any uses on assumes. Below we remove any type; // test assumes that will not be treated as Unknown by LTT.; // The type test assumes will be treated by LTT as Unsat if the type id is; // not used on a global (in which case it has no entry in the TypeIdMap).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:596,Testability,test,test,596,"// At this point we could remove all type test assume sequences, as they; // were originally inserted for WPD. However, we can keep these in the; // code stream for later analysis (e.g. to help drive more efficient ICP; // sequences). They will eventually be removed by a second LowerTypeTests; // invocation that cleans them up. In order to do this correctly, the first; // LowerTypeTests invocation needs to know that they have ""Unknown"" type; // test resolution, so that they aren't treated as Unsat and lowered to; // False, which will break any uses on assumes. Below we remove any type; // test assumes that will not be treated as Unknown by LTT.; // The type test assumes will be treated by LTT as Unsat if the type id is; // not used on a global (in which case it has no entry in the TypeIdMap).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:666,Testability,test,test,666,"// At this point we could remove all type test assume sequences, as they; // were originally inserted for WPD. However, we can keep these in the; // code stream for later analysis (e.g. to help drive more efficient ICP; // sequences). They will eventually be removed by a second LowerTypeTests; // invocation that cleans them up. In order to do this correctly, the first; // LowerTypeTests invocation needs to know that they have ""Unknown"" type; // test resolution, so that they aren't treated as Unsat and lowered to; // False, which will break any uses on assumes. Below we remove any type; // test assumes that will not be treated as Unknown by LTT.; // The type test assumes will be treated by LTT as Unsat if the type id is; // not used on a global (in which case it has no entry in the TypeIdMap).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:568,Performance,optimiz,optimization,568,"// For ThinLTO importing, we need to remove the type test assumes if this is; // an MDString type id without a corresponding TypeIdSummary. Any; // non-MDString type ids are ignored and treated as Unknown by LTT, so their; // type test assumes can be kept. If the MDString type id is missing a; // TypeIdSummary (e.g. because there was no use on a vcall, preventing the; // exporting phase of WPD from analyzing it), then it would be treated as; // Unsat by LTT and we need to remove its type test assumes here. If not; // used on a vcall we don't need them for later optimization use in any; // case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:53,Testability,test,test,53,"// For ThinLTO importing, we need to remove the type test assumes if this is; // an MDString type id without a corresponding TypeIdSummary. Any; // non-MDString type ids are ignored and treated as Unknown by LTT, so their; // type test assumes can be kept. If the MDString type id is missing a; // TypeIdSummary (e.g. because there was no use on a vcall, preventing the; // exporting phase of WPD from analyzing it), then it would be treated as; // Unsat by LTT and we need to remove its type test assumes here. If not; // used on a vcall we don't need them for later optimization use in any; // case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:231,Testability,test,test,231,"// For ThinLTO importing, we need to remove the type test assumes if this is; // an MDString type id without a corresponding TypeIdSummary. Any; // non-MDString type ids are ignored and treated as Unknown by LTT, so their; // type test assumes can be kept. If the MDString type id is missing a; // TypeIdSummary (e.g. because there was no use on a vcall, preventing the; // exporting phase of WPD from analyzing it), then it would be treated as; // Unsat by LTT and we need to remove its type test assumes here. If not; // used on a vcall we don't need them for later optimization use in any; // case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:493,Testability,test,test,493,"// For ThinLTO importing, we need to remove the type test assumes if this is; // an MDString type id without a corresponding TypeIdSummary. Any; // non-MDString type ids are ignored and treated as Unknown by LTT, so their; // type test assumes can be kept. If the MDString type id is missing a; // TypeIdSummary (e.g. because there was no use on a vcall, preventing the; // exporting phase of WPD from analyzing it), then it would be treated as; // Unsat by LTT and we need to remove its type test assumes here. If not; // used on a vcall we don't need them for later optimization use in any; // case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:58,Performance,load,loads,58,"// Start by generating ""pessimistic"" code that explicitly loads the function; // pointer from the vtable and performs the type check. If possible, we will; // eliminate the load and the type check later.; // If possible, only generate the load at the point where it is used.; // This helps avoid unnecessary spills.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:109,Performance,perform,performs,109,"// Start by generating ""pessimistic"" code that explicitly loads the function; // pointer from the vtable and performs the type check. If possible, we will; // eliminate the load and the type check later.; // If possible, only generate the load at the point where it is used.; // This helps avoid unnecessary spills.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:173,Performance,load,load,173,"// Start by generating ""pessimistic"" code that explicitly loads the function; // pointer from the vtable and performs the type check. If possible, we will; // eliminate the load and the type check later.; // If possible, only generate the load at the point where it is used.; // This helps avoid unnecessary spills.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:239,Performance,load,load,239,"// Start by generating ""pessimistic"" code that explicitly loads the function; // pointer from the vtable and performs the type check. If possible, we will; // eliminate the load and the type check later.; // If possible, only generate the load at the point where it is used.; // This helps avoid unnecessary spills.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:290,Safety,avoid,avoid,290,"// Start by generating ""pessimistic"" code that explicitly loads the function; // pointer from the vtable and performs the type check. If possible, we will; // eliminate the load and the type check later.; // If possible, only generate the load at the point where it is used.; // This helps avoid unnecessary spills.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:25,Testability,test,test,25,// Likewise for the type test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:17,Safety,unsafe,unsafe,17,// The number of unsafe uses is initially the number of uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:161,Safety,unsafe,unsafe,161,"// If the function pointer has a non-call user, we cannot eliminate the type; // check, as one of those users may eventually call the pointer. Increment; // the unsafe use count to make sure it cannot reach zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:30,Usability,GUID,GUID,30,// Look up ValueInfo with the GUID in the current linkage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:28,Usability,GUID,GUID,28,"// If no entry is found and GUID is different from GUID computed using; // exported name, look up ValueInfo with the exported name unconditionally.; // This is a fallback.; //; // The reason to have a fallback:; // 1. LTO could enable global value internalization via; // `enable-lto-internalization`.; // 2. The GUID in ExportedSummary is computed using exported name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:51,Usability,GUID,GUID,51,"// If no entry is found and GUID is different from GUID computed using; // exported name, look up ValueInfo with the exported name unconditionally.; // This is a fallback.; //; // The reason to have a fallback:; // 1. LTO could enable global value internalization via; // `enable-lto-internalization`.; // 2. The GUID in ExportedSummary is computed using exported name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:313,Usability,GUID,GUID,313,"// If no entry is found and GUID is different from GUID computed using; // exported name, look up ValueInfo with the exported name unconditionally.; // This is a fallback.; //; // The reason to have a fallback:; // 1. LTO could enable global value internalization via; // `enable-lto-internalization`.; // 2. The GUID in ExportedSummary is computed using exported name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:10,Usability,learn,learn,10,"// First, learn unreachability by analyzing function IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:3,Usability,Learn,Learn,3,// Learn unreachability from ExportSummary if ExportSummary is present.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:231,Availability,error,error,231,"// If only some of the modules were split, we cannot correctly perform; // this transformation. We already checked for the presense of type tests; // with partially split modules during the thin link, and would have emitted; // an error if any were found, so here we can simply return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:63,Performance,perform,perform,63,"// If only some of the modules were split, we cannot correctly perform; // this transformation. We already checked for the presense of type tests; // with partially split modules during the thin link, and would have emitted; // an error if any were found, so here we can simply return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:140,Testability,test,tests,140,"// If only some of the modules were split, we cannot correctly perform; // this transformation. We already checked for the presense of type tests; // with partially split modules during the thin link, and would have emitted; // an error if any were found, so here we can simply return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:271,Usability,simpl,simply,271,"// If only some of the modules were split, we cannot correctly perform; // this transformation. We already checked for the presense of type tests; // with partially split modules during the thin link, and would have emitted; // an error if any were found, so here we can simply return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:397,Safety,detect,detection,397,"// For any type id used on a global's type metadata, create the type id; // summary resolution regardless of whether we can devirtualize, so that; // lower type tests knows the type id is not Unsat. If it was not used on; // a global's type metadata, the TypeIdMap entry set will be empty, and; // we don't want to create an entry (with the default Unknown type; // resolution), which can prevent detection of the Unsat.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:161,Testability,test,tests,161,"// For any type id used on a global's type metadata, create the type id; // summary resolution regardless of whether we can devirtualize, so that; // lower type tests knows the type id is not Unsat. If it was not used on; // a global's type metadata, the TypeIdMap entry set will be empty, and; // we don't want to create an entry (with the default Unknown type; // resolution), which can prevent detection of the Unsat.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:63,Performance,load,load,63,"// CFI-specific: if we are exporting and any llvm.type.checked.load; // intrinsics were *not* devirtualized, we need to add the resulting; // llvm.type.test intrinsics to the function summaries so that the; // LowerTypeTests pass will export them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:152,Testability,test,test,152,"// CFI-specific: if we are exporting and any llvm.type.checked.load; // intrinsics were *not* devirtualized, we need to add the resulting; // llvm.type.test intrinsics to the function summaries so that the; // LowerTypeTests pass will export them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:108,Testability,test,tests,108,"// Create the type id summary resolution regardlness of whether we can; // devirtualize, so that lower type tests knows the type id is used on; // a global and not Unsat. We do this here rather than in the loop over the; // CallSlots, since that handling will only see type tests that directly; // feed assumes, and we would miss any that aren't currently handled by WPD; // (such as type tests that feed assumes via phis).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:274,Testability,test,tests,274,"// Create the type id summary resolution regardlness of whether we can; // devirtualize, so that lower type tests knows the type id is used on; // a global and not Unsat. We do this here rather than in the loop over the; // CallSlots, since that handling will only see type tests that directly; // feed assumes, and we would miss any that aren't currently handled by WPD; // (such as type tests that feed assumes via phis).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:389,Testability,test,tests,389,"// Create the type id summary resolution regardlness of whether we can; // devirtualize, so that lower type tests knows the type id is used on; // a global and not Unsat. We do this here rather than in the loop over the; // CallSlots, since that handling will only see type tests that directly; // feed assumes, and we would miss any that aren't currently handled by WPD; // (such as type tests that feed assumes via phis).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:39,Integrability,message,message,39,// Optionally have the thin link print message for each devirtualized; // function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ARCRuntimeEntryPoints.h:42,Performance,Optimiz,Optimization,42,"//===- ARCRuntimeEntryPoints.h - ObjC ARC Optimization ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file contains a class ARCRuntimeEntryPoints for use in; /// creating/managing references to entry points to the arc objective c runtime.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ARCRuntimeEntryPoints.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ARCRuntimeEntryPoints.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ARCRuntimeEntryPoints.h:96,Safety,avoid,avoid,96,/// Declarations for ObjC runtime functions and constants. These are initialized; /// lazily to avoid cluttering up the Module with unused declarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ARCRuntimeEntryPoints.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ARCRuntimeEntryPoints.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ARCRuntimeEntryPoints.h:4,Performance,Cache,Cached,4,/// Cached reference to the module which we will insert declarations into.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ARCRuntimeEntryPoints.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ARCRuntimeEntryPoints.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:7,Integrability,Depend,DependencyAnalysis,7,"//===- DependencyAnalysis.cpp - ObjC ARC Optimization ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines special dependency analysis routines used in Objective C; /// ARC Optimizations.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:422,Integrability,depend,dependency,422,"//===- DependencyAnalysis.cpp - ObjC ARC Optimization ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines special dependency analysis routines used in Objective C; /// ARC Optimizations.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:442,Integrability,rout,routines,442,"//===- DependencyAnalysis.cpp - ObjC ARC Optimization ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines special dependency analysis routines used in Objective C; /// ARC Optimizations.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:41,Performance,Optimiz,Optimization,41,"//===- DependencyAnalysis.cpp - ObjC ARC Optimization ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines special dependency analysis routines used in Objective C; /// ARC Optimizations.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:480,Performance,Optimiz,Optimizations,480,"//===- DependencyAnalysis.cpp - ObjC ARC Optimization ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines special dependency analysis routines used in Objective C; /// ARC Optimizations.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:4,Testability,Test,Test,4,/// Test whether the given instruction can result in a reference count; /// modification (positive or negative) for the pointer's object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:9,Performance,perform,perform,9,// First perform a quick check if Class can not touch ref counts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:4,Testability,Test,Test,4,"/// Test whether the given instruction can ""use"" the given pointer's object in a; /// way that requires the reference count to be positive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:74,Integrability,depend,dependence,74,"// If we can't tell what the underlying object was, assume there is a; // dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:25,Integrability,depend,dependencies,25,/// Test if there can be dependencies on Inst through Arg. This function only; /// tests dependencies relevant for removing pairs of calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:89,Integrability,depend,dependencies,89,/// Test if there can be dependencies on Inst through Arg. This function only; /// tests dependencies relevant for removing pairs of calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:4,Testability,Test,Test,4,/// Test if there can be dependencies on Inst through Arg. This function only; /// tests dependencies relevant for removing pairs of calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:83,Testability,test,tests,83,/// Test if there can be dependencies on Inst through Arg. This function only; /// tests dependencies relevant for removing pairs of calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:90,Integrability,depend,dependencies,90,/// Walk up the CFG from StartPos (which is in StartBB) and find local and; /// non-local dependencies on Arg.; ///; /// TODO: Cache results?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:127,Performance,Cache,Cache,127,/// Walk up the CFG from StartPos (which is in StartBB) and find local and; /// non-local dependencies on Arg.; ///; /// TODO: Cache results?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:138,Performance,optimiz,optimizations,138,"// Determine whether the original StartBB post-dominates all of the blocks we; // visited. If not, insert a sentinel indicating that most optimizations are; // not safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:164,Safety,safe,safe,164,"// Determine whether the original StartBB post-dominates all of the blocks we; // visited. If not, insert a sentinel indicating that most optimizations are; // not safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h:7,Integrability,Depend,DependencyAnalysis,7,"//===- DependencyAnalysis.h - ObjC ARC Optimization ---*- C++ -*-----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file declares special dependency analysis routines used in Objective C; /// ARC Optimizations.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h:423,Integrability,depend,dependency,423,"//===- DependencyAnalysis.h - ObjC ARC Optimization ---*- C++ -*-----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file declares special dependency analysis routines used in Objective C; /// ARC Optimizations.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h:443,Integrability,rout,routines,443,"//===- DependencyAnalysis.h - ObjC ARC Optimization ---*- C++ -*-----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file declares special dependency analysis routines used in Objective C; /// ARC Optimizations.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h:39,Performance,Optimiz,Optimization,39,"//===- DependencyAnalysis.h - ObjC ARC Optimization ---*- C++ -*-----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file declares special dependency analysis routines used in Objective C; /// ARC Optimizations.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h:481,Performance,Optimiz,Optimizations,481,"//===- DependencyAnalysis.h - ObjC ARC Optimization ---*- C++ -*-----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file declares special dependency analysis routines used in Objective C; /// ARC Optimizations.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h:10,Integrability,Depend,DependenceKind,10,/// \enum DependenceKind; /// Defines different dependence kinds among various ARC constructs.; ///; /// There are several kinds of dependence-like concepts in use here.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h:48,Integrability,depend,dependence,48,/// \enum DependenceKind; /// Defines different dependence kinds among various ARC constructs.; ///; /// There are several kinds of dependence-like concepts in use here.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h:132,Integrability,depend,dependence-like,132,/// \enum DependenceKind; /// Defines different dependence kinds among various ARC constructs.; ///; /// There are several kinds of dependence-like concepts in use here.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h:9,Integrability,depend,dependent,9,"/// Find dependent instructions. If there is exactly one dependent instruction,; /// return it. Otherwise, return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h:57,Integrability,depend,dependent,57,"/// Find dependent instructions. If there is exactly one dependent instruction,; /// return it. Otherwise, return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h:4,Testability,Test,Test,4,"/// Test whether the given instruction can ""use"" the given pointer's object in a; /// way that requires the reference count to be positive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h:4,Testability,Test,Test,4,/// Test whether the given instruction can result in a reference count; /// modification (positive or negative) for the pointer's object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARC.h:28,Performance,Optimiz,Optimization,28,"//===- ObjCARC.h - ObjC ARC Optimization --------------*- C++ -*-----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines common definitions/declarations used by the ObjC ARC; /// Optimizer. ARC stands for Automatic Reference Counting and is a system for; /// managing reference counts for objects in Objective C.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARC.h:467,Performance,Optimiz,Optimizer,467,"//===- ObjCARC.h - ObjC ARC Optimization --------------*- C++ -*-----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines common definitions/declarations used by the ObjC ARC; /// Optimizer. ARC stands for Automatic Reference Counting and is a system for; /// managing reference counts for objects in Objective C.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp:36,Performance,Optimiz,Optimization,36,"//===- ObjCARCAPElim.cpp - ObjC ARC Optimization --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// This specific file implements optimizations which remove extraneous; /// autorelease pools.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp:423,Performance,optimiz,optimizations,423,"//===- ObjCARCAPElim.cpp - ObjC ARC Optimization --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// This specific file implements optimizations which remove extraneous; /// autorelease pools.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp:606,Performance,optimiz,optimizations,606,"//===- ObjCARCAPElim.cpp - ObjC ARC Optimization --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// This specific file implements optimizations which remove extraneous; /// autorelease pools.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp:98,Testability,test,testcases,98,// This recursion depth limit is arbitrary. It's just great; // enough to cover known interesting testcases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp:30,Modifiability,variab,variable,30,"// Find the llvm.global_ctors variable, as the first step in; // identifying the global constructors. In theory, unnecessary autorelease; // pools could occur anywhere, but in practice it's pretty rare. Global; // ctors are a place where autorelease pools get inserted automatically,; // so it's pretty common for them to be unnecessary, and it's pretty; // profitable to eliminate them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp:62,Performance,optimiz,optimize,62,"// Ok, a single-block constructor function definition. Try to optimize it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:615,Integrability,contract,contracting,615,"//===- ObjCARCContract.cpp - ObjC ARC Optimization ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines late ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// This specific file mainly deals with ``contracting'' multiple lower level; /// operations into singular higher level operations through pattern matching.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//; // TODO: ObjCARCContract could insert PHI nodes when uses aren't; // dominated by single calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:38,Performance,Optimiz,Optimization,38,"//===- ObjCARCContract.cpp - ObjC ARC Optimization ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines late ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// This specific file mainly deals with ``contracting'' multiple lower level; /// operations into singular higher level operations through pattern matching.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//; // TODO: ObjCARCContract could insert PHI nodes when uses aren't; // dominated by single calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:423,Performance,optimiz,optimizations,423,"//===- ObjCARCContract.cpp - ObjC ARC Optimization ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines late ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// This specific file mainly deals with ``contracting'' multiple lower level; /// operations into singular higher level operations through pattern matching.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//; // TODO: ObjCARCContract could insert PHI nodes when uses aren't; // dominated by single calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:13,Performance,optimiz,optimizations,13,"/// Late ARC optimizations; ///; /// These change the IR in a way that makes it difficult to be analyzed by; /// ObjCARCOpt, so it's run late.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:86,Performance,optimiz,optimization,86,/// The inline asm string to insert between calls and RetainRV calls to make; /// the optimization work on targets which need it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:36,Performance,Load,Load,36,// Get the location associated with Load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:8,Availability,down,down,8,"// Walk down to find the store and the release, which may be in either order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:39,Deployability,release,release,39,"// Walk down to find the store and the release, which may be in either order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:57,Deployability,release,release,57,"// If we found the store we were looking for and saw the release,; // break. There is no more work to be done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:61,Deployability,release,release,61,"// Now we know that we have not seen either the store or the release. If I; // is the release, mark that we saw the release and continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:86,Deployability,release,release,86,"// Now we know that we have not seen either the store or the release. If I; // is the release, mark that we saw the release and continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:116,Deployability,release,release,116,"// Now we know that we have not seen either the store or the release. If I; // is the release, mark that we saw the release and continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:42,Deployability,release,release,42,"// If we have seen the store, but not the release...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:52,Deployability,release,release,52,"// We need to make sure that it is safe to move the release from its; // current position to the store. This implies proving that any; // instruction in between Store and the Release conservatively can not use; // the RCIdentityRoot of Release. If we can prove we can ignore Inst, so; // continue...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:175,Deployability,Release,Release,175,"// We need to make sure that it is safe to move the release from its; // current position to the store. This implies proving that any; // instruction in between Store and the Release conservatively can not use; // the RCIdentityRoot of Release. If we can prove we can ignore Inst, so; // continue...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:236,Deployability,Release,Release,236,"// We need to make sure that it is safe to move the release from its; // current position to the store. This implies proving that any; // instruction in between Store and the Release conservatively can not use; // the RCIdentityRoot of Release. If we can prove we can ignore Inst, so; // continue...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:35,Safety,safe,safe,35,"// We need to make sure that it is safe to move the release from its; // current position to the store. This implies proving that any; // instruction in between Store and the Release conservatively can not use; // the RCIdentityRoot of Release. If we can prove we can ignore Inst, so; // continue...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:134,Performance,load,load,134,"// Ok, now we know we have not seen a store yet.; // If Inst is a retain, we don't care about it as it doesn't prevent moving; // the load to the store.; //; // TODO: This is one area where the optimization could be made more; // aggressive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:194,Performance,optimiz,optimization,194,"// Ok, now we know we have not seen a store yet.; // If Inst is a retain, we don't care about it as it doesn't prevent moving; // the load to the store.; //; // TODO: This is one area where the optimization could be made more; // aggressive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:32,Performance,load,load,32,"// See if Inst can write to our load location, if it can not, just ignore; // the instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:207,Performance,load,load,207,"// If Inst can, then check if Inst is a simple store. If Inst is not a; // store or a store that is not simple, then we have some we do not; // understand writing to this memory implying we can not move the load; // over the write to any subsequent store that we may find.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:40,Usability,simpl,simple,40,"// If Inst can, then check if Inst is a simple store. If Inst is not a; // store or a store that is not simple, then we have some we do not; // understand writing to this memory implying we can not move the load; // over the write to any subsequent store that we may find.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:104,Usability,simpl,simple,104,"// If Inst can, then check if Inst is a simple store. If Inst is not a; // store or a store that is not simple, then we have some we do not; // understand writing to this memory implying we can not move the load; // over the write to any subsequent store that we may find.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:51,Deployability,release,release,51,"// If we did not find the store or did not see the release, fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:111,Deployability,release,release,111,// It is only safe to move the retain to the store if we can prove; // conservatively that nothing besides the release can decrement reference; // counts in between the retain and the store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:14,Safety,safe,safe,14,// It is only safe to move the retain to the store if we can prove; // conservatively that nothing besides the release can decrement reference; // counts in between the retain and the store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:353,Deployability,release,release,353,"/// Attempt to merge an objc_release with a store, load, and objc_retain to form; /// an objc_storeStrong. An objc_storeStrong:; ///; /// objc_storeStrong(i8** %old_ptr, i8* new_value); ///; /// is equivalent to the following IR sequence:; ///; /// ; Load old value.; /// %old_value = load i8** %old_ptr (1); ///; /// ; Increment the new value and then release the old value. This must occur; /// ; in order in case old_value releases new_value in its destructor causing; /// ; us to potentially have a dangling ptr.; /// tail call i8* @objc_retain(i8* %new_value) (2); /// tail call void @objc_release(i8* %old_value) (3); ///; /// ; Store the new_value into old_ptr; /// store i8* %new_value, i8** %old_ptr (4); ///; /// The safety of this optimization is based around the following; /// considerations:; ///; /// 1. We are forming the store strong at the store. Thus to perform this; /// optimization it must be safe to move the retain, load, and release to; /// (4).; /// 2. We need to make sure that any re-orderings of (1), (2), (3), (4) are; /// safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:426,Deployability,release,releases,426,"/// Attempt to merge an objc_release with a store, load, and objc_retain to form; /// an objc_storeStrong. An objc_storeStrong:; ///; /// objc_storeStrong(i8** %old_ptr, i8* new_value); ///; /// is equivalent to the following IR sequence:; ///; /// ; Load old value.; /// %old_value = load i8** %old_ptr (1); ///; /// ; Increment the new value and then release the old value. This must occur; /// ; in order in case old_value releases new_value in its destructor causing; /// ; us to potentially have a dangling ptr.; /// tail call i8* @objc_retain(i8* %new_value) (2); /// tail call void @objc_release(i8* %old_value) (3); ///; /// ; Store the new_value into old_ptr; /// store i8* %new_value, i8** %old_ptr (4); ///; /// The safety of this optimization is based around the following; /// considerations:; ///; /// 1. We are forming the store strong at the store. Thus to perform this; /// optimization it must be safe to move the retain, load, and release to; /// (4).; /// 2. We need to make sure that any re-orderings of (1), (2), (3), (4) are; /// safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:950,Deployability,release,release,950,"/// Attempt to merge an objc_release with a store, load, and objc_retain to form; /// an objc_storeStrong. An objc_storeStrong:; ///; /// objc_storeStrong(i8** %old_ptr, i8* new_value); ///; /// is equivalent to the following IR sequence:; ///; /// ; Load old value.; /// %old_value = load i8** %old_ptr (1); ///; /// ; Increment the new value and then release the old value. This must occur; /// ; in order in case old_value releases new_value in its destructor causing; /// ; us to potentially have a dangling ptr.; /// tail call i8* @objc_retain(i8* %new_value) (2); /// tail call void @objc_release(i8* %old_value) (3); ///; /// ; Store the new_value into old_ptr; /// store i8* %new_value, i8** %old_ptr (4); ///; /// The safety of this optimization is based around the following; /// considerations:; ///; /// 1. We are forming the store strong at the store. Thus to perform this; /// optimization it must be safe to move the retain, load, and release to; /// (4).; /// 2. We need to make sure that any re-orderings of (1), (2), (3), (4) are; /// safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:51,Performance,load,load,51,"/// Attempt to merge an objc_release with a store, load, and objc_retain to form; /// an objc_storeStrong. An objc_storeStrong:; ///; /// objc_storeStrong(i8** %old_ptr, i8* new_value); ///; /// is equivalent to the following IR sequence:; ///; /// ; Load old value.; /// %old_value = load i8** %old_ptr (1); ///; /// ; Increment the new value and then release the old value. This must occur; /// ; in order in case old_value releases new_value in its destructor causing; /// ; us to potentially have a dangling ptr.; /// tail call i8* @objc_retain(i8* %new_value) (2); /// tail call void @objc_release(i8* %old_value) (3); ///; /// ; Store the new_value into old_ptr; /// store i8* %new_value, i8** %old_ptr (4); ///; /// The safety of this optimization is based around the following; /// considerations:; ///; /// 1. We are forming the store strong at the store. Thus to perform this; /// optimization it must be safe to move the retain, load, and release to; /// (4).; /// 2. We need to make sure that any re-orderings of (1), (2), (3), (4) are; /// safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:251,Performance,Load,Load,251,"/// Attempt to merge an objc_release with a store, load, and objc_retain to form; /// an objc_storeStrong. An objc_storeStrong:; ///; /// objc_storeStrong(i8** %old_ptr, i8* new_value); ///; /// is equivalent to the following IR sequence:; ///; /// ; Load old value.; /// %old_value = load i8** %old_ptr (1); ///; /// ; Increment the new value and then release the old value. This must occur; /// ; in order in case old_value releases new_value in its destructor causing; /// ; us to potentially have a dangling ptr.; /// tail call i8* @objc_retain(i8* %new_value) (2); /// tail call void @objc_release(i8* %old_value) (3); ///; /// ; Store the new_value into old_ptr; /// store i8* %new_value, i8** %old_ptr (4); ///; /// The safety of this optimization is based around the following; /// considerations:; ///; /// 1. We are forming the store strong at the store. Thus to perform this; /// optimization it must be safe to move the retain, load, and release to; /// (4).; /// 2. We need to make sure that any re-orderings of (1), (2), (3), (4) are; /// safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:285,Performance,load,load,285,"/// Attempt to merge an objc_release with a store, load, and objc_retain to form; /// an objc_storeStrong. An objc_storeStrong:; ///; /// objc_storeStrong(i8** %old_ptr, i8* new_value); ///; /// is equivalent to the following IR sequence:; ///; /// ; Load old value.; /// %old_value = load i8** %old_ptr (1); ///; /// ; Increment the new value and then release the old value. This must occur; /// ; in order in case old_value releases new_value in its destructor causing; /// ; us to potentially have a dangling ptr.; /// tail call i8* @objc_retain(i8* %new_value) (2); /// tail call void @objc_release(i8* %old_value) (3); ///; /// ; Store the new_value into old_ptr; /// store i8* %new_value, i8** %old_ptr (4); ///; /// The safety of this optimization is based around the following; /// considerations:; ///; /// 1. We are forming the store strong at the store. Thus to perform this; /// optimization it must be safe to move the retain, load, and release to; /// (4).; /// 2. We need to make sure that any re-orderings of (1), (2), (3), (4) are; /// safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:742,Performance,optimiz,optimization,742,"/// Attempt to merge an objc_release with a store, load, and objc_retain to form; /// an objc_storeStrong. An objc_storeStrong:; ///; /// objc_storeStrong(i8** %old_ptr, i8* new_value); ///; /// is equivalent to the following IR sequence:; ///; /// ; Load old value.; /// %old_value = load i8** %old_ptr (1); ///; /// ; Increment the new value and then release the old value. This must occur; /// ; in order in case old_value releases new_value in its destructor causing; /// ; us to potentially have a dangling ptr.; /// tail call i8* @objc_retain(i8* %new_value) (2); /// tail call void @objc_release(i8* %old_value) (3); ///; /// ; Store the new_value into old_ptr; /// store i8* %new_value, i8** %old_ptr (4); ///; /// The safety of this optimization is based around the following; /// considerations:; ///; /// 1. We are forming the store strong at the store. Thus to perform this; /// optimization it must be safe to move the retain, load, and release to; /// (4).; /// 2. We need to make sure that any re-orderings of (1), (2), (3), (4) are; /// safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:873,Performance,perform,perform,873,"/// Attempt to merge an objc_release with a store, load, and objc_retain to form; /// an objc_storeStrong. An objc_storeStrong:; ///; /// objc_storeStrong(i8** %old_ptr, i8* new_value); ///; /// is equivalent to the following IR sequence:; ///; /// ; Load old value.; /// %old_value = load i8** %old_ptr (1); ///; /// ; Increment the new value and then release the old value. This must occur; /// ; in order in case old_value releases new_value in its destructor causing; /// ; us to potentially have a dangling ptr.; /// tail call i8* @objc_retain(i8* %new_value) (2); /// tail call void @objc_release(i8* %old_value) (3); ///; /// ; Store the new_value into old_ptr; /// store i8* %new_value, i8** %old_ptr (4); ///; /// The safety of this optimization is based around the following; /// considerations:; ///; /// 1. We are forming the store strong at the store. Thus to perform this; /// optimization it must be safe to move the retain, load, and release to; /// (4).; /// 2. We need to make sure that any re-orderings of (1), (2), (3), (4) are; /// safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:891,Performance,optimiz,optimization,891,"/// Attempt to merge an objc_release with a store, load, and objc_retain to form; /// an objc_storeStrong. An objc_storeStrong:; ///; /// objc_storeStrong(i8** %old_ptr, i8* new_value); ///; /// is equivalent to the following IR sequence:; ///; /// ; Load old value.; /// %old_value = load i8** %old_ptr (1); ///; /// ; Increment the new value and then release the old value. This must occur; /// ; in order in case old_value releases new_value in its destructor causing; /// ; us to potentially have a dangling ptr.; /// tail call i8* @objc_retain(i8* %new_value) (2); /// tail call void @objc_release(i8* %old_value) (3); ///; /// ; Store the new_value into old_ptr; /// store i8* %new_value, i8** %old_ptr (4); ///; /// The safety of this optimization is based around the following; /// considerations:; ///; /// 1. We are forming the store strong at the store. Thus to perform this; /// optimization it must be safe to move the retain, load, and release to; /// (4).; /// 2. We need to make sure that any re-orderings of (1), (2), (3), (4) are; /// safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:940,Performance,load,load,940,"/// Attempt to merge an objc_release with a store, load, and objc_retain to form; /// an objc_storeStrong. An objc_storeStrong:; ///; /// objc_storeStrong(i8** %old_ptr, i8* new_value); ///; /// is equivalent to the following IR sequence:; ///; /// ; Load old value.; /// %old_value = load i8** %old_ptr (1); ///; /// ; Increment the new value and then release the old value. This must occur; /// ; in order in case old_value releases new_value in its destructor causing; /// ; us to potentially have a dangling ptr.; /// tail call i8* @objc_retain(i8* %new_value) (2); /// tail call void @objc_release(i8* %old_value) (3); ///; /// ; Store the new_value into old_ptr; /// store i8* %new_value, i8** %old_ptr (4); ///; /// The safety of this optimization is based around the following; /// considerations:; ///; /// 1. We are forming the store strong at the store. Thus to perform this; /// optimization it must be safe to move the retain, load, and release to; /// (4).; /// 2. We need to make sure that any re-orderings of (1), (2), (3), (4) are; /// safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:727,Safety,safe,safety,727,"/// Attempt to merge an objc_release with a store, load, and objc_retain to form; /// an objc_storeStrong. An objc_storeStrong:; ///; /// objc_storeStrong(i8** %old_ptr, i8* new_value); ///; /// is equivalent to the following IR sequence:; ///; /// ; Load old value.; /// %old_value = load i8** %old_ptr (1); ///; /// ; Increment the new value and then release the old value. This must occur; /// ; in order in case old_value releases new_value in its destructor causing; /// ; us to potentially have a dangling ptr.; /// tail call i8* @objc_retain(i8* %new_value) (2); /// tail call void @objc_release(i8* %old_value) (3); ///; /// ; Store the new_value into old_ptr; /// store i8* %new_value, i8** %old_ptr (4); ///; /// The safety of this optimization is based around the following; /// considerations:; ///; /// 1. We are forming the store strong at the store. Thus to perform this; /// optimization it must be safe to move the retain, load, and release to; /// (4).; /// 2. We need to make sure that any re-orderings of (1), (2), (3), (4) are; /// safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:915,Safety,safe,safe,915,"/// Attempt to merge an objc_release with a store, load, and objc_retain to form; /// an objc_storeStrong. An objc_storeStrong:; ///; /// objc_storeStrong(i8** %old_ptr, i8* new_value); ///; /// is equivalent to the following IR sequence:; ///; /// ; Load old value.; /// %old_value = load i8** %old_ptr (1); ///; /// ; Increment the new value and then release the old value. This must occur; /// ; in order in case old_value releases new_value in its destructor causing; /// ; us to potentially have a dangling ptr.; /// tail call i8* @objc_retain(i8* %new_value) (2); /// tail call void @objc_release(i8* %old_value) (3); ///; /// ; Store the new_value into old_ptr; /// store i8* %new_value, i8** %old_ptr (4); ///; /// The safety of this optimization is based around the following; /// considerations:; ///; /// 1. We are forming the store strong at the store. Thus to perform this; /// optimization it must be safe to move the retain, load, and release to; /// (4).; /// 2. We need to make sure that any re-orderings of (1), (2), (3), (4) are; /// safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:1053,Safety,safe,safe,1053,"/// Attempt to merge an objc_release with a store, load, and objc_retain to form; /// an objc_storeStrong. An objc_storeStrong:; ///; /// objc_storeStrong(i8** %old_ptr, i8* new_value); ///; /// is equivalent to the following IR sequence:; ///; /// ; Load old value.; /// %old_value = load i8** %old_ptr (1); ///; /// ; Increment the new value and then release the old value. This must occur; /// ; in order in case old_value releases new_value in its destructor causing; /// ; us to potentially have a dangling ptr.; /// tail call i8* @objc_retain(i8* %new_value) (2); /// tail call void @objc_release(i8* %old_value) (3); ///; /// ; Store the new_value into old_ptr; /// store i8* %new_value, i8** %old_ptr (4); ///; /// The safety of this optimization is based around the following; /// considerations:; ///; /// 1. We are forming the store strong at the store. Thus to perform this; /// optimization it must be safe to move the retain, load, and release to; /// (4).; /// 2. We need to make sure that any re-orderings of (1), (2), (3), (4) are; /// safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:50,Performance,load,loaded,50,// See if we are releasing something that we just loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:14,Availability,down,down,14,"// First scan down the BB from Load, looking for a store of the RCIdentityRoot; // of Load's",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:31,Performance,Load,Load,31,"// First scan down the BB from Load, looking for a store of the RCIdentityRoot; // of Load's",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:86,Performance,Load,Load,86,"// First scan down the BB from Load, looking for a store of the RCIdentityRoot; // of Load's",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:188,Safety,safe,safe,188,"// We can't set the tail flag yet, because we haven't yet determined; // whether there are any escaping allocas. Remember this call, so that; // we can set the tail flag once we know it's safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:22,Integrability,rout,routines,22,"// Only these library routines return their argument. In particular,; // objc_retainBlock does not necessarily return its argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:24,Performance,optimiz,optimization,24,"// If we succeed in our optimization, fall through.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:79,Availability,redundant,redundant,79,"// Return true if this is a bundled retainRV/claimRV call, which is always; // redundant with the attachedcall in the bundle, and is going to be erased; // at the end of this pass. This avoids undoing objc-arc-expand and; // replacing uses of the retainRV/claimRV call's argument with its result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:79,Safety,redund,redundant,79,"// Return true if this is a bundled retainRV/claimRV call, which is always; // redundant with the attachedcall in the bundle, and is going to be erased; // at the end of this pass. This avoids undoing objc-arc-expand and; // replacing uses of the retainRV/claimRV call's argument with its result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:186,Safety,avoid,avoids,186,"// Return true if this is a bundled retainRV/claimRV call, which is always; // redundant with the attachedcall in the bundle, and is going to be erased; // at the end of this pass. This avoids undoing objc-arc-expand and; // replacing uses of the retainRV/claimRV call's argument with its result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:193,Usability,undo,undoing,193,"// Return true if this is a bundled retainRV/claimRV call, which is always; // redundant with the attachedcall in the bundle, and is going to be erased; // at the end of this pass. This avoids undoing objc-arc-expand and; // replacing uses of the retainRV/claimRV call's argument with its result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:122,Usability,undo,undo,122,"// If this isn't a bundled call, and the target doesn't need a special; // inline-asm marker, we're done: return now, and undo objc-arc-expand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:45,Deployability,release,release,45,"// Try to form an objc store strong from our release. If we fail, there is; // nothing further to do below, so continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:2,Integrability,Contract,ContractPass,2,/*ContractPass=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:199,Safety,unsafe,unsafe,199,"// Track whether it's ok to mark objc_storeStrong calls with the ""tail""; // keyword. Be conservative if the function has variadic arguments.; // It seems that functions which ""return twice"" are also unsafe for the; // ""tail"" argument, because they are setjmp, which could need to; // return to an earlier stack state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:158,Energy Efficiency,reduce,reduces,158,"// For ObjC library calls which return their argument, replace uses of the; // argument with uses of the call return value, if it dominates the use. This; // reduces register pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:85,Usability,undo,undoing,85,"// First try to peephole Inst. If there is nothing further we can do in; // terms of undoing objc-arc-expand, process the next inst.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:21,Usability,undo,undo,21,"// Otherwise, try to undo objc-arc-expand.; // Don't use GetArgRCIdentityRoot because we don't want to look through bitcasts; // and such; to do the replacement, the argument must have type i8*.; // Function for replacing uses of Arg dominated by Inst.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:80,Modifiability,rewrite,rewrite,80,"// If the call's return value dominates a use of the call's argument; // value, rewrite the use to use the return value. We check for; // reachability here because an unreachable call is considered to; // trivially dominate itself, which would lead us to rewriting its; // argument in terms of its return value, which would lead to; // infinite loops in GetArgRCIdentityRoot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:21,Modifiability,rewrite,rewrite,21,"// While we're here, rewrite all edges for this PHI, rather; // than just one use at a time, to minimize the number of; // bitcasts we emit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp:36,Performance,Optimiz,Optimization,36,"//===- ObjCARCExpand.cpp - ObjC ARC Optimization --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// This specific file deals with early optimizations which perform certain; /// cleanup operations.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp:418,Performance,optimiz,optimizations,418,"//===- ObjCARCExpand.cpp - ObjC ARC Optimization --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// This specific file deals with early optimizations which perform certain; /// cleanup operations.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp:607,Performance,optimiz,optimizations,607,"//===- ObjCARCExpand.cpp - ObjC ARC Optimization --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// This specific file deals with early optimizations which perform certain; /// cleanup operations.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp:627,Performance,perform,perform,627,"//===- ObjCARCExpand.cpp - ObjC ARC Optimization --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// This specific file deals with early optimizations which perform certain; /// cleanup operations.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp:232,Integrability,contract,contract,232,"// These calls return their argument verbatim, as a low-level; // optimization. However, this makes high-level optimizations; // harder. Undo any uses of this optimization that the front-end; // emitted here. We'll redo them in the contract pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp:66,Performance,optimiz,optimization,66,"// These calls return their argument verbatim, as a low-level; // optimization. However, this makes high-level optimizations; // harder. Undo any uses of this optimization that the front-end; // emitted here. We'll redo them in the contract pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp:111,Performance,optimiz,optimizations,111,"// These calls return their argument verbatim, as a low-level; // optimization. However, this makes high-level optimizations; // harder. Undo any uses of this optimization that the front-end; // emitted here. We'll redo them in the contract pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp:159,Performance,optimiz,optimization,159,"// These calls return their argument verbatim, as a low-level; // optimization. However, this makes high-level optimizations; // harder. Undo any uses of this optimization that the front-end; // emitted here. We'll redo them in the contract pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp:137,Usability,Undo,Undo,137,"// These calls return their argument verbatim, as a low-level; // optimization. However, this makes high-level optimizations; // harder. Undo any uses of this optimization that the front-end; // emitted here. We'll redo them in the contract pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:626,Availability,redundant,redundant,626,"//===- ObjCARCOpts.cpp - ObjC ARC Optimization ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// The optimizations performed include elimination of redundant, partially; /// redundant, and inconsequential reference count operations, elimination of; /// redundant weak pointer operations, and numerous minor simplifications.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:652,Availability,redundant,redundant,652,"//===- ObjCARCOpts.cpp - ObjC ARC Optimization ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// The optimizations performed include elimination of redundant, partially; /// redundant, and inconsequential reference count operations, elimination of; /// redundant weak pointer operations, and numerous minor simplifications.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:731,Availability,redundant,redundant,731,"//===- ObjCARCOpts.cpp - ObjC ARC Optimization ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// The optimizations performed include elimination of redundant, partially; /// redundant, and inconsequential reference count operations, elimination of; /// redundant weak pointer operations, and numerous minor simplifications.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:34,Performance,Optimiz,Optimization,34,"//===- ObjCARCOpts.cpp - ObjC ARC Optimization ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// The optimizations performed include elimination of redundant, partially; /// redundant, and inconsequential reference count operations, elimination of; /// redundant weak pointer operations, and numerous minor simplifications.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:422,Performance,optimiz,optimizations,422,"//===- ObjCARCOpts.cpp - ObjC ARC Optimization ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// The optimizations performed include elimination of redundant, partially; /// redundant, and inconsequential reference count operations, elimination of; /// redundant weak pointer operations, and numerous minor simplifications.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:579,Performance,optimiz,optimizations,579,"//===- ObjCARCOpts.cpp - ObjC ARC Optimization ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// The optimizations performed include elimination of redundant, partially; /// redundant, and inconsequential reference count operations, elimination of; /// redundant weak pointer operations, and numerous minor simplifications.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:593,Performance,perform,performed,593,"//===- ObjCARCOpts.cpp - ObjC ARC Optimization ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// The optimizations performed include elimination of redundant, partially; /// redundant, and inconsequential reference count operations, elimination of; /// redundant weak pointer operations, and numerous minor simplifications.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:626,Safety,redund,redundant,626,"//===- ObjCARCOpts.cpp - ObjC ARC Optimization ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// The optimizations performed include elimination of redundant, partially; /// redundant, and inconsequential reference count operations, elimination of; /// redundant weak pointer operations, and numerous minor simplifications.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:652,Safety,redund,redundant,652,"//===- ObjCARCOpts.cpp - ObjC ARC Optimization ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// The optimizations performed include elimination of redundant, partially; /// redundant, and inconsequential reference count operations, elimination of; /// redundant weak pointer operations, and numerous minor simplifications.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:731,Safety,redund,redundant,731,"//===- ObjCARCOpts.cpp - ObjC ARC Optimization ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// The optimizations performed include elimination of redundant, partially; /// redundant, and inconsequential reference count operations, elimination of; /// redundant weak pointer operations, and numerous minor simplifications.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:785,Usability,simpl,simplifications,785,"//===- ObjCARCOpts.cpp - ObjC ARC Optimization ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// The optimizations performed include elimination of redundant, partially; /// redundant, and inconsequential reference count operations, elimination of; /// redundant weak pointer operations, and numerous minor simplifications.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:635,Deployability,release,release,635,"/// @}; ///; /// \defgroup ARCOpt ARC Optimization.; /// @{; // TODO: On code like this:; //; // objc_retain(%x); // stuff_that_cannot_release(); // objc_autorelease(%x); // stuff_that_cannot_release(); // objc_retain(%x); // stuff_that_cannot_release(); // objc_autorelease(%x); //; // The second retain and autorelease can be deleted.; // TODO: It should be possible to delete; // objc_autoreleasePoolPush and objc_autoreleasePoolPop; // pairs if nothing is actually autoreleased between them. Also, autorelease; // calls followed by objc_autoreleasePoolPop calls (perhaps in ObjC++ code; // after inlining) can be turned into plain release calls.; // TODO: Critical-edge splitting. If the optimial insertion point is; // a critical edge, the current algorithm has to fail, because it doesn't; // know how to split edges. It should be possible to make the optimizer; // think in terms of edges, rather than blocks, and then split critical; // edges on demand.; // TODO: OptimizeSequences could generalized to be Interprocedural.; // TODO: Recognize that a bunch of other objc runtime calls have; // non-escaping arguments and non-releasing arguments, and may be; // non-autoreleasing.; // TODO: Sink autorelease calls as far as possible. Unfortunately we; // usually can't sink them past other calls, which would be the main; // case where it would be useful.; // TODO: The pointer returned from objc_loadWeakRetained is retained.; // TODO: Delete release+retain pairs (rare).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:1450,Deployability,release,release,1450,"/// @}; ///; /// \defgroup ARCOpt ARC Optimization.; /// @{; // TODO: On code like this:; //; // objc_retain(%x); // stuff_that_cannot_release(); // objc_autorelease(%x); // stuff_that_cannot_release(); // objc_retain(%x); // stuff_that_cannot_release(); // objc_autorelease(%x); //; // The second retain and autorelease can be deleted.; // TODO: It should be possible to delete; // objc_autoreleasePoolPush and objc_autoreleasePoolPop; // pairs if nothing is actually autoreleased between them. Also, autorelease; // calls followed by objc_autoreleasePoolPop calls (perhaps in ObjC++ code; // after inlining) can be turned into plain release calls.; // TODO: Critical-edge splitting. If the optimial insertion point is; // a critical edge, the current algorithm has to fail, because it doesn't; // know how to split edges. It should be possible to make the optimizer; // think in terms of edges, rather than blocks, and then split critical; // edges on demand.; // TODO: OptimizeSequences could generalized to be Interprocedural.; // TODO: Recognize that a bunch of other objc runtime calls have; // non-escaping arguments and non-releasing arguments, and may be; // non-autoreleasing.; // TODO: Sink autorelease calls as far as possible. Unfortunately we; // usually can't sink them past other calls, which would be the main; // case where it would be useful.; // TODO: The pointer returned from objc_loadWeakRetained is retained.; // TODO: Delete release+retain pairs (rare).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:38,Performance,Optimiz,Optimization,38,"/// @}; ///; /// \defgroup ARCOpt ARC Optimization.; /// @{; // TODO: On code like this:; //; // objc_retain(%x); // stuff_that_cannot_release(); // objc_autorelease(%x); // stuff_that_cannot_release(); // objc_retain(%x); // stuff_that_cannot_release(); // objc_autorelease(%x); //; // The second retain and autorelease can be deleted.; // TODO: It should be possible to delete; // objc_autoreleasePoolPush and objc_autoreleasePoolPop; // pairs if nothing is actually autoreleased between them. Also, autorelease; // calls followed by objc_autoreleasePoolPop calls (perhaps in ObjC++ code; // after inlining) can be turned into plain release calls.; // TODO: Critical-edge splitting. If the optimial insertion point is; // a critical edge, the current algorithm has to fail, because it doesn't; // know how to split edges. It should be possible to make the optimizer; // think in terms of edges, rather than blocks, and then split critical; // edges on demand.; // TODO: OptimizeSequences could generalized to be Interprocedural.; // TODO: Recognize that a bunch of other objc runtime calls have; // non-escaping arguments and non-releasing arguments, and may be; // non-autoreleasing.; // TODO: Sink autorelease calls as far as possible. Unfortunately we; // usually can't sink them past other calls, which would be the main; // case where it would be useful.; // TODO: The pointer returned from objc_loadWeakRetained is retained.; // TODO: Delete release+retain pairs (rare).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:858,Performance,optimiz,optimizer,858,"/// @}; ///; /// \defgroup ARCOpt ARC Optimization.; /// @{; // TODO: On code like this:; //; // objc_retain(%x); // stuff_that_cannot_release(); // objc_autorelease(%x); // stuff_that_cannot_release(); // objc_retain(%x); // stuff_that_cannot_release(); // objc_autorelease(%x); //; // The second retain and autorelease can be deleted.; // TODO: It should be possible to delete; // objc_autoreleasePoolPush and objc_autoreleasePoolPop; // pairs if nothing is actually autoreleased between them. Also, autorelease; // calls followed by objc_autoreleasePoolPop calls (perhaps in ObjC++ code; // after inlining) can be turned into plain release calls.; // TODO: Critical-edge splitting. If the optimial insertion point is; // a critical edge, the current algorithm has to fail, because it doesn't; // know how to split edges. It should be possible to make the optimizer; // think in terms of edges, rather than blocks, and then split critical; // edges on demand.; // TODO: OptimizeSequences could generalized to be Interprocedural.; // TODO: Recognize that a bunch of other objc runtime calls have; // non-escaping arguments and non-releasing arguments, and may be; // non-autoreleasing.; // TODO: Sink autorelease calls as far as possible. Unfortunately we; // usually can't sink them past other calls, which would be the main; // case where it would be useful.; // TODO: The pointer returned from objc_loadWeakRetained is retained.; // TODO: Delete release+retain pairs (rare).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:972,Performance,Optimiz,OptimizeSequences,972,"/// @}; ///; /// \defgroup ARCOpt ARC Optimization.; /// @{; // TODO: On code like this:; //; // objc_retain(%x); // stuff_that_cannot_release(); // objc_autorelease(%x); // stuff_that_cannot_release(); // objc_retain(%x); // stuff_that_cannot_release(); // objc_autorelease(%x); //; // The second retain and autorelease can be deleted.; // TODO: It should be possible to delete; // objc_autoreleasePoolPush and objc_autoreleasePoolPop; // pairs if nothing is actually autoreleased between them. Also, autorelease; // calls followed by objc_autoreleasePoolPop calls (perhaps in ObjC++ code; // after inlining) can be turned into plain release calls.; // TODO: Critical-edge splitting. If the optimial insertion point is; // a critical edge, the current algorithm has to fail, because it doesn't; // know how to split edges. It should be possible to make the optimizer; // think in terms of edges, rather than blocks, and then split critical; // edges on demand.; // TODO: OptimizeSequences could generalized to be Interprocedural.; // TODO: Recognize that a bunch of other objc runtime calls have; // non-escaping arguments and non-releasing arguments, and may be; // non-autoreleasing.; // TODO: Sink autorelease calls as far as possible. Unfortunately we; // usually can't sink them past other calls, which would be the main; // case where it would be useful.; // TODO: The pointer returned from objc_loadWeakRetained is retained.; // TODO: Delete release+retain pairs (rare).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:12,Availability,down,down,12,/// The top-down traversal uses this to record information known about a; /// pointer at the bottom of each block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:59,Availability,down,down,59,/// Attempt to find the PtrState object describing the top down state for; /// pointer Arg. Return a new initialized PtrState describing the top down; /// state for Arg if we do not find one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:145,Availability,down,down,145,/// Attempt to find the PtrState object describing the top down state for; /// pointer Arg. Return a new initialized PtrState describing the top down; /// state for Arg if we do not find one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:152,Availability,down,down,152,/// Compute the number of possible unique paths from an entry to an exit; /// which pass through this block. This is only valid after both the; /// top-down and bottom-up traversals are complete.; ///; /// Returns true if overflow occurred. Returns false if overflow did not; /// occur.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:12,Availability,down,down,12,/// The top-down traversal uses this to merge information about predecessors to; /// form the initial state for a new block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:47,Availability,down,down,47,"// In order to be consistent, we clear the top down pointers when by adding; // TopDownPathCount becomes OverflowOccurredValue even though ""true"" overflow; // has not occurred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:33,Usability,clear,clear,33,"// In order to be consistent, we clear the top down pointers when by adding; // TopDownPathCount becomes OverflowOccurredValue even though ""true"" overflow; // has not occurred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:47,Availability,down,down,47,"// In order to be consistent, we clear the top down pointers when by adding; // BottomUpPathCount becomes OverflowOccurredValue even though ""true"" overflow; // has not occurred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:33,Usability,clear,clear,33,"// In order to be consistent, we clear the top down pointers when by adding; // BottomUpPathCount becomes OverflowOccurredValue even though ""true"" overflow; // has not occurred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:17,Performance,optimiz,optimization,17,/// The main ARC optimization pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:6,Performance,cache,cache,6,/// A cache of references to runtime entry point constants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:6,Performance,cache,cache,6,/// A cache of MDKinds that can be passed into other functions to propagate; /// MDKind identifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:81,Deployability,release,release,81,/// A flag indicating whether the optimization that removes or moves; /// retain/release pairs should be performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:34,Performance,optimiz,optimization,34,/// A flag indicating whether the optimization that removes or moves; /// retain/release pairs should be performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:105,Performance,perform,performed,105,/// A flag indicating whether the optimization that removes or moves; /// retain/release pairs should be performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:4,Performance,Optimiz,Optimize,4,"/// Optimize an individual call, optionally passing the; /// GetArgRCIdentityRoot if it has already been computed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:11,Performance,optimiz,optimize,11,"/// Try to optimize an AutoreleaseRV with a RetainRV or UnsafeClaimRV. If the; /// optimization occurs, returns true to indicate that the caller should; /// assume the instructions are dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:83,Performance,optimiz,optimization,83,"/// Try to optimize an AutoreleaseRV with a RetainRV or UnsafeClaimRV. If the; /// optimization occurs, returns true to indicate that the caller should; /// assume the instructions are dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:56,Safety,Unsafe,UnsafeClaimRV,56,"/// Try to optimize an AutoreleaseRV with a RetainRV or UnsafeClaimRV. If the; /// optimization occurs, returns true to indicate that the caller should; /// assume the instructions are dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:55,Deployability,Release,Release,55,"// UnsafeClaimRV is a frontend peephole for RetainRV + Release. Since the; // AutoreleaseRV and RetainRV cancel out, replace UnsafeClaimRV with Release.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:144,Deployability,Release,Release,144,"// UnsafeClaimRV is a frontend peephole for RetainRV + Release. Since the; // AutoreleaseRV and RetainRV cancel out, replace UnsafeClaimRV with Release.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:3,Safety,Unsafe,UnsafeClaimRV,3,"// UnsafeClaimRV is a frontend peephole for RetainRV + Release. Since the; // AutoreleaseRV and RetainRV cancel out, replace UnsafeClaimRV with Release.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:125,Safety,Unsafe,UnsafeClaimRV,125,"// UnsafeClaimRV is a frontend peephole for RetainRV + Release. Since the; // AutoreleaseRV and RetainRV cancel out, replace UnsafeClaimRV with Release.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:35,Deployability,Release,Release,35,// Run the normal optimizations on Release.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:18,Performance,optimiz,optimizations,18,// Run the normal optimizations on Release.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:45,Usability,simpl,simplifications,45,"/// Visit each call, one at a time, and make simplifications without doing any; /// additional analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:98,Safety,Unsafe,UnsafeClaimRV,98,"// Store any delayed AutoreleaseRV intrinsics, so they can be easily paired; // with RetainRV and UnsafeClaimRV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:49,Testability,log,logic,49,"// Nothing to delay, but we may as well skip the logic below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:163,Performance,Optimiz,OptimizeInlinedAutoreleaseRVCall,163,"// Given the frontend rules for emitting AutoreleaseRV, RetainRV, and; // UnsafeClaimRV, it's probably safe to skip over even opaque function calls; // here since OptimizeInlinedAutoreleaseRVCall will confirm that they; // have the same RCIdentityRoot. However, what really matters is; // skipping instructions or intrinsics that the inliner could leave behind;; // be conservative for now and don't skip over opaque calls, which could; // potentially include other ARC calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:74,Safety,Unsafe,UnsafeClaimRV,74,"// Given the frontend rules for emitting AutoreleaseRV, RetainRV, and; // UnsafeClaimRV, it's probably safe to skip over even opaque function calls; // here since OptimizeInlinedAutoreleaseRVCall will confirm that they; // have the same RCIdentityRoot. However, what really matters is; // skipping instructions or intrinsics that the inliner could leave behind;; // be conservative for now and don't skip over opaque calls, which could; // potentially include other ARC calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:103,Safety,safe,safe,103,"// Given the frontend rules for emitting AutoreleaseRV, RetainRV, and; // UnsafeClaimRV, it's probably safe to skip over even opaque function calls; // here since OptimizeInlinedAutoreleaseRVCall will confirm that they; // have the same RCIdentityRoot. However, what really matters is; // skipping instructions or intrinsics that the inliner could leave behind;; // be conservative for now and don't skip over opaque calls, which could; // potentially include other ARC calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:118,Performance,optimiz,optimize,118,"// This is a non-ARC instruction. If we're delaying an AutoreleaseRV,; // check if it's safe to skip over it; if not, optimize the AutoreleaseRV; // now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:88,Safety,safe,safe,88,"// This is a non-ARC instruction. If we're delaying an AutoreleaseRV,; // check if it's safe to skip over it; if not, optimize the AutoreleaseRV; // now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:115,Safety,safe,safely,115,/// This function returns true if the value is inert. An ObjC ARC runtime call; /// taking an inert operand can be safely deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:180,Performance,optimiz,optimizer,180,"// Delete no-op casts. These function calls have special semantics, but; // the semantics are entirely implemented via lowering in the front-end,; // so by the time they reach the optimizer, they are just no-op calls; // which return their argument.; //; // There are gray areas here, as the ability to cast reference-counted; // pointers to raw void* and back allows code to break ARC assumptions,; // however these are currently considered to be unimportant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:34,Deployability,release,release,34,"// Keep track of which of retain, release, autorelease, and retain_block; // are actually present in this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:223,Deployability,release,release,223,"// If Arg is a PHI, and one or more incoming values to the; // PHI are null, and the call is control-equivalent to the PHI, and there; // are no relevant side effects between the PHI and the call, and the call; // is not a release that doesn't have the clang.imprecise_release tag, the; // call could be pushed up to just those paths with non-null incoming; // values. For now, don't bother splitting critical edges for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:51,Performance,optimiz,optimize,51,"// If we have null operands and no critical edges, optimize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:41,Integrability,depend,depends,41,"// Don't move these; the RV optimization depends on the autoreleaseRV; // being tail called, and the retainRV being immediately after a call; // (which might still happen if we get lucky with codegen layout, but; // it's not worth taking the chance).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:28,Performance,optimiz,optimization,28,"// Don't move these; the RV optimization depends on the autoreleaseRV; // being tail called, and the retainRV being immediately after a call; // (which might still happen if we get lucky with codegen layout, but; // it's not worth taking the chance).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:21,Availability,down,down,21,"/// If we have a top down pointer in the S_Use state, make sure that there are; /// no CFG hazards by checking the states of various bottom up pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:91,Safety,hazard,hazards,91,"/// If we have a top down pointer in the S_Use state, make sure that there are; /// no CFG hazards by checking the states of various bottom up pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:21,Availability,Down,Down,21,"/// If we have a Top Down pointer in the S_CanRelease state, make sure that; /// there are no CFG hazards by checking the states of various bottom up; /// pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:98,Safety,hazard,hazards,98,"/// If we have a Top Down pointer in the S_CanRelease state, make sure that; /// there are no CFG hazards by checking the states of various bottom up; /// pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:14,Availability,down,down,14,"// If any top-down local-use or possible-dec has a succ which is earlier in; // the sequence, forget it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:31,Availability,down,down,31,// Make sure that if extra top down states are added in the future that this; // code is updated to handle it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:89,Deployability,update,updated,89,// Make sure that if extra top down states are added in the future that this; // code is updated to handle it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:180,Deployability,release,releases,180,"// If bottom up, the pointer is in an S_None state, clear the sequence; // progress since the sequence in the bottom up state finished; // suggesting a mismatch in between retains/releases. This is true for; // all three cases that we are handling here: S_Retain, S_Use, and; // S_CanRelease.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:52,Usability,clear,clear,52,"// If bottom up, the pointer is in an S_None state, clear the sequence; // progress since the sequence in the bottom up state finished; // suggesting a mismatch in between retains/releases. This is true for; // all three cases that we are handling here: S_Retain, S_Use, and; // S_CanRelease.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:37,Performance,perform,perform,37,"// If we have S_Use or S_CanRelease, perform our check for cfg hazard; // checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:63,Safety,hazard,hazard,63,"// If we have S_Use or S_CanRelease, perform our check for cfg hazard; // checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:240,Performance,perform,perform,240,"// If we would have cleared the state foregoing the fact that we are known; // safe, stop code motion. This is because whether or not it is safe to; // remove RR pairs via KnownSafe is an orthogonal concept to whether we; // are allowed to perform code motion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:79,Safety,safe,safe,79,"// If we would have cleared the state foregoing the fact that we are known; // safe, stop code motion. This is because whether or not it is safe to; // remove RR pairs via KnownSafe is an orthogonal concept to whether we; // are allowed to perform code motion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:140,Safety,safe,safe,140,"// If we would have cleared the state foregoing the fact that we are known; // safe, stop code motion. This is because whether or not it is safe to; // remove RR pairs via KnownSafe is an orthogonal concept to whether we; // are allowed to perform code motion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:20,Usability,clear,cleared,20,"// If we would have cleared the state foregoing the fact that we are known; // safe, stop code motion. This is because whether or not it is safe to; // remove RR pairs via KnownSafe is an orthogonal concept to whether we; // are allowed to perform code motion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:48,Energy Efficiency,reduce,reduced,48,"// In OptimizeIndividualCalls, we have strength reduced all optimizable; // objc_retainBlocks to objc_retains. Thus at this point any; // objc_retainBlocks that we see are not optimizable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:6,Performance,Optimiz,OptimizeIndividualCalls,6,"// In OptimizeIndividualCalls, we have strength reduced all optimizable; // objc_retainBlocks to objc_retains. Thus at this point any; // objc_retainBlocks that we see are not optimizable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:60,Performance,optimiz,optimizable,60,"// In OptimizeIndividualCalls, we have strength reduced all optimizable; // objc_retainBlocks to objc_retains. Thus at this point any; // objc_retainBlocks that we see are not optimizable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:176,Performance,optimiz,optimizable,176,"// In OptimizeIndividualCalls, we have strength reduced all optimizable; // objc_retainBlocks to objc_retains. Thus at this point any; // objc_retainBlocks that we see are not optimizable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:19,Deployability,release,release,19,"// Don't do retain+release tracking for ARCInstKind::RetainRV, because; // it's better to let it remain as the first instruction after a call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:19,Usability,clear,clear,19,"// Conservatively, clear MyStates for all known pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:8,Deployability,Release,ReleaseInsertPtToRCIdentityRoots,8,"// Fill ReleaseInsertPtToRCIdentityRoots, which is a map from insertion points; // to the set of RC identity roots that would be released by the release calls; // moved to the insertion points.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:129,Deployability,release,released,129,"// Fill ReleaseInsertPtToRCIdentityRoots, which is a map from insertion points; // to the set of RC identity roots that would be released by the release calls; // moved to the insertion points.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:145,Deployability,release,release,145,"// Fill ReleaseInsertPtToRCIdentityRoots, which is a map from insertion points; // to the set of RC identity roots that would be released by the release calls; // moved to the insertion points.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:67,Deployability,release,release,67,// Collect all the insertion points of the objc_release calls that release; // the RC identity root of the objc_retain call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:279,Availability,down,down,279,"// Disable code motion if the current position is S_Retain to prevent; // moving the objc_retain call past objc_release calls. If it's; // S_CanRelease or larger, it's not necessary to disable code motion as; // the insertion points that prevent the objc_retain call from moving down; // should have been set already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:48,Energy Efficiency,reduce,reduced,48,"// In OptimizeIndividualCalls, we have strength reduced all optimizable; // objc_retainBlocks to objc_retains. Thus at this point any; // objc_retainBlocks that we see are not optimizable. We need to break since; // a retain can be a potential use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:6,Performance,Optimiz,OptimizeIndividualCalls,6,"// In OptimizeIndividualCalls, we have strength reduced all optimizable; // objc_retainBlocks to objc_retains. Thus at this point any; // objc_retainBlocks that we see are not optimizable. We need to break since; // a retain can be a potential use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:60,Performance,optimiz,optimizable,60,"// In OptimizeIndividualCalls, we have strength reduced all optimizable; // objc_retainBlocks to objc_retains. Thus at this point any; // objc_retainBlocks that we see are not optimizable. We need to break since; // a retain can be a potential use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:176,Performance,optimiz,optimizable,176,"// In OptimizeIndividualCalls, we have strength reduced all optimizable; // objc_retainBlocks to objc_retains. Thus at this point any; // objc_retainBlocks that we see are not optimizable. We need to break since; // a retain can be a potential use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:84,Availability,down,down,84,// Try to form a tentative pair in between this release instruction and the; // top down pointers that we are tracking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:48,Deployability,release,release,48,// Try to form a tentative pair in between this release instruction and the; // top down pointers that we are tracking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:43,Deployability,Release,Release,43,"// If we succeed, copy S's RRInfo into the Release -> {Retain Set; // Map}. Then we clear S.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:84,Usability,clear,clear,84,"// If we succeed, copy S's RRInfo into the Release -> {Retain Set; // Map}. Then we clear S.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:19,Usability,clear,clear,19,"// Conservatively, clear MyStates for all known pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:35,Availability,down,down,35,"// Visit all the instructions, top-down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:31,Availability,down,down,31,// Visit the function both top-down and bottom-up.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:179,Deployability,release,release,179,"// Use reverse-postorder traversals, because we magically know that loops; // will be well behaved, i.e. they won't repeatedly call retain on a single; // pointer without doing a release. We can't use the ReversePostOrderTraversal; // class here because we want the reverse-CFG postorder to consider each; // function exit point, and we want to ignore selected cycle edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:33,Availability,down,down,33,// Use reverse-postorder for top-down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:40,Deployability,Release,ReleasesToMove,40,/// Move the calls in RetainsToMove and ReleasesToMove.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:29,Deployability,release,release,29,// Insert the new retain and release calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:34,Deployability,release,release,34,// Delete the original retain and release calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:36,Availability,down,down-collected,36,// Connect the dots between the top-down-collected RetainsToMove and; // bottom-up-collected ReleasesToMove to form sets of related calls.; // This is an iterative process so that we connect multiple releases; // to multiple retains if needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:93,Deployability,Release,ReleasesToMove,93,// Connect the dots between the top-down-collected RetainsToMove and; // bottom-up-collected ReleasesToMove to form sets of related calls.; // This is an iterative process so that we connect multiple releases; // to multiple retains if needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:200,Deployability,release,releases,200,// Connect the dots between the top-down-collected RetainsToMove and; // bottom-up-collected ReleasesToMove to form sets of related calls.; // This is an iterative process so that we connect multiple releases; // to multiple retains if needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:10,Deployability,release,release,10,"// If the release does not have a reference to the retain as well,; // something happened which is unaccounted for. Do not do anything.; //; // This can happen if we catch an additive overflow during path count; // merging.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:13,Deployability,Release,ReleaseMetadata,13,// Merge the ReleaseMetadata and IsTailCallRelease values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:50,Deployability,release,release,50,"// If the retain does not have a reference to the release as well,; // something happened which is unaccounted for. Do not do anything.; //; // This can happen if we catch an additive overflow during path count; // merging.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:47,Safety,safe,safe,47,// We can only remove pointers if we are known safe in both directions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:97,Deployability,release,release,97,"// Determine whether the new insertion points we computed preserve the; // balance of retain and release calls through the program.; // TODO: If the fully aggressive solution isn't valid, try to find a; // less aggressive solution which is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:170,Performance,perform,perform,170,"// At this point, we are not going to remove any RR pairs, but we still are; // able to move RR pairs. If one of our pointers is afflicted with; // CFGHazards, we cannot perform such code motion so exit early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:81,Deployability,release,release,81,"// Determine whether the original call points are balanced in the retain and; // release calls through the program. If not, conservatively don't touch; // them.; // TODO: It's theoretically possible to do code motion in this case, as; // long as the existing imbalances are maintained.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:46,Deployability,release,releases,46,"/// Identify pairings between the retains and releases, and delete and/or move; /// them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:23,Deployability,release,released,23,"// If the object being released is in static or stack storage, we know it's; // not being managed by ObjC reference counting, so we can delete pairs; // regardless of what possible decrements or uses lie between them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:36,Availability,down,down-collected,36,// Connect the dots between the top-down-collected RetainsToMove and; // bottom-up-collected ReleasesToMove to form sets of related calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:93,Deployability,Release,ReleasesToMove,93,// Connect the dots between the top-down-collected RetainsToMove and; // bottom-up-collected ReleasesToMove to form sets of related calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:17,Performance,optimiz,optimizations,17,/// Weak pointer optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:38,Performance,optimiz,optimizations,38,"// First, do memdep-style RLE and S2L optimizations. We can't use memdep; // itself because it uses AliasAnalysis and we need to do provenance; // queries instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:43,Availability,avail,available,43,"// TODO: For now, just look for an earlier available version of this value; // within the same block. Theoretically, we could do memdep-style non-local; // analysis too, but that would want caching. A better approach would be to; // use the technique that EarlyCSE uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:14,Performance,load,loading,14,"// If this is loading from the same pointer, replace this load's value; // with that one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:58,Performance,load,load,58,"// If this is loading from the same pointer, replace this load's value; // with that one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:10,Performance,load,load,10,"// If the load has a builtin retain, insert a plain retain for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:17,Availability,redundant,redundant,17,// Zap the fully redundant load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:27,Performance,load,load,27,// Zap the fully redundant load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:17,Safety,redund,redundant,17,// Zap the fully redundant load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:86,Performance,load,load,86,// If this is storing to the same pointer and has the same size etc.; // replace this load's value with the stored value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:10,Performance,load,load,10,"// If the load has a builtin retain, insert a plain retain for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:17,Availability,redundant,redundant,17,// Zap the fully redundant load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:27,Performance,load,load,27,// Zap the fully redundant load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:17,Safety,redund,redundant,17,// Zap the fully redundant load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:66,Deployability,release,releases,66,/// Identify program paths which execute sequences of retains and releases which; /// can be eliminated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:3,Deployability,Release,Releases,3,"// Releases, Retains - These are used to store the results of the main flow; // analysis. These use Value* as the key instead of Instruction* so that the; // map stays valid when we get around to rewriting code and calls get; // replaced by arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:24,Integrability,depend,dependent,24,/// Check if there is a dependent call earlier that does not have anything in; /// between the Retain and the call that can affect the reference count of their; /// shared pointer argument. Note that Retain need not be in BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:11,Integrability,depend,dependent,11,/// Find a dependent retain that precedes the given autorelease for which there; /// is nothing in between the two instructions that can affect the ref count of; /// Arg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:44,Integrability,depend,dependent,44,/// Look for an ``autorelease'' instruction dependent on Arg such that there are; /// no instructions dependent on Arg that need a positive ref count in between; /// the autorelease and the ret.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:102,Integrability,depend,dependent,102,/// Look for an ``autorelease'' instruction dependent on Arg such that there are; /// no instructions dependent on Arg that need a positive ref count in between; /// the autorelease and the ret.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:80,Integrability,depend,dependent,80,// Look for an ``autorelease'' instruction that is a predecessor of Ret and; // dependent on Arg such that there are no instructions dependent on Arg; // that need a positive ref count in between the autorelease and Ret.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:133,Integrability,depend,dependent,133,// Look for an ``autorelease'' instruction that is a predecessor of Ret and; // dependent on Arg such that there are no instructions dependent on Arg; // that need a positive ref count in between the autorelease and Ret.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:3,Usability,Intuit,Intuitively,3,"// Intuitively, objc_retain and others are nocapture, however in practice; // they are not, because they return their argument value. And objc_release; // calls finalizers which can have arbitrary side effects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:38,Performance,cache,cache,38,// Initialize our runtime entry point cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:2,Integrability,Contract,ContractPass,2,/*ContractPass=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:13,Performance,perform,performs,13,"// This pass performs several distinct transformations. As a compile-time aid; // when compiling code that isn't ObjC, skip these if the relevant ObjC; // library functions aren't declared.; // Preliminary optimizations. This also computes UsedInThisFunction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:206,Performance,optimiz,optimizations,206,"// This pass performs several distinct transformations. As a compile-time aid; // when compiling code that isn't ObjC, skip these if the relevant ObjC; // library functions aren't declared.; // Preliminary optimizations. This also computes UsedInThisFunction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:3,Performance,Optimiz,Optimizations,3,// Optimizations for weak pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:28,Deployability,release,release,28,// Optimizations for retain+release pairs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:3,Performance,Optimiz,Optimizations,3,// Optimizations for retain+release pairs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:79,Deployability,release,release,79,// Run OptimizeSequences until it either stops making changes or; // no retain+release pair nesting is detected.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:7,Performance,Optimiz,OptimizeSequences,7,// Run OptimizeSequences until it either stops making changes or; // no retain+release pair nesting is detected.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:103,Safety,detect,detected,103,// Run OptimizeSequences until it either stops making changes or; // no retain+release pair nesting is detected.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:3,Performance,Optimiz,Optimizations,3,// Optimizations if objc_autorelease is used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:27,Performance,optimiz,optimization,27,// Gather statistics after optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp:41,Performance,Optimiz,Optimization,41,"//===- ProvenanceAnalysis.cpp - ObjC ARC Optimization ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; ///; /// This file defines a special form of Alias Analysis called ``Provenance; /// Analysis''. The word ``provenance'' refers to the history of the ownership; /// of an object. Thus ``Provenance Analysis'' is an analysis which attempts to; /// use various techniques to determine if locally; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp:85,Energy Efficiency,efficient,efficient,85,"// If the values are PHIs in the same block, we can do a more precise as well; // as efficient check: just check for relations between the values on; // corresponding edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp:4,Testability,Test,Test,4,"/// Test if the value of P, or any value covered by its provenance, is ever; /// stored within the function (not counting callees).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp:43,Performance,load,load,43,// An ObjC-Identified object can't alias a load if it is never locally stored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.h:39,Performance,Optimiz,Optimization,39,"//===- ProvenanceAnalysis.h - ObjC ARC Optimization -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; ///; /// This file declares a special form of Alias Analysis called ``Provenance; /// Analysis''. The word ``provenance'' refers to the history of the ownership; /// of an object. Thus ``Provenance Analysis'' is an analysis which attempts to; /// use various techniques to determine if locally; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysisEvaluator.cpp:50,Performance,Optimiz,Optimization,50,"//===- ProvenanceAnalysisEvaluator.cpp - ObjC ARC Optimization ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysisEvaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysisEvaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:21,Deployability,release,releases,21,"// If both sides are releases, choose the more conservative one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:28,Deployability,Release,ReleaseMetadata,28,// Conservatively merge the ReleaseMetadata information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:117,Safety,avoid,avoid,117,"// If we're doing a merge on a path that's previously seen a partial; // merge, conservatively drop the sequence, to avoid doing partial; // RR elimination. If the branch predicates for the two merge differ,; // mixing them is unsafe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:227,Safety,unsafe,unsafe,227,"// If we're doing a merge on a path that's previously seen a partial; // merge, conservatively drop the sequence, to avoid doing partial; // RR elimination. If the branch predicates for the two merge differ,; // mixing them is unsafe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:17,Deployability,release,releases,17,"// If we see two releases in a row on the same pointer. If so, make; // a note, and we'll cicle back to revisit it after we've; // hopefully eliminated the second release, which may allow us to; // eliminate the first release too.; // Theoretically we could implement removal of nested retain+release; // pairs by making PtrState hold a stack of states, but this is; // simple and avoids adding overhead for the non-nested case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:163,Deployability,release,release,163,"// If we see two releases in a row on the same pointer. If so, make; // a note, and we'll cicle back to revisit it after we've; // hopefully eliminated the second release, which may allow us to; // eliminate the first release too.; // Theoretically we could implement removal of nested retain+release; // pairs by making PtrState hold a stack of states, but this is; // simple and avoids adding overhead for the non-nested case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:218,Deployability,release,release,218,"// If we see two releases in a row on the same pointer. If so, make; // a note, and we'll cicle back to revisit it after we've; // hopefully eliminated the second release, which may allow us to; // eliminate the first release too.; // Theoretically we could implement removal of nested retain+release; // pairs by making PtrState hold a stack of states, but this is; // simple and avoids adding overhead for the non-nested case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:293,Deployability,release,release,293,"// If we see two releases in a row on the same pointer. If so, make; // a note, and we'll cicle back to revisit it after we've; // hopefully eliminated the second release, which may allow us to; // eliminate the first release too.; // Theoretically we could implement removal of nested retain+release; // pairs by making PtrState hold a stack of states, but this is; // simple and avoids adding overhead for the non-nested case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:381,Safety,avoid,avoids,381,"// If we see two releases in a row on the same pointer. If so, make; // a note, and we'll cicle back to revisit it after we've; // hopefully eliminated the second release, which may allow us to; // eliminate the first release too.; // Theoretically we could implement removal of nested retain+release; // pairs by making PtrState hold a stack of states, but this is; // simple and avoids adding overhead for the non-nested case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:370,Usability,simpl,simple,370,"// If we see two releases in a row on the same pointer. If so, make; // a note, and we'll cicle back to revisit it after we've; // hopefully eliminated the second release, which may allow us to; // eliminate the first release too.; // Theoretically we could implement removal of nested retain+release; // pairs by making PtrState hold a stack of states, but this is; // simple and avoids adding overhead for the non-nested case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:82,Deployability,release,release,82,"// If OldSeq is not S_Use or OldSeq is S_Use and we are tracking an; // imprecise release, clear our reverse insertion points.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:91,Usability,clear,clear,91,"// If OldSeq is not S_Use or OldSeq is S_Use and we are tracking an; // imprecise release, clear our reverse insertion points.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:22,Deployability,release,releases,22,// Check for possible releases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:19,Deployability,release,release,19,"// Don't do retain+release tracking for ARCInstKind::RetainRV, because; // it's; // better to let it remain as the first instruction after a call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:290,Deployability,release,release,290,"// If we see two retains in a row on the same pointer. If so, make; // a note, and we'll cicle back to revisit it after we've; // hopefully eliminated the second retain, which may allow us to; // eliminate the first retain too.; // Theoretically we could implement removal of nested retain+release; // pairs by making PtrState hold a stack of states, but this is; // simple and avoids adding overhead for the non-nested case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:378,Safety,avoid,avoids,378,"// If we see two retains in a row on the same pointer. If so, make; // a note, and we'll cicle back to revisit it after we've; // hopefully eliminated the second retain, which may allow us to; // eliminate the first retain too.; // Theoretically we could implement removal of nested retain+release; // pairs by making PtrState hold a stack of states, but this is; // simple and avoids adding overhead for the non-nested case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:367,Usability,simpl,simple,367,"// If we see two retains in a row on the same pointer. If so, make; // a note, and we'll cicle back to revisit it after we've; // hopefully eliminated the second retain, which may allow us to; // eliminate the first retain too.; // Theoretically we could implement removal of nested retain+release; // pairs by making PtrState hold a stack of states, but this is; // simple and avoids adding overhead for the non-nested case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:22,Deployability,release,releases,22,// Check for possible releases. Treat clang.arc.use as a releasing instruction; // to prevent sinking a retain past it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:621,Performance,optimiz,optimization,621,"//===- PtrState.h - ARC State for a Ptr -------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains declarations for the ARC state associated with a ptr. It; // is only used by the ARC Sequence Dataflow computation. By separating this; // from the actual dataflow, it is easier to consider the mechanics of the ARC; // optimization separate from the actual predicates being used.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:72,Deployability,release,release,72,/// Unidirectional information about either a; /// retain-decrement-use-release sequence or release-use-decrement-retain; /// reverse sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:92,Deployability,release,release-use-decrement-retain,92,/// Unidirectional information about either a; /// retain-decrement-use-release sequence or release-use-decrement-retain; /// reverse sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:236,Deployability,release,release,236,"/// After an objc_retain, the reference count of the referenced; /// object is known to be positive. Similarly, before an objc_release, the; /// reference count of the referenced object is known to be positive. If; /// there are retain-release pairs in code regions where the retain count; /// is known to be positive, they can be eliminated, regardless of any side; /// effects between them.; ///; /// Also, a retain+release pair nested within another retain+release; /// pair all on the known same pointer value can be eliminated, regardless; /// of any intervening side effects.; ///; /// KnownSafe is true when either of these conditions is satisfied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:418,Deployability,release,release,418,"/// After an objc_retain, the reference count of the referenced; /// object is known to be positive. Similarly, before an objc_release, the; /// reference count of the referenced object is known to be positive. If; /// there are retain-release pairs in code regions where the retain count; /// is known to be positive, they can be eliminated, regardless of any side; /// effects between them.; ///; /// Also, a retain+release pair nested within another retain+release; /// pair all on the known same pointer value can be eliminated, regardless; /// of any intervening side effects.; ///; /// KnownSafe is true when either of these conditions is satisfied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:460,Deployability,release,release,460,"/// After an objc_retain, the reference count of the referenced; /// object is known to be positive. Similarly, before an objc_release, the; /// reference count of the referenced object is known to be positive. If; /// there are retain-release pairs in code regions where the retain count; /// is known to be positive, they can be eliminated, regardless of any side; /// effects between them.; ///; /// Also, a retain+release pair nested within another retain+release; /// pair all on the known same pointer value can be eliminated, regardless; /// of any intervening side effects.; ///; /// KnownSafe is true when either of these conditions is satisfied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:14,Availability,down,down,14,"/// For a top-down sequence, the set of objc_retains or; /// objc_retainBlocks. For bottom-up, the set of objc_releases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:84,Deployability,release,release,84,"/// If this is true, we cannot perform code motion but can still remove; /// retain/release pairs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:31,Performance,perform,perform,31,"/// If this is true, we cannot perform code motion but can still remove; /// retain/release pairs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:100,Deployability,release,releases,100,/// (Re-)Initialize this bottom up pointer returning true if we detected a; /// pointer with nested releases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:64,Safety,detect,detected,64,/// (Re-)Initialize this bottom up pointer returning true if we detected a; /// pointer with nested releases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:31,Deployability,release,releases,31,/// Return true if this set of releases can be paired with a release. Modifies; /// state appropriately to reflect that the matching occurred if it is; /// successful.; ///; /// It is assumed that one has already checked that the RCIdentity of the; /// retain and the RCIdentity of this ptr state are the same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:61,Deployability,release,release,61,/// Return true if this set of releases can be paired with a release. Modifies; /// state appropriately to reflect that the matching occurred if it is; /// successful.; ///; /// It is assumed that one has already checked that the RCIdentity of the; /// retain and the RCIdentity of this ptr state are the same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:100,Deployability,release,releases,100,/// (Re-)Initialize this bottom up pointer returning true if we detected a; /// pointer with nested releases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:64,Safety,detect,detected,64,/// (Re-)Initialize this bottom up pointer returning true if we detected a; /// pointer with nested releases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:73,Deployability,release,release,73,/// Return true if this set of retains can be paired with the given; /// release. Modifies state appropriately to reflect that the matching; /// occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:26,Performance,perform,perform,26,"//===- ADCE.cpp - Code to perform dead code elimination -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Aggressive Dead Code Elimination pass. This pass; // optimistically assumes that all instructions are dead until proven otherwise,; // allowing it to eliminate dead computations that other DCE passes do not; // catch, particularly involving loop computations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:50,Integrability,interface,interface,50,// This is a temporary option until we change the interface to this pass based; // on optimization level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:86,Performance,optimiz,optimization,86,// This is a temporary option until we change the interface to this pass based; // on optimization level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:10,Security,access,access,10,/// Quick access to information for block containing associated Instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:12,Integrability,depend,dependence,12,/// Control dependence sources need to be live for this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:10,Security,access,access,10,"/// Quick access to the LiveInfo for the terminator,; /// holds the value &InstInfo[Terminator]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:4,Performance,Cache,Cache,4,/// Cache of BB->getTerminator().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:50,Deployability,update,updates,50,"// ADCE does not use DominatorTree per se, but it updates it to preserve the; // analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:66,Integrability,depend,dependence,66,/// The set of blocks which we have determined whose control; /// dependence sources must be live and which have not had; /// those dependences analyzed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:132,Integrability,depend,dependences,132,/// The set of blocks which we have determined whose control; /// dependence sources must be live and which have not had; /// those dependences analyzed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:87,Integrability,depend,dependences,87,/// Analyze dead branches to find those whose branches are the sources; /// of control dependences impacting a live block. Those branches are; /// marked live.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:95,Modifiability,rewrite,rewrite,95,/// Identify connected sections of the control flow graph which have; /// dead terminators and rewrite the control flow graph to remove them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:111,Performance,load,load,111,// We will have an entry in the map for each block so we grow the; // structure to twice that size to keep the load factor low in the hash table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:134,Security,hash,hash,134,// We will have an entry in the map for each block so we grow the; // structure to twice that size to keep the load factor low in the hash table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:104,Security,hash,hash,104,"// Iterate over blocks and initialize BlockInfoVec entries, count; // instructions to size the InstInfo hash table.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:21,Testability,test,test,21,// TODO -- move this test into llvm::isInstructionTriviallyDead,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:59,Availability,Alive,AliveScopes,59,"// Even though DILocations are not scopes, shove them into AliveScopes so we; // don't revisit them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:150,Integrability,depend,dependent,150,"// If a predecessor block is not live, mark it as control-flow live; // which will trigger marking live branches upon which; // that block is control dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:126,Integrability,depend,dependent,126,// The dominance frontier of a live block X in the reverse; // control graph is the set of blocks upon which X is control; // dependent. The following sequence computes the set of blocks; // which currently have dead terminators that are control; // dependence sources of a block which is in NewLiveBlocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:250,Integrability,depend,dependence,250,// The dominance frontier of a live block X in the reverse; // control graph is the set of blocks upon which X is control; // dependent. The following sequence computes the set of blocks; // which currently have dead terminators that are control; // dependence sources of a block which is in NewLiveBlocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:101,Deployability,update,update,101,//===----------------------------------------------------------------------===//; //; // Routines to update the CFG and SSA information before removing dead code.; //; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:89,Integrability,Rout,Routines,89,//===----------------------------------------------------------------------===//; //; // Routines to update the CFG and SSA information before removing dead code.; //; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:3,Deployability,Update,Updates,3,// Updates control and dataflow around dead blocks,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:31,Availability,alive,alive,31,// Check if the instruction is alive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:51,Availability,alive,alive,51,// Check if the scope of this variable location is alive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:30,Modifiability,variab,variable,30,// Check if the scope of this variable location is alive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:176,Availability,alive,alive,176,"// If intrinsic is pointing at a live SSA value, there may be an; // earlier optimization bug: if we know the location of the variable,; // why isn't the scope of the location alive?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:126,Modifiability,variab,variable,126,"// If intrinsic is pointing at a live SSA value, there may be an; // earlier optimization bug: if we know the location of the variable,; // why isn't the scope of the location alive?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:77,Performance,optimiz,optimization,77,"// If intrinsic is pointing at a live SSA value, there may be an; // earlier optimization bug: if we know the location of the variable,; // why isn't the scope of the location alive?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:211,Safety,safe,safely,211,"// The inverse of the live set is the dead set. These are those instructions; // that have no side effects and do not influence the control flow or return; // value of the function, and may therefore be deleted safely.; // NOTE: We reuse the Worklist vector here for memory efficiency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:139,Availability,alive,alive,139,"// With ""RemoveDIs"" debug-info stored in DPValue objects, debug-info; // attached to this instruction, and drop any for scopes that aren't alive,; // like the rest of this loop does. Extending support to assignment tracking; // is future work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:183,Modifiability,Extend,Extending,183,"// With ""RemoveDIs"" debug-info stored in DPValue objects, debug-info; // attached to this instruction, and drop any for scopes that aren't alive,; // like the rest of this loop does. Extending support to assignment tracking; // is future work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:3,Safety,Avoid,Avoid,3,// Avoid removing a DPV that is linked to instructions because it holds; // information about an existing store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:31,Availability,alive,alive,31,// Check if the instruction is alive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:3,Safety,Avoid,Avoid,3,// Avoid removing a dbg.assign that is linked to instructions because it; // holds information about an existing store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:51,Availability,alive,alive,51,// Check if the scope of this variable location is alive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:30,Modifiability,variab,variable,30,// Check if the scope of this variable location is alive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:33,Deployability,update,update,33,// Collect removed successors to update the (Post)DominatorTrees.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:314,Modifiability,extend,extend,314,"// This provides a post-order numbering of the reverse control flow graph; // Note that it is incomplete in the presence of infinite loops but we don't; // need numbers blocks which don't reach the end of the functions since; // all branches in those blocks are forced live.; // For each block without successors, extend the DFS from the block; // backward through the graph",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:102,Deployability,integrat,integration,102,//===----------------------------------------------------------------------===//; //; // Pass Manager integration code; //; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:102,Integrability,integrat,integration,102,//===----------------------------------------------------------------------===//; //; // Pass Manager integration code; //; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:108,Availability,avail,available,108,"// ADCE does not need DominatorTree, but require DominatorTree here; // to update analysis if it is already available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:75,Deployability,update,update,75,"// ADCE does not need DominatorTree, but require DominatorTree here; // to update analysis if it is already available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp:89,Performance,Load,Load,89,"//===----------------------- AlignmentFromAssumptions.cpp -----------------===//; // Set Load/Store Alignments From Assumptions; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a ScalarEvolution-based transformation to set; // the alignments of load, stores and memory intrinsics based on the truth; // expressions of assume intrinsics. The primary motivation is to handle; // complex alignment assumptions that apply to vector loads and stores that; // appear after vectorization and unrolling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp:519,Performance,load,load,519,"//===----------------------- AlignmentFromAssumptions.cpp -----------------===//; // Set Load/Store Alignments From Assumptions; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a ScalarEvolution-based transformation to set; // the alignments of load, stores and memory intrinsics based on the truth; // expressions of assume intrinsics. The primary motivation is to handle; // complex alignment assumptions that apply to vector loads and stores that; // appear after vectorization and unrolling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp:702,Performance,load,loads,702,"//===----------------------- AlignmentFromAssumptions.cpp -----------------===//; // Set Load/Store Alignments From Assumptions; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a ScalarEvolution-based transformation to set; // the alignments of load, stores and memory intrinsics based on the truth; // expressions of assume intrinsics. The primary motivation is to handle; // complex alignment assumptions that apply to vector loads and stores that; // appear after vectorization and unrolling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp:224,Energy Efficiency,reduce,reduced,224,"// Given an expression for the (constant) alignment, AlignSCEV, and an; // expression for the displacement between a pointer and the aligned address,; // DiffSCEV, compute the alignment of the displaced pointer if it can be reduced; // to a constant. Using SCEV to compute alignment handles the case where; // DiffSCEV is a recurrence with constant start such that the aligned offset; // is constant. e.g. {16,+,32} % 32 -> 16.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp:134,Energy Efficiency,power,power,134,"// If the displacement is not an exact multiple, but the remainder is a; // constant, then return this remainder (but only if it is a power of 2).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp:82,Modifiability,extend,extended,82,"// On 32-bit platforms, DiffSCEV might now have type i32 -- we've always; // sign-extended OffSCEV to i64, so make sure they agree again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp:215,Performance,load,loads,215,"// The relative offset to the alignment assumption did not yield a constant,; // but we should try harder: if we assume that a is 32-byte aligned, then in; // for (i = 0; i < 1024; i += 4) r += a[i]; not all of the loads from a are; // 32-byte aligned, but instead alternate between 32 and 16-byte alignment.; // As a result, the new alignment will not be a constant, but can still; // be improved over the default (of 4) to 16.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp:8,Energy Efficiency,power,power,8,// Only power of two alignments are supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp:18,Deployability,update,updated,18,"// Now that we've updated that use of the pointer, look for other uses of; // the pointer to update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp:93,Deployability,update,update,93,"// Now that we've updated that use of the pointer, look for other uses of; // the pointer to update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp:633,Usability,simpl,simplify,633,"//===---- BDCE.cpp - Bit-tracking dead code elimination -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Bit-Tracking Dead Code Elimination pass. Some; // instructions (shifts, some ands, ors, etc.) kill some of their input bits.; // We track these dead bits and remove instructions that compute only these; // dead bits. We also simplify sext that generates unused extension bits,; // converting it to a zext.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp:109,Usability,clear,cleared,109,"/// If an instruction is trivialized (dead), then the chain of users of that; /// instruction may need to be cleared of assumptions that can no longer be; /// guaranteed correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp:349,Safety,avoid,avoid,349,"// Note that we need to check for non-int types above before asking for; // demanded bits. Normally, the only way to reach an instruction with an; // non-int type is via an instruction that has side effects (or otherwise; // will demand its input bits). However, if we have a readnone function; // that returns an unsized type (e.g., void), we must avoid asking for the; // demanded bits of the function call's return value. A void-returning; // readnone function is always dead (and so we can stop walking the use/def; // chain here), but the check is necessary to avoid asserting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp:566,Safety,avoid,avoid,566,"// Note that we need to check for non-int types above before asking for; // demanded bits. Normally, the only way to reach an instruction with an; // non-int type is via an instruction that has side effects (or otherwise; // will demand its input bits). However, if we have a readnone function; // that returns an unsized type (e.g., void), we must avoid asking for the; // demanded bits of the function call's return value. A void-returning; // readnone function is always dead (and so we can stop walking the use/def; // chain here), but the check is necessary to avoid asserting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp:572,Testability,assert,asserting,572,"// Note that we need to check for non-int types above before asking for; // demanded bits. Normally, the only way to reach an instruction with an; // non-int type is via an instruction that has side effects (or otherwise; // will demand its input bits). However, if we have a readnone function; // that returns an unsized type (e.g., void), we must avoid asking for the; // demanded bits of the function call's return value. A void-returning; // readnone function is always dead (and so we can stop walking the use/def; // chain here), but the check is necessary to avoid asserting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp:57,Safety,avoid,avoid,57,// DFS through subsequent users while tracking visits to avoid cycles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp:182,Security,access,accesses,182,"// We do not have to worry about llvm.assume or range metadata:; // 1. llvm.assume demands its operand, so trivializing can't change it.; // 2. range metadata only applies to memory accesses which demand all bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp:85,Safety,avoid,avoid,85,"// If the instruction has side effects and no non-dbg uses,; // skip it. This way we avoid computing known bits on an instruction; // that will not help us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp:21,Safety,detect,detects,21,// DemandedBits only detects dead integer uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CallSiteSplitting.cpp:561,Security,expose,expose,561,"//===- CallSiteSplitting.cpp ----------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a transformation that tries to split a call-site to pass; // more constrained arguments if its argument is predicated in the control flow; // so that we can expose better context to the later passes (e.g, inliner, jump; // threading, or IPA-CP based function cloning, etc.).; // As of now we support two cases :; //; // 1) Try to a split call-site with constrained arguments, if any constraints; // on any argument can be found by following the single predecessors of the; // all site's predecessors. Currently this pass only handles call-sites with 2; // predecessors. For example, in the code below, we try to split the call-site; // since we can predicate the argument(ptr) based on the OR condition.; //; // Split from :; // if (!ptr || c); // callee(ptr);; // to :; // if (!ptr); // callee(null) // set the known constant value; // else if (c); // callee(nonnull ptr) // set non-null attribute in the argument; //; // 2) We can also split a call-site based on constant incoming values of a PHI; // For example,; // from :; // Header:; // %c = icmp eq i32 %i1, %i2; // br i1 %c, label %Tail, label %TBB; // TBB:; // br label Tail%; // Tail:; // %p = phi i32 [ 0, %Header], [ 1, %TBB]; // call void @bar(i32 %p); // to; // Header:; // %c = icmp eq i32 %i1, %i2; // br i1 %c, label %Tail-split0, label %TBB; // TBB:; // br label %Tail-split1; // Tail-split0:; // call void @bar(i32 0); // br label %Tail; // Tail-split1:; // call void @bar(i32 1); // br label %Tail; // Tail:; // %p = phi i32 [ 0, %Tail-split0 ], [ 1, %Tail-split1 ]; //; //===---------------------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CallSiteSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CallSiteSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CallSiteSplitting.cpp:245,Deployability,update,updated,245,// Allow splitting a call-site only when the CodeSize cost of the; // instructions before the call is less then DuplicationThreshold. The; // instructions before the call will be duplicated in the split blocks and; // corresponding uses will be updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CallSiteSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CallSiteSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CallSiteSplitting.cpp:63,Usability,simpl,simple,63,"// ValueToValueMapTy is neither copy nor moveable, so we use a simple array; // here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CallSiteSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CallSiteSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CallSiteSplitting.cpp:48,Deployability,patch,patching,48,// Erase the tail block once done with musttail patching,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CallSiteSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CallSiteSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:1189,Energy Efficiency,reduce,reduce,1189,"//===- ConstantHoisting.cpp - Prepare code for expensive constants --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies expensive constants to hoist and coalesces them to; // better prepare it for SelectionDAG-based code generation. This works around; // the limitations of the basic-block-at-a-time approach.; //; // First it scans all instructions for integer constants and calculates its; // cost. If the constant can be folded into the instruction (the cost is; // TCC_Free) or the cost is just a simple operation (TCC_BASIC), then we don't; // consider it expensive and leave it alone. This is the default behavior and; // the default implementation of getIntImmCostInst will always return TCC_Free.; //; // If the cost is more than TCC_BASIC, then the integer constant can't be folded; // into the instruction and it might be beneficial to hoist the constant.; // Similar constants are coalesced to reduce register pressure and; // materialization code.; //; // When a constant is hoisted, it is also hidden behind a bitcast to force it to; // be live-out of the basic block. Otherwise the constant would be just; // duplicated and each basic block would have its own copy in the SelectionDAG.; // The SelectionDAG recognizes such constants as opaque and doesn't perform; // certain transformations on them, which would create a new expensive constant.; //; // This optimization is only applied to integer constants in instructions and; // simple (this means not nested) constant cast expressions. For example:; // %0 = load i64* inttoptr (i64 big_constant to i64*); //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:1553,Performance,perform,perform,1553,"//===- ConstantHoisting.cpp - Prepare code for expensive constants --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies expensive constants to hoist and coalesces them to; // better prepare it for SelectionDAG-based code generation. This works around; // the limitations of the basic-block-at-a-time approach.; //; // First it scans all instructions for integer constants and calculates its; // cost. If the constant can be folded into the instruction (the cost is; // TCC_Free) or the cost is just a simple operation (TCC_BASIC), then we don't; // consider it expensive and leave it alone. This is the default behavior and; // the default implementation of getIntImmCostInst will always return TCC_Free.; //; // If the cost is more than TCC_BASIC, then the integer constant can't be folded; // into the instruction and it might be beneficial to hoist the constant.; // Similar constants are coalesced to reduce register pressure and; // materialization code.; //; // When a constant is hoisted, it is also hidden behind a bitcast to force it to; // be live-out of the basic block. Otherwise the constant would be just; // duplicated and each basic block would have its own copy in the SelectionDAG.; // The SelectionDAG recognizes such constants as opaque and doesn't perform; // certain transformations on them, which would create a new expensive constant.; //; // This optimization is only applied to integer constants in instructions and; // simple (this means not nested) constant cast expressions. For example:; // %0 = load i64* inttoptr (i64 big_constant to i64*); //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:1656,Performance,optimiz,optimization,1656,"//===- ConstantHoisting.cpp - Prepare code for expensive constants --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies expensive constants to hoist and coalesces them to; // better prepare it for SelectionDAG-based code generation. This works around; // the limitations of the basic-block-at-a-time approach.; //; // First it scans all instructions for integer constants and calculates its; // cost. If the constant can be folded into the instruction (the cost is; // TCC_Free) or the cost is just a simple operation (TCC_BASIC), then we don't; // consider it expensive and leave it alone. This is the default behavior and; // the default implementation of getIntImmCostInst will always return TCC_Free.; //; // If the cost is more than TCC_BASIC, then the integer constant can't be folded; // into the instruction and it might be beneficial to hoist the constant.; // Similar constants are coalesced to reduce register pressure and; // materialization code.; //; // When a constant is hoisted, it is also hidden behind a bitcast to force it to; // be live-out of the basic block. Otherwise the constant would be just; // duplicated and each basic block would have its own copy in the SelectionDAG.; // The SelectionDAG recognizes such constants as opaque and doesn't perform; // certain transformations on them, which would create a new expensive constant.; //; // This optimization is only applied to integer constants in instructions and; // simple (this means not nested) constant cast expressions. For example:; // %0 = load i64* inttoptr (i64 big_constant to i64*); //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:1810,Performance,load,load,1810,"//===- ConstantHoisting.cpp - Prepare code for expensive constants --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies expensive constants to hoist and coalesces them to; // better prepare it for SelectionDAG-based code generation. This works around; // the limitations of the basic-block-at-a-time approach.; //; // First it scans all instructions for integer constants and calculates its; // cost. If the constant can be folded into the instruction (the cost is; // TCC_Free) or the cost is just a simple operation (TCC_BASIC), then we don't; // consider it expensive and leave it alone. This is the default behavior and; // the default implementation of getIntImmCostInst will always return TCC_Free.; //; // If the cost is more than TCC_BASIC, then the integer constant can't be folded; // into the instruction and it might be beneficial to hoist the constant.; // Similar constants are coalesced to reduce register pressure and; // materialization code.; //; // When a constant is hoisted, it is also hidden behind a bitcast to force it to; // be live-out of the basic block. Otherwise the constant would be just; // duplicated and each basic block would have its own copy in the SelectionDAG.; // The SelectionDAG recognizes such constants as opaque and doesn't perform; // certain transformations on them, which would create a new expensive constant.; //; // This optimization is only applied to integer constants in instructions and; // simple (this means not nested) constant cast expressions. For example:; // %0 = load i64* inttoptr (i64 big_constant to i64*); //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:785,Usability,simpl,simple,785,"//===- ConstantHoisting.cpp - Prepare code for expensive constants --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies expensive constants to hoist and coalesces them to; // better prepare it for SelectionDAG-based code generation. This works around; // the limitations of the basic-block-at-a-time approach.; //; // First it scans all instructions for integer constants and calculates its; // cost. If the constant can be folded into the instruction (the cost is; // TCC_Free) or the cost is just a simple operation (TCC_BASIC), then we don't; // consider it expensive and leave it alone. This is the default behavior and; // the default implementation of getIntImmCostInst will always return TCC_Free.; //; // If the cost is more than TCC_BASIC, then the integer constant can't be folded; // into the instruction and it might be beneficial to hoist the constant.; // Similar constants are coalesced to reduce register pressure and; // materialization code.; //; // When a constant is hoisted, it is also hidden behind a bitcast to force it to; // be live-out of the basic block. Otherwise the constant would be just; // duplicated and each basic block would have its own copy in the SelectionDAG.; // The SelectionDAG recognizes such constants as opaque and doesn't perform; // certain transformations on them, which would create a new expensive constant.; //; // This optimization is only applied to integer constants in instructions and; // simple (this means not nested) constant cast expressions. For example:; // %0 = load i64* inttoptr (i64 big_constant to i64*); //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:1730,Usability,simpl,simple,1730,"//===- ConstantHoisting.cpp - Prepare code for expensive constants --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies expensive constants to hoist and coalesces them to; // better prepare it for SelectionDAG-based code generation. This works around; // the limitations of the basic-block-at-a-time approach.; //; // First it scans all instructions for integer constants and calculates its; // cost. If the constant can be folded into the instruction (the cost is; // TCC_Free) or the cost is just a simple operation (TCC_BASIC), then we don't; // consider it expensive and leave it alone. This is the default behavior and; // the default implementation of getIntImmCostInst will always return TCC_Free.; //; // If the cost is more than TCC_BASIC, then the integer constant can't be folded; // into the instruction and it might be beneficial to hoist the constant.; // Similar constants are coalesced to reduce register pressure and; // materialization code.; //; // When a constant is hoisted, it is also hidden behind a bitcast to force it to; // be live-out of the basic block. Otherwise the constant would be just; // duplicated and each basic block would have its own copy in the SelectionDAG.; // The SelectionDAG recognizes such constants as opaque and doesn't perform; // certain transformations on them, which would create a new expensive constant.; //; // This optimization is only applied to integer constants in instructions and; // simple (this means not nested) constant cast expressions. For example:; // %0 = load i64* inttoptr (i64 big_constant to i64*); //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:4,Performance,Perform,Perform,4,/// Perform the constant hoisting optimization for the given function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:34,Performance,optimiz,optimization,34,/// Perform the constant hoisting optimization for the given function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:7,Usability,simpl,simple,7,// The simple and common case. This also includes constant expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:39,Availability,down,down,39,// Sort the nodes in Candidates in top-down order and save the nodes; // in Orders.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:84,Deployability,update,update,84,"// Initially, ParentInsertPts is empty and ParentPtsFreq is 0. Every child; // will update its parent's ParentInsertPts and ParentPtsFreq.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:299,Energy Efficiency,reduce,reduce,299,"// Choose to insert in Node or in subtree of Node.; // Don't hoist to EHPad because we may not find a proper place to insert; // in EHPad.; // If the total frequency of InsertPts is the same as the frequency of the; // target Node, and InsertPts contains more than one nodes, choose hoisting; // to reduce code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:99,Performance,load,load,99,"// A constant GEP expression that has a GlobalVariable as base pointer is; // usually lowered to a load from constant pool. Such operation is unlikely; // to be cheaper than compute it by <Base + Offset>, which can be lowered to; // an ADD instruction or folded into Load/Store instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:267,Performance,Load,Load,267,"// A constant GEP expression that has a GlobalVariable as base pointer is; // usually lowered to a load from constant pool. Such operation is unlikely; // to be cheaper than compute it by <Base + Offset>, which can be lowered to; // an ADD instruction or folded into Load/Store instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:147,Modifiability,variab,variables,147,// The cost of materializing the constants (defined in; // `TargetTransformInfo::getIntImmCostInst`) for instructions which only; // take constant variables is lower than `TargetTransformInfo::TCC_Basic`.; // So it's safe for us to collect constant candidates from all; // IntrinsicInsts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:217,Safety,safe,safe,217,// The cost of materializing the constants (defined in; // `TargetTransformInfo::getIntImmCostInst`) for instructions which only; // take constant variables is lower than `TargetTransformInfo::TCC_Basic`.; // So it's safe for us to collect constant candidates from all; // IntrinsicInsts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:3,Usability,Simpl,Simple,3,// Simple linear scan through the sorted constant candidate vector for viable; // merge candidates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:4,Deployability,Update,Updates,4,"/// Updates the operand at Idx in instruction Inst with the result of; /// instruction Mat. If the instruction is a PHI node then special; /// handling for duplicate values from the same incoming basic block is; /// required.; /// \return The update will always succeed, but the return value indicated if; /// Mat was used for the update or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:243,Deployability,update,update,243,"/// Updates the operand at Idx in instruction Inst with the result of; /// instruction Mat. If the instruction is a PHI node then special; /// handling for duplicate values from the same incoming basic block is; /// required.; /// \return The update will always succeed, but the return value indicated if; /// Mat was used for the update or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:331,Deployability,update,update,331,"/// Updates the operand at Idx in instruction Inst with the result of; /// instruction Mat. If the instruction is a PHI node then special; /// handling for duplicate values from the same incoming basic block is; /// required.; /// \return The update will always succeed, but the return value indicated if; /// Mat was used for the update or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:354,Modifiability,variab,variable,354,"// Check if any previous operand of the PHI node has the same incoming basic; // block. This is a very odd case that happens when the incoming basic block; // has a switch statement. In this case use the same value as the previous; // operand(s), otherwise we will fail verification due to different values.; // The values are actually the same, but the variable names are different; // and the verifier doesn't like that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:60,Deployability,update,update,60,/// Emit materialization code for all rebased constants and update their; /// users.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:68,Safety,avoid,avoid,68,// Check if we already have visited this cast instruction before to avoid; // unnecessary cloning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:66,Deployability,update,update,66,// Use the same debug location as the instruction we are about to update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:28,Integrability,depend,depending,28,"// First, collect constants depending on this IP of the base.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:25,Integrability,depend,depend,25,"// If only few constants depend on this IP of base, skip rebasing,; // assuming the base and the rebased have the same materialization cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:51,Integrability,depend,depending,51,// Emit materialization code for rebased constants depending on this IP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:4,Performance,Optimiz,Optimize,4,/// Optimize expensive integer constants in the given function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:69,Integrability,depend,dependent,69,// Finally hoist the base constant and emit materialization code for dependent; // constants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:163,Usability,simpl,simplify,163,/// Represents either; /// * a condition that holds on entry to a block (=condition fact); /// * an assume (=assume fact); /// * a use of a compare instruction to simplify.; /// It also tracks the Dominator DFS in and out numbers for each entry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:22,Usability,simpl,simplify,22,/// An instruction to simplify (e.g. an overflow math; /// intrinsics).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:39,Usability,simpl,simplify,39,/// An use of a compare instruction to simplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:25,Usability,simpl,simplified,25,// The use may have been simplified to a constant already.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:4,Modifiability,Variab,Variables,4,/// Variables that can be removed from the system once the stack entry gets; /// removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:4,Integrability,Wrap,Wrapper,4,"/// Wrapper encapsulating separate constraint systems and corresponding value; /// mappings for both unsigned and signed information. Facts are added to and; /// conditions are checked against the corresponding system depending on the; /// signed-ness of their predicates. While the information is kept separate; /// based on signed-ness, certain conditions can be transferred between the two; /// systems.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:218,Integrability,depend,depending,218,"/// Wrapper encapsulating separate constraint systems and corresponding value; /// mappings for both unsigned and signed information. Facts are added to and; /// conditions are checked against the corresponding system depending on the; /// signed-ness of their predicates. While the information is kept separate; /// based on signed-ness, certain conditions can be transferred between the two; /// systems.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:156,Modifiability,variab,variables,156,"/// Turn a comparison of the form \p Op0 \p Pred \p Op1 into a vector of; /// constraints, using indices from the corresponding constraint system.; /// New variables that need to be added to the system are collected in; /// \p NewVariables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:261,Modifiability,variab,variables,261,"/// Turns a comparison of the form \p Op0 \p Pred \p Op1 into a vector of; /// constraints using getConstraint. Returns an empty constraint if the result; /// cannot be used to query the existing constraint system, e.g. because it; /// would require adding new variables. Also tries to convert signed; /// predicates to unsigned ones if possible to allow using the unsigned system; /// which increases the effectiveness of the signed <-> unsigned transfer; /// logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:461,Testability,log,logic,461,"/// Turns a comparison of the form \p Op0 \p Pred \p Op1 into a vector of; /// constraints using getConstraint. Returns an empty constraint if the result; /// cannot be used to query the existing constraint system, e.g. because it; /// would require adding new variables. Also tries to convert signed; /// predicates to unsigned ones if possible to allow using the unsigned system; /// which increases the effectiveness of the signed <-> unsigned transfer; /// logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:32,Modifiability,Variab,Variable,32,/// Represents a (Coefficient * Variable) entry after IR decomposition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:16,Modifiability,variab,variable,16,/// True if the variable is known positive in the current constraint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:3,Modifiability,Variab,Variable,3,"// Variable and constant offsets for a chain of GEPs, with base pointer BasePtr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:32,Modifiability,variab,variable,32,"// namespace; // Try to collect variable and constant offsets for \p GEP, partly traversing; // nested GEPs. Returns an OffsetResult with nullptr as BasePtr of collecting; // the offset fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:40,Modifiability,variab,variable,40,// TODO: Support cases with more than 1 variable offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:15,Modifiability,variab,variable,15,"// More than 1 variable index, use outer result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:77,Modifiability,Variab,Variable,77,"// Decomposes \p V into a constant offset + list of pairs { Coefficient,; // Variable } where Coefficient * Variable. The sum of the constant offset and; // pairs equals \p V.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:108,Modifiability,Variab,Variable,108,"// Decomposes \p V into a constant offset + list of pairs { Coefficient,; // Variable } where Coefficient * Variable. The sum of the constant offset and; // pairs equals \p V.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:101,Integrability,wrap,wrap,101,"// Don't handle integers > 64 bit. Our coefficients are 64-bit large, so; // coefficient add/mul may wrap, while the operation in the full bit width; // would not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:17,Modifiability,variab,variables,17,// Make sure all variables have entries in Value2Index or NewVariables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:11,Modifiability,variab,variables,11,// Collect variables that are known to be positive in all uses in the; // constraint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:28,Modifiability,Variab,Variable,28,"// Remove any (Coefficient, Variable) entry where the Coefficient is 0 for new; // variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:83,Modifiability,variab,variables,83,"// Remove any (Coefficient, Variable) entry where the Coefficient is 0 for new; // variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:29,Modifiability,variab,variables,29,// Add extra constraints for variables that are known positive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:91,Modifiability,variab,variables,91,// Handle trivially true compares directly to avoid adding V UGE 0 constraints; // for all variables in the unsigned system.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:46,Safety,avoid,avoid,46,// Handle trivially true compares directly to avoid adding V UGE 0 constraints; // for all variables in the unsigned system.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:197,Testability,log,logic,197,"// If both operands are known to be non-negative, change signed predicates to; // unsigned ones. This increases the reasoning effectiveness in combination; // with the signed <-> unsigned transfer logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:25,Integrability,depend,depends,25,// FIXME: This currently depends on the order we add facts. Ideally we; // would first add all known facts and only then try to add additional; // facts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:39,Integrability,wrap,wrap,39,"// If SCEV guarantees that AR does not wrap, PN >= StartValue can be added; // unconditionally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:9,Modifiability,Extend,Extend,9,// TODO: Extend to allow steps > -1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:10,Integrability,wrap,wrap,10,// AR may wrap.; // Add StartValue >= PN conditional on B <= StartValue which guarantees that; // the loop exits before wrapping with a step of -1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:120,Integrability,wrap,wrapping,120,// AR may wrap.; // Add StartValue >= PN conditional on B <= StartValue which guarantees that; // the loop exits before wrapping with a step of -1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:10,Integrability,wrap,wrap,10,// AR may wrap. Add PN >= StartValue conditional on StartValue <= B which; // guarantees that the loop exits before wrapping in combination with the; // restrictions on B and the step above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:116,Integrability,wrap,wrapping,116,// AR may wrap. Add PN >= StartValue conditional on StartValue <= B which; // guarantees that the loop exits before wrapping in combination with the; // restrictions on B and the step above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:3,Performance,Queue,Queue,3,// Queue conditions and assumes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:34,Usability,simpl,simplification,34,// Enqueue ssub_with_overflow for simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:82,Usability,simpl,simplifying,82,// TODO: Check if it is possible to instead only added the min/max facts; // when simplifying uses of the min/max intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:107,Performance,queue,queue,107,"// If the condition is a chain of ORs/AND and the successor only has the; // current block as predecessor, queue conditions for the successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:72,Usability,simpl,simplifying,72,"// namespace; /// Helper function to generate a reproducer function for simplifying \p Cond.; /// The reproducer function contains a series of @llvm.assume calls, one for; /// each condition in \p Stack. For each condition, the operand instruction are; /// cloned until we reach operands that have an entry in \p Value2Index. Those; /// will then be added as function arguments. \p DT is used to order cloned; /// instructions. The reproducer function will get added to \p M, if it is; /// non-null. Otherwise no reproducer function is generated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:142,Deployability,Update,Update,142,"// Clone instructions in \p Ops and their operands recursively until reaching; // an value in Value2Index (external input to the reproducer). Update Old2New; // mapping for the original and cloned instructions. Sort instructions to; // clone by dominance, then insert the cloned instructions in the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:344,Testability,assert,assert,344,"// Materialize the assumptions for the reproducer using the entries in Stack.; // That is, first clone the operands of the condition recursively until we; // reach an external input to the reproducer and add them to the reproducer; // function. Then add an ICmp for the condition (with the inverse predicate if; // the entry is negated) and an assert using the ICmp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:104,Availability,avail,available,104,// Conditions in an assume trivially simplify to true. Skip uses; // in assume calls to not destroy the available information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:37,Usability,simpl,simplify,37,// Conditions in an assume trivially simplify to true. Skip uses; // in assume calls to not destroy the available information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:10,Modifiability,variab,variables,10,// Remove variables in the system that went out of scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:16,Usability,simpl,simplify,16,"// Don't try to simplify the first condition of a select by the second, as; // this may make the select more poisonous than the original one.; // TODO: check if the first operand may be poison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:40,Usability,simpl,simplified,40,// Check if the second condition can be simplified now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:50,Modifiability,variab,variables,50,"// If R has been added to the system, add the new variables and queue it for; // removal once it goes out-of-scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:64,Performance,queue,queue,64,"// If R has been added to the system, add the new variables and queue it for; // removal once it goes out-of-scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:86,Usability,simpl,simplified,86,"// If A s>= B && B s>= 0, ssub.with.overflow(a, b) should not overflow and; // can be simplified to a regular sub.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:536,Testability,log,logic,536,"// Next, sort worklist by dominance, so that dominating conditions to check; // and facts come before conditions and facts dominated by them. If a; // condition to check and a fact have the same numbers, conditional facts come; // first. Assume facts and checks are ordered according to their relative; // order in the containing basic block. Also make sure conditions with; // constant operands come before conditions without constant operands. This; // increases the effectiveness of the current signed <-> unsigned fact; // transfer logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:11,Usability,simpl,simplify,11,"/// Try to simplify a phi with constant incoming values that match the edge; /// values of a non-constant value on all other edges:; /// bb0:; /// %isnull = icmp eq i8* %x, null; /// br i1 %isnull, label %bb2, label %bb1; /// bb1:; /// br label %bb2; /// bb2:; /// %r = phi i8* [ %x, %bb1 ], [ null, %bb0 ]; /// -->; /// %r = %x",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:32,Modifiability,variab,variable,32,// We have a phi with exactly 1 variable incoming value and 1 or more constant; // incoming values. See if all constant incoming values can be mapped back to; // the same incoming variable value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:180,Modifiability,variab,variable,180,// We have a phi with exactly 1 variable incoming value and 1 or more constant; // incoming values. See if all constant incoming values can be mapped back to; // the same incoming variable value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:48,Modifiability,variab,variable,48,// All constant incoming values map to the same variable along the incoming; // edges of the phi. The phi is unnecessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:12,Usability,learn,learns,12,"// Once LVI learns to handle vector types, we could also add support; // for vector type constants that are not all zeroes or all ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:289,Availability,avail,available,289,"/// Simplify a switch instruction by removing cases which can never fire. If the; /// uselessness of a case could be determined locally then constant propagation; /// would already have figured it out. Instead, walk the predecessors and; /// statically evaluate cases based on information available on that edge. Cases; /// that cannot fire no matter what the incoming edge can safely be removed. If; /// a case fires on every incoming edge then the entire switch can be removed; /// and replaced with a branch to the case destination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:378,Safety,safe,safely,378,"/// Simplify a switch instruction by removing cases which can never fire. If the; /// uselessness of a case could be determined locally then constant propagation; /// would already have figured it out. Instead, walk the predecessors and; /// statically evaluate cases based on information available on that edge. Cases; /// that cannot fire no matter what the incoming edge can safely be removed. If; /// a case fires on every incoming edge then the entire switch can be removed; /// and replaced with a branch to the case destination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:4,Usability,Simpl,Simplify,4,"/// Simplify a switch instruction by removing cases which can never fire. If the; /// uselessness of a case could be determined locally then constant propagation; /// would already have figured it out. Instead, walk the predecessors and; /// statically evaluate cases based on information available on that edge. Cases; /// that cannot fire no matter what the incoming edge can safely be removed. If; /// a case fires on every incoming edge then the entire switch can be removed; /// and replaced with a branch to the case destination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:79,Testability,log,logic,79,// The condition can be modified by removePredecessor's PHI simplification; // logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:60,Usability,simpl,simplification,60,// The condition can be modified by removePredecessor's PHI simplification; // logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:26,Usability,simpl,simplified,26,// If the switch has been simplified to the point where it can be replaced; // by a branch then do so now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:61,Usability,simpl,simplify,61,"// See if @llvm.abs argument is alays positive/negative, and simplify.; // Notably, INT_MIN can belong to either range, regardless of the NSW,; // because it is negation-invariant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:31,Integrability,wrap,wrap,31,// See if we can infer some no-wrap flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite this with.overflow intrinsic as non-overflowing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:36,Integrability,wrap,wrap,36,// See if we can infer the other no-wrap too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:36,Integrability,wrap,wrap,36,// See if we can infer the other no-wrap too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:253,Performance,optimiz,optimization,253,"// Deopt bundle operands are intended to capture state with minimal; // perturbance of the code otherwise. If we can find a constant value for; // any such operand and remove a use of the original value, that's; // desireable since it may allow further optimization of that value (e.g. via; // single use rules in instcombine). Since deopt uses tend to,; // idiomatically, appear along rare conditional paths, it's reasonable likely; // we may have a conditional fact with which LVI can fold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:38,Availability,down,down,38,/// Try to shrink a sdiv/srem's width down to the smallest power of two that's; /// sufficient to contain its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:59,Energy Efficiency,power,power,59,/// Try to shrink a sdiv/srem's width down to the smallest power of two that's; /// sufficient to contain its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:21,Energy Efficiency,power,power,21,// Find the smallest power of two bitwidth that's sufficient to hold Instr's; // operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:66,Energy Efficiency,power,power,66,// NewWidth might be greater than OrigWidth if OrigWidth is not a power of; // two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:470,Modifiability,rewrite,rewrite,470,"// Given; // R = X u% Y; // We can represent the modulo operation as a loop/self-recursion:; // urem_rec(X, Y):; // Z = X - Y; // if X u< Y; // ret X; // else; // ret urem_rec(Z, Y); // which isn't better, but if we only need a single iteration; // to compute the answer, this becomes quite good:; // R = X < Y ? X : X - Y iff X u< 2*Y (w/ unsigned saturation); // Now, we do not care about all full multiples of Y in X, they do not change; // the answer, thus we could rewrite the expression as:; // X* = X - (Y * |_ X / Y _|); // R = X* % Y; // so we don't need the *first* iteration to return, we just need to; // know *which* iteration will always return, so we could also rewrite it as:; // X* = X - (Y * |_ X / Y _|); // R = X* % Y iff X* u< 2*Y (w/ unsigned saturation); // but that does not seem profitable here.; // Even if we don't know X's range, the divisor may be so large, X can't ever; // be 2x larger than that. I.e. if divisor is always negative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:677,Modifiability,rewrite,rewrite,677,"// Given; // R = X u% Y; // We can represent the modulo operation as a loop/self-recursion:; // urem_rec(X, Y):; // Z = X - Y; // if X u< Y; // ret X; // else; // ret urem_rec(Z, Y); // which isn't better, but if we only need a single iteration; // to compute the answer, this becomes quite good:; // R = X < Y ? X : X - Y iff X u< 2*Y (w/ unsigned saturation); // Now, we do not care about all full multiples of Y in X, they do not change; // the answer, thus we could rewrite the expression as:; // X* = X - (Y * |_ X / Y _|); // R = X* % Y; // so we don't need the *first* iteration to return, we just need to; // know *which* iteration will always return, so we could also rewrite it as:; // X* = X - (Y * |_ X / Y _|); // R = X* % Y iff X* u< 2*Y (w/ unsigned saturation); // but that does not seem profitable here.; // Even if we don't know X's range, the divisor may be so large, X can't ever; // be 2x larger than that. I.e. if divisor is always negative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:38,Availability,down,down,38,/// Try to shrink a udiv/urem's width down to the smallest power of two that's; /// sufficient to contain its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:59,Energy Efficiency,power,power,59,/// Try to shrink a udiv/urem's width down to the smallest power of two that's; /// sufficient to contain its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:21,Energy Efficiency,power,power,21,// Find the smallest power of two bitwidth that's sufficient to hold Instr's; // operands.; // What is the smallest bit width that can accommodate the entire value ranges; // of both of the operands?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:66,Energy Efficiency,power,power,66,// NewWidth might be greater than OrigWidth if OrigWidth is not a power of; // two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:10,Usability,simpl,simplify,10,// Try to simplify our new urem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:10,Usability,simpl,simplify,10,// Try to simplify our new udiv.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:62,Usability,simpl,simplify,62,// Visiting in a pre-order depth-first traversal causes us to simplify early; // blocks before querying later blocks (which require us to analyze early; // blocks). Eagerly simplifying shallow blocks means there is strictly less; // work to do for deep blocks. This also means we don't visit unreachable; // blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:173,Usability,simpl,simplifying,173,// Visiting in a pre-order depth-first traversal causes us to simplify early; // blocks before querying later blocks (which require us to analyze early; // blocks). Eagerly simplifying shallow blocks means there is strictly less; // work to do for deep blocks. This also means we don't visit unreachable; // blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:104,Testability,test,tests,104,"// Try to determine the return value if we can. This is mainly here to; // simplify the writing of unit tests, but also helps to enable IPO by; // constant folding the return values of callees.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:75,Usability,simpl,simplify,75,"// Try to determine the return value if we can. This is mainly here to; // simplify the writing of unit tests, but also helps to enable IPO by; // constant folding the return values of callees.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:15,Availability,alive,alive,15,"// Keeping LVI alive is expensive, both because it uses a lot of memory, and; // because invalidating values in LVI is expensive. While CVP does preserve; // LVI, we know that passes after JumpThreading+CVP will not need the result; // of this analysis, so we forcefully discard it early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DCE.cpp:25,Performance,perform,perform,25,"//===- DCE.cpp - Code to perform dead code elimination --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements dead inst elimination and dead code elimination.; //; // Dead Inst Elimination performs a single pass over the function removing; // instructions that are obviously dead. Dead Code Elimination is similar, but; // it rechecks instructions that were used by removed instructions to see if; // they are newly dead.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DCE.cpp:483,Performance,perform,performs,483,"//===- DCE.cpp - Code to perform dead code elimination --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements dead inst elimination and dead code elimination.; //; // Dead Inst Elimination performs a single pass over the function removing; // instructions that are obviously dead. Dead Code Elimination is similar, but; // it rechecks instructions that were used by removed instructions to see if; // they are newly dead.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DCE.cpp:121,Safety,avoid,avoids,121,"// Iterate over the original function, only adding insts to the worklist; // if they actually need to be revisited. This avoids having to pre-init; // the worklist with the entire function's worth of instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:149,Availability,down,downstream,149,"// This flags allows or disallows DSE to optimize MemorySSA during its; // traversal. Note that DSE optimizing MemorySSA may impact other passes; // downstream of the DSE invocation and can lead to issues not being; // reproducible in isolation (i.e. when MemorySSA is built from scratch). In; // those cases, the flag can be used to check if DSE's MemorySSA optimizations; // impact follow-up passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:41,Performance,optimiz,optimize,41,"// This flags allows or disallows DSE to optimize MemorySSA during its; // traversal. Note that DSE optimizing MemorySSA may impact other passes; // downstream of the DSE invocation and can lead to issues not being; // reproducible in isolation (i.e. when MemorySSA is built from scratch). In; // those cases, the flag can be used to check if DSE's MemorySSA optimizations; // impact follow-up passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:100,Performance,optimiz,optimizing,100,"// This flags allows or disallows DSE to optimize MemorySSA during its; // traversal. Note that DSE optimizing MemorySSA may impact other passes; // downstream of the DSE invocation and can lead to issues not being; // reproducible in isolation (i.e. when MemorySSA is built from scratch). In; // those cases, the flag can be used to check if DSE's MemorySSA optimizations; // impact follow-up passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:359,Performance,optimiz,optimizations,359,"// This flags allows or disallows DSE to optimize MemorySSA during its; // traversal. Note that DSE optimizing MemorySSA may impact other passes; // downstream of the DSE invocation and can lead to issues not being; // reproducible in isolation (i.e. when MemorySSA is built from scratch). In; // those cases, the flag can be used to check if DSE's MemorySSA optimizations; // impact follow-up passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:55,Safety,safe,safely,55,/// Returns true if the end of this instruction can be safely shortened in; /// length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:69,Safety,safe,safe,69,// Do shorten memory intrinsics.; // FIXME: Add memmove if it's also safe to transform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:61,Safety,safe,safely,61,/// Returns true if the beginning of this instruction can be safely shortened; /// in length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:61,Availability,mask,masked,61,"// end anonymous namespace; /// Check if two instruction are masked stores that completely; /// overwrite one another. More specifically, \p KillingI has to; /// overwrite \p DeadI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:3,Availability,Mask,Masks,3,// Masks.; // TODO: check that KillingII's mask is a superset of the DeadII's mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:43,Availability,mask,mask,43,// Masks.; // TODO: check that KillingII's mask is a superset of the DeadII's mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:78,Availability,mask,mask,78,// Masks.; // TODO: check that KillingII's mask is a superset of the DeadII's mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:212,Integrability,depend,depends,212,"// We may now overlap, although the overlap is not complete. There might also; // be other incomplete overlaps, and together, they might cover the complete; // dead store.; // Note: The correctness of this logic depends on the fact that this function; // is not even called providing DepWrite when there are any intervening reads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:206,Testability,log,logic,206,"// We may now overlap, although the overlap is not complete. There might also; // be other incomplete overlaps, and together, they might cover the complete; // dead store.; // Note: The correctness of this logic depends on the fact that this function; // is not even called providing DepWrite when there are any intervening reads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:200,Safety,avoid,avoid,200,// Another interesting case is if the killing store overwrites the end of the; // dead store.; //; // |--dead--|; // |-- killing --|; //; // In this case we may want to trim the size of dead store to avoid; // generating stores to addresses which will definitely be overwritten killing; // store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:246,Safety,avoid,avoid,246,"// Finally, we also need to check if the killing store overwrites the; // beginning of the dead store.; //; // |--dead--|; // |-- killing --|; //; // In this case we may want to move the destination address and trim the size; // of dead store to avoid generating stores to addresses which will definitely; // be overwritten killing store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:40,Security,access,accessed,40,/// Returns true if the memory which is accessed by the second instruction is not; /// modified between the first and the second instruction.; /// Precondition: Second instruction must be dominated by the first; /// instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:126,Security,access,accessed,126,// Do a backwards scan through the CFG from SecondI to FirstI. Look for; // instructions which can modify the memory location accessed by SecondI.; //; // While doing the walk keep track of the address to check. It might be; // different in different basic blocks due to PHI translation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:278,Energy Efficiency,reduce,reduce,278,"// We assume that memet/memcpy operates in chunks of the ""largest"" native; // type size and aligned on the same value. That means optimal start and size; // of memset/memcpy should be modulo of preferred alignment of that type. That; // is it there is no any sense in trying to reduce store size any further; // since any ""extra"" stores comes for free anyway.; // On the other hand, maximum alignment we can achieve is limited by alignment; // of initial store.; // TODO: Limit maximum alignment by preferred (or abi?) alignment of the; // ""largest"" native type.; // Note: What is the proper way to get that value?; // Should TargetTransformInfo::getRegisterBitWidth be used or anything else?; // PrefAlign = std::min(DL.getPrefTypeAlign(LargestType), PrefAlign);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:3,Deployability,Update,Update,3,// Update attached dbg.assign intrinsics. Assume 8-bit byte.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:11,Deployability,update,update,11,// Finally update start and size of dead access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:41,Security,access,access,41,// Finally update start and size of dead access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:3,Usability,Clear,Clear,3,"// Clear the bits we'll be replacing, then OR with the smaller; // store, shifted appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:19,Security,access,access,19,// Calls that only access inaccessible memory cannot read or write any memory; // locations we consider for elimination.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:82,Deployability,release,release,82,"// We can remove the dead stores, irrespective of the fence and its ordering; // (release/acquire/seq_cst). Fences only constraints the ordering of; // already visible stores, it does not make a store visible to other; // threads. So, skipping over a fence does not change a store from being; // dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:48,Performance,cache,cache,48,"/// The single BatchAA instance that is used to cache AA queries. It will; /// not be invalidated over the whole run. This is safe, because:; /// 1. Only memory writes are removed, so the alias cache for memory; /// locations remains valid.; /// 2. No new instructions are added (only instructions removed), so cached; /// information for a deleted value cannot be accessed by a re-used new; /// value pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:194,Performance,cache,cache,194,"/// The single BatchAA instance that is used to cache AA queries. It will; /// not be invalidated over the whole run. This is safe, because:; /// 1. Only memory writes are removed, so the alias cache for memory; /// locations remains valid.; /// 2. No new instructions are added (only instructions removed), so cached; /// information for a deleted value cannot be accessed by a re-used new; /// value pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:311,Performance,cache,cached,311,"/// The single BatchAA instance that is used to cache AA queries. It will; /// not be invalidated over the whole run. This is safe, because:; /// 1. Only memory writes are removed, so the alias cache for memory; /// locations remains valid.; /// 2. No new instructions are added (only instructions removed), so cached; /// information for a deleted value cannot be accessed by a re-used new; /// value pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:126,Safety,safe,safe,126,"/// The single BatchAA instance that is used to cache AA queries. It will; /// not be invalidated over the whole run. This is safe, because:; /// 1. Only memory writes are removed, so the alias cache for memory; /// locations remains valid.; /// 2. No new instructions are added (only instructions removed), so cached; /// information for a deleted value cannot be accessed by a re-used new; /// value pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:365,Security,access,accessed,365,"/// The single BatchAA instance that is used to cache AA queries. It will; /// not be invalidated over the whole run. This is safe, because:; /// 1. Only memory writes are removed, so the alias cache for memory; /// locations remains valid.; /// 2. No new instructions are added (only instructions removed), so cached; /// information for a deleted value cannot be accessed by a re-used new; /// value pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:103,Safety,detect,detect,103,"// Whether the function contains any irreducible control flow, useful for; // being accurately able to detect loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:77,Security,access,accesses,77,// Post-order numbers for each basic block. Used to figure out if memory; // accesses are executed before another access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:114,Security,access,access,114,// Post-order numbers for each basic block. Used to figure out if memory; // accesses are executed before another access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:253,Safety,abort,abort,253,"// Use the precise location size specified by the 3rd argument; // for determining KillingI overwrites DeadLoc if it is a memset_chk; // instruction. memset_chk will write either the amount specified as 3rd; // argument or the function will immediately abort and exit the program.; // NOTE: AA may determine NoAlias if it can prove that the access size; // is larger than the allocation size due to that being UB. To avoid; // returning potentially invalid NoAlias results by AA, limit the use of; // the precise location size to isOverwrite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:417,Safety,avoid,avoid,417,"// Use the precise location size specified by the 3rd argument; // for determining KillingI overwrites DeadLoc if it is a memset_chk; // instruction. memset_chk will write either the amount specified as 3rd; // argument or the function will immediately abort and exit the program.; // NOTE: AA may determine NoAlias if it can prove that the access size; // is larger than the allocation size due to that being UB. To avoid; // returning potentially invalid NoAlias results by AA, limit the use of; // the precise location size to isOverwrite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:341,Security,access,access,341,"// Use the precise location size specified by the 3rd argument; // for determining KillingI overwrites DeadLoc if it is a memset_chk; // instruction. memset_chk will write either the amount specified as 3rd; // argument or the function will immediately abort and exit the program.; // NOTE: AA may determine NoAlias if it can prove that the access size; // is larger than the allocation size due to that being UB. To avoid; // returning potentially invalid NoAlias results by AA, limit the use of; // the precise location size to isOverwrite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:82,Integrability,depend,dependencies,82,// AliasAnalysis does not always account for loops. Limit overwrite checks; // to dependencies for which we can guarantee they are independent of any; // loops they are in.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:3,Availability,Mask,Masked,3,"// Masked stores have imprecise locations, but we can reason about them; // to some extent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:39,Integrability,depend,depends,39,// Bail on doing Size comparison which depends on AA for now; // TODO: Remove AnyScalable once Alias Analysis deal with scalable vectors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:120,Performance,scalab,scalable,120,// Bail on doing Size comparison which depends on AA for now; // TODO: Remove AnyScalable once Alias Analysis deal with scalable vectors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:148,Security,access,access,148,// Non aliasing stores to different objects don't overlap. Note that; // if the killing store is known to overwrite whole object (out of; // bounds access overwrites whole object as well) then it is assumed to; // completely overwrite any store to the same object even if they don't; // actually alias (see next check).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:15,Security,access,access,15,"// The killing access completely overlaps the dead store if and only if; // both start and end of the dead one is ""inside"" the killing one:; // |<->|--dead--|<->|; // |-----killing------|; // Accesses may overlap if and only if start of one of them is ""inside""; // another one:; // |<->|--dead--|<-------->|; // |-------killing--------|; // OR; // |-------dead-------|; // |<->|---killing---|<----->|; //; // We have to be careful here as *Off is signed while *.Size is unsigned.; // Check if the dead access starts ""not before"" the killing one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:192,Security,Access,Accesses,192,"// The killing access completely overlaps the dead store if and only if; // both start and end of the dead one is ""inside"" the killing one:; // |<->|--dead--|<->|; // |-----killing------|; // Accesses may overlap if and only if start of one of them is ""inside""; // another one:; // |<->|--dead--|<-------->|; // |-------killing--------|; // OR; // |-------dead-------|; // |<->|---killing---|<----->|; //; // We have to be careful here as *Off is signed while *.Size is unsigned.; // Check if the dead access starts ""not before"" the killing one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:502,Security,access,access,502,"// The killing access completely overlaps the dead store if and only if; // both start and end of the dead one is ""inside"" the killing one:; // |<->|--dead--|<->|; // |-----killing------|; // Accesses may overlap if and only if start of one of them is ""inside""; // another one:; // |<->|--dead--|<-------->|; // |-------killing--------|; // OR; // |-------dead-------|; // |<->|---killing---|<----->|; //; // We have to be careful here as *Off is signed while *.Size is unsigned.; // Check if the dead access starts ""not before"" the killing one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:15,Security,access,access,15,"// If the dead access ends ""not after"" the killing access then the; // dead one is completely overwritten by the killing one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:51,Security,access,access,51,"// If the dead access ends ""not after"" the killing access then the; // dead one is completely overwritten by the killing one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:24,Security,access,access,24,"// If start of the dead access is ""before"" end of the killing access; // then accesses overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:62,Security,access,access,62,"// If start of the dead access is ""before"" end of the killing access; // then accesses overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:78,Security,access,accesses,78,"// If start of the dead access is ""before"" end of the killing access; // then accesses overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:27,Security,access,access,27,"// If start of the killing access is ""before"" end of the dead access then; // accesses overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:62,Security,access,access,62,"// If start of the killing access is ""before"" end of the dead access then; // accesses overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:78,Security,access,accesses,78,"// If start of the killing access is ""before"" end of the dead access then; // accesses overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:26,Security,access,accesses,26,// Can reach here only if accesses are known not to overlap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:249,Testability,test,test,249,// NOTE: This could be made more precise by PointerMayBeCapturedBefore; // with the killing MemoryDef. But we refrain from doing so for now to; // limit compile-time and this does not cause any changes to the number; // of stores removed on a large test set in practice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:126,Performance,load,load,126,"// UseInst has a MemoryDef associated in MemorySSA. It's possible for a; // MemoryDef to not write to memory, e.g. a volatile load is modeled as a; // MemoryDef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:92,Security,Access,AccessI,92,/// Returns true if \p MaybeTerm is a memory terminator for \p Loc from; /// instruction \p AccessI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:46,Security,access,accesses,46,"// If the terminator is a free-like call, all accesses to the underlying; // object can be considered terminated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:22,Integrability,depend,dependency,22,"/// Returns true if a dependency between \p Current and \p KillingDef is; /// guaranteed to be loop invariant for the loops that they are in. Either; /// because they are known to be in the same block, in the same loop level or; /// by guaranteeing that \p CurrentLoc only references a single MemoryLocation; /// during execution of the containing function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:10,Integrability,depend,dependency,10,"// If the dependency is within the same block or loop level (being careful; // of irreducible loops), we know that AA will return a valid result for the; // memory dependency. (Both at the function level, outside of any loop,; // would also be valid but we currently disable that to limit compile time).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:164,Integrability,depend,dependency,164,"// If the dependency is within the same block or loop level (being careful; // of irreducible loops), we know that AA will return a valid result for the; // memory dependency. (Both at the function level, outside of any loop,; // would also be valid but we currently disable that to limit compile time).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:93,Security,access,access,93,"// Find a MemoryDef writing to \p KillingLoc and dominating \p StartAccess,; // with no read access between them or on any other path to a function exit; // block if \p KillingLoc is not accessible after the function returns. If; // there is no such MemoryDef, return std::nullopt. The returned value may not; // (completely) overwrite \p KillingLoc. Currently we bail out when we; // encounter an aliasing MemoryUse (read).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:187,Security,access,accessible,187,"// Find a MemoryDef writing to \p KillingLoc and dominating \p StartAccess,; // with no read access between them or on any other path to a function exit; // block if \p KillingLoc is not accessible after the function returns. If; // there is no such MemoryDef, return std::nullopt. The returned value may not; // (completely) overwrite \p KillingLoc. Currently we bail out when we; // encounter an aliasing MemoryUse (read).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:8,Performance,optimiz,optimize,8,"// Only optimize defining access of KillingDef when directly starting at its; // defining access. The defining access also must only access KillingLoc. At; // the moment we only support instructions with a single write location, so; // it should be sufficient to disable optimizations for instructions that; // also read from memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:271,Performance,optimiz,optimizations,271,"// Only optimize defining access of KillingDef when directly starting at its; // defining access. The defining access also must only access KillingLoc. At; // the moment we only support instructions with a single write location, so; // it should be sufficient to disable optimizations for instructions that; // also read from memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:26,Security,access,access,26,"// Only optimize defining access of KillingDef when directly starting at its; // defining access. The defining access also must only access KillingLoc. At; // the moment we only support instructions with a single write location, so; // it should be sufficient to disable optimizations for instructions that; // also read from memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:90,Security,access,access,90,"// Only optimize defining access of KillingDef when directly starting at its; // defining access. The defining access also must only access KillingLoc. At; // the moment we only support instructions with a single write location, so; // it should be sufficient to disable optimizations for instructions that; // also read from memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:111,Security,access,access,111,"// Only optimize defining access of KillingDef when directly starting at its; // defining access. The defining access also must only access KillingLoc. At; // the moment we only support instructions with a single write location, so; // it should be sufficient to disable optimizations for instructions that; // also read from memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:133,Security,access,access,133,"// Only optimize defining access of KillingDef when directly starting at its; // defining access. The defining access also must only access KillingLoc. At; // the moment we only support instructions with a single write location, so; // it should be sufficient to disable optimizations for instructions that; // also read from memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:32,Security,access,access,32,"// Find the next clobbering Mod access for DefLoc, starting at StartAccess.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:19,Security,Access,Accesses,19,"// Cost of a step. Accesses in the same block are more likely to be valid; // candidates for elimination, hence consider them cheaper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:73,Performance,optimiz,optimized,73,// CurrentDef is the earliest write clobber of KillingDef. Use it as; // optimized access. Do not optimize if CurrentDef is already the; // defining access of KillingDef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:98,Performance,optimiz,optimize,98,// CurrentDef is the earliest write clobber of KillingDef. Use it as; // optimized access. Do not optimize if CurrentDef is already the; // defining access of KillingDef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:83,Security,access,access,83,// CurrentDef is the earliest write clobber of KillingDef. Use it as; // optimized access. Do not optimize if CurrentDef is already the; // defining access of KillingDef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:149,Security,access,access,149,// CurrentDef is the earliest write clobber of KillingDef. Use it as; // optimized access. Do not optimize if CurrentDef is already the; // defining access of KillingDef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:56,Performance,optimiz,optimized,56,// Once a may-aliasing def is encountered do not set an optimized; // access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:70,Security,access,access,70,// Once a may-aliasing def is encountered do not set an optimized; // access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:3,Security,Access,Accesses,3,// Accesses to objects accessible after the function returns can only be; // eliminated if the access is dead along all paths to the exit. Collect; // the blocks with killing (=completely overwriting MemoryDefs) and check if; // they cover all paths from MaybeDeadAccess to any function exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:23,Security,access,accessible,23,// Accesses to objects accessible after the function returns can only be; // eliminated if the access is dead along all paths to the exit. Collect; // the blocks with killing (=completely overwriting MemoryDefs) and check if; // they cover all paths from MaybeDeadAccess to any function exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:95,Security,access,access,95,// Accesses to objects accessible after the function returns can only be; // eliminated if the access is dead along all paths to the exit. Collect; // the blocks with killing (=completely overwriting MemoryDefs) and check if; // they cover all paths from MaybeDeadAccess to any function exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:29,Security,access,accesses,29,// Bail out if the number of accesses to check exceeds the scan limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:54,Security,access,access,54,// If this worklist walks back to the original memory access (and the; // pointer is not guarenteed loop invariant) then we cannot assume that a; // store kills itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:379,Performance,load,loads,379,"// Check all uses for MemoryDefs, except for defs completely overwriting; // the original location. Otherwise we have to check uses of *all*; // MemoryDefs we discover, including non-aliasing ones. Otherwise we might; // miss cases like the following; // 1 = Def(LoE) ; <----- DeadDef stores [0,1]; // 2 = Def(1) ; (2, 1) = NoAlias, stores [2,3]; // Use(2) ; MayAlias 2 *and* 1, loads [0, 3].; // (The Use points to the *first* Def it may alias); // 3 = Def(1) ; <---- Current (3, 2) = NoAlias, (3,1) = MayAlias,; // stores [0,1]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:7,Security,access,accesses,7,"// For accesses to locations visible after the function returns, make sure; // that the location is dead (=overwritten) along all paths from; // MaybeDeadAccess to the exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:274,Energy Efficiency,allocate,allocated,274,"// Remove memory defs directly if they don't produce results, but only; // queue other dead instructions for later removal. They may have been; // used as memory locations that have been cached by BatchAA. Removing; // them here may lead to newly created instructions to be allocated at the; // same address, yielding stale cache entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:75,Performance,queue,queue,75,"// Remove memory defs directly if they don't produce results, but only; // queue other dead instructions for later removal. They may have been; // used as memory locations that have been cached by BatchAA. Removing; // them here may lead to newly created instructions to be allocated at the; // same address, yielding stale cache entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:187,Performance,cache,cached,187,"// Remove memory defs directly if they don't produce results, but only; // queue other dead instructions for later removal. They may have been; // used as memory locations that have been cached by BatchAA. Removing; // them here may lead to newly created instructions to be allocated at the; // same address, yielding stale cache entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:324,Performance,cache,cache,324,"// Remove memory defs directly if they don't produce results, but only; // queue other dead instructions for later removal. They may have been; // used as memory locations that have been cached by BatchAA. Removing; // them here may lead to newly created instructions to be allocated at the; // same address, yielding stale cache entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:166,Security,access,accesses,166,// Check if \p DeadI acts as a DSE barrier for \p KillingI. The following; // instructions act as barriers:; // * A memory instruction that may throw and \p KillingI accesses a non-stack; // object.; // * Atomic stores stronger that monotonic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:25,Performance,load,load,25,"// If DeadI is an atomic load/store stronger than monotonic, do not try to; // eliminate/reorder it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:84,Security,access,accessed,84,/// Eliminate writes to objects that are not visible in the caller and are not; /// accessed before returning from the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:92,Performance,load,loaded,92,"/// \returns true if \p Def is a no-op store, either because it; /// directly stores back a loaded value or stores zero to a calloced object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:21,Security,access,access,21,"// If the clobbering access is LiveOnEntry, no instructions between them; // can modify the memory location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:35,Performance,load,load,35,// Get the defining access for the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:20,Security,access,access,20,// Get the defining access for the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:27,Security,access,accesses,27,// Fast path: the defining accesses are the same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:157,Performance,Load,LoadAccess,157,// Look through phi accesses. Recursively scan all phi accesses by; // adding them to a worklist. Bail when we run into a memory def that; // does not match LoadAccess.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:20,Security,access,accesses,20,// Look through phi accesses. Recursively scan all phi accesses by; // adding them to a worklist. Bail when we run into a memory def that; // does not match LoadAccess.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:55,Security,access,accesses,55,// Look through phi accesses. Recursively scan all phi accesses by; // adding them to a worklist. Bail when we run into a memory def that; // does not match LoadAccess.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:81,Security,access,access,81,"// We don't want to bail when we run into the store memory def. But,; // the phi access may point to it. So, pretend like we've already; // checked it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:177,Performance,load,load,177,"// TODO: Skip no alias MemoryDefs that have no aliasing reads.; // We are searching for the definition of the store's destination.; // So, if that is the same definition as the load, then this is a; // noop. Otherwise, fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:110,Performance,optimiz,optimized,110,"// To conserve compile-time, we avoid walking to the next clobbering def.; // Instead, we just try to get the optimized access, if it exists. DSE; // will try to optimize defs during the earlier traversal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:162,Performance,optimiz,optimize,162,"// To conserve compile-time, we avoid walking to the next clobbering def.; // Instead, we just try to get the optimized access, if it exists. DSE; // will try to optimize defs during the earlier traversal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:32,Safety,avoid,avoid,32,"// To conserve compile-time, we avoid walking to the next clobbering def.; // Instead, we just try to get the optimized access, if it exists. DSE; // will try to optimize defs during the earlier traversal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:120,Security,access,access,120,"// To conserve compile-time, we avoid walking to the next clobbering def.; // Instead, we just try to get the optimized access, if it exists. DSE; // will try to optimize defs during the earlier traversal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:3,Deployability,Update,Update,3,// Update stored value of earlier store to merged constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:81,Deployability,update,updated,81,// Remove killing store and remove any outstanding overlap; // intervals for the updated store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:1155,Modifiability,variab,variable,1155,"atement inside a loop ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Transform each threading path to effectively jump thread the DFA. For; // example, the CFG below could be transformed as follows, where the cloned; // blocks unconditionally branch to the next correct case based on what is; // identified in the analysis.; //; // sw.bb sw.bb; // / | \ / | \; // case1 case2 case3 case1 case2 case3; // \ | / | | |; // determinator det.2 det.3 det.1; // br sw.bb / | \; // sw.bb.2 sw.bb.3 sw.bb.1; // br case2 br case3 br case1; //; // Definitions and Terminology:; //; // * Threading path:; // a list of basic blocks, the exit state, and the block that determines; // the next state, for which the following notation will be used:; // < path of BBs that form a cycle > [ state, determinator ]; //; // * Predictable switch:; // The switch variable is always a known constant so that all conditional; // jumps based on switch variable can be converted to unconditional jump.; //; // * Determinator:; // The basic block that determines the next state of the DFA.; //; // Representing the optimization in C-like pseudocode: the code pattern on the; // left could functionally be transformed to the right pattern if the switch; // condition is predictable.; //; // X = A goto A; // for (...) A:; // switch (X) ...; // case A goto B; // X = B B:; // case B ...; // X = C goto C; //; // The pass first checks that switch variable X is decided by the control flow; // path taken in the loop; for example, in case B, the next value of X is; // decided to be C. It then enumerates through all paths in the loop and labels; // the basic blocks where the next state is decided.; //; // Using this information it creates new paths that unconditio",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:1241,Modifiability,variab,variable,1241,"atement inside a loop ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Transform each threading path to effectively jump thread the DFA. For; // example, the CFG below could be transformed as follows, where the cloned; // blocks unconditionally branch to the next correct case based on what is; // identified in the analysis.; //; // sw.bb sw.bb; // / | \ / | \; // case1 case2 case3 case1 case2 case3; // \ | / | | |; // determinator det.2 det.3 det.1; // br sw.bb / | \; // sw.bb.2 sw.bb.3 sw.bb.1; // br case2 br case3 br case1; //; // Definitions and Terminology:; //; // * Threading path:; // a list of basic blocks, the exit state, and the block that determines; // the next state, for which the following notation will be used:; // < path of BBs that form a cycle > [ state, determinator ]; //; // * Predictable switch:; // The switch variable is always a known constant so that all conditional; // jumps based on switch variable can be converted to unconditional jump.; //; // * Determinator:; // The basic block that determines the next state of the DFA.; //; // Representing the optimization in C-like pseudocode: the code pattern on the; // left could functionally be transformed to the right pattern if the switch; // condition is predictable.; //; // X = A goto A; // for (...) A:; // switch (X) ...; // case A goto B; // X = B B:; // case B ...; // X = C goto C; //; // The pass first checks that switch variable X is decided by the control flow; // path taken in the loop; for example, in case B, the next value of X is; // decided to be C. It then enumerates through all paths in the loop and labels; // the basic blocks where the next state is decided.; //; // Using this information it creates new paths that unconditio",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:1731,Modifiability,variab,variable,1731,"ption; //; //===----------------------------------------------------------------------===//; //; // Transform each threading path to effectively jump thread the DFA. For; // example, the CFG below could be transformed as follows, where the cloned; // blocks unconditionally branch to the next correct case based on what is; // identified in the analysis.; //; // sw.bb sw.bb; // / | \ / | \; // case1 case2 case3 case1 case2 case3; // \ | / | | |; // determinator det.2 det.3 det.1; // br sw.bb / | \; // sw.bb.2 sw.bb.3 sw.bb.1; // br case2 br case3 br case1; //; // Definitions and Terminology:; //; // * Threading path:; // a list of basic blocks, the exit state, and the block that determines; // the next state, for which the following notation will be used:; // < path of BBs that form a cycle > [ state, determinator ]; //; // * Predictable switch:; // The switch variable is always a known constant so that all conditional; // jumps based on switch variable can be converted to unconditional jump.; //; // * Determinator:; // The basic block that determines the next state of the DFA.; //; // Representing the optimization in C-like pseudocode: the code pattern on the; // left could functionally be transformed to the right pattern if the switch; // condition is predictable.; //; // X = A goto A; // for (...) A:; // switch (X) ...; // case A goto B; // X = B B:; // case B ...; // X = C goto C; //; // The pass first checks that switch variable X is decided by the control flow; // path taken in the loop; for example, in case B, the next value of X is; // decided to be C. It then enumerates through all paths in the loop and labels; // the basic blocks where the next state is decided.; //; // Using this information it creates new paths that unconditionally branch to; // the next case. This involves cloning code, so it only gets triggered if the; // amount of code duplicated is below a threshold.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:1402,Performance,optimiz,optimization,1402,"ption; //; //===----------------------------------------------------------------------===//; //; // Transform each threading path to effectively jump thread the DFA. For; // example, the CFG below could be transformed as follows, where the cloned; // blocks unconditionally branch to the next correct case based on what is; // identified in the analysis.; //; // sw.bb sw.bb; // / | \ / | \; // case1 case2 case3 case1 case2 case3; // \ | / | | |; // determinator det.2 det.3 det.1; // br sw.bb / | \; // sw.bb.2 sw.bb.3 sw.bb.1; // br case2 br case3 br case1; //; // Definitions and Terminology:; //; // * Threading path:; // a list of basic blocks, the exit state, and the block that determines; // the next state, for which the following notation will be used:; // < path of BBs that form a cycle > [ state, determinator ]; //; // * Predictable switch:; // The switch variable is always a known constant so that all conditional; // jumps based on switch variable can be converted to unconditional jump.; //; // * Determinator:; // The basic block that determines the next state of the DFA.; //; // Representing the optimization in C-like pseudocode: the code pattern on the; // left could functionally be transformed to the right pattern if the switch; // condition is predictable.; //; // X = A goto A; // for (...) A:; // switch (X) ...; // case A goto B; // X = B B:; // case B ...; // X = C goto C; //; // The pass first checks that switch variable X is decided by the control flow; // path taken in the loop; for example, in case B, the next value of X is; // decided to be C. It then enumerates through all paths in the loop and labels; // the basic blocks where the next state is decided.; //; // Using this information it creates new paths that unconditionally branch to; // the next case. This involves cloning code, so it only gets triggered if the; // amount of code duplicated is below a threshold.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:1120,Safety,Predict,Predictable,1120,"atement inside a loop ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Transform each threading path to effectively jump thread the DFA. For; // example, the CFG below could be transformed as follows, where the cloned; // blocks unconditionally branch to the next correct case based on what is; // identified in the analysis.; //; // sw.bb sw.bb; // / | \ / | \; // case1 case2 case3 case1 case2 case3; // \ | / | | |; // determinator det.2 det.3 det.1; // br sw.bb / | \; // sw.bb.2 sw.bb.3 sw.bb.1; // br case2 br case3 br case1; //; // Definitions and Terminology:; //; // * Threading path:; // a list of basic blocks, the exit state, and the block that determines; // the next state, for which the following notation will be used:; // < path of BBs that form a cycle > [ state, determinator ]; //; // * Predictable switch:; // The switch variable is always a known constant so that all conditional; // jumps based on switch variable can be converted to unconditional jump.; //; // * Determinator:; // The basic block that determines the next state of the DFA.; //; // Representing the optimization in C-like pseudocode: the code pattern on the; // left could functionally be transformed to the right pattern if the switch; // condition is predictable.; //; // X = A goto A; // for (...) A:; // switch (X) ...; // case A goto B; // X = B B:; // case B ...; // X = C goto C; //; // The pass first checks that switch variable X is decided by the control flow; // path taken in the loop; for example, in case B, the next value of X is; // decided to be C. It then enumerates through all paths in the loop and labels; // the basic blocks where the next state is decided.; //; // Using this information it creates new paths that unconditio",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:1556,Safety,predict,predictable,1556,"ption; //; //===----------------------------------------------------------------------===//; //; // Transform each threading path to effectively jump thread the DFA. For; // example, the CFG below could be transformed as follows, where the cloned; // blocks unconditionally branch to the next correct case based on what is; // identified in the analysis.; //; // sw.bb sw.bb; // / | \ / | \; // case1 case2 case3 case1 case2 case3; // \ | / | | |; // determinator det.2 det.3 det.1; // br sw.bb / | \; // sw.bb.2 sw.bb.3 sw.bb.1; // br case2 br case3 br case1; //; // Definitions and Terminology:; //; // * Threading path:; // a list of basic blocks, the exit state, and the block that determines; // the next state, for which the following notation will be used:; // < path of BBs that form a cycle > [ state, determinator ]; //; // * Predictable switch:; // The switch variable is always a known constant so that all conditional; // jumps based on switch variable can be converted to unconditional jump.; //; // * Determinator:; // The basic block that determines the next state of the DFA.; //; // Representing the optimization in C-like pseudocode: the code pattern on the; // left could functionally be transformed to the right pattern if the switch; // condition is predictable.; //; // X = A goto A; // for (...) A:; // switch (X) ...; // case A goto B; // X = B B:; // case B ...; // X = C goto C; //; // The pass first checks that switch variable X is decided by the control flow; // path taken in the loop; for example, in case B, the next value of X is; // decided to be C. It then enumerates through all paths in the loop and labels; // the basic blocks where the next state is decided.; //; // Using this information it creates new paths that unconditionally branch to; // the next case. This involves cloning code, so it only gets triggered if the; // amount of code duplicated is below a threshold.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:269,Performance,optimiz,optimizeSelectInst,269,/// Unfold the select instruction held in \p SIToUnfold by replacing it with; /// control flow.; ///; /// Put newly discovered select instructions into \p NewSIsToUnfold. Put newly; /// created basic blocks into \p NewBBs.; ///; /// TODO: merge it with CodeGenPrepare::optimizeSelectInst() if possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:3,Deployability,Update,Update,3,// Update the phi node of SI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:3,Deployability,Update,Update,3,// Update any other PHI nodes in EndBlock.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:3,Deployability,Update,Update,3,// Update the phi node of SI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:3,Deployability,Update,Update,3,// Update any other PHI nodes in EndBlock.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:157,Performance,cache,cached,157,// This block could now be visited again from a different predecessor. Note; // that this will result in exponential runtime. Subpaths could possibly be; // cached but it takes a lot of memory to store them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:18,Performance,perform,performs,18,"/// This function performs both a legality check and profitability check at; /// the same time since it is convenient to do so. It iterates through all; /// blocks that will be cloned, and keeps track of the duplication cost. It; /// also returns false if it is illegal to clone some required block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:3,Deployability,Update,Update,3,"// Update Metrics for the Switch block, this is always cloned",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:13,Deployability,update,update,13,"// Otherwise update Metrics for all blocks that will be cloned. If any; // block is already cloned and would be reused, don't double count it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:48,Energy Efficiency,reduce,reduced,48,"// Factor in the number of conditional branches reduced from jump; // threading. Assume that lowering the switch block is implemented by; // using binary search, hence the LogBase2().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:38,Performance,optimiz,optimizer,38,"// Compared with jump tables, the DFA optimizer removes an indirect branch; // on each loop iteration, thus making branch prediction more precise. The; // more branch targets there are, the more likely it is for the branch; // predictor to make a mistake, and the more benefit there is in the DFA; // optimizer. Thus, the more branch targets there are, the lower is the; // cost of the DFA opt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:301,Performance,optimiz,optimizer,301,"// Compared with jump tables, the DFA optimizer removes an indirect branch; // on each loop iteration, thus making branch prediction more precise. The; // more branch targets there are, the more likely it is for the branch; // predictor to make a mistake, and the more benefit there is in the DFA; // optimizer. Thus, the more branch targets there are, the lower is the; // cost of the DFA opt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:122,Safety,predict,prediction,122,"// Compared with jump tables, the DFA optimizer removes an indirect branch; // on each loop iteration, thus making branch prediction more precise. The; // more branch targets there are, the more likely it is for the branch; // predictor to make a mistake, and the more benefit there is in the DFA; // optimizer. Thus, the more branch targets there are, the lower is the; // cost of the DFA opt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:227,Safety,predict,predictor,227,"// Compared with jump tables, the DFA optimizer removes an indirect branch; // on each loop iteration, thus making branch prediction more precise. The; // more branch targets there are, the more likely it is for the branch; // predictor to make a mistake, and the more benefit there is in the DFA; // optimizer. Thus, the more branch targets there are, the lower is the; // cost of the DFA opt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:35,Deployability,update,update,35,"// After all paths are cloned, now update the last successor of the cloned; // path so it skips over the switch statement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:58,Deployability,update,update,58,"// For each instruction that was cloned and used outside, update its uses",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:219,Deployability,update,update,219,"/// For a specific ThreadingPath \p Path, create an exit path starting from; /// the determinator block.; ///; /// To remember the correct destination, we have to duplicate blocks; /// corresponding to each state. Also update the terminating instruction of; /// the predecessors, and phis in the successor blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:53,Deployability,update,update,53,"// We already cloned BB for this NextState, now just update the branch; // and continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:20,Deployability,update,update,20,// Clone the BB and update the successor of Prev to jump to the new block,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:133,Deployability,update,updated,133,"/// Restore SSA form after cloning blocks.; ///; /// Each cloned block creates new defs for a variable, and the uses need to be; /// updated to reflect this. The uses may be replaced with a cloned value, or; /// some derived phi instruction. Note that all uses of a value defined in the; /// same block were already remapped when cloning the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:94,Modifiability,variab,variable,94,"/// Restore SSA form after cloning blocks.; ///; /// Each cloned block creates new defs for a variable, and the uses need to be; /// updated to reflect this. The uses may be replaced with a cloned value, or; /// some derived phi instruction. Note that all uses of a value defined in the; /// same block were already remapped when cloning the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:4,Deployability,Update,Update,4,/// Update the phi nodes in BB's successors.; ///; /// This means creating a new incoming value from NewBB with the new; /// instruction wherever there is an incoming value from BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:54,Deployability,update,update,54,"// If BB is the last block in the path, we can simply update the one case; // successor that will be reached.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:47,Usability,simpl,simply,47,"// If BB is the last block in the path, we can simply update the one case; // successor that will be reached.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:13,Deployability,update,update,13,// Otherwise update phis in all successors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:179,Deployability,update,updated,179,"// Check if a successor has already been cloned for the particular exit; // value. In this case if a successor was already cloned, the phi nodes; // in the cloned block should be updated directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:79,Deployability,update,updated,79,"// When a path is reused, there is a chance that predecessors were already; // updated before. Check if the predecessor needs to be updated first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:132,Deployability,update,updated,132,"// When a path is reused, there is a chance that predecessors were already; // updated before. Check if the predecessor needs to be updated first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:4,Deployability,Update,Update,4,"/// Update the last branch of a particular cloned path to point to the correct; /// case successor.; ///; /// Note that this is an optional step and would have been done in later; /// optimizations, but it makes the CFG significantly easier to work with.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:184,Performance,optimiz,optimizations,184,"/// Update the last branch of a particular cloned path to point to the correct; /// case successor.; ///; /// Note that this is an optional step and would have been done in later; /// optimizations, but it makes the CFG significantly easier to work with.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:77,Deployability,update,updated,77,// Note multiple paths can end at the same block so check that it is not; // updated yet,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:33,Performance,optimiz,optimization,33,// For the time being limit this optimization to occurring once in a; // function since it can change the CFG significantly. This is not a; // strict requirement but it can cause buggy behavior if there is an; // overlap of blocks in different opportunities. There is a lot of room to; // experiment with catching more opportunities here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:32,Deployability,Integrat,Integrate,32,// end anonymous namespace; /// Integrate with the new Pass Manager,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:32,Integrability,Integrat,Integrate,32,// end anonymous namespace; /// Integrate with the new Pass Manager,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:11,Integrability,wrap,wrapper,11,/// A thin wrapper to store two values that we matched as div-rem pair.; /// We want this extra indirection to avoid dealing with RAUW'ing the map keys.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:111,Safety,avoid,avoid,111,/// A thin wrapper to store two values that we matched as div-rem pair.; /// We want this extra indirection to avoid dealing with RAUW'ing the map keys.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:632,Modifiability,enhance,enhancement,632,"/// Find matching pairs of integer div/rem ops (they have the same numerator,; /// denominator, and signedness). If they exist in different basic blocks, bring; /// them together by hoisting or replace the common division operation that is; /// implicit in the remainder:; /// X % Y <--> X - ((X / Y) * Y).; ///; /// We can largely ignore the normal safety and cost constraints on speculation; /// of these ops when we find a matching pair. This is because we are already; /// guaranteed that any exceptions and most cost are already incurred by the; /// first member of the pair.; ///; /// Note: This transform could be an oddball enhancement to EarlyCSE, GVN, or; /// SimplifyCFG, but it's split off on its own because it's different enough; /// that it doesn't quite match the stated objectives of those passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:350,Safety,safe,safety,350,"/// Find matching pairs of integer div/rem ops (they have the same numerator,; /// denominator, and signedness). If they exist in different basic blocks, bring; /// them together by hoisting or replace the common division operation that is; /// implicit in the remainder:; /// X % Y <--> X - ((X / Y) * Y).; ///; /// We can largely ignore the normal safety and cost constraints on speculation; /// of these ops when we find a matching pair. This is because we are already; /// guaranteed that any exceptions and most cost are already incurred by the; /// first member of the pair.; ///; /// Note: This transform could be an oddball enhancement to EarlyCSE, GVN, or; /// SimplifyCFG, but it's split off on its own because it's different enough; /// that it doesn't quite match the stated objectives of those passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:670,Usability,Simpl,SimplifyCFG,670,"/// Find matching pairs of integer div/rem ops (they have the same numerator,; /// denominator, and signedness). If they exist in different basic blocks, bring; /// them together by hoisting or replace the common division operation that is; /// implicit in the remainder:; /// X % Y <--> X - ((X / Y) * Y).; ///; /// We can largely ignore the normal safety and cost constraints on speculation; /// of these ops when we find a matching pair. This is because we are already; /// guaranteed that any exceptions and most cost are already incurred by the; /// first member of the pair.; ///; /// Note: This transform could be an oddball enhancement to EarlyCSE, GVN, or; /// SimplifyCFG, but it's split off on its own because it's different enough; /// that it doesn't quite match the stated objectives of those passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:89,Safety,avoid,avoid,89,// Get the matching pairs of div-rem instructions. We want this extra; // indirection to avoid dealing with having to RAUW the keys of the maps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:19,Modifiability,variab,variable,19,// suppress unused variable warning,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:3,Deployability,Update,Update,3,// Update AssertingVH<> with new instruction so it doesn't assert.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:10,Testability,Assert,AssertingVH,10,// Update AssertingVH<> with new instruction so it doesn't assert.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:59,Testability,assert,assert,59,// Update AssertingVH<> with new instruction so it doesn't assert.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:82,Modifiability,rewrite,rewrite,82,// Note that we have left ((X / Y) * Y) around.; // If it had other uses we could rewrite it as X - X % Y,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:13,Safety,safe,safe,13,// It's only safe to hoist if every instruction before the Div/Rem in the; // basic block is guaranteed to transfer execution.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:400,Modifiability,rewrite,rewrite,400,"// Look for something like this; // PredBB; // | \; // | Rem; // | /; // Div; //; // If the Rem block has a single predecessor and successor, and all paths; // from PredBB go to either RemBB or DivBB, and execution of RemBB and; // DivBB will always reach the Div/Rem, we can hoist Div to PredBB. If; // we have a DivRem operation we can also hoist Rem. Otherwise we'll leave; // Rem where it is and rewrite it to mul/sub.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:384,Energy Efficiency,reduce,reduce,384,"// Look for something like this; // PredBB; // / \; // Div Rem; //; // If the Rem and Din blocks share a unique predecessor, and all; // paths from PredBB go to either RemBB or DivBB, and execution of RemBB; // and DivBB will always reach the Div/Rem, we can hoist Div to PredBB.; // If we have a DivRem operation we can also hoist Rem. By hoisting both; // ops to the same block, we reduce code size and allow the DivRem to; // issue sooner. Without a DivRem op, this transformation is; // unprofitable because we would end up performing an extra Mul+Sub on; // the Rem path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:528,Performance,perform,performing,528,"// Look for something like this; // PredBB; // / \; // Div Rem; //; // If the Rem and Din blocks share a unique predecessor, and all; // paths from PredBB go to either RemBB or DivBB, and execution of RemBB; // and DivBB will always reach the Div/Rem, we can hoist Div to PredBB.; // If we have a DivRem operation we can also hoist Rem. By hoisting both; // ops to the same block, we reduce code size and allow the DivRem to; // issue sooner. Without a DivRem op, this transformation is; // unprofitable because we would end up performing an extra Mul+Sub on; // the Rem path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:60,Performance,optimiz,optimization,60,"// If DivInst has the exact flag, remove it. Otherwise this optimization; // may replace a well-defined value 'X % Y' with poison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:3,Deployability,Update,Update,3,// Update AssertingVH<> with new instruction so it doesn't assert.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:10,Testability,Assert,AssertingVH,10,// Update AssertingVH<> with new instruction so it doesn't assert.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:59,Testability,assert,assert,59,// Update AssertingVH<> with new instruction so it doesn't assert.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:461,Availability,redundant,redundant,461,"//===- EarlyCSE.cpp - Simple and fast CSE pass ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs a simple dominator tree walk that eliminates trivially; // redundant instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:393,Performance,perform,performs,393,"//===- EarlyCSE.cpp - Simple and fast CSE pass ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs a simple dominator tree walk that eliminates trivially; // redundant instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:461,Safety,redund,redundant,461,"//===- EarlyCSE.cpp - Simple and fast CSE pass ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs a simple dominator tree walk that eliminates trivially; // redundant instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:22,Usability,Simpl,Simple,22,"//===- EarlyCSE.cpp - Simple and fast CSE pass ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs a simple dominator tree walk that eliminates trivially; // redundant instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:404,Usability,simpl,simple,404,"//===- EarlyCSE.cpp - Simple and fast CSE pass ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs a simple dominator tree walk that eliminates trivially; // redundant instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:85,Usability,Simpl,SimpleValue,85,//===----------------------------------------------------------------------===//; // SimpleValue; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:28,Availability,avail,available,28,/// Struct representing the available values in the scoped hash table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:59,Security,hash,hash,59,/// Struct representing the available values in the scoped hash table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:229,Performance,optimiz,optimization,229,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:317,Performance,optimiz,optimizations,317,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:356,Safety,detect,detect,356,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:40,Security,access,access,40,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:90,Security,access,accessing,90,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:378,Security,access,accessing,378,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:177,Usability,resume,resume,177,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:61,Deployability,A/B,A/B,61,// Look through a 'not' of the condition operand by swapping A/B.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:79,Energy Efficiency,power,powerful,79,"// Match canonical forms of min/max. We are not using ValueTracking's; // more powerful matchSelectPattern() because it may rely on instruction flags; // such as ""nsw"". That would be incompatible with the current hashing; // mechanism that may remove flags to increase the likelihood of CSE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:213,Security,hash,hashing,213,"// Match canonical forms of min/max. We are not using ValueTracking's; // more powerful matchSelectPattern() because it may rely on instruction flags; // such as ""nsw"". That would be incompatible with the current hashing; // mechanism that may remove flags to increase the likelihood of CSE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:85,Integrability,depend,depend,85,"// Don't CSE convergent calls in different basic blocks, because they; // implicitly depend on the set of threads that is currently executing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:3,Security,Hash,Hash,3,// Hash in all of the operands as pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:3,Security,Hash,Hash,3,// Hash general selects to allow matching commuted true/false operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:257,Safety,detect,detect,257,"// Hash min/max (cmp + select) to allow for commuted operands.; // Min/max may also have non-canonical compare predicate (eg, the compare for; // smin may use 'sgt' rather than 'slt'), and non-canonical operands in the; // compare.; // TODO: We should also detect FP min/max.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:3,Security,Hash,Hash,3,"// Hash min/max (cmp + select) to allow for commuted operands.; // Min/max may also have non-canonical compare predicate (eg, the compare for; // smin may use 'sgt' rather than 'slt'), and non-canonical operands in the; // compare.; // TODO: We should also detect FP min/max.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:3,Security,Hash,Hash,3,"// Hash general selects to allow matching commuted true/false operands.; // If we do not have a compare as the condition, just hash in the condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:127,Security,hash,hash,127,"// Hash general selects to allow matching commuted true/false operands.; // If we do not have a compare as the condition, just hash in the condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:85,Integrability,depend,depend,85,"// Don't CSE convergent calls in different basic blocks, because they; // implicitly depend on the set of threads that is currently executing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:22,Security,hash,hash,22,"// If -earlycse-debug-hash was specified, return a constant -- this; // will force all hashing to collide, so we'll exhaustively search; // the table for a match, and the assertion in isEqual will fire if; // there's a bug causing equal keys to hash differently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:87,Security,hash,hashing,87,"// If -earlycse-debug-hash was specified, return a constant -- this; // will force all hashing to collide, so we'll exhaustively search; // the table for a match, and the assertion in isEqual will fire if; // there's a bug causing equal keys to hash differently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:245,Security,hash,hash,245,"// If -earlycse-debug-hash was specified, return a constant -- this; // will force all hashing to collide, so we'll exhaustively search; // the table for a match, and the assertion in isEqual will fire if; // there's a bug causing equal keys to hash differently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:171,Testability,assert,assertion,171,"// If -earlycse-debug-hash was specified, return a constant -- this; // will force all hashing to collide, so we'll exhaustively search; // the table for a match, and the assertion in isEqual will fire if; // there's a bug causing equal keys to hash differently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:31,Integrability,depend,depend,31,"// Convergent calls implicitly depend on the set of threads that is; // currently executing, so conservatively return false if they are in; // different basic blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:24,Safety,detect,detect,24,// TODO: We should also detect FP min/max.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:369,Deployability,A/B,A/B,369,"// If the true/false operands are swapped and the conditions are compares; // with inverted predicates, the selects are equal:; // select (icmp Pred, X, Y), A, B <--> select (icmp InvPred, X, Y), B, A; //; // This also handles patterns with a double-negation in the sense of not +; // inverse, because we looked through a 'not' in the matching function and; // swapped A/B:; // select (cmp Pred, X, Y), A, B <--> select (not (cmp InvPred, X, Y)), B, A; //; // This intentionally does NOT handle patterns with a double-negation in; // the sense of not + not, because doing so could result in values; // comparing; // as equal that hash differently in the min/max cases like:; // select (cmp slt, X, Y), X, Y <--> select (not (not (cmp slt, X, Y))), X, Y; // ^ hashes as min ^ would not hash as min; // In the context of the EarlyCSE pass, however, such cases never reach; // this code, as we simplify the double-negation before hashing the second; // select (and so still succeed at CSEing them).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:630,Security,hash,hash,630,"// If the true/false operands are swapped and the conditions are compares; // with inverted predicates, the selects are equal:; // select (icmp Pred, X, Y), A, B <--> select (icmp InvPred, X, Y), B, A; //; // This also handles patterns with a double-negation in the sense of not +; // inverse, because we looked through a 'not' in the matching function and; // swapped A/B:; // select (cmp Pred, X, Y), A, B <--> select (not (cmp InvPred, X, Y)), B, A; //; // This intentionally does NOT handle patterns with a double-negation in; // the sense of not + not, because doing so could result in values; // comparing; // as equal that hash differently in the min/max cases like:; // select (cmp slt, X, Y), X, Y <--> select (not (not (cmp slt, X, Y))), X, Y; // ^ hashes as min ^ would not hash as min; // In the context of the EarlyCSE pass, however, such cases never reach; // this code, as we simplify the double-negation before hashing the second; // select (and so still succeed at CSEing them).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:759,Security,hash,hashes,759,"// If the true/false operands are swapped and the conditions are compares; // with inverted predicates, the selects are equal:; // select (icmp Pred, X, Y), A, B <--> select (icmp InvPred, X, Y), B, A; //; // This also handles patterns with a double-negation in the sense of not +; // inverse, because we looked through a 'not' in the matching function and; // swapped A/B:; // select (cmp Pred, X, Y), A, B <--> select (not (cmp InvPred, X, Y)), B, A; //; // This intentionally does NOT handle patterns with a double-negation in; // the sense of not + not, because doing so could result in values; // comparing; // as equal that hash differently in the min/max cases like:; // select (cmp slt, X, Y), X, Y <--> select (not (not (cmp slt, X, Y))), X, Y; // ^ hashes as min ^ would not hash as min; // In the context of the EarlyCSE pass, however, such cases never reach; // this code, as we simplify the double-negation before hashing the second; // select (and so still succeed at CSEing them).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:785,Security,hash,hash,785,"// If the true/false operands are swapped and the conditions are compares; // with inverted predicates, the selects are equal:; // select (icmp Pred, X, Y), A, B <--> select (icmp InvPred, X, Y), B, A; //; // This also handles patterns with a double-negation in the sense of not +; // inverse, because we looked through a 'not' in the matching function and; // swapped A/B:; // select (cmp Pred, X, Y), A, B <--> select (not (cmp InvPred, X, Y)), B, A; //; // This intentionally does NOT handle patterns with a double-negation in; // the sense of not + not, because doing so could result in values; // comparing; // as equal that hash differently in the min/max cases like:; // select (cmp slt, X, Y), X, Y <--> select (not (not (cmp slt, X, Y))), X, Y; // ^ hashes as min ^ would not hash as min; // In the context of the EarlyCSE pass, however, such cases never reach; // this code, as we simplify the double-negation before hashing the second; // select (and so still succeed at CSEing them).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:927,Security,hash,hashing,927,"// If the true/false operands are swapped and the conditions are compares; // with inverted predicates, the selects are equal:; // select (icmp Pred, X, Y), A, B <--> select (icmp InvPred, X, Y), B, A; //; // This also handles patterns with a double-negation in the sense of not +; // inverse, because we looked through a 'not' in the matching function and; // swapped A/B:; // select (cmp Pred, X, Y), A, B <--> select (not (cmp InvPred, X, Y)), B, A; //; // This intentionally does NOT handle patterns with a double-negation in; // the sense of not + not, because doing so could result in values; // comparing; // as equal that hash differently in the min/max cases like:; // select (cmp slt, X, Y), X, Y <--> select (not (not (cmp slt, X, Y))), X, Y; // ^ hashes as min ^ would not hash as min; // In the context of the EarlyCSE pass, however, such cases never reach; // this code, as we simplify the double-negation before hashing the second; // select (and so still succeed at CSEing them).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:891,Usability,simpl,simplify,891,"// If the true/false operands are swapped and the conditions are compares; // with inverted predicates, the selects are equal:; // select (icmp Pred, X, Y), A, B <--> select (icmp InvPred, X, Y), B, A; //; // This also handles patterns with a double-negation in the sense of not +; // inverse, because we looked through a 'not' in the matching function and; // swapped A/B:; // select (cmp Pred, X, Y), A, B <--> select (not (cmp InvPred, X, Y)), B, A; //; // This intentionally does NOT handle patterns with a double-negation in; // the sense of not + not, because doing so could result in values; // comparing; // as equal that hash differently in the min/max cases like:; // select (cmp slt, X, Y), X, Y <--> select (not (not (cmp slt, X, Y))), X, Y; // ^ hashes as min ^ would not hash as min; // In the context of the EarlyCSE pass, however, such cases never reach; // this code, as we simplify the double-negation before hashing the second; // select (and so still succeed at CSEing them).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:73,Security,hash,hash,73,"// These comparisons are nontrivial, so assert that equality implies; // hash equality (DenseMap demands this as an invariant).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:40,Testability,assert,assert,40,"// These comparisons are nontrivial, so assert that equality implies; // hash equality (DenseMap demands this as an invariant).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:28,Availability,avail,available,28,/// Struct representing the available call values in the scoped hash; /// table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:64,Security,hash,hash,64,/// Struct representing the available call values in the scoped hash; /// table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:229,Performance,optimiz,optimization,229,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:317,Performance,optimiz,optimizations,317,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:356,Safety,detect,detect,356,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:40,Security,access,access,40,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:90,Security,access,accessing,90,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:378,Security,access,accessing,378,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:177,Usability,resume,resume,177,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:3,Security,Hash,Hash,3,// Hash all of the operands as pointers and mix in the opcode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:31,Integrability,depend,depend,31,"// Convergent calls implicitly depend on the set of threads that is; // currently executing, so conservatively return false if they are in; // different basic blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:149,Availability,redundant,redundant,149,"/// A simple and fast domtree-based CSE pass.; ///; /// This pass does a simple depth-first walk over the dominator tree,; /// eliminating trivially redundant instructions and using instsimplify to; /// canonicalize things as it goes. It is intended to be fast and catch obvious; /// cases so that instcombine and other passes are more effective. It is; /// expected that a later pass of GVN will catch the interesting/hard cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:149,Safety,redund,redundant,149,"/// A simple and fast domtree-based CSE pass.; ///; /// This pass does a simple depth-first walk over the dominator tree,; /// eliminating trivially redundant instructions and using instsimplify to; /// canonicalize things as it goes. It is intended to be fast and catch obvious; /// cases so that instcombine and other passes are more effective. It is; /// expected that a later pass of GVN will catch the interesting/hard cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:6,Usability,simpl,simple,6,"/// A simple and fast domtree-based CSE pass.; ///; /// This pass does a simple depth-first walk over the dominator tree,; /// eliminating trivially redundant instructions and using instsimplify to; /// canonicalize things as it goes. It is intended to be fast and catch obvious; /// cases so that instcombine and other passes are more effective. It is; /// expected that a later pass of GVN will catch the interesting/hard cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:73,Usability,simpl,simple,73,"/// A simple and fast domtree-based CSE pass.; ///; /// This pass does a simple depth-first walk over the dominator tree,; /// eliminating trivially redundant instructions and using instsimplify to; /// canonicalize things as it goes. It is intended to be fast and catch obvious; /// cases so that instcombine and other passes are more effective. It is; /// expected that a later pass of GVN will catch the interesting/hard cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:113,Availability,down,down,113,"/// A scoped hash table of the current values of all of our simple; /// scalar expressions.; ///; /// As we walk down the domtree, we look to see if instructions are in this:; /// if so, we replace them with what we find, otherwise we insert them so; /// that dominated values can succeed in their lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:13,Security,hash,hash,13,"/// A scoped hash table of the current values of all of our simple; /// scalar expressions.; ///; /// As we walk down the domtree, we look to see if instructions are in this:; /// if so, we replace them with what we find, otherwise we insert them so; /// that dominated values can succeed in their lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:60,Usability,simpl,simple,60,"/// A scoped hash table of the current values of all of our simple; /// scalar expressions.; ///; /// As we walk down the domtree, we look to see if instructions are in this:; /// if so, we replace them with what we find, otherwise we insert them so; /// that dominated values can succeed in their lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:200,Availability,redundant,redundant,200,"/// A scoped hash table of the current values of previously encountered; /// memory locations.; ///; /// This allows us to get efficient access to dominating loads or stores when; /// we have a fully redundant load. In addition to the most recent load, we; /// keep track of a generation count of the read, which is compared against; /// the current generation count. The current generation count is incremented; /// after every possibly writing memory operation, which ensures that we only; /// CSE loads with other loads that have no intervening store. Ordering; /// events (such as fences or atomic instructions) increment the generation; /// count as well; essentially, we model these as writes to all possible; /// locations. Note that atomic and/or volatile loads and stores can be; /// present the table; it is the responsibility of the consumer to inspect; /// the atomicity/volatility if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:127,Energy Efficiency,efficient,efficient,127,"/// A scoped hash table of the current values of previously encountered; /// memory locations.; ///; /// This allows us to get efficient access to dominating loads or stores when; /// we have a fully redundant load. In addition to the most recent load, we; /// keep track of a generation count of the read, which is compared against; /// the current generation count. The current generation count is incremented; /// after every possibly writing memory operation, which ensures that we only; /// CSE loads with other loads that have no intervening store. Ordering; /// events (such as fences or atomic instructions) increment the generation; /// count as well; essentially, we model these as writes to all possible; /// locations. Note that atomic and/or volatile loads and stores can be; /// present the table; it is the responsibility of the consumer to inspect; /// the atomicity/volatility if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:158,Performance,load,loads,158,"/// A scoped hash table of the current values of previously encountered; /// memory locations.; ///; /// This allows us to get efficient access to dominating loads or stores when; /// we have a fully redundant load. In addition to the most recent load, we; /// keep track of a generation count of the read, which is compared against; /// the current generation count. The current generation count is incremented; /// after every possibly writing memory operation, which ensures that we only; /// CSE loads with other loads that have no intervening store. Ordering; /// events (such as fences or atomic instructions) increment the generation; /// count as well; essentially, we model these as writes to all possible; /// locations. Note that atomic and/or volatile loads and stores can be; /// present the table; it is the responsibility of the consumer to inspect; /// the atomicity/volatility if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:210,Performance,load,load,210,"/// A scoped hash table of the current values of previously encountered; /// memory locations.; ///; /// This allows us to get efficient access to dominating loads or stores when; /// we have a fully redundant load. In addition to the most recent load, we; /// keep track of a generation count of the read, which is compared against; /// the current generation count. The current generation count is incremented; /// after every possibly writing memory operation, which ensures that we only; /// CSE loads with other loads that have no intervening store. Ordering; /// events (such as fences or atomic instructions) increment the generation; /// count as well; essentially, we model these as writes to all possible; /// locations. Note that atomic and/or volatile loads and stores can be; /// present the table; it is the responsibility of the consumer to inspect; /// the atomicity/volatility if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:247,Performance,load,load,247,"/// A scoped hash table of the current values of previously encountered; /// memory locations.; ///; /// This allows us to get efficient access to dominating loads or stores when; /// we have a fully redundant load. In addition to the most recent load, we; /// keep track of a generation count of the read, which is compared against; /// the current generation count. The current generation count is incremented; /// after every possibly writing memory operation, which ensures that we only; /// CSE loads with other loads that have no intervening store. Ordering; /// events (such as fences or atomic instructions) increment the generation; /// count as well; essentially, we model these as writes to all possible; /// locations. Note that atomic and/or volatile loads and stores can be; /// present the table; it is the responsibility of the consumer to inspect; /// the atomicity/volatility if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:500,Performance,load,loads,500,"/// A scoped hash table of the current values of previously encountered; /// memory locations.; ///; /// This allows us to get efficient access to dominating loads or stores when; /// we have a fully redundant load. In addition to the most recent load, we; /// keep track of a generation count of the read, which is compared against; /// the current generation count. The current generation count is incremented; /// after every possibly writing memory operation, which ensures that we only; /// CSE loads with other loads that have no intervening store. Ordering; /// events (such as fences or atomic instructions) increment the generation; /// count as well; essentially, we model these as writes to all possible; /// locations. Note that atomic and/or volatile loads and stores can be; /// present the table; it is the responsibility of the consumer to inspect; /// the atomicity/volatility if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:517,Performance,load,loads,517,"/// A scoped hash table of the current values of previously encountered; /// memory locations.; ///; /// This allows us to get efficient access to dominating loads or stores when; /// we have a fully redundant load. In addition to the most recent load, we; /// keep track of a generation count of the read, which is compared against; /// the current generation count. The current generation count is incremented; /// after every possibly writing memory operation, which ensures that we only; /// CSE loads with other loads that have no intervening store. Ordering; /// events (such as fences or atomic instructions) increment the generation; /// count as well; essentially, we model these as writes to all possible; /// locations. Note that atomic and/or volatile loads and stores can be; /// present the table; it is the responsibility of the consumer to inspect; /// the atomicity/volatility if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:764,Performance,load,loads,764,"/// A scoped hash table of the current values of previously encountered; /// memory locations.; ///; /// This allows us to get efficient access to dominating loads or stores when; /// we have a fully redundant load. In addition to the most recent load, we; /// keep track of a generation count of the read, which is compared against; /// the current generation count. The current generation count is incremented; /// after every possibly writing memory operation, which ensures that we only; /// CSE loads with other loads that have no intervening store. Ordering; /// events (such as fences or atomic instructions) increment the generation; /// count as well; essentially, we model these as writes to all possible; /// locations. Note that atomic and/or volatile loads and stores can be; /// present the table; it is the responsibility of the consumer to inspect; /// the atomicity/volatility if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:200,Safety,redund,redundant,200,"/// A scoped hash table of the current values of previously encountered; /// memory locations.; ///; /// This allows us to get efficient access to dominating loads or stores when; /// we have a fully redundant load. In addition to the most recent load, we; /// keep track of a generation count of the read, which is compared against; /// the current generation count. The current generation count is incremented; /// after every possibly writing memory operation, which ensures that we only; /// CSE loads with other loads that have no intervening store. Ordering; /// events (such as fences or atomic instructions) increment the generation; /// count as well; essentially, we model these as writes to all possible; /// locations. Note that atomic and/or volatile loads and stores can be; /// present the table; it is the responsibility of the consumer to inspect; /// the atomicity/volatility if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:13,Security,hash,hash,13,"/// A scoped hash table of the current values of previously encountered; /// memory locations.; ///; /// This allows us to get efficient access to dominating loads or stores when; /// we have a fully redundant load. In addition to the most recent load, we; /// keep track of a generation count of the read, which is compared against; /// the current generation count. The current generation count is incremented; /// after every possibly writing memory operation, which ensures that we only; /// CSE loads with other loads that have no intervening store. Ordering; /// events (such as fences or atomic instructions) increment the generation; /// count as well; essentially, we model these as writes to all possible; /// locations. Note that atomic and/or volatile loads and stores can be; /// present the table; it is the responsibility of the consumer to inspect; /// the atomicity/volatility if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:137,Security,access,access,137,"/// A scoped hash table of the current values of previously encountered; /// memory locations.; ///; /// This allows us to get efficient access to dominating loads or stores when; /// we have a fully redundant load. In addition to the most recent load, we; /// keep track of a generation count of the read, which is compared against; /// the current generation count. The current generation count is incremented; /// after every possibly writing memory operation, which ensures that we only; /// CSE loads with other loads that have no intervening store. Ordering; /// events (such as fences or atomic instructions) increment the generation; /// count as well; essentially, we model these as writes to all possible; /// locations. Note that atomic and/or volatile loads and stores can be; /// present the table; it is the responsibility of the consumer to inspect; /// the atomicity/volatility if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:12,Security,hash,hash,12,// A scoped hash table mapping memory locations (represented as typed; // addresses) to generation numbers at which that memory location became; // (henceforth indefinitely) invariant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:124,Performance,load,loads,124,/// A scoped hash table of the current values of read-only call; /// values.; ///; /// It uses the same generation count as loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:13,Security,hash,hash,13,/// A scoped hash table of the current values of read-only call; /// values.; ///; /// It uses the same generation count as loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:67,Security,hash,hash,67,"// Almost a POD, but needs to call the constructors for the scoped hash; // tables so that a new scope gets pushed on. These are RAII so that the; // scope gets popped when the NodeScope is destroyed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:141,Performance,load,loads,141,"// Contains all the needed information to create a stack for doing a depth; // first traversal of the tree. This includes scopes for values, loads, and; // calls as well as the generation. There is a child iterator so that the; // children do not need to be store separately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:3,Security,Access,Accessors,3,// Accessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:4,Integrability,Wrap,Wrapper,4,"/// Wrapper class to handle memory instructions, including loads,; /// stores and intrinsic loads and stores defined by the target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:59,Performance,load,loads,59,"/// Wrapper class to handle memory instructions, including loads,; /// stores and intrinsic loads and stores defined by the target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:92,Performance,load,loads,92,"/// Wrapper class to handle memory instructions, including loads,; /// stores and intrinsic loads and stores defined by the target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:17,Availability,mask,masked,17,"// Use the ID of masked load as the ""matching id"". This will; // prevent matching non-masked loads/stores with masked ones; // (which could be done), but at the moment, the code here; // does not support matching intrinsics with non-intrinsics,; // so keep the MatchingIds specific to masked instructions; // for now (TODO).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:86,Availability,mask,masked,86,"// Use the ID of masked load as the ""matching id"". This will; // prevent matching non-masked loads/stores with masked ones; // (which could be done), but at the moment, the code here; // does not support matching intrinsics with non-intrinsics,; // so keep the MatchingIds specific to masked instructions; // for now (TODO).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:111,Availability,mask,masked,111,"// Use the ID of masked load as the ""matching id"". This will; // prevent matching non-masked loads/stores with masked ones; // (which could be done), but at the moment, the code here; // does not support matching intrinsics with non-intrinsics,; // so keep the MatchingIds specific to masked instructions; // for now (TODO).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:285,Availability,mask,masked,285,"// Use the ID of masked load as the ""matching id"". This will; // prevent matching non-masked loads/stores with masked ones; // (which could be done), but at the moment, the code here; // does not support matching intrinsics with non-intrinsics,; // so keep the MatchingIds specific to masked instructions; // for now (TODO).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:24,Performance,load,load,24,"// Use the ID of masked load as the ""matching id"". This will; // prevent matching non-masked loads/stores with masked ones; // (which could be done), but at the moment, the code here; // does not support matching intrinsics with non-intrinsics,; // so keep the MatchingIds specific to masked instructions; // for now (TODO).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:93,Performance,load,loads,93,"// Use the ID of masked load as the ""matching id"". This will; // prevent matching non-masked loads/stores with masked ones; // (which could be done), but at the moment, the code here; // does not support matching intrinsics with non-intrinsics,; // so keep the MatchingIds specific to masked instructions; // for now (TODO).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:31,Performance,load,loads,31,"// For regular (non-intrinsic) loads/stores, this is set to -1. For; // intrinsic loads/stores, the id is retrieved from the corresponding; // field in the MemIntrinsicInfo structure. That field contains; // non-negative values only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:82,Performance,load,loads,82,"// For regular (non-intrinsic) loads/stores, this is set to -1. For; // intrinsic loads/stores, the id is retrieved from the corresponding; // field in the MemIntrinsicInfo structure. That field contains; // non-negative values only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:54,Availability,mask,masked,54,// We could really use specific intrinsic classes for masked loads; // and stores in IntrinsicInst.h.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:61,Performance,load,loads,61,// We could really use specific intrinsic classes for masked loads; // and stores in IntrinsicInst.h.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:27,Availability,mask,masked,27,"// Trying to replace later masked load with the earlier one.; // Check that the pointers are the same, and; // - masks and pass-throughs are the same, or; // - replacee's pass-through is ""undef"" and replacer's mask is a; // super-set of the replacee's mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:113,Availability,mask,masks,113,"// Trying to replace later masked load with the earlier one.; // Check that the pointers are the same, and; // - masks and pass-throughs are the same, or; // - replacee's pass-through is ""undef"" and replacer's mask is a; // super-set of the replacee's mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:210,Availability,mask,mask,210,"// Trying to replace later masked load with the earlier one.; // Check that the pointers are the same, and; // - masks and pass-throughs are the same, or; // - replacee's pass-through is ""undef"" and replacer's mask is a; // super-set of the replacee's mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:252,Availability,mask,mask,252,"// Trying to replace later masked load with the earlier one.; // Check that the pointers are the same, and; // - masks and pass-throughs are the same, or; // - replacee's pass-through is ""undef"" and replacer's mask is a; // super-set of the replacee's mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:34,Performance,load,load,34,"// Trying to replace later masked load with the earlier one.; // Check that the pointers are the same, and; // - masks and pass-throughs are the same, or; // - replacee's pass-through is ""undef"" and replacer's mask is a; // super-set of the replacee's mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:129,Availability,mask,mask,129,"// Trying to replace a load of a stored value with the store's value.; // Check that the pointers are the same, and; // - load's mask is a subset of store's mask, and; // - load's pass-through is ""undef"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:157,Availability,mask,mask,157,"// Trying to replace a load of a stored value with the store's value.; // Check that the pointers are the same, and; // - load's mask is a subset of store's mask, and; // - load's pass-through is ""undef"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:23,Performance,load,load,23,"// Trying to replace a load of a stored value with the store's value.; // Check that the pointers are the same, and; // - load's mask is a subset of store's mask, and; // - load's pass-through is ""undef"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:122,Performance,load,load,122,"// Trying to replace a load of a stored value with the store's value.; // Check that the pointers are the same, and; // - load's mask is a subset of store's mask, and; // - load's pass-through is ""undef"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:173,Performance,load,load,173,"// Trying to replace a load of a stored value with the store's value.; // Check that the pointers are the same, and; // - load's mask is a subset of store's mask, and; // - load's pass-through is ""undef"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:109,Availability,mask,mask,109,"// Trying to remove a store of the loaded value.; // Check that the pointers are the same, and; // - store's mask is a subset of the load's mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:140,Availability,mask,mask,140,"// Trying to remove a store of the loaded value.; // Check that the pointers are the same, and; // - store's mask is a subset of the load's mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:35,Performance,load,loaded,35,"// Trying to remove a store of the loaded value.; // Check that the pointers are the same, and; // - store's mask is a subset of the load's mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:133,Performance,load,load,133,"// Trying to remove a store of the loaded value.; // Check that the pointers are the same, and; // - store's mask is a subset of the load's mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:118,Availability,mask,mask,118,"// Trying to remove a dead store (earlier).; // Check that the pointers are the same,; // - the to-be-removed store's mask is a subset of the other store's; // mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:160,Availability,mask,mask,160,"// Trying to remove a dead store (earlier).; // Check that the pointers are the same,; // - the to-be-removed store's mask is a subset of the other store's; // mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:349,Deployability,update,updated,349,// Removing a store here can leave MemorySSA in an unoptimized state by; // creating MemoryPhis that have identical arguments and by creating; // MemoryUses whose defining access is not an actual clobber. The phi case; // is handled by MemorySSA when passing OptimizePhis = true to; // removeMemoryAccess. The non-optimized MemoryUse case is lazily updated; // by MemorySSA's getClobberingMemoryAccess.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:259,Performance,Optimiz,OptimizePhis,259,// Removing a store here can leave MemorySSA in an unoptimized state by; // creating MemoryPhis that have identical arguments and by creating; // MemoryUses whose defining access is not an actual clobber. The phi case; // is handled by MemorySSA when passing OptimizePhis = true to; // removeMemoryAccess. The non-optimized MemoryUse case is lazily updated; // by MemorySSA's getClobberingMemoryAccess.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:314,Performance,optimiz,optimized,314,// Removing a store here can leave MemorySSA in an unoptimized state by; // creating MemoryPhis that have identical arguments and by creating; // MemoryUses whose defining access is not an actual clobber. The phi case; // is handled by MemorySSA when passing OptimizePhis = true to; // removeMemoryAccess. The non-optimized MemoryUse case is lazily updated; // by MemorySSA's getClobberingMemoryAccess.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:172,Security,access,access,172,// Removing a store here can leave MemorySSA in an unoptimized state by; // creating MemoryPhis that have identical arguments and by creating; // MemoryUses whose defining access is not an actual clobber. The phi case; // is handled by MemorySSA when passing OptimizePhis = true to; // removeMemoryAccess. The non-optimized MemoryUse case is lazily updated; // by MemorySSA's getClobberingMemoryAccess.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:189,Performance,load,load,189,"// end anonymous namespace; /// Determine if the memory referenced by LaterInst is from the same heap; /// version as EarlierInst.; /// This is currently called in two scenarios:; ///; /// load p; /// ...; /// load p; ///; /// and; ///; /// x = load p; /// ...; /// store x, p; ///; /// in both cases we want to verify that there are no possible writes to the; /// memory referenced by p between the earlier and later instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:210,Performance,load,load,210,"// end anonymous namespace; /// Determine if the memory referenced by LaterInst is from the same heap; /// version as EarlierInst.; /// This is currently called in two scenarios:; ///; /// load p; /// ...; /// load p; ///; /// and; ///; /// x = load p; /// ...; /// store x, p; ///; /// in both cases we want to verify that there are no possible writes to the; /// memory referenced by p between the earlier and later instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:245,Performance,load,load,245,"// end anonymous namespace; /// Determine if the memory referenced by LaterInst is from the same heap; /// version as EarlierInst.; /// This is currently called in two scenarios:; ///; /// load p; /// ...; /// load p; ///; /// and; ///; /// x = load p; /// ...; /// store x, p; ///; /// in both cases we want to verify that there are no possible writes to the; /// memory referenced by p between the earlier and later instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:13,Usability,simpl,simple,13,// Check the simple memory generation tracking first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:483,Deployability,pipeline,pipeline,483,"// If MemorySSA has determined that one of EarlierInst or LaterInst does not; // read/write memory, then we can safely return true here.; // FIXME: We could be more aggressive when checking doesNotAccessMemory(),; // onlyReadsMemory(), mayReadFromMemory(), and mayWriteToMemory() in this pass; // by also checking the MemorySSA MemoryAccess on the instruction. Initial; // experiments suggest this isn't worthwhile, at least for C/C++ code compiled; // with the default optimization pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:470,Performance,optimiz,optimization,470,"// If MemorySSA has determined that one of EarlierInst or LaterInst does not; // read/write memory, then we can safely return true here.; // FIXME: We could be more aggressive when checking doesNotAccessMemory(),; // onlyReadsMemory(), mayReadFromMemory(), and mayWriteToMemory() in this pass; // by also checking the MemorySSA MemoryAccess on the instruction. Initial; // experiments suggest this isn't worthwhile, at least for C/C++ code compiled; // with the default optimization pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:112,Safety,safe,safely,112,"// If MemorySSA has determined that one of EarlierInst or LaterInst does not; // read/write memory, then we can safely return true here.; // FIXME: We could be more aggressive when checking doesNotAccessMemory(),; // onlyReadsMemory(), mayReadFromMemory(), and mayWriteToMemory() in this pass; // by also checking the MemorySSA MemoryAccess on the instruction. Initial; // experiments suggest this isn't worthwhile, at least for C/C++ code compiled; // with the default optimization pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:14,Performance,load,loaded,14,// A location loaded from with an invariant_load is assumed to *never* change; // within the visible scope of the compilation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:31,Performance,load,loads,31,"// ""target"" intrinsic forms of loads aren't currently known to; // MemoryLocation::get. TODO",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:32,Performance,load,loads,32,// We don't yet handle removing loads with ordering of any kind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:30,Performance,load,load,30,// We can't replace an atomic load with one which isn't also atomic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:229,Availability,avail,available,229,"// The value V returned from this function is used differently depending; // on whether MemInst is a load or a store. If it's a load, we will replace; // MemInst with V, if it's a store, we will check if V is the same as the; // available value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:63,Integrability,depend,depending,63,"// The value V returned from this function is used differently depending; // on whether MemInst is a load or a store. If it's a load, we will replace; // MemInst with V, if it's a store, we will check if V is the same as the; // available value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:101,Performance,load,load,101,"// The value V returned from this function is used differently depending; // on whether MemInst is a load or a store. If it's a load, we will replace; // MemInst with V, if it's a store, we will check if V is the same as the; // available value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:128,Performance,load,load,128,"// The value V returned from this function is used differently depending; // on whether MemInst is a load or a store. If it's a load, we will replace; // MemInst with V, if it's a store, we will check if V is the same as the; // available value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:349,Security,hash,hash,349,"// If this node has a single predecessor which ends in a conditional branch,; // we can infer the value of the branch condition given that we took this; // path. We need the single predecessor to ensure there's not another path; // which reaches this block where the condition might hold a different; // value. Since we're adding this to the scoped hash table (like any other; // def), it will have been popped if we encounter a future merge block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:97,Availability,Avail,AvailableValues,97,"// See if any instructions in the block can be eliminated. If so, do it. If; // not, add them to AvailableValues.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:134,Integrability,depend,dependencies,134,"// Skip assume intrinsics, they don't really have side effects (although; // they're marked as such to ensure preservation of control dependencies),; // and this pass will not bother with its removal. However, we should mark; // its condition as true for all dominated blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:411,Performance,perform,perform,411,"// We can skip all invariant.start intrinsics since they only read memory,; // and we can forward values across it. For invariant starts without; // invariant ends, we can use the fact that the invariantness never ends to; // start a scope in the current generaton which is true for all future; // generations. Also, we dont need to consume the last store since the; // semantics of invariant.start allow us to perform DSE of the last; // store, if there was a store following invariant.start. Consider:; //; // store 30, i8* p; // invariant.start(p); // store 40, i8* p; // We can DSE the store to 30, since the store 40 to invariant location p; // causes undefined behaviour.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:88,Deployability,update,update,88,"// Guard intrinsics read all memory, but don't write any memory.; // Accordingly, don't update the generation but consume the last store (to; // avoid an incorrect DSE).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:145,Safety,avoid,avoid,145,"// Guard intrinsics read all memory, but don't write any memory.; // Accordingly, don't update the generation but consume the last store (to; // avoid an incorrect DSE).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:29,Usability,simpl,simplified,29,// If the instruction can be simplified (e.g. X+0 = X) then replace it with; // its simpler value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:84,Usability,simpl,simpler,84,// If the instruction can be simplified (e.g. X+0 = X) then replace it with; // its simpler value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:16,Usability,simpl,simple,16,"// If this is a simple instruction that we can value number, process it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:33,Availability,avail,available,33,"// See if the instruction has an available value. If so, use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:47,Availability,avail,available,47,"// Otherwise, just remember that this value is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:29,Performance,load,load,29,"// If this is a non-volatile load, process it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:122,Availability,avail,available,122,"// (conservatively) we can't peak past the ordering implied by this; // operation, but we can add this load to our set of available values",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:103,Performance,load,load,103,"// (conservatively) we can't peak past the ordering implied by this; // operation, but we can add this load to our set of available values",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:27,Performance,load,load,27,"// If we pass an invariant load, we know that memory location is; // indefinitely constant from the moment of first dereferenceability.; // We conservatively treat the invariant_load as that moment. If we; // pass a invariant load after already establishing a scope, don't; // restart it since we want to preserve the earliest point seen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:226,Performance,load,load,226,"// If we pass an invariant load, we know that memory location is; // indefinitely constant from the moment of first dereferenceability.; // We conservatively treat the invariant_load as that moment. If we; // pass a invariant load after already establishing a scope, don't; // restart it since we want to preserve the earliest point seen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:17,Availability,avail,available,17,"// If we have an available version of this load, and if it is the right; // generation or the load is known to be from an invariant location,; // replace this instruction.; //; // If either the dominating load or the current load are invariant, then; // we can assume the current load loads the same value as the dominating; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:43,Performance,load,load,43,"// If we have an available version of this load, and if it is the right; // generation or the load is known to be from an invariant location,; // replace this instruction.; //; // If either the dominating load or the current load are invariant, then; // we can assume the current load loads the same value as the dominating; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:94,Performance,load,load,94,"// If we have an available version of this load, and if it is the right; // generation or the load is known to be from an invariant location,; // replace this instruction.; //; // If either the dominating load or the current load are invariant, then; // we can assume the current load loads the same value as the dominating; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:205,Performance,load,load,205,"// If we have an available version of this load, and if it is the right; // generation or the load is known to be from an invariant location,; // replace this instruction.; //; // If either the dominating load or the current load are invariant, then; // we can assume the current load loads the same value as the dominating; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:225,Performance,load,load,225,"// If we have an available version of this load, and if it is the right; // generation or the load is known to be from an invariant location,; // replace this instruction.; //; // If either the dominating load or the current load are invariant, then; // we can assume the current load loads the same value as the dominating; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:280,Performance,load,load,280,"// If we have an available version of this load, and if it is the right; // generation or the load is known to be from an invariant location,; // replace this instruction.; //; // If either the dominating load or the current load are invariant, then; // we can assume the current load loads the same value as the dominating; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:285,Performance,load,loads,285,"// If we have an available version of this load, and if it is the right; // generation or the load is known to be from an invariant location,; // replace this instruction.; //; // If either the dominating load or the current load are invariant, then; // we can assume the current load loads the same value as the dominating; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:328,Performance,load,load,328,"// If we have an available version of this load, and if it is the right; // generation or the load is known to be from an invariant location,; // replace this instruction.; //; // If either the dominating load or the current load are invariant, then; // we can assume the current load loads the same value as the dominating; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:136,Performance,Load,Load,136,"// If this instruction may read from memory or throw (and potentially read; // from memory in the exception handler), forget LastStore. Load/store; // intrinsics will indicate both a read and a write to memory. The target; // may override this (e.g. so that a store intrinsic does not read from; // memory, and thus will be treated the same as a regular store for; // commoning purposes).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:17,Availability,avail,available,17,"// If we have an available version of this call, and if it is the right; // generation, replace this instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:5,Deployability,release,release,5,"// A release fence requires that all stores complete before it, but does; // not prevent the reordering of following loads 'before' the fence. As a; // result, we don't need to consider it as writing to memory and don't need; // to advance the generation. We do need to prevent DSE across the fence,; // but that's handled above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:117,Performance,load,loads,117,"// A release fence requires that all stores complete before it, but does; // not prevent the reordering of following loads 'before' the fence. As a; // result, we don't need to consider it as writing to memory and don't need; // to advance the generation. We do need to prevent DSE across the fence,; // but that's handled above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:232,Availability,avail,available,232,"// write back DSE - If we write back the same value we just loaded from; // the same location and haven't passed any intervening writes or ordering; // operations, we can remove the write. The primary benefit is in allowing; // the available load table to remain valid and value forward past where; // the store originally was.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:60,Performance,load,loaded,60,"// write back DSE - If we write back the same value we just loaded from; // the same location and haven't passed any intervening writes or ordering; // operations, we can remove the write. The primary benefit is in allowing; // the available load table to remain valid and value forward past where; // the store originally was.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:242,Performance,load,load,242,"// write back DSE - If we write back the same value we just loaded from; // the same location and haven't passed any intervening writes or ordering; // operations, we can remove the write. The primary benefit is in allowing; // the available load table to remain valid and value forward past where; // the store originally was.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:97,Performance,load,load,97,"// It is okay to have a LastStore to a different pointer here if MemorySSA; // tells us that the load and store are from the same memory generation.; // In that case, LastStore should keep its present value since we're; // removing the current store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:10,Safety,avoid,avoid,10,// We can avoid incrementing the generation count since we were able; // to eliminate this store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:122,Availability,avail,available,122,"// Okay, this isn't something we can CSE at all. Check to see if it is; // something that could modify memory. If so, our available memory values; // cannot be used so bump the generation count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:100,Performance,load,loads,100,// We do a trivial form of DSE if there are two stores to the same; // location with no intervening loads. Delete the earlier store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:52,Performance,load,loaded,52,"// Okay, we just invalidated anything we knew about loaded values. Try; // to salvage *something* by remembering that the stored value is a live; // version of the pointer. It is safe to forward from volatile stores; // to non-volatile loads, so we don't have to check for volatility of; // the store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:236,Performance,load,loads,236,"// Okay, we just invalidated anything we knew about loaded values. Try; // to salvage *something* by remembering that the stored value is a live; // version of the pointer. It is safe to forward from volatile stores; // to non-volatile loads, so we don't have to check for volatility of; // the store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:179,Safety,safe,safe,179,"// Okay, we just invalidated anything we knew about loaded values. Try; // to salvage *something* by remembering that the stored value is a live; // version of the pointer. It is safe to forward from volatile stores; // to non-volatile loads, so we don't have to check for volatility of; // the store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:358,Usability,clear,clear,358,"// Remember that this was the last unordered store we saw for DSE. We; // don't yet handle DSE on ordered or volatile stores since we don't; // have a good way to model the ordering requirement for following; // passes once the store is removed. We could insert a fence, but; // since fences are slightly stronger than stores in their ordering,; // it's not clear this is a profitable transform. Another option would; // be to merge the ordering with that of the post dominating store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:63,Performance,perform,performance,63,"// Note, deque is being used here because there is significant performance; // gains over vector when the container becomes very large due to the; // specific access patterns. For more information see the mailing list; // discussion on this:; // http://lists.llvm.org/pipermail/llvm-commits/Week-of-Mon-20120116/135228.html",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:159,Security,access,access,159,"// Note, deque is being used here because there is significant performance; // gains over vector when the container becomes very large due to the; // specific access patterns. For more information see the mailing list; // discussion on this:; // http://lists.llvm.org/pipermail/llvm-commits/Week-of-Mon-20120116/135228.html",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:149,Availability,redundant,redundant,149,"/// A simple and fast domtree-based CSE pass.; ///; /// This pass does a simple depth-first walk over the dominator tree,; /// eliminating trivially redundant instructions and using instsimplify to; /// canonicalize things as it goes. It is intended to be fast and catch obvious; /// cases so that instcombine and other passes are more effective. It is; /// expected that a later pass of GVN will catch the interesting/hard cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:149,Safety,redund,redundant,149,"/// A simple and fast domtree-based CSE pass.; ///; /// This pass does a simple depth-first walk over the dominator tree,; /// eliminating trivially redundant instructions and using instsimplify to; /// canonicalize things as it goes. It is intended to be fast and catch obvious; /// cases so that instcombine and other passes are more effective. It is; /// expected that a later pass of GVN will catch the interesting/hard cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:6,Usability,simpl,simple,6,"/// A simple and fast domtree-based CSE pass.; ///; /// This pass does a simple depth-first walk over the dominator tree,; /// eliminating trivially redundant instructions and using instsimplify to; /// canonicalize things as it goes. It is intended to be fast and catch obvious; /// cases so that instcombine and other passes are more effective. It is; /// expected that a later pass of GVN will catch the interesting/hard cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:73,Usability,simpl,simple,73,"/// A simple and fast domtree-based CSE pass.; ///; /// This pass does a simple depth-first walk over the dominator tree,; /// eliminating trivially redundant instructions and using instsimplify to; /// canonicalize things as it goes. It is intended to be fast and catch obvious; /// cases so that instcombine and other passes are more effective. It is; /// expected that a later pass of GVN will catch the interesting/hard cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/FlattenCFGPass.cpp:79,Safety,avoid,avoid,79,// Use block handles instead of iterating over function blocks directly; // to avoid using iterators invalidated by erasing blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/FlattenCFGPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/FlattenCFGPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/FlattenCFGPass.cpp:10,Integrability,interface,interface,10,// Public interface to the FlattenCFG pass,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/FlattenCFGPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/FlattenCFGPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Float2Int.cpp:20,Usability,simpl,simple,20,"// The algorithm is simple. Start at instructions that convert from the; // float to the int domain: fptoui, fptosi and fcmp. Walk up the def-use; // graph, using an equivalence datastructure to unify graphs that interfere.; //; // Mappable instructions are those with an integer corrollary that, given; // integer domain inputs, produce an integer output; fadd, for example.; //; // If a non-mappable instruction is seen, this entire def-use graph is marked; // as non-transformable. If we see an instruction that converts from the; // integer domain to FP domain (uitofp,sitofp), we terminate our walk.; /// The largest integer type worth dealing with.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Float2Int.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Float2Int.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Float2Int.cpp:17,Availability,down,down,17,"// Walk forwards down the list of seen instructions, so we visit defs before; // uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Float2Int.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Float2Int.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Float2Int.cpp:3,Performance,Perform,Perform,3,// Perform dead code elimination on the instructions we just modified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Float2Int.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Float2Int.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Float2Int.cpp:3,Usability,Clear,Clear,3,// Clear out all state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Float2Int.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Float2Int.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:583,Performance,optimiz,optimization,583,"//===- GuardWidening.cpp - ---- Guard widening ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the guard widening pass. The semantics of the; // @llvm.experimental.guard intrinsic lets LLVM transform it so that it fails; // more often that it did before the transform. This optimization is called; // ""widening"" and can be used hoist and common runtime checks in situations like; // these:; //; // %cmp0 = 7 u< Length; // call @llvm.experimental.guard(i1 %cmp0) [ ""deopt""(...) ]; // call @unknown_side_effects(); // %cmp1 = 9 u< Length; // call @llvm.experimental.guard(i1 %cmp1) [ ""deopt""(...) ]; // ...; //; // =>; //; // %cmp0 = 9 u< Length; // call @llvm.experimental.guard(i1 %cmp0) [ ""deopt""(...) ]; // call @unknown_side_effects(); // ...; //; // If %cmp0 is false, @llvm.experimental.guard will ""deoptimize"" back to a; // generic implementation of the same function, which will have the correct; // semantics from that point onward. It is always _legal_ to deoptimize (so; // replacing %cmp0 with false is ""correct""), though it may not always be; // profitable to do so.; //; // NB! This pass is a work in progress. It hasn't been tuned to be ""production; // ready"" yet. It is known to have quadriatic running time and will not scale; // to large numbers of guards; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:1448,Performance,tune,tuned,1448,"//===- GuardWidening.cpp - ---- Guard widening ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the guard widening pass. The semantics of the; // @llvm.experimental.guard intrinsic lets LLVM transform it so that it fails; // more often that it did before the transform. This optimization is called; // ""widening"" and can be used hoist and common runtime checks in situations like; // these:; //; // %cmp0 = 7 u< Length; // call @llvm.experimental.guard(i1 %cmp0) [ ""deopt""(...) ]; // call @unknown_side_effects(); // %cmp1 = 9 u< Length; // call @llvm.experimental.guard(i1 %cmp1) [ ""deopt""(...) ]; // ...; //; // =>; //; // %cmp0 = 9 u< Length; // call @llvm.experimental.guard(i1 %cmp0) [ ""deopt""(...) ]; // call @unknown_side_effects(); // ...; //; // If %cmp0 is false, @llvm.experimental.guard will ""deoptimize"" back to a; // generic implementation of the same function, which will have the correct; // semantics from that point onward. It is always _legal_ to deoptimize (so; // replacing %cmp0 with false is ""correct""), though it may not always be; // profitable to do so.; //; // NB! This pass is a work in progress. It hasn't been tuned to be ""production; // ready"" yet. It is known to have quadriatic running time and will not scale; // to large numbers of guards; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:620,Safety,safe,safest,620,"/// Find a point at which the widened condition of \p Guard should be inserted.; /// When it is represented as intrinsic call, we can do it right before the call; /// instruction. However, when we are dealing with widenable branch, we must; /// account for the following situation: widening should not turn a; /// loop-invariant condition into a loop-variant. It means that if; /// widenable.condition() call is invariant (w.r.t. any loop), the new wide; /// condition should stay invariant. Otherwise there can be a miscompile, like; /// the one described at https://github.com/llvm/llvm-project/issues/60234. The; /// safest way to do it is to expand the new condition at WC's block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:16,Performance,perform,performance,16,"/// Widening is performance neutral as far as the cycles spent in check; /// conditions goes (but can still help, e.g., code layout, having less; /// deopt state).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:389,Availability,avail,available,389,"/// Common helper used by \c widenGuard and \c isWideningCondProfitable. Try; /// to generate an expression computing the logical AND of \p ChecksToHoist; /// and \p ChecksToWiden. Return true if the expression computing the AND is; /// only as expensive as computing one of the set of expressions. If \p; /// InsertPt is true then actually generate the resulting expression, make it; /// available at \p InsertPt and return it in \p Result (else no change to the; /// IR is made).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:122,Testability,log,logical,122,"/// Common helper used by \c widenGuard and \c isWideningCondProfitable. Try; /// to generate an expression computing the logical AND of \p ChecksToHoist; /// and \p ChecksToWiden. Return true if the expression computing the AND is; /// only as expensive as computing one of the set of expressions. If \p; /// InsertPt is true then actually generate the resulting expression, make it; /// available at \p InsertPt and return it in \p Result (else no change to the; /// IR is made).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:86,Availability,avail,available,86,/// Generate the logical AND of \p ChecksToHoist and \p OldCondition and make; /// it available at InsertPt,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:17,Testability,log,logical,17,/// Generate the logical AND of \p ChecksToHoist and \p OldCondition and make; /// it available at InsertPt,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:161,Availability,failure,failure,161,"/// Parse \p ToParse into a conjunction (logical-and) of range checks; and; /// append them to \p Checks. Returns true on success, may clobber \c Checks; /// on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:41,Testability,log,logical-and,41,"/// Parse \p ToParse into a conjunction (logical-and) of range checks; and; /// append them to \p Checks. Returns true on success, may clobber \c Checks; /// on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:274,Availability,failure,failure,274,/// Combine the checks in \p Checks into a smaller set of checks and append; /// them into \p CombinedChecks. Return true on success (i.e. all of checks; /// in \p Checks were combined into \p CombinedChecks). Clobbers \p Checks; /// and \p CombinedChecks on success and on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:23,Testability,log,logical,23,/// Can we compute the logical AND of \p ChecksToHoist and \p ChecksToWiden; /// for the price of computing only one of the set of expressions?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:107,Availability,down,downsides,107,"// If the guard was conditional executed, it may never be reached; // dynamically. There are two potential downsides to hoisting it out of the; // conditionally executed region: 1) we may spuriously deopt without need and; // 2) we have the extra cost of computing the guard condition in the common; // case. At the moment, we really only consider the second in our heuristic; // here. TODO: evaluate cost model for spurious deopt; // NOTE: As written, this also lets us hoist right over another guard which; // is essentially just another spelling for control flow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:11,Availability,down,down,11,// Only go down the dominator tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:105,Performance,Cache,CacheOfFreezes,105,// A bit overloaded data structures. Visited contains constant/GV; // if we already met it. In this case CacheOfFreezes has a freeze if it is; // required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:431,Integrability,wrap,wrap,431,"// We have a series of f+1 checks as:; //; // I+k_0 u< L ... Chk_0; // I+k_1 u< L ... Chk_1; // ...; // I+k_f u< L ... Chk_f; //; // with forall i in [0,f]: k_f-k_i u< k_f-k_0 ... Precond_0; // k_f-k_0 u< INT_MIN+k_f ... Precond_1; // k_f != k_0 ... Precond_2; //; // Claim:; // Chk_0 AND Chk_f implies all the other checks; //; // Informal proof sketch:; //; // We will show that the integer range [I+k_0,I+k_f] does not unsigned-wrap; // (i.e. going from I+k_0 to I+k_f does not cross the -1,0 boundary) and; // thus I+k_f is the greatest unsigned value in that range.; //; // This combined with Ckh_(f+1) shows that everything in that range is u< L.; // Via Precond_0 we know that all of the indices in Chk_0 through Chk_(f+1); // lie in [I+k_0,I+k_f], this proving our claim.; //; // To see that [I+k_0,I+k_f] is not a wrapping range, note that there are; // two possibilities: I+k_0 u< I+k_f or I+k_0 >u I+k_f (they can't be equal; // since k_0 != k_f). In the former case, [I+k_0,I+k_f] is not a wrapping; // range by definition, and the latter case is impossible:; //; // 0-----I+k_f---I+k_0----L---INT_MAX,INT_MIN------------------(-1); // xxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx; //; // For Chk_0 to succeed, we'd have to have k_f-k_0 (the range highlighted; // with 'x' above) to be at least >u INT_MIN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:823,Integrability,wrap,wrapping,823,"// We have a series of f+1 checks as:; //; // I+k_0 u< L ... Chk_0; // I+k_1 u< L ... Chk_1; // ...; // I+k_f u< L ... Chk_f; //; // with forall i in [0,f]: k_f-k_i u< k_f-k_0 ... Precond_0; // k_f-k_0 u< INT_MIN+k_f ... Precond_1; // k_f != k_0 ... Precond_2; //; // Claim:; // Chk_0 AND Chk_f implies all the other checks; //; // Informal proof sketch:; //; // We will show that the integer range [I+k_0,I+k_f] does not unsigned-wrap; // (i.e. going from I+k_0 to I+k_f does not cross the -1,0 boundary) and; // thus I+k_f is the greatest unsigned value in that range.; //; // This combined with Ckh_(f+1) shows that everything in that range is u< L.; // Via Precond_0 we know that all of the indices in Chk_0 through Chk_(f+1); // lie in [I+k_0,I+k_f], this proving our claim.; //; // To see that [I+k_0,I+k_f] is not a wrapping range, note that there are; // two possibilities: I+k_0 u< I+k_f or I+k_0 >u I+k_f (they can't be equal; // since k_0 != k_f). In the former case, [I+k_0,I+k_f] is not a wrapping; // range by definition, and the latter case is impossible:; //; // 0-----I+k_f---I+k_0----L---INT_MAX,INT_MIN------------------(-1); // xxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx; //; // For Chk_0 to succeed, we'd have to have k_f-k_0 (the range highlighted; // with 'x' above) to be at least >u INT_MIN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:1002,Integrability,wrap,wrapping,1002,"// We have a series of f+1 checks as:; //; // I+k_0 u< L ... Chk_0; // I+k_1 u< L ... Chk_1; // ...; // I+k_f u< L ... Chk_f; //; // with forall i in [0,f]: k_f-k_i u< k_f-k_0 ... Precond_0; // k_f-k_0 u< INT_MIN+k_f ... Precond_1; // k_f != k_0 ... Precond_2; //; // Claim:; // Chk_0 AND Chk_f implies all the other checks; //; // Informal proof sketch:; //; // We will show that the integer range [I+k_0,I+k_f] does not unsigned-wrap; // (i.e. going from I+k_0 to I+k_f does not cross the -1,0 boundary) and; // thus I+k_f is the greatest unsigned value in that range.; //; // This combined with Ckh_(f+1) shows that everything in that range is u< L.; // Via Precond_0 we know that all of the indices in Chk_0 through Chk_(f+1); // lie in [I+k_0,I+k_f], this proving our claim.; //; // To see that [I+k_0,I+k_f] is not a wrapping range, note that there are; // two possibilities: I+k_0 u< I+k_f or I+k_0 >u I+k_f (they can't be equal; // since k_0 != k_f). In the former case, [I+k_0,I+k_f] is not a wrapping; // range by definition, and the latter case is impossible:; //; // 0-----I+k_f---I+k_0----L---INT_MAX,INT_MIN------------------(-1); // xxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx; //; // For Chk_0 to succeed, we'd have to have k_f-k_0 (the range highlighted; // with 'x' above) to be at least >u INT_MIN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:3,Safety,Avoid,Avoid,3,// Avoid requesting analyses if there are no guards or widenable conditions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:27,Availability,redundant,redundant,27,"//===- GVN.cpp - Eliminate redundant values and loads ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs global value numbering to eliminate fully redundant; // instructions. It also performs simple dead load elimination.; //; // Note that this pass does the value numbering itself; it does not use the; // ValueNumbering analysis passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:444,Availability,redundant,redundant,444,"//===- GVN.cpp - Eliminate redundant values and loads ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs global value numbering to eliminate fully redundant; // instructions. It also performs simple dead load elimination.; //; // Note that this pass does the value numbering itself; it does not use the; // ValueNumbering analysis passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:48,Performance,load,loads,48,"//===- GVN.cpp - Eliminate redundant values and loads ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs global value numbering to eliminate fully redundant; // instructions. It also performs simple dead load elimination.; //; // Note that this pass does the value numbering itself; it does not use the; // ValueNumbering analysis passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:393,Performance,perform,performs,393,"//===- GVN.cpp - Eliminate redundant values and loads ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs global value numbering to eliminate fully redundant; // instructions. It also performs simple dead load elimination.; //; // Note that this pass does the value numbering itself; it does not use the; // ValueNumbering analysis passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:480,Performance,perform,performs,480,"//===- GVN.cpp - Eliminate redundant values and loads ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs global value numbering to eliminate fully redundant; // instructions. It also performs simple dead load elimination.; //; // Note that this pass does the value numbering itself; it does not use the; // ValueNumbering analysis passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:501,Performance,load,load,501,"//===- GVN.cpp - Eliminate redundant values and loads ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs global value numbering to eliminate fully redundant; // instructions. It also performs simple dead load elimination.; //; // Note that this pass does the value numbering itself; it does not use the; // ValueNumbering analysis passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:27,Safety,redund,redundant,27,"//===- GVN.cpp - Eliminate redundant values and loads ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs global value numbering to eliminate fully redundant; // instructions. It also performs simple dead load elimination.; //; // Note that this pass does the value numbering itself; it does not use the; // ValueNumbering analysis passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:444,Safety,redund,redundant,444,"//===- GVN.cpp - Eliminate redundant values and loads ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs global value numbering to eliminate fully redundant; // instructions. It also performs simple dead load elimination.; //; // Note that this pass does the value numbering itself; it does not use the; // ValueNumbering analysis passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:489,Usability,simpl,simple,489,"//===- GVN.cpp - Eliminate redundant values and loads ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs global value numbering to eliminate fully redundant; // instructions. It also performs simple dead load elimination.; //; // Note that this pass does the value numbering itself; it does not use the; // ValueNumbering analysis passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:51,Availability,avail,available,51,// end namespace llvm; /// Represents a particular available value that we know how to materialize.; /// Materialization of an AvailableValue never fails. An AvailableValue is; /// implicitly associated with a rematerialization point which is the; /// location of the instruction from which it was formed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:127,Availability,Avail,AvailableValue,127,// end namespace llvm; /// Represents a particular available value that we know how to materialize.; /// Materialization of an AvailableValue never fails. An AvailableValue is; /// implicitly associated with a rematerialization point which is the; /// location of the instruction from which it was formed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:158,Availability,Avail,AvailableValue,158,// end namespace llvm; /// Represents a particular available value that we know how to materialize.; /// Materialization of an AvailableValue never fails. An AvailableValue is; /// implicitly associated with a rematerialization point which is the; /// location of the instruction from which it was formed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:36,Security,access,accessed,36,// A simple offsetted value that is accessed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:5,Usability,simpl,simple,5,// A simple offsetted value that is accessed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:25,Performance,load,load,25,// A value produced by a load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:31,Performance,load,loaded,31,// A memory intrinsic which is loaded from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:29,Performance,load,loaded,29,// A pointer select which is loaded from and for which the load; // can be replace by a value select.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:59,Performance,load,load,59,// A pointer select which is loaded from and for which the load; // can be replace by a value select.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:64,Performance,load,load,64,/// Offset - The byte offset in Val that is interesting for the load query.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:18,Availability,Avail,AvailableValue,18,/// Represents an AvailableValue which can be rematerialized at the end of; /// the associated BasicBlock.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:20,Availability,avail,available,20,/// AV - The actual available value,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:231,Energy Efficiency,efficient,efficient,231,"// Ensure that commutative instructions that only differ by a permutation; // of their operands get the same value number by sorting the operand value; // numbers. Since commutative operands are the 1st two operands it is more; // efficient to sort by hand rather than using, say, std::sort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:53,Performance,scalab,scalable,53,"// If converting to offset representation fails (for scalable vectors),; // fall back to type-based implementation:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:229,Performance,optimiz,optimization,229,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:317,Performance,optimiz,optimizations,317,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:356,Safety,detect,detect,356,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:40,Security,access,access,40,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:90,Security,access,accessing,90,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:378,Security,access,accessing,378,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:177,Usability,resume,resume,177,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:57,Integrability,depend,depend,57,"// Do not combine convergent calls since they implicitly depend on the set of; // threads that is currently executing, and they might be in different basic; // blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:7,Availability,mask,masked,7,"// For masked load/store intrinsics, the local_dep may actually be; // a normal load or store instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:14,Performance,load,load,14,"// For masked load/store intrinsics, the local_dep may actually be; // a normal load or store instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:80,Performance,load,load,80,"// For masked load/store intrinsics, the local_dep may actually be; // a normal load or store instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:28,Testability,log,logic,28,// FIXME: Move the checking logic to MemDep!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:86,Integrability,depend,dependencies,86,"// We don't handle non-definitions. If we already have a call, reject; // instruction dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:104,Modifiability,variab,variables,104,"// FIXME: The order of evaluation of these 'getResult' calls is very; // significant! Re-ordering these variables will cause GVN when run alone to; // be less effective! We should fix memdep and basic-aa to not exhibit this; // behavior, but until then don't change the order here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:37,Availability,avail,available,37,/// We know the block *is not* fully available. This is a fixpoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:33,Availability,avail,available,33,/// We know the block *is* fully available. This is a fixpoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:46,Availability,avail,available,46,"/// We do not know whether the block is fully available or not,; /// but we are currently speculating that it will be.; /// If it would have turned out that the block was, in fact, not fully; /// available, this would have been cleaned up into an Unavailable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:196,Availability,avail,available,196,"/// We do not know whether the block is fully available or not,; /// but we are currently speculating that it will be.; /// If it would have turned out that the block was, in fact, not fully; /// available, this would have been cleaned up into an Unavailable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:77,Availability,avail,available,77,"/// Return true if we can prove that the value; /// we're analyzing is fully available in the specified block. As we go, keep; /// track of which blocks we know are fully alive in FullyAvailableBlocks. This; /// map is actually a tri-state map with the following values:; /// 0) we know the block *is not* fully available.; /// 1) we know the block *is* fully available.; /// 2) we do not know whether the block is fully available or not, but we are; /// currently speculating that it will be.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:171,Availability,alive,alive,171,"/// Return true if we can prove that the value; /// we're analyzing is fully available in the specified block. As we go, keep; /// track of which blocks we know are fully alive in FullyAvailableBlocks. This; /// map is actually a tri-state map with the following values:; /// 0) we know the block *is not* fully available.; /// 1) we know the block *is* fully available.; /// 2) we do not know whether the block is fully available or not, but we are; /// currently speculating that it will be.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:312,Availability,avail,available,312,"/// Return true if we can prove that the value; /// we're analyzing is fully available in the specified block. As we go, keep; /// track of which blocks we know are fully alive in FullyAvailableBlocks. This; /// map is actually a tri-state map with the following values:; /// 0) we know the block *is not* fully available.; /// 1) we know the block *is* fully available.; /// 2) we do not know whether the block is fully available or not, but we are; /// currently speculating that it will be.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:360,Availability,avail,available,360,"/// Return true if we can prove that the value; /// we're analyzing is fully available in the specified block. As we go, keep; /// track of which blocks we know are fully alive in FullyAvailableBlocks. This; /// map is actually a tri-state map with the following values:; /// 0) we know the block *is not* fully available.; /// 1) we know the block *is* fully available.; /// 2) we do not know whether the block is fully available or not, but we are; /// currently speculating that it will be.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:421,Availability,avail,available,421,"/// Return true if we can prove that the value; /// we're analyzing is fully available in the specified block. As we go, keep; /// track of which blocks we know are fully alive in FullyAvailableBlocks. This; /// map is actually a tri-state map with the following values:; /// 0) we know the block *is not* fully available.; /// 1) we know the block *is* fully available.; /// 2) we do not know whether the block is fully available or not, but we are; /// currently speculating that it will be.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:140,Availability,avail,available,140,// The number of times we didn't find an entry for a block in a map and; // optimistically inserted an entry marking block as speculatively available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:83,Availability,Avail,Available,83,// LoadFO - depth-first!; // Optimistically assume that the block is Speculatively Available and check; // to see if we already know about this block in one lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Performance,Load,LoadFO,3,// LoadFO - depth-first!; // Optimistically assume that the block is Speculatively Available and check; // to see if we already know about this block in one lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:52,Availability,avail,available,52,// Tentatively consider this block as speculatively available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:70,Availability,Avail,Available,70,// If the block isn't marked as fixpoint yet; // (the Unavailable and Available states are fixpoints),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Performance,Queue,Queue,3,// Queue successors for further processing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:74,Availability,avail,available,74,"// Okay, we have encountered an unavailable block.; // Mark speculatively available blocks reachable from UnavailableBB as; // unavailable as well. Paths are terminated when they reach blocks not in; // FullyAvailableBlocks or they are not marked as speculatively available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:264,Availability,avail,available,264,"// Okay, we have encountered an unavailable block.; // Mark speculatively available blocks reachable from UnavailableBB as; // unavailable as well. Paths are terminated when they reach blocks not in; // FullyAvailableBlocks or they are not marked as speculatively available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:19,Performance,load,loads,19,"/// Given a set of loads specified by ValuesPerBlock,; /// construct SSA form, allowing us to eliminate Load. This returns the value; /// that should be used at Load's definition site.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:104,Performance,Load,Load,104,"/// Given a set of loads specified by ValuesPerBlock,; /// construct SSA form, allowing us to eliminate Load. This returns the value; /// that should be used at Load's definition site.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:161,Performance,Load,Load,161,"/// Given a set of loads specified by ValuesPerBlock,; /// construct SSA form, allowing us to eliminate Load. This returns the value; /// that should be used at Load's definition site.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:23,Availability,redundant,redundant,23,"// Check for the fully redundant, dominating load case. In this case, we can; // just use the dominating value directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:45,Performance,load,load,45,"// Check for the fully redundant, dominating load case. In this case, we can; // just use the dominating value directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:23,Safety,redund,redundant,23,"// Check for the fully redundant, dominating load case. In this case, we can; // just use the dominating value directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:80,Availability,avail,available,80,"// If the value is the load that we will be eliminating, and the block it's; // available in is the block that the load is in, then don't add it as; // SSAUpdater will resolve the value to the relevant phi which may let it; // avoid phi construction entirely if there's actually only one value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:23,Performance,load,load,23,"// If the value is the load that we will be eliminating, and the block it's; // available in is the block that the load is in, then don't add it as; // SSAUpdater will resolve the value to the relevant phi which may let it; // avoid phi construction entirely if there's actually only one value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:115,Performance,load,load,115,"// If the value is the load that we will be eliminating, and the block it's; // available in is the block that the load is in, then don't add it as; // SSAUpdater will resolve the value to the relevant phi which may let it; // avoid phi construction entirely if there's actually only one value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:227,Safety,avoid,avoid,227,"// If the value is the load that we will be eliminating, and the block it's; // available in is the block that the load is in, then don't add it as; // SSAUpdater will resolve the value to the relevant phi which may let it; // avoid phi construction entirely if there's actually only one value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Performance,Perform,Perform,3,// Perform PHI construction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:37,Performance,load,load,37,"// We are adding a new user for this load, for which the original; // metadata may not hold. Additionally, the new load may have a different; // size and type, so their metadata cannot be combined in any; // straightforward way.; // Drop all metadata that is not known to cause immediate UB on violation,; // unless the load has !noundef, in which case all metadata violations; // will be promoted to UB.; // TODO: We can combine noalias/alias.scope metadata here, because it is; // independent of the load type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:115,Performance,load,load,115,"// We are adding a new user for this load, for which the original; // metadata may not hold. Additionally, the new load may have a different; // size and type, so their metadata cannot be combined in any; // straightforward way.; // Drop all metadata that is not known to cause immediate UB on violation,; // unless the load has !noundef, in which case all metadata violations; // will be promoted to UB.; // TODO: We can combine noalias/alias.scope metadata here, because it is; // independent of the load type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:320,Performance,load,load,320,"// We are adding a new user for this load, for which the original; // metadata may not hold. Additionally, the new load may have a different; // size and type, so their metadata cannot be combined in any; // straightforward way.; // Drop all metadata that is not known to cause immediate UB on violation,; // unless the load has !noundef, in which case all metadata violations; // will be promoted to UB.; // TODO: We can combine noalias/alias.scope metadata here, because it is; // independent of the load type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:502,Performance,load,load,502,"// We are adding a new user for this load, for which the original; // metadata may not hold. Additionally, the new load may have a different; // size and type, so their metadata cannot be combined in any; // straightforward way.; // Drop all metadata that is not known to cause immediate UB on violation,; // unless the load has !noundef, in which case all metadata violations; // will be promoted to UB.; // TODO: We can combine noalias/alias.scope metadata here, because it is; // independent of the load type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:38,Performance,load,load,38,// Introduce a new value select for a load from an eligible pointer select.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:66,Performance,load,load-elimination,66,/// Try to locate the three instruction involved in a missed; /// load-elimination case that is due to an intervening store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:125,Availability,avail,available,125,"// There is no dominating use, check if we can find a closest non-dominating; // use that lies between any other potentially available use and Load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:143,Performance,Load,Load,143,"// There is no dominating use, check if we can find a closest non-dominating; // use that lies between any other potentially available use and Load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:33,Availability,avail,available,33,"// These uses are both partially available at Load were it not for; // the clobber, but neither lies strictly after the other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:46,Performance,Load,Load,46,"// These uses are both partially available at Load were it not for; // the clobber, but neither lies strictly after the other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:62,Performance,Load,Load,62,// else: keep current OtherAccess since it lies between U and Load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:55,Modifiability,extend,extended,55,// Find non-clobbered value for Loc memory location in extended basic block; // (chain of basic blocks with single predecessors) starting From instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:10,Integrability,depend,dependence,10,"// If the dependence is to a store that writes to a superset of the bits; // read by the load, we can extract the bits we need for the load from the; // stored value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:89,Performance,load,load,89,"// If the dependence is to a store that writes to a superset of the bits; // read by the load, we can extract the bits we need for the load from the; // stored value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:135,Performance,load,load,135,"// If the dependence is to a store that writes to a superset of the bits; // read by the load, we can extract the bits we need for the load from the; // stored value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:52,Performance,load,load,52,"// Check to see if we have something like this:; // load i32* P; // load i8* (P+1); // if we have this, replace the later with an extraction from the former.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:68,Performance,load,load,68,"// Check to see if we have something like this:; // load i32* P; // load i8* (P+1); // if we have this, replace the later with an extraction from the former.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Performance,Load,Loading,3,// Loading the alloca -> undef.; // Loading immediately after lifetime begin -> undef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:36,Performance,Load,Loading,36,// Loading the alloca -> undef.; // Loading immediately after lifetime begin -> undef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:10,Performance,load,loads,10,"// Reject loads and stores that are to the same address but are of; // different types if we have to. If the stored value is convertable to; // the loaded value, we can reuse it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:148,Performance,load,loaded,148,"// Reject loads and stores that are to the same address but are of; // different types if we have to. If the stored value is convertable to; // the loaded value, we can reuse it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:69,Performance,load,load,69,"// If the types mismatch and we can't handle it, reject reuse of the load.; // If the stored value is larger or equal to the loaded value, we can reuse; // it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:125,Performance,load,loaded,125,"// If the types mismatch and we can't handle it, reject reuse of the load.; // If the stored value is larger or equal to the loaded value, we can reuse; // it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:27,Integrability,depend,dependent,27,// Check if load with Addr dependent from select can be converted to select; // between load values. There must be no instructions between the found; // loads and DepInst that may clobber the loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:12,Performance,load,load,12,// Check if load with Addr dependent from select can be converted to select; // between load values. There must be no instructions between the found; // loads and DepInst that may clobber the loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:88,Performance,load,load,88,// Check if load with Addr dependent from select can be converted to select; // between load values. There must be no instructions between the found; // loads and DepInst that may clobber the loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:153,Performance,load,loads,153,// Check if load with Addr dependent from select can be converted to select; // between load values. There must be no instructions between the found; // loads and DepInst that may clobber the loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:192,Performance,load,loads,192,// Check if load with Addr dependent from select can be converted to select; // between load values. There must be no instructions between the found; // loads and DepInst that may clobber the loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:100,Availability,avail,available,100,"// Filter out useless results (non-locals, etc). Keep track of the blocks; // where we have a value available in repl, also keep track of whether we see; // dependencies that produce an unknown value for the load (such as a call; // that could potentially clobber the load).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:157,Integrability,depend,dependencies,157,"// Filter out useless results (non-locals, etc). Keep track of the blocks; // where we have a value available in repl, also keep track of whether we see; // dependencies that produce an unknown value for the load (such as a call; // that could potentially clobber the load).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:208,Performance,load,load,208,"// Filter out useless results (non-locals, etc). Keep track of the blocks; // where we have a value available in repl, also keep track of whether we see; // dependencies that produce an unknown value for the load (such as a call; // that could potentially clobber the load).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:268,Performance,load,load,268,"// Filter out useless results (non-locals, etc). Keep track of the blocks; // where we have a value available in repl, also keep track of whether we see; // dependencies that produce an unknown value for the load (such as a call; // that could potentially clobber the load).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:8,Integrability,depend,dependent,8,// Dead dependent mem-op disguise as a load evaluating the same value; // as the load in question.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:39,Performance,load,load,39,// Dead dependent mem-op disguise as a load evaluating the same value; // as the load in question.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:81,Performance,load,load,81,// Dead dependent mem-op disguise as a load evaluating the same value; // as the load in question.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:21,Performance,load,loaded,21,// The address being loaded in this non-local block may not be the same as; // the pointer operand of the load if PHI translation occurs. Make sure; // to consider the right address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:106,Performance,load,load,106,// The address being loaded in this non-local block may not be the same as; // the pointer operand of the load if PHI translation occurs. Make sure; // to consider the right address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:50,Integrability,depend,dependency,50,"// subtlety: because we know this was a non-local dependency, we know; // it's safe to materialize anywhere between the instruction within; // DepInfo and the end of it's block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:79,Safety,safe,safe,79,"// subtlety: because we know this was a non-local dependency, we know; // it's safe to materialize anywhere between the instruction within; // DepInfo and the end of it's block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:46,Availability,avail,available,46,"/// Given the following code, v1 is partially available on some edges, but not; /// available on the edge from PredBB. This function tries to find if there is; /// another identical load in the other successor of PredBB.; ///; /// v0 = load %addr; /// br %LoadBB; ///; /// LoadBB:; /// v1 = load %addr; /// ...; ///; /// PredBB:; /// ...; /// br %cond, label %LoadBB, label %SuccBB; ///; /// SuccBB:; /// v2 = load %addr; /// ...; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:84,Availability,avail,available,84,"/// Given the following code, v1 is partially available on some edges, but not; /// available on the edge from PredBB. This function tries to find if there is; /// another identical load in the other successor of PredBB.; ///; /// v0 = load %addr; /// br %LoadBB; ///; /// LoadBB:; /// v1 = load %addr; /// ...; ///; /// PredBB:; /// ...; /// br %cond, label %LoadBB, label %SuccBB; ///; /// SuccBB:; /// v2 = load %addr; /// ...; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:182,Performance,load,load,182,"/// Given the following code, v1 is partially available on some edges, but not; /// available on the edge from PredBB. This function tries to find if there is; /// another identical load in the other successor of PredBB.; ///; /// v0 = load %addr; /// br %LoadBB; ///; /// LoadBB:; /// v1 = load %addr; /// ...; ///; /// PredBB:; /// ...; /// br %cond, label %LoadBB, label %SuccBB; ///; /// SuccBB:; /// v2 = load %addr; /// ...; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:236,Performance,load,load,236,"/// Given the following code, v1 is partially available on some edges, but not; /// available on the edge from PredBB. This function tries to find if there is; /// another identical load in the other successor of PredBB.; ///; /// v0 = load %addr; /// br %LoadBB; ///; /// LoadBB:; /// v1 = load %addr; /// ...; ///; /// PredBB:; /// ...; /// br %cond, label %LoadBB, label %SuccBB; ///; /// SuccBB:; /// v2 = load %addr; /// ...; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:256,Performance,Load,LoadBB,256,"/// Given the following code, v1 is partially available on some edges, but not; /// available on the edge from PredBB. This function tries to find if there is; /// another identical load in the other successor of PredBB.; ///; /// v0 = load %addr; /// br %LoadBB; ///; /// LoadBB:; /// v1 = load %addr; /// ...; ///; /// PredBB:; /// ...; /// br %cond, label %LoadBB, label %SuccBB; ///; /// SuccBB:; /// v2 = load %addr; /// ...; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:273,Performance,Load,LoadBB,273,"/// Given the following code, v1 is partially available on some edges, but not; /// available on the edge from PredBB. This function tries to find if there is; /// another identical load in the other successor of PredBB.; ///; /// v0 = load %addr; /// br %LoadBB; ///; /// LoadBB:; /// v1 = load %addr; /// ...; ///; /// PredBB:; /// ...; /// br %cond, label %LoadBB, label %SuccBB; ///; /// SuccBB:; /// v2 = load %addr; /// ...; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:291,Performance,load,load,291,"/// Given the following code, v1 is partially available on some edges, but not; /// available on the edge from PredBB. This function tries to find if there is; /// another identical load in the other successor of PredBB.; ///; /// v0 = load %addr; /// br %LoadBB; ///; /// LoadBB:; /// v1 = load %addr; /// ...; ///; /// PredBB:; /// ...; /// br %cond, label %LoadBB, label %SuccBB; ///; /// SuccBB:; /// v2 = load %addr; /// ...; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:360,Performance,Load,LoadBB,360,"/// Given the following code, v1 is partially available on some edges, but not; /// available on the edge from PredBB. This function tries to find if there is; /// another identical load in the other successor of PredBB.; ///; /// v0 = load %addr; /// br %LoadBB; ///; /// LoadBB:; /// v1 = load %addr; /// ...; ///; /// PredBB:; /// ...; /// br %cond, label %LoadBB, label %SuccBB; ///; /// SuccBB:; /// v2 = load %addr; /// ...; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:410,Performance,load,load,410,"/// Given the following code, v1 is partially available on some edges, but not; /// available on the edge from PredBB. This function tries to find if there is; /// another identical load in the other successor of PredBB.; ///; /// v0 = load %addr; /// br %LoadBB; ///; /// LoadBB:; /// v1 = load %addr; /// ...; ///; /// PredBB:; /// ...; /// br %cond, label %LoadBB, label %SuccBB; ///; /// SuccBB:; /// v2 = load %addr; /// ...; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:7,Usability,simpl,simplicity,7,// For simplicity we handle a Pred has 2 successors only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:32,Integrability,depend,depends,32,"// If an identical load doesn't depends on any local instructions, it can; // be safely moved to PredBB.; // Also check for the implicit control flow instructions. See the comments; // in PerformLoadPRE for details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:19,Performance,load,load,19,"// If an identical load doesn't depends on any local instructions, it can; // be safely moved to PredBB.; // Also check for the implicit control flow instructions. See the comments; // in PerformLoadPRE for details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:188,Performance,Perform,PerformLoadPRE,188,"// If an identical load doesn't depends on any local instructions, it can; // be safely moved to PredBB.; // Also check for the implicit control flow instructions. See the comments; // in PerformLoadPRE for details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:81,Safety,safe,safely,81,"// If an identical load doesn't depends on any local instructions, it can; // be safely moved to PredBB.; // Also check for the implicit control flow instructions. See the comments; // in PerformLoadPRE for details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:101,Performance,load,load,101,"// Otherwise there is something in the same BB clobbers the memory, we can't; // move this and later load to PredBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:20,Performance,load,load,20,// Transfer the old load's AA tags to the new load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:46,Performance,load,load,46,// Transfer the old load's AA tags to the new load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:31,Performance,load,load,31,"// We do not propagate the old load's debug location, because the new; // load now lives in a different BB, and we want to avoid a jumpy line; // table.; // FIXME: How do we retain source locations without causing poor debugging; // behavior?; // Add the newly created load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:74,Performance,load,load,74,"// We do not propagate the old load's debug location, because the new; // load now lives in a different BB, and we want to avoid a jumpy line; // table.; // FIXME: How do we retain source locations without causing poor debugging; // behavior?; // Add the newly created load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:269,Performance,load,load,269,"// We do not propagate the old load's debug location, because the new; // load now lives in a different BB, and we want to avoid a jumpy line; // table.; // FIXME: How do we retain source locations without causing poor debugging; // behavior?; // Add the newly created load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:123,Safety,avoid,avoid,123,"// We do not propagate the old load's debug location, because the new; // load now lives in a different BB, and we want to avoid a jumpy line; // table.; // FIXME: How do we retain source locations without causing poor debugging; // behavior?; // Add the newly created load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:80,Performance,load,load,80,// For PredBB in CriticalEdgePredAndLoad we need to replace the uses of old; // load instruction with the new created load instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:118,Performance,load,load,118,// For PredBB in CriticalEdgePredAndLoad we need to replace the uses of old; // load instruction with the new created load instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Performance,Perform,Perform,3,// Perform PHI construction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:83,Availability,avail,available,83,"// Okay, we have *some* definitions of the value. This means that the value; // is available in some of our (transitive) predecessors. Lets think about; // doing PRE of this load. This will involve inserting a new load into the; // predecessor when it's not available. We could do this in general, but; // prefer to not increase code size. As such, we only do this when we know; // that we only have to insert *one* load (which means we're basically moving; // the load, not inserting a new one).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:258,Availability,avail,available,258,"// Okay, we have *some* definitions of the value. This means that the value; // is available in some of our (transitive) predecessors. Lets think about; // doing PRE of this load. This will involve inserting a new load into the; // predecessor when it's not available. We could do this in general, but; // prefer to not increase code size. As such, we only do this when we know; // that we only have to insert *one* load (which means we're basically moving; // the load, not inserting a new one).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:174,Performance,load,load,174,"// Okay, we have *some* definitions of the value. This means that the value; // is available in some of our (transitive) predecessors. Lets think about; // doing PRE of this load. This will involve inserting a new load into the; // predecessor when it's not available. We could do this in general, but; // prefer to not increase code size. As such, we only do this when we know; // that we only have to insert *one* load (which means we're basically moving; // the load, not inserting a new one).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:214,Performance,load,load,214,"// Okay, we have *some* definitions of the value. This means that the value; // is available in some of our (transitive) predecessors. Lets think about; // doing PRE of this load. This will involve inserting a new load into the; // predecessor when it's not available. We could do this in general, but; // prefer to not increase code size. As such, we only do this when we know; // that we only have to insert *one* load (which means we're basically moving; // the load, not inserting a new one).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:416,Performance,load,load,416,"// Okay, we have *some* definitions of the value. This means that the value; // is available in some of our (transitive) predecessors. Lets think about; // doing PRE of this load. This will involve inserting a new load into the; // predecessor when it's not available. We could do this in general, but; // prefer to not increase code size. As such, we only do this when we know; // that we only have to insert *one* load (which means we're basically moving; // the load, not inserting a new one).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:465,Performance,load,load,465,"// Okay, we have *some* definitions of the value. This means that the value; // is available in some of our (transitive) predecessors. Lets think about; // doing PRE of this load. This will involve inserting a new load into the; // predecessor when it's not available. We could do this in general, but; // prefer to not increase code size. As such, we only do this when we know; // that we only have to insert *one* load (which means we're basically moving; // the load, not inserting a new one).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:71,Performance,load,load,71,"// Check that there is no implicit control flow instructions above our load in; // its block. If there is an instruction that doesn't always pass the; // execution to the following instruction, then moving through it may become; // invalid. For example:; //; // int arr[LEN];; // int index = ???;; // ...; // guard(0 <= index && index < LEN);; // use(arr[index]);; //; // It is illegal to move the array access to any point above the guard,; // because if the index is out of bounds we should deoptimize rather than; // access the array.; // Check that there is no guard in this block above our instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:404,Security,access,access,404,"// Check that there is no implicit control flow instructions above our load in; // its block. If there is an instruction that doesn't always pass the; // execution to the following instruction, then moving through it may become; // invalid. For example:; //; // int arr[LEN];; // int index = ???;; // ...; // guard(0 <= index && index < LEN);; // use(arr[index]);; //; // It is illegal to move the array access to any point above the guard,; // because if the index is out of bounds we should deoptimize rather than; // access the array.; // Check that there is no guard in this block above our instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:520,Security,access,access,520,"// Check that there is no implicit control flow instructions above our load in; // its block. If there is an instruction that doesn't always pass the; // execution to the following instruction, then moving through it may become; // invalid. For example:; //; // int arr[LEN];; // int index = ???;; // ...; // guard(0 <= index && index < LEN);; // use(arr[index]);; //; // It is illegal to move the array access to any point above the guard,; // because if the index is out of bounds we should deoptimize rather than; // access the array.; // Check that there is no guard in this block above our instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:175,Performance,load,load,175,"// If any of these blocks has more than one successor (i.e. if the edge we; // just traversed was critical), then there are other paths through this; // block along which the load may not be anticipated. Hoisting the load; // above this block would be adding the load to execution paths along; // which it was not previously executed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:217,Performance,load,load,217,"// If any of these blocks has more than one successor (i.e. if the edge we; // just traversed was critical), then there are other paths through this; // block along which the load may not be anticipated. Hoisting the load; // above this block would be adding the load to execution paths along; // which it was not previously executed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:263,Performance,load,load,263,"// If any of these blocks has more than one successor (i.e. if the edge we; // just traversed was critical), then there are other paths through this; // block along which the load may not be anticipated. Hoisting the load; // above this block would be adding the load to execution paths along; // which it was not previously executed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:70,Availability,avail,available,70,// Check to see how many predecessors have the loaded value fully; // available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:47,Performance,load,loaded,47,// Check to see how many predecessors have the loaded value fully; // available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:25,Performance,Load,LoadBB,25,// The edge from Pred to LoadBB is a critical edge will be splitted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:25,Performance,Load,LoadBB,25,"// The edge from Pred to LoadBB is a critical edge, another successor of Pred; // contains a load can be moved to Pred. This data structure maps the Pred to; // the movable load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:93,Performance,load,load,93,"// The edge from Pred to LoadBB is a critical edge, another successor of Pred; // contains a load can be moved to Pred. This data structure maps the Pred to; // the movable load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:173,Performance,load,load,173,"// The edge from Pred to LoadBB is a critical edge, another successor of Pred; // contains a load can be moved to Pred. This data structure maps the Pred to; // the movable load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:126,Performance,load,load,126,"// If any predecessor block is an EH pad that does not allow non-PHI; // instructions before the terminator, we can't PRE the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:45,Performance,load,load,45,// Decide whether PRE is profitable for this load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:184,Availability,avail,available,184,"// If we need to insert new load in multiple predecessors, reject it.; // FIXME: If we could restructure the CFG, we could make a common pred with; // all the preds that don't have an available Load and insert a new load into; // that one block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:28,Performance,load,load,28,"// If we need to insert new load in multiple predecessors, reject it.; // FIXME: If we could restructure the CFG, we could make a common pred with; // all the preds that don't have an available Load and insert a new load into; // that one block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:194,Performance,Load,Load,194,"// If we need to insert new load in multiple predecessors, reject it.; // FIXME: If we could restructure the CFG, we could make a common pred with; // all the preds that don't have an available Load and insert a new load into; // that one block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:216,Performance,load,load,216,"// If we need to insert new load in multiple predecessors, reject it.; // FIXME: If we could restructure the CFG, we could make a common pred with; // all the preds that don't have an available Load and insert a new load into; // that one block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:36,Performance,load,load,36,// Now we know where we will insert load. We must ensure that it is safe; // to speculatively execute the load at that points.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:106,Performance,load,load,106,// Now we know where we will insert load. We must ensure that it is safe; // to speculatively execute the load at that points.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:68,Safety,safe,safe,68,// Now we know where we will insert load. We must ensure that it is safe; // to speculatively execute the load at that points.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:29,Deployability,update,update,29,"// Split critical edges, and update the unavailable predecessors accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:16,Performance,load,load,16,// Check if the load can safely be moved to all the unavailable predecessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:25,Safety,safe,safely,25,// Check if the load can safely be moved to all the unavailable predecessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:473,Availability,avail,available,473,"// Do PHI translation to get its value in the predecessor if necessary. The; // returned pointer (if non-null) is guaranteed to dominate UnavailablePred.; // We do the translation for each edge we skipped by going from Load's block; // to LoadBB, otherwise we might miss pieces needing translation.; // If all preds have a single successor, then we know it is safe to insert; // the load on the pred (?!?), so we can insert code to materialize the; // pointer if it is not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:219,Performance,Load,Load,219,"// Do PHI translation to get its value in the predecessor if necessary. The; // returned pointer (if non-null) is guaranteed to dominate UnavailablePred.; // We do the translation for each edge we skipped by going from Load's block; // to LoadBB, otherwise we might miss pieces needing translation.; // If all preds have a single successor, then we know it is safe to insert; // the load on the pred (?!?), so we can insert code to materialize the; // pointer if it is not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:239,Performance,Load,LoadBB,239,"// Do PHI translation to get its value in the predecessor if necessary. The; // returned pointer (if non-null) is guaranteed to dominate UnavailablePred.; // We do the translation for each edge we skipped by going from Load's block; // to LoadBB, otherwise we might miss pieces needing translation.; // If all preds have a single successor, then we know it is safe to insert; // the load on the pred (?!?), so we can insert code to materialize the; // pointer if it is not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:383,Performance,load,load,383,"// Do PHI translation to get its value in the predecessor if necessary. The; // returned pointer (if non-null) is guaranteed to dominate UnavailablePred.; // We do the translation for each edge we skipped by going from Load's block; // to LoadBB, otherwise we might miss pieces needing translation.; // If all preds have a single successor, then we know it is safe to insert; // the load on the pred (?!?), so we can insert code to materialize the; // pointer if it is not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:360,Safety,safe,safe,360,"// Do PHI translation to get its value in the predecessor if necessary. The; // returned pointer (if non-null) is guaranteed to dominate UnavailablePred.; // We do the translation for each edge we skipped by going from Load's block; // to LoadBB, otherwise we might miss pieces needing translation.; // If all preds have a single successor, then we know it is safe to insert; // the load on the pred (?!?), so we can insert code to materialize the; // pointer if it is not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:31,Performance,load,load,31,"// Okay, we can eliminate this load by inserting a reload in the predecessor; // and using PHI construction to get the value in the other predecessors, do; // it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:81,Performance,load,load,81,// Instructions that have been inserted in predecessor(s) to materialize; // the load address do not retain their original debug locations. Doing; // so could lead to confusing (but correct) source attributions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:82,Availability,avail,availability,82,"// FIXME: We really _ought_ to insert these value numbers into their; // parent's availability map. However, in doing so, we risk getting into; // ordering issues. If a block hasn't been processed yet, we would be; // marking a value as AVAIL-IN, which isn't what we intend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:237,Availability,AVAIL,AVAIL-IN,237,"// FIXME: We really _ought_ to insert these value numbers into their; // parent's availability map. However, in doing so, we risk getting into; // ordering issues. If a block hasn't been processed yet, we would be; // marking a value as AVAIL-IN, which isn't what we intend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:125,Safety,risk,risk,125,"// FIXME: We really _ought_ to insert these value numbers into their; // parent's availability map. However, in doing so, we risk getting into; // ordering issues. If a block hasn't been processed yet, we would be; // marking a value as AVAIL-IN, which isn't what we intend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:11,Availability,avail,available,11,// Must be available in preheader.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:68,Availability,fault,fault,68,"// We plan to hoist the load to preheader without introducing a new fault.; // In order to do it, we need to prove that we cannot side-exit the loop; // once loop header is first entered before execution of the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:24,Performance,load,load,24,"// We plan to hoist the load to preheader without introducing a new fault.; // In order to do it, we need to prove that we cannot side-exit the loop; // once loop header is first entered before execution of the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:211,Performance,load,load,211,"// We plan to hoist the load to preheader without introducing a new fault.; // In order to do it, we need to prove that we cannot side-exit the loop; // once loop header is first entered before execution of the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:78,Safety,safe,safely,78,"// Make sure the memory at this pointer cannot be freed, therefore we can; // safely reload from it after clobber.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:38,Integrability,depend,dependencies,38,/// Attempt to eliminate a load whose dependencies are; /// non-local by performing PHI construction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:27,Performance,load,load,27,/// Attempt to eliminate a load whose dependencies are; /// non-local by performing PHI construction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:73,Performance,perform,performing,73,/// Attempt to eliminate a load whose dependencies are; /// non-local by performing PHI construction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:30,Integrability,depend,dependencies,30,// Step 1: Find the non-local dependencies of the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:50,Performance,load,load,50,// Step 1: Find the non-local dependencies of the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:69,Integrability,depend,dependencies,69,"// If we had to process more than one hundred blocks to find the; // dependencies, this load isn't worth worrying about. Optimizing; // it will be too expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:88,Performance,load,load,88,"// If we had to process more than one hundred blocks to find the; // dependencies, this load isn't worth worrying about. Optimizing; // it will be too expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:121,Performance,Optimiz,Optimizing,121,"// If we had to process more than one hundred blocks to find the; // dependencies, this load isn't worth worrying about. Optimizing; // it will be too expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:31,Availability,failure,failure,31,"// If we had a phi translation failure, we'll have a single entry which is a; // clobber in the current block. Reject this early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:11,Performance,load,load,11,"// If this load follows a GEP, see if we can PRE the indices before analyzing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:23,Availability,avail,availability,23,// Step 2: Analyze the availability of the load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:43,Performance,load,load,43,// Step 2: Analyze the availability of the load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:66,Performance,load,load,66,"// If we have no predecessors that produce a known value for this load, exit; // early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:145,Availability,redundant,redundant,145,"// Step 3: Eliminate fully redundancy.; //; // If all of the instructions we depend on produce a known value for this; // load, then it is fully redundant and we can use PHI insertion to compute; // its value. Insert PHIs and remove the fully redundant value now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:243,Availability,redundant,redundant,243,"// Step 3: Eliminate fully redundancy.; //; // If all of the instructions we depend on produce a known value for this; // load, then it is fully redundant and we can use PHI insertion to compute; // its value. Insert PHIs and remove the fully redundant value now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:77,Integrability,depend,depend,77,"// Step 3: Eliminate fully redundancy.; //; // If all of the instructions we depend on produce a known value for this; // load, then it is fully redundant and we can use PHI insertion to compute; // its value. Insert PHIs and remove the fully redundant value now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:122,Performance,load,load,122,"// Step 3: Eliminate fully redundancy.; //; // If all of the instructions we depend on produce a known value for this; // load, then it is fully redundant and we can use PHI insertion to compute; // its value. Insert PHIs and remove the fully redundant value now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:27,Safety,redund,redundancy,27,"// Step 3: Eliminate fully redundancy.; //; // If all of the instructions we depend on produce a known value for this; // load, then it is fully redundant and we can use PHI insertion to compute; // its value. Insert PHIs and remove the fully redundant value now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:145,Safety,redund,redundant,145,"// Step 3: Eliminate fully redundancy.; //; // If all of the instructions we depend on produce a known value for this; // load, then it is fully redundant and we can use PHI insertion to compute; // its value. Insert PHIs and remove the fully redundant value now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:243,Safety,redund,redundant,243,"// Step 3: Eliminate fully redundancy.; //; // If all of the instructions we depend on produce a known value for this; // load, then it is fully redundant and we can use PHI insertion to compute; // its value. Insert PHIs and remove the fully redundant value now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Performance,Perform,Perform,3,// Perform PHI construction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:55,Deployability,update,update,55,"// If instruction I has debug info, then we should not update it.; // Also, if I has a null DebugLoc, then it is still potentially incorrect; // to propagate Load's DebugLoc because Load may not post-dominate I.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:158,Performance,Load,Load,158,"// If instruction I has debug info, then we should not update it.; // Also, if I has a null DebugLoc, then it is still potentially incorrect; // to propagate Load's DebugLoc because Load may not post-dominate I.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:182,Performance,Load,Load,182,"// If instruction I has debug info, then we should not update it.; // Also, if I has a null DebugLoc, then it is still potentially incorrect; // to propagate Load's DebugLoc because Load may not post-dominate I.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:29,Safety,redund,redundancy,29,// Step 4: Eliminate partial redundancy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:112,Performance,optimiz,optimization,112,"// If we can prove either side non-zero, then equality must imply; // equivalence.; // FIXME: We should do this optimization if 'no signed zeros' is; // applicable via an instruction-level fast-math-flag or some other; // indicator that relaxed FP semantics are being used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:112,Performance,optimiz,optimization,112,"// If we can prove either side non-zero, then equality must imply; // equivalence.; // FIXME: We should do this optimization if 'no signed zeros' is; // applicable via an instruction-level fast-math-flag or some other; // indicator that relaxed FP semantics are being used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:53,Performance,load,load,53,// Insert a new store to null instruction before the load to indicate that; // this code is not reachable. FIXME: We could insert unreachable; // instruction directly because we can modify the CFG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:16,Security,access,accesses,16,"// If there are accesses in the current basic block, find the first one; // that does not come before NewS. The new memory access is inserted; // after the found access or before the terminator if no such access is; // found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:123,Security,access,access,123,"// If there are accesses in the current basic block, find the first one; // that does not come before NewS. The new memory access is inserted; // after the found access or before the terminator if no such access is; // found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:162,Security,access,access,162,"// If there are accesses in the current basic block, find the first one; // that does not come before NewS. The new memory access is inserted; // after the found access or before the terminator if no such access is; // found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:205,Security,access,access,205,"// If there are accesses in the current basic block, find the first one; // that does not come before NewS. The new memory access is inserted; // after the found access or before the terminator if no such access is; // found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:488,Performance,load,load,488,"// If we find an equality fact, canonicalize all dominated uses in this block; // to one of the two values. We heuristically choice the ""oldest"" of the; // two where age is determined by value number. (Note that propagateEquality; // above handles the cross block case.); //; // Key case to cover are:; // 1); // %cmp = fcmp oeq float 3.000000e+00, %0 ; const on lhs could happen; // call void @llvm.assume(i1 %cmp); // ret float %0 ; will change it to ret float 3.000000e+00; // 2); // %load = load float, float* %addr; // %cmp = fcmp oeq float %load, %0; // call void @llvm.assume(i1 %cmp); // ret float %load ; will change it to ret float %0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:495,Performance,load,load,495,"// If we find an equality fact, canonicalize all dominated uses in this block; // to one of the two values. We heuristically choice the ""oldest"" of the; // two where age is determined by value number. (Note that propagateEquality; // above handles the cross block case.); //; // Key case to cover are:; // 1); // %cmp = fcmp oeq float 3.000000e+00, %0 ; const on lhs could happen; // call void @llvm.assume(i1 %cmp); // ret float %0 ; will change it to ret float 3.000000e+00; // 2); // %load = load float, float* %addr; // %cmp = fcmp oeq float %load, %0; // call void @llvm.assume(i1 %cmp); // ret float %load ; will change it to ret float %0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:547,Performance,load,load,547,"// If we find an equality fact, canonicalize all dominated uses in this block; // to one of the two values. We heuristically choice the ""oldest"" of the; // two where age is determined by value number. (Note that propagateEquality; // above handles the cross block case.); //; // Key case to cover are:; // 1); // %cmp = fcmp oeq float 3.000000e+00, %0 ; const on lhs could happen; // call void @llvm.assume(i1 %cmp); // ret float %0 ; will change it to ret float 3.000000e+00; // 2); // %load = load float, float* %addr; // %cmp = fcmp oeq float %load, %0; // call void @llvm.assume(i1 %cmp); // ret float %load ; will change it to ret float %0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:607,Performance,load,load,607,"// If we find an equality fact, canonicalize all dominated uses in this block; // to one of the two values. We heuristically choice the ""oldest"" of the; // two where age is determined by value number. (Note that propagateEquality; // above handles the cross block case.); //; // Key case to cover are:; // 1); // %cmp = fcmp oeq float 3.000000e+00, %0 ; const on lhs could happen; // call void @llvm.assume(i1 %cmp); // ret float %0 ; will change it to ret float 3.000000e+00; // 2); // %load = load float, float* %addr; // %cmp = fcmp oeq float %load, %0; // call void @llvm.assume(i1 %cmp); // ret float %load ; will change it to ret float %0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:290,Testability,log,logic,290,"// Heuristically pick the better replacement -- the choice of heuristic; // isn't terribly important here, but the fact we canonicalize on some; // replacement is for exposing other simplifications.; // TODO: pull this out as a helper function and reuse w/existing; // (slightly different) logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:182,Usability,simpl,simplifications,182,"// Heuristically pick the better replacement -- the choice of heuristic; // isn't terribly important here, but the fact we canonicalize on some; // replacement is for exposing other simplifications.; // TODO: pull this out as a helper function and reuse w/existing; // (slightly different) logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:177,Testability,log,logic,177,"// NOTE: The non-block local cases are handled by the call to; // propagateEquality above; this block is just about handling the block; // local cases. TODO: There's a bunch of logic in propagateEqualiy which; // isn't duplicated for the block local case, can we share it somehow?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:27,Performance,load,load,27,"/// Attempt to eliminate a load, first by eliminating it; /// locally, and then attempting non-local elimination if that fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:25,Security,audit,audited,25,// This code hasn't been audited for ordered or volatile memory access,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:64,Security,access,access,64,// This code hasn't been audited for ordered or volatile memory access,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:34,Performance,load,loaded,34,// ... to a pointer that has been loaded from before...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:4,Integrability,Wrap,Wrap,4,/// Wrap phiTranslateImpl to provide caching functionality.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:96,Integrability,depend,depend,96,"// If there is any value related with Num is defined in a BB other than; // PhiBlock, it cannot depend on a phi in PhiBlock without going through; // a backedge. We can do an early exit in that case to save compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:40,Performance,cache,cache,40,/// Erase stale entry from phiTranslate cache so phiTranslate can be computed; /// again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:237,Security,expose,expose,237,"// If there is no obvious reason to prefer the left-hand side over the; // right-hand side, ensure the longest lived term is on the right-hand side,; // so the shortest lived term will be replaced by the longest lived.; // This tends to expose more simplifications.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:249,Usability,simpl,simplifications,249,"// If there is no obvious reason to prefer the left-hand side over the; // right-hand side, ensure the longest lived term is on the right-hand side,; // so the shortest lived term will be replaced by the longest lived.; // This tends to expose more simplifications.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:517,Performance,optimiz,optimizing,517,"// If value numbering later sees that an instruction in the scope is equal; // to 'LHS' then ensure it will be turned into 'RHS'. In order to preserve; // the invariant that instructions only occur in the leader table for their; // own value number (this is used by removeFromLeaderTable), do not do this; // if RHS is an instruction (if an instruction in the scope is morphed into; // LHS then it will be turned into RHS by the next GVN iteration anyway, so; // using the leader table is about compiling faster, not optimizing better).; // The leader table only tracks basic blocks, not edges. Only add to if we; // have the simple case where the edge dominates the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:626,Usability,simpl,simple,626,"// If value numbering later sees that an instruction in the scope is equal; // to 'LHS' then ensure it will be turned into 'RHS'. In order to preserve; // the invariant that instructions only occur in the leader table for their; // own value number (this is used by removeFromLeaderTable), do not do this; // if RHS is an instruction (if an instruction in the scope is morphed into; // LHS then it will be turned into RHS by the next GVN iteration anyway, so; // using the leader table is about compiling faster, not optimizing better).; // The leader table only tracks basic blocks, not edges. Only add to if we; // have the simple case where the edge dominates the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Performance,Cache,Cached,3,// Cached information for anything that uses LHS will be invalid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Performance,Cache,Cached,3,// Cached information for anything that uses NotCmp will be invalid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:192,Usability,simpl,simple,192,"// Ensure that any instruction in scope that gets the ""A < B"" value number; // is replaced with false.; // The leader table only tracks basic blocks, not edges. Only add to if we; // have the simple case where the edge dominates the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:21,Availability,avail,availability,21,"/// When calculating availability, handle an instruction; /// by inserting it into the appropriate sets",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:133,Safety,redund,redundancies,133,"// If the instruction can be easily simplified then do so now in preference; // to value numbering it. Value numbering often exposes redundancies, for; // example if it determines that %y is equal to %x then the instruction; // ""%z = and i32 %x, %y"" becomes ""%z = and i32 %x, %x"" which we now simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:125,Security,expose,exposes,125,"// If the instruction can be easily simplified then do so now in preference; // to value numbering it. Value numbering often exposes redundancies, for; // example if it determines that %y is equal to %x then the instruction; // ""%z = and i32 %x, %y"" becomes ""%z = and i32 %x, %x"" which we now simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:36,Usability,simpl,simplified,36,"// If the instruction can be easily simplified then do so now in preference; // to value numbering it. Value numbering often exposes redundancies, for; // example if it determines that %y is equal to %x then the instruction; // ""%z = and i32 %x, %y"" becomes ""%z = and i32 %x, %x"" which we now simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:293,Usability,simpl,simplify,293,"// If the instruction can be easily simplified then do so now in preference; // to value numbering it. Value numbering often exposes redundancies, for; // example if it determines that %y is equal to %x then the instruction; // ""%z = and i32 %x, %y"" becomes ""%z = and i32 %x, %x"" which we now simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Usability,Simpl,Simplification,3,"// Simplification can cause a special instruction to become not special.; // For example, devirtualization to a willreturn function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:36,Performance,perform,perform,36,"// For conditional branches, we can perform simple conditional propagation on; // the condition value itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:44,Usability,simpl,simple,44,"// For conditional branches, we can perform simple conditional propagation on; // the condition value itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Safety,Avoid,Avoid,3,// Avoid multiple edges early.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:95,Safety,redund,redundancies,95,"// Instructions with void type don't return a value, so there's; // no point in trying to find redundancies in them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:62,Modifiability,inherit,inherited,62,// Perform fast-path value-number based elimination of values inherited from; // dominators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Performance,Perform,Perform,3,// Perform fast-path value-number based elimination of values inherited from; // dominators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Availability,Failure,Failure,3,"// Failure, just remember this instance for future use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:64,Performance,optimiz,optimization,64,"// Merge unconditional branches, allowing PRE to catch more; // optimization opportunities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:73,Performance,perform,performPRE,73,// Fabricate val-num for dead-code in order to suppress assertion in; // performPRE().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:56,Testability,assert,assertion,56,// Fabricate val-num for dead-code in order to suppress assertion in; // performPRE().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:127,Availability,redundant,redundant,127,"// FIXME: Should perform GVN again after PRE does something. PRE can move; // computations into blocks where they become fully redundant. Note that; // we can't do this until PRE's critical edge splitting updates memdep.; // Actually, when this happens, we should just fully integrate PRE into GVN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:205,Deployability,update,updates,205,"// FIXME: Should perform GVN again after PRE does something. PRE can move; // computations into blocks where they become fully redundant. Note that; // we can't do this until PRE's critical edge splitting updates memdep.; // Actually, when this happens, we should just fully integrate PRE into GVN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:275,Deployability,integrat,integrate,275,"// FIXME: Should perform GVN again after PRE does something. PRE can move; // computations into blocks where they become fully redundant. Note that; // we can't do this until PRE's critical edge splitting updates memdep.; // Actually, when this happens, we should just fully integrate PRE into GVN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:275,Integrability,integrat,integrate,275,"// FIXME: Should perform GVN again after PRE does something. PRE can move; // computations into blocks where they become fully redundant. Note that; // we can't do this until PRE's critical edge splitting updates memdep.; // Actually, when this happens, we should just fully integrate PRE into GVN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:17,Performance,perform,perform,17,"// FIXME: Should perform GVN again after PRE does something. PRE can move; // computations into blocks where they become fully redundant. Note that; // we can't do this until PRE's critical edge splitting updates memdep.; // Actually, when this happens, we should just fully integrate PRE into GVN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:127,Safety,redund,redundant,127,"// FIXME: Should perform GVN again after PRE does something. PRE can move; // computations into blocks where they become fully redundant. Note that; // we can't do this until PRE's critical edge splitting updates memdep.; // Actually, when this happens, we should just fully integrate PRE into GVN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Usability,Clear,Clearing,3,// Clearing map before every BB because it can be used only for single BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:91,Security,hash,hash,91,"// Since we may not have visited the input blocks of the phis, we can't; // use our normal hash approach for phis. Instead, simply look for; // obvious duplicates. The first pass of GVN will tend to create; // identical phis, and the second or later passes can eliminate them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:124,Usability,simpl,simply,124,"// Since we may not have visited the input blocks of the phis, we can't; // use our normal hash approach for phis. Instead, simply look for; // obvious duplicates. The first pass of GVN will tend to create; // identical phis, and the second or later passes can eliminate them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Safety,Avoid,Avoid,3,// Avoid iterator invalidation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:28,Availability,down,down,28,"// Because we are going top-down through the block, all value numbers; // will be available in the predecessor by the time we need them. Any; // that weren't originally present will have been instantiated earlier; // in this loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:82,Availability,avail,available,82,"// Because we are going top-down through the block, all value numbers; // will be available in the predecessor by the time we need them. Any; // that weren't originally present will have been instantiated earlier; // in this loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:152,Modifiability,Rewrite,Rewrite,152,"// This could be a newly inserted instruction, in which case, we won't; // find a value number, and should give up before we hurt ourselves.; // FIXME: Rewrite the infrastructure to let it easier to value number; // and process newly inserted instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:51,Availability,avail,available,51,// Fail out if we encounter an operand that is not available in; // the PRE predecessor. This is typically because of loads which; // are not value numbered precisely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:118,Performance,load,loads,118,// Fail out if we encounter an operand that is not available in; // the PRE predecessor. This is typically because of loads which; // are not value numbered precisely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:14,Availability,avail,availability,14,// Update the availability map to include the new instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Deployability,Update,Update,3,// Update the availability map to include the new instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:334,Availability,avail,available,334,"// Don't do PRE on GEPs. The inserted PHI would prevent CodeGenPrepare from; // sinking the addressing mode computation back to its uses. Extending the; // GEP's live range increases the register pressure, and therefore it can; // introduce unnecessary spills.; //; // This doesn't prevent Load PRE. PHI translation will make the GEP available; // to the load by moving it to the predecessor block if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:138,Modifiability,Extend,Extending,138,"// Don't do PRE on GEPs. The inserted PHI would prevent CodeGenPrepare from; // sinking the addressing mode computation back to its uses. Extending the; // GEP's live range increases the register pressure, and therefore it can; // introduce unnecessary spills.; //; // This doesn't prevent Load PRE. PHI translation will make the GEP available; // to the load by moving it to the predecessor block if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:290,Performance,Load,Load,290,"// Don't do PRE on GEPs. The inserted PHI would prevent CodeGenPrepare from; // sinking the addressing mode computation back to its uses. Extending the; // GEP's live range increases the register pressure, and therefore it can; // introduce unnecessary spills.; //; // This doesn't prevent Load PRE. PHI translation will make the GEP available; // to the load by moving it to the predecessor block if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:355,Performance,load,load,355,"// Don't do PRE on GEPs. The inserted PHI would prevent CodeGenPrepare from; // sinking the addressing mode computation back to its uses. Extending the; // GEP's live range increases the register pressure, and therefore it can; // introduce unnecessary spills.; //; // This doesn't prevent Load PRE. PHI translation will make the GEP available; // to the load by moving it to the predecessor block if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Deployability,Update,Update,3,// Update the RPO numbers for this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:13,Safety,safe,safe,13,// It is not safe to do PRE when P->CurrentBlock is a loop backedge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:121,Performance,perform,perform,121,"// We may have a case where all predecessors have the instruction,; // and we just need to insert a phi node. Otherwise, perform; // insertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:60,Energy Efficiency,schedul,schedule,60,"// We can't do PRE safely on a critical edge, so instead we schedule; // the edge to be split and perform the PRE the next time we iterate; // on the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:98,Performance,perform,perform,98,"// We can't do PRE safely on a critical edge, so instead we schedule; // the edge to be split and perform the PRE the next time we iterate; // on the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:19,Safety,safe,safely,19,"// We can't do PRE safely on a critical edge, so instead we schedule; // the edge to be split and perform the PRE the next time we iterate; // on the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:34,Availability,avail,available,34,// Create a PHI to make the value available in this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:55,Deployability,patch,patch,55,"// If we use an existing value in this phi, we have to patch the original; // value because the phi will be used to replace a later value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:147,Performance,cache,cache,147,"// After creating a new PHI for ValNo, the phi translate result for ValNo will; // be changed, so erase the related stale entries in phi translate cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:4,Performance,Perform,Perform,4,/// Perform a purely local form of PRE that looks for diamond; /// control flow patterns and attempts to perform simple PRE at the join point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:105,Performance,perform,perform,105,/// Perform a purely local form of PRE that looks for diamond; /// control flow patterns and attempts to perform simple PRE at the join point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:113,Usability,simpl,simple,113,/// Perform a purely local form of PRE that looks for diamond; /// control flow patterns and attempts to perform simple PRE at the join point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:9,Performance,perform,perform,9,// Don't perform PRE on an EH pad.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:29,Usability,simpl,simplify,29,"// GVN does not require loop-simplify, do not try to preserve it if it is not; // possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:90,Performance,optimiz,optimization,90,/// Split critical edges found during the previous; /// iteration that may enable further optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:7,Availability,down,down,7,// Top-down walk of the dominator tree,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:179,Deployability,update,update,179,"/// BB is declared dead, which implied other blocks become dead as well. This; /// function is to add all these blocks to ""DeadBlocks"". For the dead blocks'; /// live successors, update their phi nodes by replacing the operands; /// corresponding to dead blocks with UndefVal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:57,Deployability,update,update,57,// S could be proved dead later on. That is why we don't update phi; // operands at this moment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:41,Deployability,update,update,41,"// For the dead blocks' live successors, update their phi nodes by replacing; // the operands corresponding to dead blocks with UndefVal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:573,Deployability,Update,Update,573,"// If the given branch is recognized as a foldable branch (i.e. conditional; // branch with constant condition), it will perform following analyses and; // transformation.; // 1) If the dead out-coming edge is a critical-edge, split it. Let; // R be the target of the dead out-coming edge.; // 1) Identify the set of dead blocks implied by the branch's dead outcoming; // edge. The result of this step will be {X| X is dominated by R}; // 2) Identify those blocks which haves at least one dead predecessor. The; // result of this step will be dominance-frontier(R).; // 3) Update the PHIs in DF(R) by replacing the operands corresponding to; // dead blocks with ""UndefVal"" in an hope these PHIs will optimized away.; //; // Return true iff *NEW* dead code are found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:121,Performance,perform,perform,121,"// If the given branch is recognized as a foldable branch (i.e. conditional; // branch with constant condition), it will perform following analyses and; // transformation.; // 1) If the dead out-coming edge is a critical-edge, split it. Let; // R be the target of the dead out-coming edge.; // 1) Identify the set of dead blocks implied by the branch's dead outcoming; // edge. The result of this step will be {X| X is dominated by R}; // 2) Identify those blocks which haves at least one dead predecessor. The; // result of this step will be dominance-frontier(R).; // 3) Update the PHIs in DF(R) by replacing the operands corresponding to; // dead blocks with ""UndefVal"" in an hope these PHIs will optimized away.; //; // Return true iff *NEW* dead code are found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:700,Performance,optimiz,optimized,700,"// If the given branch is recognized as a foldable branch (i.e. conditional; // branch with constant condition), it will perform following analyses and; // transformation.; // 1) If the dead out-coming edge is a critical-edge, split it. Let; // R be the target of the dead out-coming edge.; // 1) Identify the set of dead blocks implied by the branch's dead outcoming; // edge. The result of this step will be {X| X is dominated by R}; // 2) Identify those blocks which haves at least one dead predecessor. The; // result of this step will be dominance-frontier(R).; // 3) Update the PHIs in DF(R) by replacing the operands corresponding to; // dead blocks with ""UndefVal"" in an hope these PHIs will optimized away.; //; // Return true iff *NEW* dead code are found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Performance,perform,performPRE,3,"// performPRE() will trigger assert if it comes across an instruction without; // associated val-num. As it normally has far more live instructions than dead; // instructions, it makes more sense just to ""fabricate"" a val-number for the; // dead code than checking if instruction involved is dead or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:29,Testability,assert,assert,29,"// performPRE() will trigger assert if it comes across an instruction without; // associated val-num. As it normally has far more live instructions than dead; // instructions, it makes more sense just to ""fabricate"" a val-number for the; // dead code than checking if instruction involved is dead or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:14,Integrability,interface,interface,14,// The public interface to this file...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:1427,Availability,redundant,redundant,1427,"//===- GVNHoist.cpp - Hoist scalar and load expressions -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists expressions from branches to a common dominator. It uses; // GVN (global value numbering) to discover expressions computing the same; // values. The primary goals of code-hoisting are:; // 1. To reduce the code size.; // 2. In some cases reduce critical path (by exposing more ILP).; //; // The algorithm factors out the reachability of values such that multiple; // queries to find reachability of values are fast. This is based on finding the; // ANTIC points in the CFG which do not change during hoisting. The ANTIC points; // are basically the dominance-frontiers in the inverse graph. So we introduce a; // data structure (CHI nodes) to keep track of values flowing out of a basic; // block. We only do this for values with multiple occurrences in the function; // as they are the potential hoistable candidates. This approach allows us to; // hoist instructions to a basic block with more than two successors, as well as; // deal with infinite loops in a trivial way.; //; // Limitations: This pass does not hoist fully redundant expressions because; // they are already handled by GVN-PRE. It is advisable to run gvn-hoist before; // and after gvn-pre because gvn-pre creates opportunities for more instructions; // to be hoisted.; //; // Hoisting may affect the performance in some cases. To mitigate that, hoisting; // is disabled in the following cases.; // 1. Scalars across calls.; // 2. geps when corresponding load/store cannot be hoisted.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:595,Energy Efficiency,reduce,reduce,595,"//===- GVNHoist.cpp - Hoist scalar and load expressions -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists expressions from branches to a common dominator. It uses; // GVN (global value numbering) to discover expressions computing the same; // values. The primary goals of code-hoisting are:; // 1. To reduce the code size.; // 2. In some cases reduce critical path (by exposing more ILP).; //; // The algorithm factors out the reachability of values such that multiple; // queries to find reachability of values are fast. This is based on finding the; // ANTIC points in the CFG which do not change during hoisting. The ANTIC points; // are basically the dominance-frontiers in the inverse graph. So we introduce a; // data structure (CHI nodes) to keep track of values flowing out of a basic; // block. We only do this for values with multiple occurrences in the function; // as they are the potential hoistable candidates. This approach allows us to; // hoist instructions to a basic block with more than two successors, as well as; // deal with infinite loops in a trivial way.; //; // Limitations: This pass does not hoist fully redundant expressions because; // they are already handled by GVN-PRE. It is advisable to run gvn-hoist before; // and after gvn-pre because gvn-pre creates opportunities for more instructions; // to be hoisted.; //; // Hoisting may affect the performance in some cases. To mitigate that, hoisting; // is disabled in the following cases.; // 1. Scalars across calls.; // 2. geps when corresponding load/store cannot be hoisted.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:638,Energy Efficiency,reduce,reduce,638,"//===- GVNHoist.cpp - Hoist scalar and load expressions -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists expressions from branches to a common dominator. It uses; // GVN (global value numbering) to discover expressions computing the same; // values. The primary goals of code-hoisting are:; // 1. To reduce the code size.; // 2. In some cases reduce critical path (by exposing more ILP).; //; // The algorithm factors out the reachability of values such that multiple; // queries to find reachability of values are fast. This is based on finding the; // ANTIC points in the CFG which do not change during hoisting. The ANTIC points; // are basically the dominance-frontiers in the inverse graph. So we introduce a; // data structure (CHI nodes) to keep track of values flowing out of a basic; // block. We only do this for values with multiple occurrences in the function; // as they are the potential hoistable candidates. This approach allows us to; // hoist instructions to a basic block with more than two successors, as well as; // deal with infinite loops in a trivial way.; //; // Limitations: This pass does not hoist fully redundant expressions because; // they are already handled by GVN-PRE. It is advisable to run gvn-hoist before; // and after gvn-pre because gvn-pre creates opportunities for more instructions; // to be hoisted.; //; // Hoisting may affect the performance in some cases. To mitigate that, hoisting; // is disabled in the following cases.; // 1. Scalars across calls.; // 2. geps when corresponding load/store cannot be hoisted.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:39,Performance,load,load,39,"//===- GVNHoist.cpp - Hoist scalar and load expressions -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists expressions from branches to a common dominator. It uses; // GVN (global value numbering) to discover expressions computing the same; // values. The primary goals of code-hoisting are:; // 1. To reduce the code size.; // 2. In some cases reduce critical path (by exposing more ILP).; //; // The algorithm factors out the reachability of values such that multiple; // queries to find reachability of values are fast. This is based on finding the; // ANTIC points in the CFG which do not change during hoisting. The ANTIC points; // are basically the dominance-frontiers in the inverse graph. So we introduce a; // data structure (CHI nodes) to keep track of values flowing out of a basic; // block. We only do this for values with multiple occurrences in the function; // as they are the potential hoistable candidates. This approach allows us to; // hoist instructions to a basic block with more than two successors, as well as; // deal with infinite loops in a trivial way.; //; // Limitations: This pass does not hoist fully redundant expressions because; // they are already handled by GVN-PRE. It is advisable to run gvn-hoist before; // and after gvn-pre because gvn-pre creates opportunities for more instructions; // to be hoisted.; //; // Hoisting may affect the performance in some cases. To mitigate that, hoisting; // is disabled in the following cases.; // 1. Scalars across calls.; // 2. geps when corresponding load/store cannot be hoisted.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:1671,Performance,perform,performance,1671,"//===- GVNHoist.cpp - Hoist scalar and load expressions -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists expressions from branches to a common dominator. It uses; // GVN (global value numbering) to discover expressions computing the same; // values. The primary goals of code-hoisting are:; // 1. To reduce the code size.; // 2. In some cases reduce critical path (by exposing more ILP).; //; // The algorithm factors out the reachability of values such that multiple; // queries to find reachability of values are fast. This is based on finding the; // ANTIC points in the CFG which do not change during hoisting. The ANTIC points; // are basically the dominance-frontiers in the inverse graph. So we introduce a; // data structure (CHI nodes) to keep track of values flowing out of a basic; // block. We only do this for values with multiple occurrences in the function; // as they are the potential hoistable candidates. This approach allows us to; // hoist instructions to a basic block with more than two successors, as well as; // deal with infinite loops in a trivial way.; //; // Limitations: This pass does not hoist fully redundant expressions because; // they are already handled by GVN-PRE. It is advisable to run gvn-hoist before; // and after gvn-pre because gvn-pre creates opportunities for more instructions; // to be hoisted.; //; // Hoisting may affect the performance in some cases. To mitigate that, hoisting; // is disabled in the following cases.; // 1. Scalars across calls.; // 2. geps when corresponding load/store cannot be hoisted.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:1825,Performance,load,load,1825,"//===- GVNHoist.cpp - Hoist scalar and load expressions -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists expressions from branches to a common dominator. It uses; // GVN (global value numbering) to discover expressions computing the same; // values. The primary goals of code-hoisting are:; // 1. To reduce the code size.; // 2. In some cases reduce critical path (by exposing more ILP).; //; // The algorithm factors out the reachability of values such that multiple; // queries to find reachability of values are fast. This is based on finding the; // ANTIC points in the CFG which do not change during hoisting. The ANTIC points; // are basically the dominance-frontiers in the inverse graph. So we introduce a; // data structure (CHI nodes) to keep track of values flowing out of a basic; // block. We only do this for values with multiple occurrences in the function; // as they are the potential hoistable candidates. This approach allows us to; // hoist instructions to a basic block with more than two successors, as well as; // deal with infinite loops in a trivial way.; //; // Limitations: This pass does not hoist fully redundant expressions because; // they are already handled by GVN-PRE. It is advisable to run gvn-hoist before; // and after gvn-pre because gvn-pre creates opportunities for more instructions; // to be hoisted.; //; // Hoisting may affect the performance in some cases. To mitigate that, hoisting; // is disabled in the following cases.; // 1. Scalars across calls.; // 2. geps when corresponding load/store cannot be hoisted.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:1427,Safety,redund,redundant,1427,"//===- GVNHoist.cpp - Hoist scalar and load expressions -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists expressions from branches to a common dominator. It uses; // GVN (global value numbering) to discover expressions computing the same; // values. The primary goals of code-hoisting are:; // 1. To reduce the code size.; // 2. In some cases reduce critical path (by exposing more ILP).; //; // The algorithm factors out the reachability of values such that multiple; // queries to find reachability of values are fast. This is based on finding the; // ANTIC points in the CFG which do not change during hoisting. The ANTIC points; // are basically the dominance-frontiers in the inverse graph. So we introduce a; // data structure (CHI nodes) to keep track of values flowing out of a basic; // block. We only do this for values with multiple occurrences in the function; // as they are the potential hoistable candidates. This approach allows us to; // hoist instructions to a basic block with more than two successors, as well as; // deal with infinite loops in a trivial way.; //; // Limitations: This pass does not hoist fully redundant expressions because; // they are already handled by GVN-PRE. It is advisable to run gvn-hoist before; // and after gvn-pre because gvn-pre creates opportunities for more instructions; // to be hoisted.; //; // Hoisting may affect the performance in some cases. To mitigate that, hoisting; // is disabled in the following cases.; // 1. Scalars across calls.; // 2. geps when corresponding load/store cannot be hoisted.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:15,Performance,load,load,15,// Records all load instructions candidate for code hoisting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:10,Performance,Load,Load,10,// Insert Load and the value number of its memory address in VNtoLoads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:36,Performance,load,loads,36,"// With opaque pointers we may have loads from the same pointer with; // different result types, which should be disambiguated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:26,Security,hash,hash,26,// Insert the Store and a hash number of the store address and the stored; // value in VNtoStores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:3,Security,Hash,Hash,3,// Hash the store address and the stored value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:100,Performance,Load,Load,100,"// A call that doesNotAccessMemory is handled as a Scalar,; // onlyReadsMemory will be handled as a Load instruction,; // all other calls will be handled as stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:109,Energy Efficiency,reduce,reduce,109,"// This pass hoists common computations across branches sharing common; // dominator. The primary goal is to reduce the code size, and in some; // cases reduce critical path (by exposing more ILP).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:153,Energy Efficiency,reduce,reduce,153,"// This pass hoists common computations across branches sharing common; // dominator. The primary goal is to reduce the code size, and in some; // cases reduce critical path (by exposing more ILP).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:279,Usability,simpl,simplify,279,"// Copied from NewGVN.cpp; // This function provides global ranking of operations so that we can place; // them in a canonical order. Note that rank alone is not necessarily enough; // for a complete ordering, as constants all have the same rank. However,; // generally, we will simplify an operation with all constants so that it; // doesn't matter what order they appear in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:52,Performance,load,loads,52,"// Return true when there are exception handling or loads of memory Def; // between Def and NewPt. This function is only called for stores: Def is; // the MemoryDef of the store to be hoisted.; // Decrement by 1 NBBsOnAllPaths for each block between HoistPt and BB, and; // return true when the counter NBBsOnAllPaths reaces 0, except when it is; // initialized to -1 which is unlimited.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:49,Performance,load,load,49,// Return true when it is safe to hoist a memory load or store U from OldPt; // to NewPt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:26,Safety,safe,safe,26,// Return true when it is safe to hoist a memory load or store U from OldPt; // to NewPt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:26,Safety,safe,safe,26,// Return true when it is safe to hoist scalar instructions from all blocks in; // WL to HoistBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:480,Availability,redundant,redundant,480,"// In the inverse CFG, the dominance frontier of basic block (BB) is the; // point where ANTIC needs to be computed for instructions which are going; // to be hoisted. Since this point does not change during gvn-hoist,; // we compute it only once (on demand).; // The ides is inspired from:; // ""Partial Redundancy Elimination in SSA Form""; // ROBERT KENNEDY, SUN CHAN, SHIN-MING LIU, RAYMOND LO, PENG TU and FRED CHOW; // They use similar idea in the forward graph to find fully redundant and; // partially redundant expressions, here it is used in the inverse graph to; // find fully anticipable instructions at merge point (post-dominator in; // the inverse CFG).; // Returns the edge via which an instruction in BB will get the values from.; // Returns true when the values are flowing out to each edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:508,Availability,redundant,redundant,508,"// In the inverse CFG, the dominance frontier of basic block (BB) is the; // point where ANTIC needs to be computed for instructions which are going; // to be hoisted. Since this point does not change during gvn-hoist,; // we compute it only once (on demand).; // The ides is inspired from:; // ""Partial Redundancy Elimination in SSA Form""; // ROBERT KENNEDY, SUN CHAN, SHIN-MING LIU, RAYMOND LO, PENG TU and FRED CHOW; // They use similar idea in the forward graph to find fully redundant and; // partially redundant expressions, here it is used in the inverse graph to; // find fully anticipable instructions at merge point (post-dominator in; // the inverse CFG).; // Returns the edge via which an instruction in BB will get the values from.; // Returns true when the values are flowing out to each edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:304,Safety,Redund,Redundancy,304,"// In the inverse CFG, the dominance frontier of basic block (BB) is the; // point where ANTIC needs to be computed for instructions which are going; // to be hoisted. Since this point does not change during gvn-hoist,; // we compute it only once (on demand).; // The ides is inspired from:; // ""Partial Redundancy Elimination in SSA Form""; // ROBERT KENNEDY, SUN CHAN, SHIN-MING LIU, RAYMOND LO, PENG TU and FRED CHOW; // They use similar idea in the forward graph to find fully redundant and; // partially redundant expressions, here it is used in the inverse graph to; // find fully anticipable instructions at merge point (post-dominator in; // the inverse CFG).; // Returns the edge via which an instruction in BB will get the values from.; // Returns true when the values are flowing out to each edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:480,Safety,redund,redundant,480,"// In the inverse CFG, the dominance frontier of basic block (BB) is the; // point where ANTIC needs to be computed for instructions which are going; // to be hoisted. Since this point does not change during gvn-hoist,; // we compute it only once (on demand).; // The ides is inspired from:; // ""Partial Redundancy Elimination in SSA Form""; // ROBERT KENNEDY, SUN CHAN, SHIN-MING LIU, RAYMOND LO, PENG TU and FRED CHOW; // They use similar idea in the forward graph to find fully redundant and; // partially redundant expressions, here it is used in the inverse graph to; // find fully anticipable instructions at merge point (post-dominator in; // the inverse CFG).; // Returns the edge via which an instruction in BB will get the values from.; // Returns true when the values are flowing out to each edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:508,Safety,redund,redundant,508,"// In the inverse CFG, the dominance frontier of basic block (BB) is the; // point where ANTIC needs to be computed for instructions which are going; // to be hoisted. Since this point does not change during gvn-hoist,; // we compute it only once (on demand).; // The ides is inspired from:; // ""Partial Redundancy Elimination in SSA Form""; // ROBERT KENNEDY, SUN CHAN, SHIN-MING LIU, RAYMOND LO, PENG TU and FRED CHOW; // They use similar idea in the forward graph to find fully redundant and; // partially redundant expressions, here it is used in the inverse graph to; // find fully anticipable instructions at merge point (post-dominator in; // the inverse CFG).; // Returns the edge via which an instruction in BB will get the values from.; // Returns true when the values are flowing out to each edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:18,Safety,safe,safe,18,"// Check if it is safe to hoist values tracked by CHI in the range; // [Begin, End) and accumulate them in Safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:107,Safety,Safe,Safe,107,"// Check if it is safe to hoist values tracked by CHI in the range; // [Begin, End) and accumulate them in Safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:36,Availability,down,down,36,"// Walk the post-dominator tree top-down and use a stack for each value to; // store the last value you see. When you hit a CHI from a given edge, the; // value to use as the argument is at the top of the stack, add the value to; // CHI and pop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:128,Safety,safe,safe,128,// Walk all the CHI-nodes to find ones which have a empty-entry and remove; // them Then collect all the instructions which are safe to hoist and see if; // they form a list of anticipable values. OutValues contains CHIs; // corresponding to each basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:22,Availability,redundant,redundant,22,"// TODO: Remove fully-redundant expressions.; // Get instruction from the Map, assume that all the Instructions; // with same VNs have same rank (this is an approximation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:22,Safety,redund,redundant,22,"// TODO: Remove fully-redundant expressions.; // Get instruction from the Map, assume that all the Instructions; // with same VNs have same rank (this is an approximation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:187,Integrability,depend,dependent,187,// Compute the Post Dominance Frontiers of each basic block; // The dominance frontier of a live block X in the reverse; // control graph is the set of blocks upon which X is control; // dependent. The following sequence computes the set of blocks; // which currently have dead terminators that are control; // dependence sources of a block which is in NewLiveBlocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:311,Integrability,depend,dependence,311,// Compute the Post Dominance Frontiers of each basic block; // The dominance frontier of a live block X in the reverse; // control graph is the set of blocks upon which X is control; // dependent. The following sequence computes the set of blocks; // which currently have dead terminators that are control; // dependence sources of a block which is in NewLiveBlocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:75,Integrability,depend,dependence,75,// Insert CHI args at each PDF to iterate on factored graph of; // control dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:46,Availability,avail,available,46,"// Return true when all operands of Instr are available at insertion point; // HoistPt. When limiting the number of hoisted expressions, one could hoist; // a load without hoisting its access function. So before hoisting any; // expression, make sure that all its operands are available at insert point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:277,Availability,avail,available,277,"// Return true when all operands of Instr are available at insertion point; // HoistPt. When limiting the number of hoisted expressions, one could hoist; // a load without hoisting its access function. So before hoisting any; // expression, make sure that all its operands are available at insert point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:159,Performance,load,load,159,"// Return true when all operands of Instr are available at insertion point; // HoistPt. When limiting the number of hoisted expressions, one could hoist; // a load without hoisting its access function. So before hoisting any; // expression, make sure that all its operands are available at insert point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:185,Security,access,access,185,"// Return true when all operands of Instr are available at insertion point; // HoistPt. When limiting the number of hoisted expressions, one could hoist; // a load without hoisting its access function. So before hoisting any; // expression, make sure that all its operands are available at insert point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:32,Availability,avail,available,32,// Make all operands of the GEP available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:69,Availability,avail,available,69,"// In the case Repl is a load or a store, we make all their GEPs; // available: GEPs are not hoisted by default to avoid the address; // computations to be hoisted without the associated load or store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:25,Performance,load,load,25,"// In the case Repl is a load or a store, we make all their GEPs; // available: GEPs are not hoisted by default to avoid the address; // computations to be hoisted without the associated load or store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:187,Performance,load,load,187,"// In the case Repl is a load or a store, we make all their GEPs; // available: GEPs are not hoisted by default to avoid the address; // computations to be hoisted without the associated load or store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:115,Safety,avoid,avoid,115,"// In the case Repl is a load or a store, we make all their GEPs; // available: GEPs are not hoisted by default to avoid the address; // computations to be hoisted without the associated load or store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:3,Performance,Perform,Perform,3,// Perform DFS Numbering of instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:39,Safety,avoid,avoid,39,// FIXME: use lazy evaluation of VN to avoid the fix-point computation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:159,Integrability,depend,dependent,159,"// To address a limitation of the current GVN, we need to rerun the; // hoisting after we hoisted loads or stores in order to be able to; // hoist all scalars dependent on the hoisted ld/st.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:98,Performance,load,loads,98,"// To address a limitation of the current GVN, we need to rerun the; // hoisting after we hoisted loads or stores in order to be able to; // hoist all scalars dependent on the hoisted ld/st.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:262,Safety,safe,safe,262,// Walk all basic blocks reachable in depth-first iteration on the inverse; // CFG from OldBB to NewBB. These blocks are all the blocks that may be; // executed between the execution of NewBB and OldBB. Hoisting an expression; // from OldBB into NewBB has to be safe on all execution paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:42,Performance,load,loads,42,// Check that we do not move a store past loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:280,Safety,safe,safe,280,// Walk all basic blocks reachable in depth-first iteration on; // the inverse CFG from BBInsn to NewHoistPt. These blocks are all the; // blocks that may be executed between the execution of NewHoistPt and; // BBInsn. Hoisting an expression from BBInsn into NewHoistPt has to be safe; // on all execution paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:24,Safety,safe,safe,24,// In place hoisting is safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:13,Integrability,depend,dependences,13,// Check for dependences on the Memory SSA.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:19,Performance,load,load,19,// Cannot move the load or store to NewBB above its definition in DBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:19,Performance,load,load,19,// Cannot move the load or store to NewPt above its definition in D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:13,Safety,unsafe,unsafe,13,// Check for unsafe hoistings due to side effects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:26,Safety,safe,safe,26,// No side effects: it is safe to hoist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:170,Safety,safe,safe,170,"// If the Terminator is some kind of ""exotic terminator"" that produces a; // value (such as InvokeInst, CallBrInst, or CatchSwitchInst) which the CHI; // uses, it is not safe to hoist the use above the def.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:164,Integrability,depend,dependent,164,"// The Basic Block where CHI is must dominate the value we want to; // track in a CHI. In the PDom walk, there can be values in the; // stack which are not control dependent e.g., nested loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:32,Safety,safe,safety,32,// Collect values which satisfy safety checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:16,Safety,safe,safety,16,"// We check for safety first because there might be multiple values in; // the same path, some of which are not safe to be hoisted, but overall; // each edge has at least one value which can be hoisted, making the; // value anticipable along that path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:112,Safety,safe,safe,112,"// We check for safety first because there might be multiple values in; // the same path, some of which are not safe to be hoisted, but overall; // each edge has at least one value which can be hoisted, making the; // value anticipable along that path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:11,Safety,safe,safe,11,// List of safe values should be anticipable at TI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:10,Availability,avail,available,10,// Gep is available if all operands of GepOp are available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:49,Availability,avail,available,49,// Gep is available if all operands of GepOp are available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:14,Availability,avail,available,14,// Gep is not available if it has operands other than GEPs that are; // defined in blocks not dominating HoistPt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:40,Availability,avail,available,40,// Check whether the operand is already available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:87,Availability,avail,available,87,"// As a GEP can refer to other GEPs, recursively make all the operands; // of this GEP available at HoistPt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:30,Performance,optimiz,optimization,30,"// Conservatively discard any optimization hints, they may differ on the; // other paths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:14,Performance,optimiz,optimization,14,"// If we have optimization hints which agree with each other along different; // paths, preserve them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:3,Deployability,Update,Update,3,// Update the uses of the old MSSA access with NewMemAcc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:35,Security,access,access,35,// Update the uses of the old MSSA access with NewMemAcc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:38,Performance,cache,cache,38,// Also invalidate the Alias Analysis cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:56,Security,access,access,56,// Replace all other instructions with Repl with memory access NewMemAcc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:34,Availability,avail,available,34,// Check that the stored value is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:72,Deployability,update,update,72,"// If there are two instructions in HoistPt to be hoisted in place:; // update Repl to be the first one, such that we can rename the uses; // of the second based on the first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:58,Availability,avail,available,58,// We can move Repl in HoistPt only when all operands are available.; // The order in which hoistings are done may influence the availability; // of operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:129,Availability,avail,availability,129,// We can move Repl in HoistPt only when all operands are available.; // The order in which hoistings are done may influence the availability; // of operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:78,Availability,avail,available,78,// When HoistingGeps there is nothing more we can do to make the; // operands available: just continue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:41,Deployability,update,update,41,// Drop debug location as per debug info update guide.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:48,Usability,guid,guide,48,// Drop debug location as per debug info update guide.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp:298,Usability,simpl,simply,298,// Note: This needs to return a SmallSetVector as the elements of; // ActiveBlocks will be later copied to Blocks using std::copy. The; // resultant order of elements in Blocks needs to be deterministic.; // Using SmallPtrSet instead causes non-deterministic order while; // copying. And we cannot simply sort Blocks as they need to match the; // corresponding Values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp:257,Energy Efficiency,efficient,efficient,257,//===----------------------------------------------------------------------===//; /// Describes a PHI node that may or may not exist. These track the PHIs; /// that must be created if we sunk a sequence of instructions. It provides; /// a hash function for efficient equality comparisons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp:239,Security,hash,hash,239,//===----------------------------------------------------------------------===//; /// Describes a PHI node that may or may not exist. These track the PHIs; /// that must be created if we sunk a sequence of instructions. It provides; /// a hash function for efficient equality comparisons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp:32,Availability,down,down,32,/// Restrict the PHI's contents down to only \c NewBlocks.; /// \c NewBlocks must be a subset of \c this->Blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp:3,Security,Hash,Hash,3,// Hash functor,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp:70,Performance,Load,LoadInst,70,"/// Helper to compute the value number for a memory instruction; /// (LoadInst/StoreInst), including checking the memory ordering and; /// volatility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp:559,Usability,simpl,simply,559,"/// \c Inst uses or touches memory. Return an ID describing the memory state; /// at \c Inst such that if getMemoryUseOrder(I1) == getMemoryUseOrder(I2),; /// the exact same memory operations happen after I1 and I2.; ///; /// This is a very hard problem in general, so we use domain-specific; /// knowledge that we only ever check for equivalence between blocks sharing a; /// single immediate successor that is common, and when determining if I1 ==; /// I2 we will have already determined that next(I1) == next(I2). This; /// inductive property allows us to simply return the value number of the next; /// instruction that defines memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp:4,Performance,Perform,Perform,4,"/// Perform the actual mechanics of sinking an instruction from Blocks into; /// BBEnd, which is their only successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp:46,Availability,down,down,46,// Now restrict the number of incoming blocks down to only those with; // VNumToSink.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp:54,Availability,redundant,redundant,54,// Does sinking this instruction render previous PHIs redundant?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp:54,Safety,redund,redundant,54,// Does sinking this instruction render previous PHIs redundant?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp:3,Deployability,Update,Update,3,// Update metadata and IR flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:974,Availability,redundant,redundant,974,"//===- InductiveRangeCheckElimination.cpp - -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The InductiveRangeCheckElimination pass splits a loop's iteration space into; // three disjoint ranges. It does that in a way such that the loop running in; // the middle loop provably does not need range checks. As an example, it will; // convert; //; // len = < known positive >; // for (i = 0; i < n; i++) {; // if (0 <= i && i < len) {; // do_something();; // } else {; // throw_out_of_bounds();; // }; // }; //; // to; //; // len = < known positive >; // limit = smin(n, len); // // no first segment; // for (i = 0; i < limit; i++) {; // if (0 <= i && i < len) { // this check is fully redundant; // do_something();; // } else {; // throw_out_of_bounds();; // }; // }; // for (i = limit; i < n; i++) {; // if (0 <= i && i < len) {; // do_something();; // } else {; // throw_out_of_bounds();; // }; // }; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:974,Safety,redund,redundant,974,"//===- InductiveRangeCheckElimination.cpp - -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The InductiveRangeCheckElimination pass splits a loop's iteration space into; // three disjoint ranges. It does that in a way such that the loop running in; // the middle loop provably does not need range checks. As an example, it will; // convert; //; // len = < known positive >; // for (i = 0; i < n; i++) {; // if (0 <= i && i < len) {; // do_something();; // } else {; // throw_out_of_bounds();; // }; // }; //; // to; //; // len = < known positive >; // limit = smin(n, len); // // no first segment; // for (i = 0; i < limit; i++) {; // if (0 <= i && i < len) { // this check is fully redundant; // do_something();; // } else {; // throw_out_of_bounds();; // }; // }; // for (i = limit; i < n; i++) {; // if (0 <= i && i < len) {; // do_something();; // } else {; // throw_out_of_bounds();; // }; // }; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:303,Modifiability,variab,variable,303,/// An inductive range check is conditional branch in a loop with; ///; /// 1. a very cold successor (i.e. the branch jumps to that successor very; /// rarely); ///; /// and; ///; /// 2. a condition that is provably true for some contiguous range of values; /// taken by the containing loop's induction variable.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:90,Availability,redundant,redundant,90,"/// Computes a range for the induction variable (IndVar) in which the range; /// check is redundant and can be constant-folded away. The induction; /// variable is not required to be the canonical {0,+,1} induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:39,Modifiability,variab,variable,39,"/// Computes a range for the induction variable (IndVar) in which the range; /// check is redundant and can be constant-folded away. The induction; /// variable is not required to be the canonical {0,+,1} induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:152,Modifiability,variab,variable,152,"/// Computes a range for the induction variable (IndVar) in which the range; /// check is redundant and can be constant-folded away. The induction; /// variable is not required to be the canonical {0,+,1} induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:215,Modifiability,variab,variable,215,"/// Computes a range for the induction variable (IndVar) in which the range; /// check is redundant and can be constant-folded away. The induction; /// variable is not required to be the canonical {0,+,1} induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:90,Safety,redund,redundant,90,"/// Computes a range for the induction variable (IndVar) in which the range; /// check is redundant and can be constant-folded away. The induction; /// variable is not required to be the canonical {0,+,1} induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:265,Safety,avoid,avoid,265,"// In order to turn ""IV - Offset < Limit"" into ""IV < Limit + Offset"", we need; // to be able to freely move values from left side of inequality to right side; // (just as in normal linear arithmetics). Overflows make things much more; // complicated, so we want to avoid this.; //; // Let's prove that the initial subtraction doesn't overflow with all IV's; // values from the safe range constructed for that check.; //; // [Case 1] IV - Offset < Limit; // It doesn't overflow if:; // SINT_MIN <= IV - Offset <= SINT_MAX; // In terms of scaled SINT we need to prove:; // SINT_MIN + Offset <= IV <= SINT_MAX + Offset; // Safe range will be constructed:; // 0 <= IV < Limit + Offset; // It means that 'IV - Offset' doesn't underflow, because:; // SINT_MIN + Offset < 0 <= IV; // and doesn't overflow:; // IV < Limit + Offset <= SINT_MAX + Offset; //; // [Case 2] Offset - IV > Limit; // It doesn't overflow if:; // SINT_MIN <= Offset - IV <= SINT_MAX; // In terms of scaled SINT we need to prove:; // -SINT_MIN >= IV - Offset >= -SINT_MAX; // Offset - SINT_MIN >= IV >= Offset - SINT_MAX; // Safe range will be constructed:; // 0 <= IV < Offset - Limit; // It means that 'Offset - IV' doesn't underflow, because; // Offset - SINT_MAX < 0 <= IV; // and doesn't overflow:; // IV < Offset - Limit <= Offset - SINT_MIN; //; // For the computed upper boundary of the IV's range (Offset +/- Limit) we; // don't know exactly whether it overflows or not. So if we can't prove this; // fact at compile time, we scale boundary computations to a wider type with; // the intention to add runtime overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:377,Safety,safe,safe,377,"// In order to turn ""IV - Offset < Limit"" into ""IV < Limit + Offset"", we need; // to be able to freely move values from left side of inequality to right side; // (just as in normal linear arithmetics). Overflows make things much more; // complicated, so we want to avoid this.; //; // Let's prove that the initial subtraction doesn't overflow with all IV's; // values from the safe range constructed for that check.; //; // [Case 1] IV - Offset < Limit; // It doesn't overflow if:; // SINT_MIN <= IV - Offset <= SINT_MAX; // In terms of scaled SINT we need to prove:; // SINT_MIN + Offset <= IV <= SINT_MAX + Offset; // Safe range will be constructed:; // 0 <= IV < Limit + Offset; // It means that 'IV - Offset' doesn't underflow, because:; // SINT_MIN + Offset < 0 <= IV; // and doesn't overflow:; // IV < Limit + Offset <= SINT_MAX + Offset; //; // [Case 2] Offset - IV > Limit; // It doesn't overflow if:; // SINT_MIN <= Offset - IV <= SINT_MAX; // In terms of scaled SINT we need to prove:; // -SINT_MIN >= IV - Offset >= -SINT_MAX; // Offset - SINT_MIN >= IV >= Offset - SINT_MAX; // Safe range will be constructed:; // 0 <= IV < Offset - Limit; // It means that 'Offset - IV' doesn't underflow, because; // Offset - SINT_MAX < 0 <= IV; // and doesn't overflow:; // IV < Offset - Limit <= Offset - SINT_MIN; //; // For the computed upper boundary of the IV's range (Offset +/- Limit) we; // don't know exactly whether it overflows or not. So if we can't prove this; // fact at compile time, we scale boundary computations to a wider type with; // the intention to add runtime overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:620,Safety,Safe,Safe,620,"// In order to turn ""IV - Offset < Limit"" into ""IV < Limit + Offset"", we need; // to be able to freely move values from left side of inequality to right side; // (just as in normal linear arithmetics). Overflows make things much more; // complicated, so we want to avoid this.; //; // Let's prove that the initial subtraction doesn't overflow with all IV's; // values from the safe range constructed for that check.; //; // [Case 1] IV - Offset < Limit; // It doesn't overflow if:; // SINT_MIN <= IV - Offset <= SINT_MAX; // In terms of scaled SINT we need to prove:; // SINT_MIN + Offset <= IV <= SINT_MAX + Offset; // Safe range will be constructed:; // 0 <= IV < Limit + Offset; // It means that 'IV - Offset' doesn't underflow, because:; // SINT_MIN + Offset < 0 <= IV; // and doesn't overflow:; // IV < Limit + Offset <= SINT_MAX + Offset; //; // [Case 2] Offset - IV > Limit; // It doesn't overflow if:; // SINT_MIN <= Offset - IV <= SINT_MAX; // In terms of scaled SINT we need to prove:; // -SINT_MIN >= IV - Offset >= -SINT_MAX; // Offset - SINT_MIN >= IV >= Offset - SINT_MAX; // Safe range will be constructed:; // 0 <= IV < Offset - Limit; // It means that 'Offset - IV' doesn't underflow, because; // Offset - SINT_MAX < 0 <= IV; // and doesn't overflow:; // IV < Offset - Limit <= Offset - SINT_MIN; //; // For the computed upper boundary of the IV's range (Offset +/- Limit) we; // don't know exactly whether it overflows or not. So if we can't prove this; // fact at compile time, we scale boundary computations to a wider type with; // the intention to add runtime overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:1090,Safety,Safe,Safe,1090,"// In order to turn ""IV - Offset < Limit"" into ""IV < Limit + Offset"", we need; // to be able to freely move values from left side of inequality to right side; // (just as in normal linear arithmetics). Overflows make things much more; // complicated, so we want to avoid this.; //; // Let's prove that the initial subtraction doesn't overflow with all IV's; // values from the safe range constructed for that check.; //; // [Case 1] IV - Offset < Limit; // It doesn't overflow if:; // SINT_MIN <= IV - Offset <= SINT_MAX; // In terms of scaled SINT we need to prove:; // SINT_MIN + Offset <= IV <= SINT_MAX + Offset; // Safe range will be constructed:; // 0 <= IV < Limit + Offset; // It means that 'IV - Offset' doesn't underflow, because:; // SINT_MIN + Offset < 0 <= IV; // and doesn't overflow:; // IV < Limit + Offset <= SINT_MAX + Offset; //; // [Case 2] Offset - IV > Limit; // It doesn't overflow if:; // SINT_MIN <= Offset - IV <= SINT_MAX; // In terms of scaled SINT we need to prove:; // -SINT_MIN >= IV - Offset >= -SINT_MAX; // Offset - SINT_MIN >= IV >= Offset - SINT_MAX; // Safe range will be constructed:; // 0 <= IV < Offset - Limit; // It means that 'Offset - IV' doesn't underflow, because; // Offset - SINT_MAX < 0 <= IV; // and doesn't overflow:; // IV < Offset - Limit <= Offset - SINT_MIN; //; // For the computed upper boundary of the IV's range (Offset +/- Limit) we; // don't know exactly whether it overflows or not. So if we can't prove this; // fact at compile time, we scale boundary computations to a wider type with; // the intention to add runtime overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:13,Safety,safe,safe,13,// Compute a safe set of limits for the main loop to run in -- effectively the; // intersection of `Range' and the iteration space of the original loop.; // Return std::nullopt if unable to compute the set of subranges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:179,Integrability,wrap,wrapping,179,"// I think we can be more aggressive here and make this nuw / nsw if the; // addition that feeds into the icmp for the latch's terminating branch is nuw; // / nsw. In any case, a wrapping 2's complement addition is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:215,Safety,safe,safe,215,"// I think we can be more aggressive here and make this nuw / nsw if the; // addition that feeds into the icmp for the latch's terminating branch is nuw; // / nsw. In any case, a wrapping 2's complement addition is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:141,Modifiability,variab,variable,141,"// We compute `Smallest` and `Greatest` such that [Smallest, Greatest), or; // [Smallest, GreatestSeen] is the range of values the induction variable; // takes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:106,Modifiability,variab,variable,106,"// These two computations may sign-overflow. Here is why that is okay:; //; // We know that the induction variable does not sign-overflow on any; // iteration except the last one, and it starts at `Start` and ends at; // `End`, decrementing by one every time.; //; // * if `Smallest` sign-overflows we know `End` is `INT_SMAX`. Since the; // induction variable is decreasing we know that the smallest value; // the loop body is actually executed with is `INT_SMIN` == `Smallest`.; //; // * if `Greatest` sign-overflows, we know it can only be `INT_SMIN`. In; // that case, `Clamp` will always return `Smallest` and; // [`Result.LowLimit`, `Result.HighLimit`) = [`Smallest`, `Smallest`); // will be an empty range. Returning an empty range is always safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:352,Modifiability,variab,variable,352,"// These two computations may sign-overflow. Here is why that is okay:; //; // We know that the induction variable does not sign-overflow on any; // iteration except the last one, and it starts at `Start` and ends at; // `End`, decrementing by one every time.; //; // * if `Smallest` sign-overflows we know `End` is `INT_SMAX`. Since the; // induction variable is decreasing we know that the smallest value; // the loop body is actually executed with is `INT_SMIN` == `Smallest`.; //; // * if `Greatest` sign-overflows, we know it can only be `INT_SMIN`. In; // that case, `Clamp` will always return `Smallest` and; // [`Result.LowLimit`, `Result.HighLimit`) = [`Smallest`, `Smallest`); // will be an empty range. Returning an empty range is always safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:749,Safety,safe,safe,749,"// These two computations may sign-overflow. Here is why that is okay:; //; // We know that the induction variable does not sign-overflow on any; // iteration except the last one, and it starts at `Start` and ends at; // `End`, decrementing by one every time.; //; // * if `Smallest` sign-overflows we know `End` is `INT_SMAX`. Since the; // induction variable is decreasing we know that the smallest value; // the loop body is actually executed with is `INT_SMIN` == `Smallest`.; //; // * if `Greatest` sign-overflows, we know it can only be `INT_SMIN`. In; // that case, `Clamp` will always return `Smallest` and; // [`Result.LowLimit`, `Result.HighLimit`) = [`Smallest`, `Smallest`); // will be an empty range. Returning an empty range is always safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:61,Modifiability,variab,variable,61,"/// Computes and returns a range of values for the induction variable (IndVar); /// in which the range check can be safely elided. If it cannot compute such a; /// range, returns std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:116,Safety,safe,safely,116,"/// Computes and returns a range of values for the induction variable (IndVar); /// in which the range check can be safely elided. If it cannot compute such a; /// range, returns std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:688,Integrability,depend,depending,688,"// IndVar is of the form ""A + B * I"" (where ""I"" is the canonical induction; // variable, that may or may not exist as a real llvm::Value in the loop) and; // this inductive range check is a range check on the ""C + D * I"" (""C"" is; // getBegin() and ""D"" is getStep()). We rewrite the value being range; // checked to ""M + N * IndVar"" where ""N"" = ""D * B^(-1)"" and ""M"" = ""C - NA"".; //; // The actual inequalities we solve are of the form; //; // 0 <= M + 1 * IndVar < L given L >= 0 (i.e. N == 1); //; // Here L stands for upper limit of the safe iteration space.; // The inequality is satisfied by (0 - M) <= IndVar < (L - M). To avoid; // overflows when calculating (0 - M) and (L - M) we, depending on type of; // IV's iteration space, limit the calculations by borders of the iteration; // space. For example, if IndVar is unsigned, (0 - M) overflows for any M > 0.; // If we figured out that ""anything greater than (-M) is safe"", we strengthen; // this to ""everything greater than 0 is safe"", assuming that values between; // -M and 0 just do not exist in unsigned iteration space, and we don't want; // to deal with overflown values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:79,Modifiability,variab,variable,79,"// IndVar is of the form ""A + B * I"" (where ""I"" is the canonical induction; // variable, that may or may not exist as a real llvm::Value in the loop) and; // this inductive range check is a range check on the ""C + D * I"" (""C"" is; // getBegin() and ""D"" is getStep()). We rewrite the value being range; // checked to ""M + N * IndVar"" where ""N"" = ""D * B^(-1)"" and ""M"" = ""C - NA"".; //; // The actual inequalities we solve are of the form; //; // 0 <= M + 1 * IndVar < L given L >= 0 (i.e. N == 1); //; // Here L stands for upper limit of the safe iteration space.; // The inequality is satisfied by (0 - M) <= IndVar < (L - M). To avoid; // overflows when calculating (0 - M) and (L - M) we, depending on type of; // IV's iteration space, limit the calculations by borders of the iteration; // space. For example, if IndVar is unsigned, (0 - M) overflows for any M > 0.; // If we figured out that ""anything greater than (-M) is safe"", we strengthen; // this to ""everything greater than 0 is safe"", assuming that values between; // -M and 0 just do not exist in unsigned iteration space, and we don't want; // to deal with overflown values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:270,Modifiability,rewrite,rewrite,270,"// IndVar is of the form ""A + B * I"" (where ""I"" is the canonical induction; // variable, that may or may not exist as a real llvm::Value in the loop) and; // this inductive range check is a range check on the ""C + D * I"" (""C"" is; // getBegin() and ""D"" is getStep()). We rewrite the value being range; // checked to ""M + N * IndVar"" where ""N"" = ""D * B^(-1)"" and ""M"" = ""C - NA"".; //; // The actual inequalities we solve are of the form; //; // 0 <= M + 1 * IndVar < L given L >= 0 (i.e. N == 1); //; // Here L stands for upper limit of the safe iteration space.; // The inequality is satisfied by (0 - M) <= IndVar < (L - M). To avoid; // overflows when calculating (0 - M) and (L - M) we, depending on type of; // IV's iteration space, limit the calculations by borders of the iteration; // space. For example, if IndVar is unsigned, (0 - M) overflows for any M > 0.; // If we figured out that ""anything greater than (-M) is safe"", we strengthen; // this to ""everything greater than 0 is safe"", assuming that values between; // -M and 0 just do not exist in unsigned iteration space, and we don't want; // to deal with overflown values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:538,Safety,safe,safe,538,"// IndVar is of the form ""A + B * I"" (where ""I"" is the canonical induction; // variable, that may or may not exist as a real llvm::Value in the loop) and; // this inductive range check is a range check on the ""C + D * I"" (""C"" is; // getBegin() and ""D"" is getStep()). We rewrite the value being range; // checked to ""M + N * IndVar"" where ""N"" = ""D * B^(-1)"" and ""M"" = ""C - NA"".; //; // The actual inequalities we solve are of the form; //; // 0 <= M + 1 * IndVar < L given L >= 0 (i.e. N == 1); //; // Here L stands for upper limit of the safe iteration space.; // The inequality is satisfied by (0 - M) <= IndVar < (L - M). To avoid; // overflows when calculating (0 - M) and (L - M) we, depending on type of; // IV's iteration space, limit the calculations by borders of the iteration; // space. For example, if IndVar is unsigned, (0 - M) overflows for any M > 0.; // If we figured out that ""anything greater than (-M) is safe"", we strengthen; // this to ""everything greater than 0 is safe"", assuming that values between; // -M and 0 just do not exist in unsigned iteration space, and we don't want; // to deal with overflown values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:627,Safety,avoid,avoid,627,"// IndVar is of the form ""A + B * I"" (where ""I"" is the canonical induction; // variable, that may or may not exist as a real llvm::Value in the loop) and; // this inductive range check is a range check on the ""C + D * I"" (""C"" is; // getBegin() and ""D"" is getStep()). We rewrite the value being range; // checked to ""M + N * IndVar"" where ""N"" = ""D * B^(-1)"" and ""M"" = ""C - NA"".; //; // The actual inequalities we solve are of the form; //; // 0 <= M + 1 * IndVar < L given L >= 0 (i.e. N == 1); //; // Here L stands for upper limit of the safe iteration space.; // The inequality is satisfied by (0 - M) <= IndVar < (L - M). To avoid; // overflows when calculating (0 - M) and (L - M) we, depending on type of; // IV's iteration space, limit the calculations by borders of the iteration; // space. For example, if IndVar is unsigned, (0 - M) overflows for any M > 0.; // If we figured out that ""anything greater than (-M) is safe"", we strengthen; // this to ""everything greater than 0 is safe"", assuming that values between; // -M and 0 just do not exist in unsigned iteration space, and we don't want; // to deal with overflown values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:924,Safety,safe,safe,924,"// IndVar is of the form ""A + B * I"" (where ""I"" is the canonical induction; // variable, that may or may not exist as a real llvm::Value in the loop) and; // this inductive range check is a range check on the ""C + D * I"" (""C"" is; // getBegin() and ""D"" is getStep()). We rewrite the value being range; // checked to ""M + N * IndVar"" where ""N"" = ""D * B^(-1)"" and ""M"" = ""C - NA"".; //; // The actual inequalities we solve are of the form; //; // 0 <= M + 1 * IndVar < L given L >= 0 (i.e. N == 1); //; // Here L stands for upper limit of the safe iteration space.; // The inequality is satisfied by (0 - M) <= IndVar < (L - M). To avoid; // overflows when calculating (0 - M) and (L - M) we, depending on type of; // IV's iteration space, limit the calculations by borders of the iteration; // space. For example, if IndVar is unsigned, (0 - M) overflows for any M > 0.; // If we figured out that ""anything greater than (-M) is safe"", we strengthen; // this to ""everything greater than 0 is safe"", assuming that values between; // -M and 0 just do not exist in unsigned iteration space, and we don't want; // to deal with overflown values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:987,Safety,safe,safe,987,"// IndVar is of the form ""A + B * I"" (where ""I"" is the canonical induction; // variable, that may or may not exist as a real llvm::Value in the loop) and; // this inductive range check is a range check on the ""C + D * I"" (""C"" is; // getBegin() and ""D"" is getStep()). We rewrite the value being range; // checked to ""M + N * IndVar"" where ""N"" = ""D * B^(-1)"" and ""M"" = ""C - NA"".; //; // The actual inequalities we solve are of the form; //; // 0 <= M + 1 * IndVar < L given L >= 0 (i.e. N == 1); //; // Here L stands for upper limit of the safe iteration space.; // The inequality is satisfied by (0 - M) <= IndVar < (L - M). To avoid; // overflows when calculating (0 - M) and (L - M) we, depending on type of; // IV's iteration space, limit the calculations by borders of the iteration; // space. For example, if IndVar is unsigned, (0 - M) overflows for any M > 0.; // If we figured out that ""anything greater than (-M) is safe"", we strengthen; // this to ""everything greater than 0 is safe"", assuming that values between; // -M and 0 just do not exist in unsigned iteration space, and we don't want; // to deal with overflown values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:488,Integrability,depend,depending,488,"// Subtract Y from X so that it does not go through border of the IV; // iteration space. Mathematically, it is equivalent to:; //; // ClampedSubtract(X, Y) = min(max(X - Y, INT_MIN), INT_MAX). [1]; //; // In [1], 'X - Y' is a mathematical subtraction (result is not bounded to; // any width of bit grid). But after we take min/max, the result is; // guaranteed to be within [INT_MIN, INT_MAX].; //; // In [1], INT_MAX and INT_MIN are respectively signed and unsigned max/min; // values, depending on type of latch condition that defines IV iteration; // space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:241,Safety,safe,safely,241,"// X is a number from signed range, Y is interpreted as signed.; // Even if Y is SINT_MAX, (X - Y) does not reach SINT_MIN. So the only; // thing we should care about is that we didn't cross SINT_MAX.; // So, if Y is positive, we subtract Y safely.; // Rule 1: Y > 0 ---> Y.; // If 0 <= -Y <= (SINT_MAX - X), we subtract Y safely.; // Rule 2: Y >=s (X - SINT_MAX) ---> Y.; // If 0 <= (SINT_MAX - X) < -Y, we can only subtract (X - SINT_MAX).; // Rule 3: Y <s (X - SINT_MAX) ---> (X - SINT_MAX).; // It gives us smax(Y, X - SINT_MAX) to subtract in all cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:323,Safety,safe,safely,323,"// X is a number from signed range, Y is interpreted as signed.; // Even if Y is SINT_MAX, (X - Y) does not reach SINT_MIN. So the only; // thing we should care about is that we didn't cross SINT_MAX.; // So, if Y is positive, we subtract Y safely.; // Rule 1: Y > 0 ---> Y.; // If 0 <= -Y <= (SINT_MAX - X), we subtract Y safely.; // Rule 2: Y >=s (X - SINT_MAX) ---> Y.; // If 0 <= (SINT_MAX - X) < -Y, we can only subtract (X - SINT_MAX).; // Rule 3: Y <s (X - SINT_MAX) ---> (X - SINT_MAX).; // It gives us smax(Y, X - SINT_MAX) to subtract in all cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:239,Safety,safe,safely,239,"// X is a number from unsigned range, Y is interpreted as signed.; // Even if Y is SINT_MIN, (X - Y) does not reach UINT_MAX. So the only; // thing we should care about is that we didn't cross zero.; // So, if Y is negative, we subtract Y safely.; // Rule 1: Y <s 0 ---> Y.; // If 0 <= Y <= X, we subtract Y safely.; // Rule 2: Y <=s X ---> Y.; // If 0 <= X < Y, we should stop at 0 and can only subtract X.; // Rule 3: Y >s X ---> X.; // It gives us smin(X, Y) to subtract in all cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:308,Safety,safe,safely,308,"// X is a number from unsigned range, Y is interpreted as signed.; // Even if Y is SINT_MIN, (X - Y) does not reach UINT_MAX. So the only; // thing we should care about is that we didn't cross zero.; // So, if Y is negative, we subtract Y safely.; // Rule 1: Y <s 0 ---> Y.; // If 0 <= Y <= X, we subtract Y safely.; // Rule 2: Y <=s X ---> Y.; // If 0 <= X < Y, we should stop at 0 and can only subtract X.; // Rule 3: Y >s X ---> X.; // It gives us smin(X, Y) to subtract in all cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:442,Safety,safe,safe,442,"// FIXME: Current implementation of ClampedSubtract implicitly assumes that; // X is non-negative (in sense of a signed value). We need to re-implement; // this function in a way that it will correctly handle negative X as well.; // We use it twice: for X = 0 everything is fine, but for X = getEnd() we can; // end up with a negative X and produce wrong results. So currently we ensure; // that if getEnd() is negative then both ends of the safe range are zero.; // Note that this may pessimize elimination of unsigned range checks against; // negative values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:24,Modifiability,extend,extended,24,// End is computed with extended type but will be truncated to a narrow one; // type of range check. Therefore we need a check that the result will not; // overflow in terms of narrow type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:105,Usability,simpl,simple,105,// TODO: we could widen the smaller range and have this work; but for now we; // bail out to keep things simple.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:105,Usability,simpl,simple,105,// TODO: we could widen the smaller range and have this work; but for now we; // bail out to keep things simple.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:205,Safety,safe,safe,205,"// Basing on the type of latch predicate, we interpret the IV iteration range; // as signed or unsigned range. We use different min/max functions (signed or; // unsigned) when intersecting this range with safe iteration ranges implied; // by range checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:25,Availability,redundant,redundant,25,// Optimize away the now-redundant range checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:3,Performance,Optimiz,Optimize,3,// Optimize away the now-redundant range checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:25,Safety,redund,redundant,25,// Optimize away the now-redundant range checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:1034,Integrability,depend,dependence,1034,"//===- IndVarSimplify.cpp - Induction Variable Elimination ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into simpler forms suitable for subsequent; // analysis and transformation.; //; // If the trip count of a loop is computable, this pass also makes the following; // changes:; // 1. The exit condition for the loop is canonicalized to compare the; // induction value against the exit value. This turns loops like:; // 'for (i = 7; i*i < 1000; ++i)' into 'for (i = 0; i != 25; ++i)'; // 2. Any use outside of the loop of an expression derived from the indvar; // is changed to compute the derived value outside of the loop, eliminating; // the dependence on the exit value of the induction variable. If the only; // purpose of the loop is to compute the exit value of some derived; // expression, this transformation will make the loop dead.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:38,Modifiability,Variab,Variable,38,"//===- IndVarSimplify.cpp - Induction Variable Elimination ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into simpler forms suitable for subsequent; // analysis and transformation.; //; // If the trip count of a loop is computable, this pass also makes the following; // changes:; // 1. The exit condition for the loop is canonicalized to compare the; // induction value against the exit value. This turns loops like:; // 'for (i = 7; i*i < 1000; ++i)' into 'for (i = 0; i != 25; ++i)'; // 2. Any use outside of the loop of an expression derived from the indvar; // is changed to compute the derived value outside of the loop, eliminating; // the dependence on the exit value of the induction variable. If the only; // purpose of the loop is to compute the exit value of some derived; // expression, this transformation will make the loop dead.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:441,Modifiability,variab,variables,441,"//===- IndVarSimplify.cpp - Induction Variable Elimination ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into simpler forms suitable for subsequent; // analysis and transformation.; //; // If the trip count of a loop is computable, this pass also makes the following; // changes:; // 1. The exit condition for the loop is canonicalized to compare the; // induction value against the exit value. This turns loops like:; // 'for (i = 7; i*i < 1000; ++i)' into 'for (i = 0; i != 25; ++i)'; // 2. Any use outside of the loop of an expression derived from the indvar; // is changed to compute the derived value outside of the loop, eliminating; // the dependence on the exit value of the induction variable. If the only; // purpose of the loop is to compute the exit value of some derived; // expression, this transformation will make the loop dead.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:1080,Modifiability,variab,variable,1080,"//===- IndVarSimplify.cpp - Induction Variable Elimination ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into simpler forms suitable for subsequent; // analysis and transformation.; //; // If the trip count of a loop is computable, this pass also makes the following; // changes:; // 1. The exit condition for the loop is canonicalized to compare the; // induction value against the exit value. This turns loops like:; // 'for (i = 7; i*i < 1000; ++i)' into 'for (i = 0; i != 25; ++i)'; // 2. Any use outside of the loop of an expression derived from the indvar; // is changed to compute the derived value outside of the loop, eliminating; // the dependence on the exit value of the induction variable. If the only; // purpose of the loop is to compute the exit value of some derived; // expression, this transformation will make the loop dead.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:497,Usability,simpl,simpler,497,"//===- IndVarSimplify.cpp - Induction Variable Elimination ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into simpler forms suitable for subsequent; // analysis and transformation.; //; // If the trip count of a loop is computable, this pass also makes the following; // changes:; // 1. The exit condition for the loop is canonicalized to compare the; // induction value against the exit value. This turns loops like:; // 'for (i = 7; i*i < 1000; ++i)' into 'for (i = 0; i != 25; ++i)'; // 2. Any use outside of the loop of an expression derived from the indvar; // is changed to compute the derived value outside of the loop, eliminating; // the dependence on the exit value of the induction variable. If the only; // purpose of the loop is to compute the exit value of some derived; // expression, this transformation will make the loop dead.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:192,Usability,simpl,simplifyAndExtend,192,/// Try to improve our exit conditions by converting condition from signed; /// to unsigned or rotating computation out of the loop.; /// (See inline comment about why this is duplicated from simplifyAndExtend),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:31,Testability,test,tests,31,/// Try to form loop invariant tests for loop exits by changing how many; /// iterations of the loop run when that is unobservable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:113,Modifiability,rewrite,rewriteNonIntegerIVs,113,"// end anonymous namespace; //===----------------------------------------------------------------------===//; // rewriteNonIntegerIVs and helpers. Prefer integer IVs.; //===----------------------------------------------------------------------===//; /// Convert APF to an integer, if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:39,Modifiability,variab,variable,39,"/// If the loop has floating induction variable then insert corresponding; /// integer induction variable if possible.; /// For example,; /// for(double i = 0; i < 10000; ++i); /// bar(i); /// is converted into; /// for(int i = 0; i < 10000; ++i); /// bar((double)i);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:97,Modifiability,variab,variable,97,"/// If the loop has floating induction variable then insert corresponding; /// integer induction variable if possible.; /// For example,; /// for(double i = 0; i < 10000; ++i); /// bar(i); /// is converted into; /// for(int i = 0; i < 10000; ++i); /// bar((double)i);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:43,Modifiability,variab,variable,43,// We convert the floating point induction variable to a signed i32 value if; // we can. This is only safe if the comparison will not overflow in a way; // that won't be trapped by the integer equivalent operations. Check for this; // now.; // TODO: We could use i64 if it is native and the range requires it.; // The start/stride/exit values must all fit in signed i32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:102,Safety,safe,safe,102,// We convert the floating point induction variable to a signed i32 value if; // we can. This is only safe if the comparison will not overflow in a way; // that won't be trapped by the integer equivalent operations. Check for this; // now.; // TODO: We could use i64 if it is native and the range requires it.; // The start/stride/exit values must all fit in signed i32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:42,Safety,avoid,avoid,42,"// If not actually striding (add x, 0.0), avoid touching the code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:48,Safety,safe,safety,48,// Positive and negative strides have different safety conditions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:140,Integrability,wrap,wrap,140,"// If this is an equality comparison, we require that the strided value; // exactly land on the exit value, otherwise the IV condition will wrap; // around and do things the fp IV wouldn't.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:23,Integrability,wrap,wrap,23,"// If the stride would wrap around the i32 before exiting, we can't; // transform the IV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:140,Integrability,wrap,wrap,140,"// If this is an equality comparison, we require that the strided value; // exactly land on the exit value, otherwise the IV condition will wrap; // around and do things the fp IV wouldn't.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:23,Integrability,wrap,wrap,23,"// If the stride would wrap around the i32 before exiting, we can't; // transform the IV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:32,Modifiability,variab,variable,32,// Insert new integer induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:23,Modifiability,variab,variable,23,"// If the FP induction variable still has uses, this is because something else; // in the loop uses its value. In order to canonicalize the induction; // variable, we chose to eliminate the IV and rewrite it in terms of an; // int->fp cast.; //; // We give preference to sitofp over uitofp because it is faster on most; // platforms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:154,Modifiability,variab,variable,154,"// If the FP induction variable still has uses, this is because something else; // in the loop uses its value. In order to canonicalize the induction; // variable, we chose to eliminate the IV and rewrite it in terms of an; // int->fp cast.; //; // We give preference to sitofp over uitofp because it is faster on most; // platforms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:197,Modifiability,rewrite,rewrite,197,"// If the FP induction variable still has uses, this is because something else; // in the loop uses its value. In order to canonicalize the induction; // variable, we chose to eliminate the IV and rewrite it in terms of an; // int->fp cast.; //; // We give preference to sitofp over uitofp because it is faster on most; // platforms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:165,Integrability,rout,routines,165,"// First step. Check to see if there are any floating-point recurrences.; // If there are, change them into integer recurrences, permitting analysis by; // the SCEV routines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:84,Modifiability,rewrite,rewriteFirstIterationLoopExitValues,84,"//===---------------------------------------------------------------------===//; // rewriteFirstIterationLoopExitValues: Rewrite loop exit values if we know; // they will exit at the first iteration.; //===---------------------------------------------------------------------===//; /// Check to see if this loop has loop invariant conditions which lead to loop; /// exits. If so, we know that if the exit path is taken, it is at the first; /// loop iteration. This lets us predict exit values of PHI nodes that live in; /// loop header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:121,Modifiability,Rewrite,Rewrite,121,"//===---------------------------------------------------------------------===//; // rewriteFirstIterationLoopExitValues: Rewrite loop exit values if we know; // they will exit at the first iteration.; //===---------------------------------------------------------------------===//; /// Check to see if this loop has loop invariant conditions which lead to loop; /// exits. If so, we know that if the exit path is taken, it is at the first; /// loop iteration. This lets us predict exit values of PHI nodes that live in; /// loop header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:473,Safety,predict,predict,473,"//===---------------------------------------------------------------------===//; // rewriteFirstIterationLoopExitValues: Rewrite loop exit values if we know; // they will exit at the first iteration.; //===---------------------------------------------------------------------===//; /// Check to see if this loop has loop invariant conditions which lead to loop; /// exits. If so, we know that if the exit path is taken, it is at the first; /// loop iteration. This lets us predict exit values of PHI nodes that live in; /// loop header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:238,Deployability,Update,Update,238,//===----------------------------------------------------------------------===//; // IV Widening - Extend the width of an IV to cover its widest uses.; //===----------------------------------------------------------------------===//; /// Update information about the induction variable that is extended by this; /// sign or zero extend operation. This is used to determine the final width of; /// the IV before actually widening it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:99,Modifiability,Extend,Extend,99,//===----------------------------------------------------------------------===//; // IV Widening - Extend the width of an IV to cover its widest uses.; //===----------------------------------------------------------------------===//; /// Update information about the induction variable that is extended by this; /// sign or zero extend operation. This is used to determine the final width of; /// the IV before actually widening it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:277,Modifiability,variab,variable,277,//===----------------------------------------------------------------------===//; // IV Widening - Extend the width of an IV to cover its widest uses.; //===----------------------------------------------------------------------===//; /// Update information about the induction variable that is extended by this; /// sign or zero extend operation. This is used to determine the final width of; /// the IV before actually widening it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:294,Modifiability,extend,extended,294,//===----------------------------------------------------------------------===//; // IV Widening - Extend the width of an IV to cover its widest uses.; //===----------------------------------------------------------------------===//; /// Update information about the induction variable that is extended by this; /// sign or zero extend operation. This is used to determine the final width of; /// the IV before actually widening it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:329,Modifiability,extend,extend,329,//===----------------------------------------------------------------------===//; // IV Widening - Extend the width of an IV to cover its widest uses.; //===----------------------------------------------------------------------===//; /// Update information about the induction variable that is extended by this; /// sign or zero extend operation. This is used to determine the final width of; /// the IV before actually widening it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:30,Modifiability,extend,extends,30,"// Check that `Cast` actually extends the induction variable (we rely on this; // later). This takes care of cases where `Cast` is extending a truncation of; // the narrow induction variable, and thus can end up being narrower than the; // ""narrow"" induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:52,Modifiability,variab,variable,52,"// Check that `Cast` actually extends the induction variable (we rely on this; // later). This takes care of cases where `Cast` is extending a truncation of; // the narrow induction variable, and thus can end up being narrower than the; // ""narrow"" induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:131,Modifiability,extend,extending,131,"// Check that `Cast` actually extends the induction variable (we rely on this; // later). This takes care of cases where `Cast` is extending a truncation of; // the narrow induction variable, and thus can end up being narrower than the; // ""narrow"" induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:182,Modifiability,variab,variable,182,"// Check that `Cast` actually extends the induction variable (we rely on this; // later). This takes care of cases where `Cast` is extending a truncation of; // the narrow induction variable, and thus can end up being narrower than the; // ""narrow"" induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:259,Modifiability,variab,variable,259,"// Check that `Cast` actually extends the induction variable (we rely on this; // later). This takes care of cases where `Cast` is extending a truncation of; // the narrow induction variable, and thus can end up being narrower than the; // ""narrow"" induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:276,Modifiability,variab,variable,276,// Cast is either an sext or zext up to this point.; // We should not widen an indvar if arithmetics on the wider indvar are more; // expensive than those on the narrower indvar. We check only the cost of ADD; // because at least an ADD is required to increment the induction variable. We; // could compute more comprehensively the cost of all instructions on the; // induction variable when necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:378,Modifiability,variab,variable,378,// Cast is either an sext or zext up to this point.; // We should not widen an indvar if arithmetics on the wider indvar are more; // expensive than those on the narrower indvar. We check only the cost of ADD; // because at least an ADD is required to increment the induction variable. We; // could compute more comprehensively the cost of all instructions on the; // induction variable when necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:6,Modifiability,extend,extend,6,"// We extend the IV to satisfy the sign of its user(s), or 'signed'; // if there are multiple users with both sign- and zero extensions,; // in order not to introduce nondeterministic behaviour based on the; // unspecified order of a PHI nodes' users-iterator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:308,Usability,Simpl,Simplification,308,//===----------------------------------------------------------------------===//; // Live IV Reduction - Minimize IVs live across the loop.; //===----------------------------------------------------------------------===//; //===----------------------------------------------------------------------===//; // Simplification of IV users based on SCEV evaluation.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:17,Integrability,interface,interface,17,// Implement the interface used by simplifyUsersOfIV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:35,Usability,simpl,simplifyUsersOfIV,35,// Implement the interface used by simplifyUsersOfIV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:230,Modifiability,extend,extend,230,// end anonymous namespace; /// Iteratively perform simplification on a worklist of IV users. Each; /// successive simplification may push more users which may themselves be; /// candidates for simplification.; ///; /// Sign/Zero extend elimination is interleaved with IV simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:44,Performance,perform,perform,44,// end anonymous namespace; /// Iteratively perform simplification on a worklist of IV users. Each; /// successive simplification may push more users which may themselves be; /// candidates for simplification.; ///; /// Sign/Zero extend elimination is interleaved with IV simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:52,Usability,simpl,simplification,52,// end anonymous namespace; /// Iteratively perform simplification on a worklist of IV users. Each; /// successive simplification may push more users which may themselves be; /// candidates for simplification.; ///; /// Sign/Zero extend elimination is interleaved with IV simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:115,Usability,simpl,simplification,115,// end anonymous namespace; /// Iteratively perform simplification on a worklist of IV users. Each; /// successive simplification may push more users which may themselves be; /// candidates for simplification.; ///; /// Sign/Zero extend elimination is interleaved with IV simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:194,Usability,simpl,simplification,194,// end anonymous namespace; /// Iteratively perform simplification on a worklist of IV users. Each; /// successive simplification may push more users which may themselves be; /// candidates for simplification.; ///; /// Sign/Zero extend elimination is interleaved with IV simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:272,Usability,simpl,simplification,272,// end anonymous namespace; /// Iteratively perform simplification on a worklist of IV users. Each; /// successive simplification may push more users which may themselves be; /// candidates for simplification.; ///; /// Sign/Zero extend elimination is interleaved with IV simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:17,Usability,simpl,simplification,17,"// Each round of simplification iterates through the SimplifyIVUsers worklist; // for all current phis, then determines whether any IVs can be; // widened. Widening adds new phis to LoopPhis, inducing another round of; // simplification on the wide IVs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:53,Usability,Simpl,SimplifyIVUsers,53,"// Each round of simplification iterates through the SimplifyIVUsers worklist; // for all current phis, then determines whether any IVs can be; // widened. Widening adds new phis to LoopPhis, inducing another round of; // simplification on the wide IVs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:222,Usability,simpl,simplification,222,"// Each round of simplification iterates through the SimplifyIVUsers worklist; // for all current phis, then determines whether any IVs can be; // widened. Widening adds new phis to LoopPhis, inducing another round of; // simplification on the wide IVs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:103,Integrability,wrap,wrap,103,"// Evaluate as many IV expressions as possible before widening any IVs. This; // forces SCEV to set no-wrap flags before evaluating sign/zero; // extension. The first time SCEV attempts to normalize sign/zero extension,; // the result becomes final. So for the most predictable results, we delay; // evaluation of sign/zero extend evaluation until needed, and avoid running; // other SCEV based analysis prior to simplifyAndExtend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:324,Modifiability,extend,extend,324,"// Evaluate as many IV expressions as possible before widening any IVs. This; // forces SCEV to set no-wrap flags before evaluating sign/zero; // extension. The first time SCEV attempts to normalize sign/zero extension,; // the result becomes final. So for the most predictable results, we delay; // evaluation of sign/zero extend evaluation until needed, and avoid running; // other SCEV based analysis prior to simplifyAndExtend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:266,Safety,predict,predictable,266,"// Evaluate as many IV expressions as possible before widening any IVs. This; // forces SCEV to set no-wrap flags before evaluating sign/zero; // extension. The first time SCEV attempts to normalize sign/zero extension,; // the result becomes final. So for the most predictable results, we delay; // evaluation of sign/zero extend evaluation until needed, and avoid running; // other SCEV based analysis prior to simplifyAndExtend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:360,Safety,avoid,avoid,360,"// Evaluate as many IV expressions as possible before widening any IVs. This; // forces SCEV to set no-wrap flags before evaluating sign/zero; // extension. The first time SCEV attempts to normalize sign/zero extension,; // the result becomes final. So for the most predictable results, we delay; // evaluation of sign/zero extend evaluation until needed, and avoid running; // other SCEV based analysis prior to simplifyAndExtend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:413,Usability,simpl,simplifyAndExtend,413,"// Evaluate as many IV expressions as possible before widening any IVs. This; // forces SCEV to set no-wrap flags before evaluating sign/zero; // extension. The first time SCEV attempts to normalize sign/zero extension,; // the result becomes final. So for the most predictable results, we delay; // evaluation of sign/zero extend evaluation until needed, and avoid running; // other SCEV based analysis prior to simplifyAndExtend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:124,Modifiability,Rewrite,Rewrite,124,"//===----------------------------------------------------------------------===//; // linearFunctionTestReplace and its kin. Rewrite the loop exit condition.; //===----------------------------------------------------------------------===//; /// Given an Value which is hoped to be part of an add recurance in the given; /// loop, return the associated Phi node if so. Otherwise, return null. Note; /// that this is less general than SCEVs AddRec checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:34,Testability,test,test,34,/// Whether the current loop exit test is based on this value. Currently this; /// is limited to a direct use in the loop condition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:29,Testability,test,test,29,// TODO: Allow non-icmp loop test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:96,Testability,test,test,96,/// linearFunctionTestReplace policy. Return true unless we can show that the; /// current exit test is already sufficiently canonical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:115,Performance,cache,cached,115,// Avoid converting a constant or loop invariant test back to a runtime; // test. This is critical for when SCEV's cached ExitCount is less precise; // than the current IR (such as after we've proven a particular exit is; // actually dead and thus the BE count never reaches our ExitCount.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:3,Safety,Avoid,Avoid,3,// Avoid converting a constant or loop invariant test back to a runtime; // test. This is critical for when SCEV's cached ExitCount is less precise; // than the current IR (such as after we've proven a particular exit is; // actually dead and thus the BE count never reaches our ExitCount.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:49,Testability,test,test,49,// Avoid converting a constant or loop invariant test back to a runtime; // test. This is critical for when SCEV's cached ExitCount is less precise; // than the current IR (such as after we've proven a particular exit is; // actually dead and thus the BE count never reaches our ExitCount.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:76,Testability,test,test,76,// Avoid converting a constant or loop invariant test back to a runtime; // test. This is critical for when SCEV's cached ExitCount is less precise; // than the current IR (such as after we've proven a particular exit is; // actually dead and thus the BE count never reaches our ExitCount.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:14,Usability,simpl,simplify,14,// Do LFTR to simplify the exit condition to an ICMP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:14,Usability,simpl,simplify,14,// Do LFTR to simplify the exit ICMP to EQ/NE,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:14,Usability,simpl,simple,14,// Look for a simple IV counter LHS,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:49,Usability,simpl,simple,49,// Do LFTR if the exit condition's IV is *not* a simple counter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:84,Availability,down,down,84,"/// Recursive helper for hasConcreteDef(). Unfortunately, this currently boils; /// down to checking that all operands are constant and listing instructions; /// that may hide undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:3,Performance,Load,Load,3,// Load and return values may be undef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:128,Availability,avail,available,128,"/// Search the loop header for a loop counter (anadd rec w/step of one); /// suitable for use by LFTR. If multiple counters are available, select the; /// ""best"" one based profitable heuristics.; ///; /// BECount may be an i8* pointer type. The pointer difference is already; /// valid count without scaling the address stride, so it remains a pointer; /// expression as far as SCEV is concerned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:49,Usability,simpl,simple,49,"// Loop over all of the PHI nodes, looking for a simple counter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:108,Testability,test,tests,108,"// AR may be a pointer type, while BECount is an integer type.; // AR may be wider than BECount. With eq/ne tests overflow is immaterial.; // AR may not be a narrower type, or we may never exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:3,Safety,Avoid,Avoid,3,// Avoid reusing a potentially undef value to compute other values that may; // have originally had a concrete definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:116,Performance,perform,performing,116,// We explicitly allow unknown phis as long as they are already used by; // the loop exit test. This is legal since performing LFTR could not; // increase the number of undef users.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:90,Testability,test,test,90,// We explicitly allow unknown phis as long as they are already used by; // the loop exit test. This is legal since performing LFTR could not; // increase the number of undef users.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:3,Safety,Avoid,Avoid,3,"// Avoid introducing undefined behavior due to poison which didn't exist in; // the original program. (Annoyingly, the rules for poison and undef; // propagation are distinct, so this does NOT cover the undef case above.); // We have to ensure that we don't introduce UB by introducing a use on an; // iteration where said IV produces poison. Our strategy here differs for; // pointers and integer IVs. For integers, we strip and reinfer as needed,; // see code in linearFunctionTestReplace. For pointers, we restrict; // transforms as there is no good way to reinfer inbounds once lost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:16,Modifiability,rewrite,rewrites,16,"/// This method rewrites the exit condition of the loop to be a canonical !=; /// comparison against the incremented loop induction variable. This pass is; /// able to rewrite the exit tests of any loop where the SCEV analysis can; /// determine a loop-invariant trip count of the loop, which is actually a much; /// broader range than just linear tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:132,Modifiability,variab,variable,132,"/// This method rewrites the exit condition of the loop to be a canonical !=; /// comparison against the incremented loop induction variable. This pass is; /// able to rewrite the exit tests of any loop where the SCEV analysis can; /// determine a loop-invariant trip count of the loop, which is actually a much; /// broader range than just linear tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:168,Modifiability,rewrite,rewrite,168,"/// This method rewrites the exit condition of the loop to be a canonical !=; /// comparison against the incremented loop induction variable. This pass is; /// able to rewrite the exit tests of any loop where the SCEV analysis can; /// determine a loop-invariant trip count of the loop, which is actually a much; /// broader range than just linear tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:185,Testability,test,tests,185,"/// This method rewrites the exit condition of the loop to be a canonical !=; /// comparison against the incremented loop induction variable. This pass is; /// able to rewrite the exit tests of any loop where the SCEV analysis can; /// determine a loop-invariant trip count of the loop, which is actually a much; /// broader range than just linear tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:348,Testability,test,tests,348,"/// This method rewrites the exit condition of the loop to be a canonical !=; /// comparison against the incremented loop induction variable. This pass is; /// able to rewrite the exit tests of any loop where the SCEV analysis can; /// determine a loop-invariant trip count of the loop, which is actually a much; /// broader range than just linear tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:157,Testability,test,test,157,"// For pointer IVs, we chose to not strip inbounds which requires us not; // to add a potentially UB introducing use. We need to either a) show; // the loop test we're modifying is already in post-inc form, or b) show; // that adding a use must not introduce UB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:721,Integrability,wrap,wraps,721,"// It may be necessary to drop nowrap flags on the incrementing instruction; // if either LFTR moves from a pre-inc check to a post-inc check (in which; // case the increment might have previously been poison on the last iteration; // only) or if LFTR switches to a different IV that was previously dynamically; // dead (and as such may be arbitrarily poison). We remove any nowrap flags; // that SCEV didn't infer for the post-inc addrec (even if we use a pre-inc; // check), because the pre-inc addrec flags may be adopted from the original; // instruction, while SCEV has to explicitly prove the post-inc nowrap flags.; // TODO: This handling is inaccurate for one case: If we switch to a; // dynamically dead IV that wraps on the first loop iteration only, which is; // not covered by the post-inc addrec. (If the new IV was not dynamically; // dead, it could not be poison on the first iteration in the first place.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:293,Integrability,wrap,wrap,293,"// For integer IVs, if we evaluated the limit in the narrower bitwidth to; // avoid the expensive expansion of the limit expression in the wider type,; // emit a truncate to narrow the IV to the ExitCount type. This is safe; // since we know (from the exit count bitwidth), that we can't self-wrap in; // the narrower type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:78,Safety,avoid,avoid,78,"// For integer IVs, if we evaluated the limit in the narrower bitwidth to; // avoid the expensive expansion of the limit expression in the wider type,; // emit a truncate to narrow the IV to the ExitCount type. This is safe; // since we know (from the exit count bitwidth), that we can't self-wrap in; // the narrower type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:219,Safety,safe,safe,219,"// For integer IVs, if we evaluated the limit in the narrower bitwidth to; // avoid the expensive expansion of the limit expression in the wider type,; // emit a truncate to narrow the IV to the ExitCount type. This is safe; // since we know (from the exit count bitwidth), that we can't self-wrap in; // the narrower type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:139,Modifiability,extend,extend,139,"// Before resorting to actually inserting the truncate, use the same; // reasoning as from SimplifyIndvar::eliminateTrunc to see if we can extend; // the other side of the comparison instead. We still evaluate the limit; // in the narrower bitwidth, we just prefer a zext/sext outside the loop to; // a truncate within in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:91,Usability,Simpl,SimplifyIndvar,91,"// Before resorting to actually inserting the truncate, use the same; // reasoning as from SimplifyIndvar::eliminateTrunc to see if we can extend; // the other side of the comparison instead. We still evaluate the limit; // in the narrower bitwidth, we just prefer a zext/sext outside the loop to; // a truncate within in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:222,Deployability,update,update,222,"// It's tempting to use replaceAllUsesWith here to fully replace the old; // comparison, but that's not immediately safe, since users of the old; // comparison may not be dominated by the new comparison. Instead, just; // update the branch to use the new comparison; in the common case this; // will make old comparison dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:116,Safety,safe,safe,116,"// It's tempting to use replaceAllUsesWith here to fully replace the old; // comparison, but that's not immediately safe, since users of the old; // comparison may not be dominated by the new comparison. Instead, just; // update the branch to use the new comparison; in the common case this; // will make old comparison dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:397,Energy Efficiency,reduce,reduce,397,"//===----------------------------------------------------------------------===//; // sinkUnusedInvariants. A late subpass to cleanup loop preheaders.; //===----------------------------------------------------------------------===//; /// If there's a single exit block, sink any loop-invariant values that; /// were defined in the preheader but not used inside the loop into the; /// exit block to reduce register pressure in the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:197,Modifiability,Refactor,Refactor,197,"// Don't sink alloca: we never want to sink static alloca's out of the; // entry block, and correctly sinking dynamic alloca's requires; // checks for stacksave/stackrestore intrinsics.; // FIXME: Refactor this check somehow?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:67,Usability,simpl,simplify,67,// Replacing with the preheader value will often allow IV users to simplify; // (especially if the preheader value is a constant).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:9,Usability,simpl,simplify,9,// Don't simplify instructions outside the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:80,Integrability,wrap,wrap,80,"// Semantically skip last iter is ""subtract 1, do not bother about unsigned; // wrap"". getLoopInvariantExitCondDuringFirstIterations knows how to deal; // with umin in a smart way, but umin(a, b) - 1 will likely not simplify.; // So we manually construct umin(a - 1, b - 1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:216,Usability,simpl,simplify,216,"// Semantically skip last iter is ""subtract 1, do not bother about unsigned; // wrap"". getLoopInvariantExitCondDuringFirstIterations knows how to deal; // with umin in a smart way, but umin(a, b) - 1 will likely not simplify.; // So we manually construct umin(a - 1, b - 1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:164,Testability,log,logic,164,"// For branch that stays in loop by TRUE condition, go through AND. For branch; // that stays in loop by FALSE condition, go through OR. Both gives the; // similar logic: ""stay in loop iff all conditions are true(false)"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:99,Safety,avoid,avoid,99,"// Go through AND/OR conditions. Collect leaf ICMPs. We only care about; // those with one use, to avoid instruction duplication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:288,Modifiability,extend,extending,288,"// Note: This is duplicating a particular part on SimplifyIndVars reasoning.; // We need to duplicate it because given icmp zext(small-iv), C, IVUsers; // never reaches the icmp since the zext doesn't fold to an AddRec unless; // it already has flags. The alternative to this would be to extending the; // set of ""interesting"" IV users to include the icmp, but doing that; // regresses results in practice by querying SCEVs before trip counts which; // rely on them which results in SCEV caching sub-optimal answers. The; // concern about caching sub-optimal results is why we only query SCEVs of; // the loop invariant RHS here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:50,Usability,Simpl,SimplifyIndVars,50,"// Note: This is duplicating a particular part on SimplifyIndVars reasoning.; // We need to duplicate it because given icmp zext(small-iv), C, IVUsers; // never reaches the icmp since the zext doesn't fold to an AddRec unless; // it already has flags. The alternative to this would be to extending the; // set of ""interesting"" IV users to include the icmp, but doing that; // regresses results in practice by querying SCEVs before trip counts which; // rely on them which results in SCEV caching sub-optimal answers. The; // concern about caching sub-optimal results is why we only query SCEVs of; // the loop invariant RHS here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:85,Performance,cache,cache,85,"// For the range reasoning, avoid computing SCEVs in the loop to avoid; // poisoning cache with sub-optimal results. For the must-execute case,; // this is a neccessary precondition for correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:28,Safety,avoid,avoid,28,"// For the range reasoning, avoid computing SCEVs in the loop to avoid; // poisoning cache with sub-optimal results. For the must-execute case,; // this is a neccessary precondition for correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:65,Safety,avoid,avoid,65,"// For the range reasoning, avoid computing SCEVs in the loop to avoid; // poisoning cache with sub-optimal results. For the must-execute case,; // this is a neccessary precondition for correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:8,Testability,log,logic,8,// Same logic applies for the inverse case,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:59,Modifiability,extend,extend,59,"// Now that we've canonicalized the condition to match the extend,; // see if we can rotate the extend out of the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:96,Modifiability,extend,extend,96,"// Now that we've canonicalized the condition to match the extend,; // see if we can rotate the extend out of the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:102,Deployability,update,update,102,// Same logic applies for the inverse case until we actually pick; // which operand of the compare to update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:8,Testability,log,logic,8,// Same logic applies for the inverse case until we actually pick; // which operand of the compare to update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:50,Modifiability,Extend,Extend,50,"// Match (icmp unsigned-cond zext, RHS); // TODO: Extend to handle corresponding sext/signed-cmp case; // TODO: Extend to other invertible functions",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:112,Modifiability,Extend,Extend,112,"// Match (icmp unsigned-cond zext, RHS); // TODO: Extend to handle corresponding sext/signed-cmp case; // TODO: Extend to other invertible functions",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:38,Modifiability,rewrite,rewriteable,38,// Remove all exits which aren't both rewriteable and execute on every; // iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:59,Modifiability,rewrite,rewrite,59,"// If our exitting block exits multiple loops, we can only rewrite the; // innermost one. Otherwise, we're changing how many times the innermost; // loop runs before it exits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:9,Modifiability,rewrite,rewrite,9,// Can't rewrite non-branch yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:441,Performance,Optimiz,OptimizeCond,441,"// TODO: We might have proved that we can skip the last iteration for; // this check. In this case, we only want to check the condition on the; // pre-last iteration (MaxBECount - 1). However, there is a nasty; // corner case:; //; // for (i = len; i != 0; i--) { ... check (i ult X) ... }; //; // If we could not prove that len != 0, then we also could not prove that; // (len - 1) is not a UINT_MAX. If we simply query (len - 1), then; // OptimizeCond will likely not prove anything for it, even if it could; // prove the same fact for len.; //; // As a temporary solution, we query both last and pre-last iterations in; // hope that we will be able to prove triviality for at least one of; // them. We can stop querying MaxBECount for this case once SCEV; // understands that (MaxBECount - 1) will not overflow here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:408,Usability,simpl,simply,408,"// TODO: We might have proved that we can skip the last iteration for; // this check. In this case, we only want to check the condition on the; // pre-last iteration (MaxBECount - 1). However, there is a nasty; // corner case:; //; // for (i = len; i != 0; i--) { ... check (i ult X) ... }; //; // If we could not prove that len != 0, then we also could not prove that; // (len - 1) is not a UINT_MAX. If we simply query (len - 1), then; // OptimizeCond will likely not prove anything for it, even if it could; // prove the same fact for len.; //; // As a temporary solution, we query both last and pre-last iterations in; // hope that we will be able to prove triviality for at least one of; // them. We can stop querying MaxBECount for this case once SCEV; // understands that (MaxBECount - 1) will not overflow here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:48,Modifiability,rewrite,rewrite,48,"// If we know we'd exit on the first iteration, rewrite the exit to; // reflect this. This does not imply the loop must exit through this; // exit; there may be an earlier one taken on the first iteration.; // We know that the backedge can't be taken, so we replace all; // the header PHIs with values coming from the preheader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:199,Energy Efficiency,power,powerful,199,"// TODO: There might be another oppurtunity to leverage SCEV's reasoning; // here. If we kept track of the min of dominanting exits so far, we could; // discharge exits with EC >= MDEC. This is less powerful than the existing; // transform (since later exits aren't considered), but potentially more; // powerful for any case where SCEV can prove a >=u b, but neither a == b; // or a >u b. Such a case is not currently known.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:304,Energy Efficiency,power,powerful,304,"// TODO: There might be another oppurtunity to leverage SCEV's reasoning; // here. If we kept track of the min of dominanting exits so far, we could; // discharge exits with EC >= MDEC. This is less powerful than the existing; // transform (since later exits aren't considered), but potentially more; // powerful for any case where SCEV can prove a >=u b, but neither a == b; // or a >u b. Such a case is not currently known.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:149,Availability,down,down,149,"// Finally, see if we can rewrite our exit conditions into a loop invariant; // form. If we have a read-only loop, and we can tell that we must exit down; // a path which does not need any of the values computed within the loop, we; // can rewrite the loop to exit on the first iteration. Note that this; // doesn't either a) tell us the loop exits on the first iteration (unless; // *all* exits are predicateable) or b) tell us *which* exit might be taken.; // This transformation looks a lot like a restricted form of dead loop; // elimination, but restricted to read-only loops and without neccesssarily; // needing to kill the loop entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:26,Modifiability,rewrite,rewrite,26,"// Finally, see if we can rewrite our exit conditions into a loop invariant; // form. If we have a read-only loop, and we can tell that we must exit down; // a path which does not need any of the values computed within the loop, we; // can rewrite the loop to exit on the first iteration. Note that this; // doesn't either a) tell us the loop exits on the first iteration (unless; // *all* exits are predicateable) or b) tell us *which* exit might be taken.; // This transformation looks a lot like a restricted form of dead loop; // elimination, but restricted to read-only loops and without neccesssarily; // needing to kill the loop entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:240,Modifiability,rewrite,rewrite,240,"// Finally, see if we can rewrite our exit conditions into a loop invariant; // form. If we have a read-only loop, and we can tell that we must exit down; // a path which does not need any of the values computed within the loop, we; // can rewrite the loop to exit on the first iteration. Note that this; // doesn't either a) tell us the loop exits on the first iteration (unless; // *all* exits are predicateable) or b) tell us *which* exit might be taken.; // This transformation looks a lot like a restricted form of dead loop; // elimination, but restricted to read-only loops and without neccesssarily; // needing to kill the loop entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:58,Modifiability,rewrite,rewrite,58,"// If our exiting block exits multiple loops, we can only rewrite the; // innermost one. Otherwise, we're changing how many times the innermost; // loop runs before it exits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:9,Modifiability,rewrite,rewrite,9,// Can't rewrite non-branch yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:193,Testability,assert,assert,193,"// We rely on not being able to reach an exiting block on a later iteration; // then it's statically compute exit count. The implementaton of; // getExitCount currently has this invariant, but assert it here so that; // breakage is obvious if this ever changes..",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:532,Energy Efficiency,reduce,reduce,532,"// Finally, do the actual predication for all predicatable blocks. A couple; // of notes here:; // 1) We don't bother to constant fold dominated exits with identical exit; // counts; that's simply a form of CSE/equality propagation and we leave; // it for dedicated passes.; // 2) We insert the comparison at the branch. Hoisting introduces additional; // legality constraints and we leave that to dedicated logic. We want to; // predicate even if we can't insert a loop invariant expression as; // peeling or unrolling will likely reduce the cost of the otherwise loop; // varying check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:408,Testability,log,logic,408,"// Finally, do the actual predication for all predicatable blocks. A couple; // of notes here:; // 1) We don't bother to constant fold dominated exits with identical exit; // counts; that's simply a form of CSE/equality propagation and we leave; // it for dedicated passes.; // 2) We insert the comparison at the branch. Hoisting introduces additional; // legality constraints and we leave that to dedicated logic. We want to; // predicate even if we can't insert a loop invariant expression as; // peeling or unrolling will likely reduce the cost of the otherwise loop; // varying check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:190,Usability,simpl,simply,190,"// Finally, do the actual predication for all predicatable blocks. A couple; // of notes here:; // 1) We don't bother to constant fold dominated exits with identical exit; // counts; that's simply a form of CSE/equality propagation and we leave; // it for dedicated passes.; // 2) We insert the comparison at the branch. Hoisting introduces additional; // legality constraints and we leave that to dedicated logic. We want to; // predicate even if we can't insert a loop invariant expression as; // peeling or unrolling will likely reduce the cost of the otherwise loop; // varying check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:139,Usability,simpl,simplification,139,//===----------------------------------------------------------------------===//; // IndVarSimplify driver. Manage several subpasses of IV simplification.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:31,Availability,avail,available,31,"// If LoopSimplify form is not available, stay out of trouble. Some notes:; // - LSR currently only supports LoopSimplify-form loops. Indvars'; // canonicalization can be a pessimization without LSR to ""clean up""; // afterwards.; // - We depend on having a preheader; in particular,; // Loop::getCanonicalInductionVariable only supports loops with preheaders,; // and we're in trouble if we can't find the induction variable even when; // we've manually inserted one.; // - LFTR relies on having a single backedge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:238,Integrability,depend,depend,238,"// If LoopSimplify form is not available, stay out of trouble. Some notes:; // - LSR currently only supports LoopSimplify-form loops. Indvars'; // canonicalization can be a pessimization without LSR to ""clean up""; // afterwards.; // - We depend on having a preheader; in particular,; // Loop::getCanonicalInductionVariable only supports loops with preheaders,; // and we're in trouble if we can't find the induction variable even when; // we've manually inserted one.; // - LFTR relies on having a single backedge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:416,Modifiability,variab,variable,416,"// If LoopSimplify form is not available, stay out of trouble. Some notes:; // - LSR currently only supports LoopSimplify-form loops. Indvars'; // canonicalization can be a pessimization without LSR to ""clean up""; // afterwards.; // - We depend on having a preheader; in particular,; // Loop::getCanonicalInductionVariable only supports loops with preheaders,; // and we're in trouble if we can't find the induction variable even when; // we've manually inserted one.; // - LFTR relies on having a single backedge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:12,Modifiability,rewrite,rewriter,12,// Create a rewriter object which we'll use to transform the code with.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:13,Availability,redundant,redundant,13,// Eliminate redundant IV users.; //; // Simplification works best when run before other consumers of SCEV. We; // attempt to avoid evaluating SCEVs for sign/zero extend operations until; // other expressions involving loop IVs have been evaluated. This helps SCEV; // set no-wrap flags before normalizing sign/zero extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:276,Integrability,wrap,wrap,276,// Eliminate redundant IV users.; //; // Simplification works best when run before other consumers of SCEV. We; // attempt to avoid evaluating SCEVs for sign/zero extend operations until; // other expressions involving loop IVs have been evaluated. This helps SCEV; // set no-wrap flags before normalizing sign/zero extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:163,Modifiability,extend,extend,163,// Eliminate redundant IV users.; //; // Simplification works best when run before other consumers of SCEV. We; // attempt to avoid evaluating SCEVs for sign/zero extend operations until; // other expressions involving loop IVs have been evaluated. This helps SCEV; // set no-wrap flags before normalizing sign/zero extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:13,Safety,redund,redundant,13,// Eliminate redundant IV users.; //; // Simplification works best when run before other consumers of SCEV. We; // attempt to avoid evaluating SCEVs for sign/zero extend operations until; // other expressions involving loop IVs have been evaluated. This helps SCEV; // set no-wrap flags before normalizing sign/zero extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:126,Safety,avoid,avoid,126,// Eliminate redundant IV users.; //; // Simplification works best when run before other consumers of SCEV. We; // attempt to avoid evaluating SCEVs for sign/zero extend operations until; // other expressions involving loop IVs have been evaluated. This helps SCEV; // set no-wrap flags before normalizing sign/zero extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:41,Usability,Simpl,Simplification,41,// Eliminate redundant IV users.; //; // Simplification works best when run before other consumers of SCEV. We; // attempt to avoid evaluating SCEVs for sign/zero extend operations until; // other expressions involving loop IVs have been evaluated. This helps SCEV; // set no-wrap flags before normalizing sign/zero extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:13,Availability,redundant,redundant,13,// Eliminate redundant IV cycles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:13,Safety,redund,redundant,13,// Eliminate redundant IV cycles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:30,Testability,test,tests,30,// Try to form loop invariant tests for loop exits by changing how many; // iterations of the loop run when that is unobservable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:39,Modifiability,rewrite,rewrite,39,"// If we have a trip count expression, rewrite the loop's exit condition; // using it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:9,Modifiability,rewrite,rewrite,9,// Can't rewrite non-branch yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:59,Modifiability,rewrite,rewrite,59,"// If our exitting block exits multiple loops, we can only rewrite the; // innermost one. Otherwise, we're changing how many times the innermost; // loop runs before it exits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:160,Performance,optimiz,optimizeLoopExits,160,"// This was handled above, but as we form SCEVs, we can sometimes refine; // existing ones; this allows exit counts to be folded to zero which; // weren't when optimizeLoopExits saw them. Arguably, we should iterate; // until stable to handle cases like this better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:3,Safety,Avoid,Avoid,3,"// Avoid high cost expansions. Note: This heuristic is questionable in; // that our definition of ""high cost"" is not exactly principled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:13,Modifiability,rewrite,rewriter,13,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted in the loop below, causing the AssertingVH in the cache to; // trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:60,Modifiability,rewrite,rewriter,60,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted in the loop below, causing the AssertingVH in the cache to; // trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:22,Performance,cache,cache,22,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted in the loop below, causing the AssertingVH in the cache to; // trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:71,Performance,cache,cache,71,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted in the loop below, causing the AssertingVH in the cache to; // trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:146,Performance,cache,cache,146,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted in the loop below, causing the AssertingVH in the cache to; // trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:127,Testability,Assert,AssertingVH,127,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted in the loop below, causing the AssertingVH in the cache to; // trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:3,Usability,Clear,Clear,3,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted in the loop below, causing the AssertingVH in the cache to; // trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:164,Energy Efficiency,reduce,reduce,164,// The Rewriter may not be used from this point on.; // Loop-invariant instructions in the preheader that aren't used in the; // loop may be sunk below the loop to reduce register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:7,Modifiability,Rewrite,Rewriter,7,// The Rewriter may not be used from this point on.; // Loop-invariant instructions in the preheader that aren't used in the; // loop may be sunk below the loop to reduce register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:3,Modifiability,rewrite,rewriteFirstIterationLoopExitValues,3,// rewriteFirstIterationLoopExitValues does not rely on the computation of; // trip count and therefore can further simplify exit values in addition to; // rewriteLoopExitValues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:156,Modifiability,rewrite,rewriteLoopExitValues,156,// rewriteFirstIterationLoopExitValues does not rely on the computation of; // trip count and therefore can further simplify exit values in addition to; // rewriteLoopExitValues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:116,Usability,simpl,simplify,116,// rewriteFirstIterationLoopExitValues does not rely on the computation of; // trip count and therefore can further simplify exit values in addition to; // rewriteLoopExitValues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:3669,Availability,down,down,3669,"ble generic pointers with; // equivalent specific pointers.; //; // The major challenge of implementing this optimization is handling PHINodes,; // which may create loops in the data flow graph. This brings two complications.; //; // First, the data flow analysis in Step 1 needs to be circular. For example,; // %generic.input = addrspacecast float addrspace(3)* %input to float*; // loop:; // %y = phi [ %generic.input, %y2 ]; // %y2 = getelementptr %y, 1; // %v = load %y2; // br ..., label %loop, ...; // proving %y specific requires proving both %generic.input and %y2 specific,; // but proving %y2 specific circles back to %y. To address this complication,; // the data flow analysis operates on a lattice:; // uninitialized > specific address spaces > generic.; // All address expressions (our implementation only considers phi, bitcast,; // addrspacecast, and getelementptr) start with the uninitialized address space.; // The monotone transfer function moves the address space of a pointer down a; // lattice path from uninitialized to specific and then to generic. A join; // operation of two different specific address spaces pushes the expression down; // to the generic address space. The analysis completes once it reaches a fixed; // point.; //; // Second, IR rewriting in Step 2 also needs to be circular. For example,; // converting %y to addrspace(3) requires the compiler to know the converted; // %y2, but converting %y2 needs the converted %y. To address this complication,; // we break these cycles using ""poison"" placeholders. When converting an; // instruction `I` to a new address space, if its operand `Op` is not converted; // yet, we let `I` temporarily use `poison` and fix all the uses later.; // For instance, our algorithm first converts %y to; // %y' = phi float addrspace(3)* [ %input, poison ]; // Then, it converts %y2 to; // %y2' = getelementptr %y', 1; // Finally, it fixes the poison in %y' so that; // %y' = phi float addrspace(3)* [ %input, %y2' ]; //; //===-",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:3829,Availability,down,down,3829,"jor challenge of implementing this optimization is handling PHINodes,; // which may create loops in the data flow graph. This brings two complications.; //; // First, the data flow analysis in Step 1 needs to be circular. For example,; // %generic.input = addrspacecast float addrspace(3)* %input to float*; // loop:; // %y = phi [ %generic.input, %y2 ]; // %y2 = getelementptr %y, 1; // %v = load %y2; // br ..., label %loop, ...; // proving %y specific requires proving both %generic.input and %y2 specific,; // but proving %y2 specific circles back to %y. To address this complication,; // the data flow analysis operates on a lattice:; // uninitialized > specific address spaces > generic.; // All address expressions (our implementation only considers phi, bitcast,; // addrspacecast, and getelementptr) start with the uninitialized address space.; // The monotone transfer function moves the address space of a pointer down a; // lattice path from uninitialized to specific and then to generic. A join; // operation of two different specific address spaces pushes the expression down; // to the generic address space. The analysis completes once it reaches a fixed; // point.; //; // Second, IR rewriting in Step 2 also needs to be circular. For example,; // converting %y to addrspace(3) requires the compiler to know the converted; // %y2, but converting %y2 needs the converted %y. To address this complication,; // we break these cycles using ""poison"" placeholders. When converting an; // instruction `I` to a new address space, if its operand `Op` is not converted; // yet, we let `I` temporarily use `poison` and fix all the uses later.; // For instance, our algorithm first converts %y to; // %y' = phi float addrspace(3)* [ %input, poison ]; // Then, it converts %y2 to; // %y2' = getelementptr %y', 1; // Finally, it fixes the poison in %y' so that; // %y' = phi float addrspace(3)* [ %input, %y2' ]; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:431,Modifiability,variab,variable,431,"//===- InferAddressSpace.cpp - --------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // CUDA C/C++ includes memory space designation as variable type qualifers (such; // as __global__ and __shared__). Knowing the space of a memory access allows; // CUDA compilers to emit faster PTX loads and stores. For example, a load from; // shared memory can be translated to `ld.shared` which is roughly 10% faster; // than a generic `ld` on an NVIDIA Tesla K40c.; //; // Unfortunately, type qualifiers only apply to variable declarations, so CUDA; // compilers must infer the memory space of an address expression from; // type-qualified variables.; //; // LLVM IR uses non-zero (so-called) specific address spaces to represent memory; // spaces (e.g. addrspace(3) means shared memory). The Clang frontend; // places only type-qualified variables in specific address spaces, and then; // conservatively `addrspacecast`s each type-qualified variable to addrspace(0); // (so-called the generic address space) for other instructions to use.; //; // For example, the Clang translates the following CUDA code; // __shared__ float a[10];; // float v = a[i];; // to; // %0 = addrspacecast [10 x float] addrspace(3)* @a to [10 x float]*; // %1 = gep [10 x float], [10 x float]* %0, i64 0, i64 %i; // %v = load float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:802,Modifiability,variab,variable,802,"//===- InferAddressSpace.cpp - --------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // CUDA C/C++ includes memory space designation as variable type qualifers (such; // as __global__ and __shared__). Knowing the space of a memory access allows; // CUDA compilers to emit faster PTX loads and stores. For example, a load from; // shared memory can be translated to `ld.shared` which is roughly 10% faster; // than a generic `ld` on an NVIDIA Tesla K40c.; //; // Unfortunately, type qualifiers only apply to variable declarations, so CUDA; // compilers must infer the memory space of an address expression from; // type-qualified variables.; //; // LLVM IR uses non-zero (so-called) specific address spaces to represent memory; // spaces (e.g. addrspace(3) means shared memory). The Clang frontend; // places only type-qualified variables in specific address spaces, and then; // conservatively `addrspacecast`s each type-qualified variable to addrspace(0); // (so-called the generic address space) for other instructions to use.; //; // For example, the Clang translates the following CUDA code; // __shared__ float a[10];; // float v = a[i];; // to; // %0 = addrspacecast [10 x float] addrspace(3)* @a to [10 x float]*; // %1 = gep [10 x float], [10 x float]* %0, i64 0, i64 %i; // %v = load float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:924,Modifiability,variab,variables,924,"//===- InferAddressSpace.cpp - --------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // CUDA C/C++ includes memory space designation as variable type qualifers (such; // as __global__ and __shared__). Knowing the space of a memory access allows; // CUDA compilers to emit faster PTX loads and stores. For example, a load from; // shared memory can be translated to `ld.shared` which is roughly 10% faster; // than a generic `ld` on an NVIDIA Tesla K40c.; //; // Unfortunately, type qualifiers only apply to variable declarations, so CUDA; // compilers must infer the memory space of an address expression from; // type-qualified variables.; //; // LLVM IR uses non-zero (so-called) specific address spaces to represent memory; // spaces (e.g. addrspace(3) means shared memory). The Clang frontend; // places only type-qualified variables in specific address spaces, and then; // conservatively `addrspacecast`s each type-qualified variable to addrspace(0); // (so-called the generic address space) for other instructions to use.; //; // For example, the Clang translates the following CUDA code; // __shared__ float a[10];; // float v = a[i];; // to; // %0 = addrspacecast [10 x float] addrspace(3)* @a to [10 x float]*; // %1 = gep [10 x float], [10 x float]* %0, i64 0, i64 %i; // %v = load float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:1123,Modifiability,variab,variables,1123,"SE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // CUDA C/C++ includes memory space designation as variable type qualifers (such; // as __global__ and __shared__). Knowing the space of a memory access allows; // CUDA compilers to emit faster PTX loads and stores. For example, a load from; // shared memory can be translated to `ld.shared` which is roughly 10% faster; // than a generic `ld` on an NVIDIA Tesla K40c.; //; // Unfortunately, type qualifiers only apply to variable declarations, so CUDA; // compilers must infer the memory space of an address expression from; // type-qualified variables.; //; // LLVM IR uses non-zero (so-called) specific address spaces to represent memory; // spaces (e.g. addrspace(3) means shared memory). The Clang frontend; // places only type-qualified variables in specific address spaces, and then; // conservatively `addrspacecast`s each type-qualified variable to addrspace(0); // (so-called the generic address space) for other instructions to use.; //; // For example, the Clang translates the following CUDA code; // __shared__ float a[10];; // float v = a[i];; // to; // %0 = addrspacecast [10 x float] addrspace(3)* @a to [10 x float]*; // %1 = gep [10 x float], [10 x float]* %0, i64 0, i64 %i; // %v = load float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v = load float addrspace(3)* %1 ; emits ld.shared.f32; // propagating the addrspace(3) from @a to %1. As the result, the NVPTX; // codegen is able to emit ld.shared.f32 for %v.; //; // Address space",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:1226,Modifiability,variab,variable,1226,"SE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // CUDA C/C++ includes memory space designation as variable type qualifers (such; // as __global__ and __shared__). Knowing the space of a memory access allows; // CUDA compilers to emit faster PTX loads and stores. For example, a load from; // shared memory can be translated to `ld.shared` which is roughly 10% faster; // than a generic `ld` on an NVIDIA Tesla K40c.; //; // Unfortunately, type qualifiers only apply to variable declarations, so CUDA; // compilers must infer the memory space of an address expression from; // type-qualified variables.; //; // LLVM IR uses non-zero (so-called) specific address spaces to represent memory; // spaces (e.g. addrspace(3) means shared memory). The Clang frontend; // places only type-qualified variables in specific address spaces, and then; // conservatively `addrspacecast`s each type-qualified variable to addrspace(0); // (so-called the generic address space) for other instructions to use.; //; // For example, the Clang translates the following CUDA code; // __shared__ float a[10];; // float v = a[i];; // to; // %0 = addrspacecast [10 x float] addrspace(3)* @a to [10 x float]*; // %1 = gep [10 x float], [10 x float]* %0, i64 0, i64 %i; // %v = load float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v = load float addrspace(3)* %1 ; emits ld.shared.f32; // propagating the addrspace(3) from @a to %1. As the result, the NVPTX; // codegen is able to emit ld.shared.f32 for %v.; //; // Address space",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:1855,Modifiability,variab,variable,1855,"ations, so CUDA; // compilers must infer the memory space of an address expression from; // type-qualified variables.; //; // LLVM IR uses non-zero (so-called) specific address spaces to represent memory; // spaces (e.g. addrspace(3) means shared memory). The Clang frontend; // places only type-qualified variables in specific address spaces, and then; // conservatively `addrspacecast`s each type-qualified variable to addrspace(0); // (so-called the generic address space) for other instructions to use.; //; // For example, the Clang translates the following CUDA code; // __shared__ float a[10];; // float v = a[i];; // to; // %0 = addrspacecast [10 x float] addrspace(3)* @a to [10 x float]*; // %1 = gep [10 x float], [10 x float]* %0, i64 0, i64 %i; // %v = load float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v = load float addrspace(3)* %1 ; emits ld.shared.f32; // propagating the addrspace(3) from @a to %1. As the result, the NVPTX; // codegen is able to emit ld.shared.f32 for %v.; //; // Address space inference works in two steps. First, it uses a data-flow; // analysis to infer as many generic pointers as possible to point to only one; // specific address space. In the above example, it can prove that %1 only; // points to addrspace(3). This algorithm was published in; // CUDA: Compiling and optimizing for a GPU platform; // Chakrabarti, Grover, Aarts, Kong, Kudlur, Lin, Marathe, Murphy, Wang; // ICCS 2012; //; // Then, address space inference replaces all refinable generic pointers with; // equivalent specific pointers.; //; // The major challenge of implementing this optimization is handling PHINodes,; // ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:578,Performance,load,loads,578,"//===- InferAddressSpace.cpp - --------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // CUDA C/C++ includes memory space designation as variable type qualifers (such; // as __global__ and __shared__). Knowing the space of a memory access allows; // CUDA compilers to emit faster PTX loads and stores. For example, a load from; // shared memory can be translated to `ld.shared` which is roughly 10% faster; // than a generic `ld` on an NVIDIA Tesla K40c.; //; // Unfortunately, type qualifiers only apply to variable declarations, so CUDA; // compilers must infer the memory space of an address expression from; // type-qualified variables.; //; // LLVM IR uses non-zero (so-called) specific address spaces to represent memory; // spaces (e.g. addrspace(3) means shared memory). The Clang frontend; // places only type-qualified variables in specific address spaces, and then; // conservatively `addrspacecast`s each type-qualified variable to addrspace(0); // (so-called the generic address space) for other instructions to use.; //; // For example, the Clang translates the following CUDA code; // __shared__ float a[10];; // float v = a[i];; // to; // %0 = addrspacecast [10 x float] addrspace(3)* @a to [10 x float]*; // %1 = gep [10 x float], [10 x float]* %0, i64 0, i64 %i; // %v = load float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:611,Performance,load,load,611,"//===- InferAddressSpace.cpp - --------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // CUDA C/C++ includes memory space designation as variable type qualifers (such; // as __global__ and __shared__). Knowing the space of a memory access allows; // CUDA compilers to emit faster PTX loads and stores. For example, a load from; // shared memory can be translated to `ld.shared` which is roughly 10% faster; // than a generic `ld` on an NVIDIA Tesla K40c.; //; // Unfortunately, type qualifiers only apply to variable declarations, so CUDA; // compilers must infer the memory space of an address expression from; // type-qualified variables.; //; // LLVM IR uses non-zero (so-called) specific address spaces to represent memory; // spaces (e.g. addrspace(3) means shared memory). The Clang frontend; // places only type-qualified variables in specific address spaces, and then; // conservatively `addrspacecast`s each type-qualified variable to addrspace(0); // (so-called the generic address space) for other instructions to use.; //; // For example, the Clang translates the following CUDA code; // __shared__ float a[10];; // float v = a[i];; // to; // %0 = addrspacecast [10 x float] addrspace(3)* @a to [10 x float]*; // %1 = gep [10 x float], [10 x float]* %0, i64 0, i64 %i; // %v = load float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:1583,Performance,load,load,1583,"_global__ and __shared__). Knowing the space of a memory access allows; // CUDA compilers to emit faster PTX loads and stores. For example, a load from; // shared memory can be translated to `ld.shared` which is roughly 10% faster; // than a generic `ld` on an NVIDIA Tesla K40c.; //; // Unfortunately, type qualifiers only apply to variable declarations, so CUDA; // compilers must infer the memory space of an address expression from; // type-qualified variables.; //; // LLVM IR uses non-zero (so-called) specific address spaces to represent memory; // spaces (e.g. addrspace(3) means shared memory). The Clang frontend; // places only type-qualified variables in specific address spaces, and then; // conservatively `addrspacecast`s each type-qualified variable to addrspace(0); // (so-called the generic address space) for other instructions to use.; //; // For example, the Clang translates the following CUDA code; // __shared__ float a[10];; // float v = a[i];; // to; // %0 = addrspacecast [10 x float] addrspace(3)* @a to [10 x float]*; // %1 = gep [10 x float], [10 x float]* %0, i64 0, i64 %i; // %v = load float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v = load float addrspace(3)* %1 ; emits ld.shared.f32; // propagating the addrspace(3) from @a to %1. As the result, the NVPTX; // codegen is able to emit ld.shared.f32 for %v.; //; // Address space inference works in two steps. First, it uses a data-flow; // analysis to infer as many generic pointers as possible to point to only one; // specific address space. In the above example, it can prove that %1 only; // points to addrspace(3). This algorithm was published i",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:1758,Performance,optimiz,optimization,1758,"ations, so CUDA; // compilers must infer the memory space of an address expression from; // type-qualified variables.; //; // LLVM IR uses non-zero (so-called) specific address spaces to represent memory; // spaces (e.g. addrspace(3) means shared memory). The Clang frontend; // places only type-qualified variables in specific address spaces, and then; // conservatively `addrspacecast`s each type-qualified variable to addrspace(0); // (so-called the generic address space) for other instructions to use.; //; // For example, the Clang translates the following CUDA code; // __shared__ float a[10];; // float v = a[i];; // to; // %0 = addrspacecast [10 x float] addrspace(3)* @a to [10 x float]*; // %1 = gep [10 x float], [10 x float]* %0, i64 0, i64 %i; // %v = load float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v = load float addrspace(3)* %1 ; emits ld.shared.f32; // propagating the addrspace(3) from @a to %1. As the result, the NVPTX; // codegen is able to emit ld.shared.f32 for %v.; //; // Address space inference works in two steps. First, it uses a data-flow; // analysis to infer as many generic pointers as possible to point to only one; // specific address space. In the above example, it can prove that %1 only; // points to addrspace(3). This algorithm was published in; // CUDA: Compiling and optimizing for a GPU platform; // Chakrabarti, Grover, Aarts, Kong, Kudlur, Lin, Marathe, Murphy, Wang; // ICCS 2012; //; // Then, address space inference replaces all refinable generic pointers with; // equivalent specific pointers.; //; // The major challenge of implementing this optimization is handling PHINodes,; // ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:1911,Performance,optimiz,optimizes,1911,"so-called) specific address spaces to represent memory; // spaces (e.g. addrspace(3) means shared memory). The Clang frontend; // places only type-qualified variables in specific address spaces, and then; // conservatively `addrspacecast`s each type-qualified variable to addrspace(0); // (so-called the generic address space) for other instructions to use.; //; // For example, the Clang translates the following CUDA code; // __shared__ float a[10];; // float v = a[i];; // to; // %0 = addrspacecast [10 x float] addrspace(3)* @a to [10 x float]*; // %1 = gep [10 x float], [10 x float]* %0, i64 0, i64 %i; // %v = load float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v = load float addrspace(3)* %1 ; emits ld.shared.f32; // propagating the addrspace(3) from @a to %1. As the result, the NVPTX; // codegen is able to emit ld.shared.f32 for %v.; //; // Address space inference works in two steps. First, it uses a data-flow; // analysis to infer as many generic pointers as possible to point to only one; // specific address space. In the above example, it can prove that %1 only; // points to addrspace(3). This algorithm was published in; // CUDA: Compiling and optimizing for a GPU platform; // Chakrabarti, Grover, Aarts, Kong, Kudlur, Lin, Marathe, Murphy, Wang; // ICCS 2012; //; // Then, address space inference replaces all refinable generic pointers with; // equivalent specific pointers.; //; // The major challenge of implementing this optimization is handling PHINodes,; // which may create loops in the data flow graph. This brings two complications.; //; // First, the data flow analysis in Step 1 needs to be circular. F",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:2004,Performance,load,load,2004,"so-called) specific address spaces to represent memory; // spaces (e.g. addrspace(3) means shared memory). The Clang frontend; // places only type-qualified variables in specific address spaces, and then; // conservatively `addrspacecast`s each type-qualified variable to addrspace(0); // (so-called the generic address space) for other instructions to use.; //; // For example, the Clang translates the following CUDA code; // __shared__ float a[10];; // float v = a[i];; // to; // %0 = addrspacecast [10 x float] addrspace(3)* @a to [10 x float]*; // %1 = gep [10 x float], [10 x float]* %0, i64 0, i64 %i; // %v = load float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v = load float addrspace(3)* %1 ; emits ld.shared.f32; // propagating the addrspace(3) from @a to %1. As the result, the NVPTX; // codegen is able to emit ld.shared.f32 for %v.; //; // Address space inference works in two steps. First, it uses a data-flow; // analysis to infer as many generic pointers as possible to point to only one; // specific address space. In the above example, it can prove that %1 only; // points to addrspace(3). This algorithm was published in; // CUDA: Compiling and optimizing for a GPU platform; // Chakrabarti, Grover, Aarts, Kong, Kudlur, Lin, Marathe, Murphy, Wang; // ICCS 2012; //; // Then, address space inference replaces all refinable generic pointers with; // equivalent specific pointers.; //; // The major challenge of implementing this optimization is handling PHINodes,; // which may create loops in the data flow graph. This brings two complications.; //; // First, the data flow analysis in Step 1 needs to be circular. F",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:2496,Performance,optimiz,optimizing,2496,"oad float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v = load float addrspace(3)* %1 ; emits ld.shared.f32; // propagating the addrspace(3) from @a to %1. As the result, the NVPTX; // codegen is able to emit ld.shared.f32 for %v.; //; // Address space inference works in two steps. First, it uses a data-flow; // analysis to infer as many generic pointers as possible to point to only one; // specific address space. In the above example, it can prove that %1 only; // points to addrspace(3). This algorithm was published in; // CUDA: Compiling and optimizing for a GPU platform; // Chakrabarti, Grover, Aarts, Kong, Kudlur, Lin, Marathe, Murphy, Wang; // ICCS 2012; //; // Then, address space inference replaces all refinable generic pointers with; // equivalent specific pointers.; //; // The major challenge of implementing this optimization is handling PHINodes,; // which may create loops in the data flow graph. This brings two complications.; //; // First, the data flow analysis in Step 1 needs to be circular. For example,; // %generic.input = addrspacecast float addrspace(3)* %input to float*; // loop:; // %y = phi [ %generic.input, %y2 ]; // %y2 = getelementptr %y, 1; // %v = load %y2; // br ..., label %loop, ...; // proving %y specific requires proving both %generic.input and %y2 specific,; // but proving %y2 specific circles back to %y. To address this complication,; // the data flow analysis operates on a lattice:; // uninitialized > specific address spaces > generic.; // All address expressions (our implementation only considers phi, bitcast,; // addrspacecast, and getelementptr) start with the uninitialized ad",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:2779,Performance,optimiz,optimization,2779,"propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v = load float addrspace(3)* %1 ; emits ld.shared.f32; // propagating the addrspace(3) from @a to %1. As the result, the NVPTX; // codegen is able to emit ld.shared.f32 for %v.; //; // Address space inference works in two steps. First, it uses a data-flow; // analysis to infer as many generic pointers as possible to point to only one; // specific address space. In the above example, it can prove that %1 only; // points to addrspace(3). This algorithm was published in; // CUDA: Compiling and optimizing for a GPU platform; // Chakrabarti, Grover, Aarts, Kong, Kudlur, Lin, Marathe, Murphy, Wang; // ICCS 2012; //; // Then, address space inference replaces all refinable generic pointers with; // equivalent specific pointers.; //; // The major challenge of implementing this optimization is handling PHINodes,; // which may create loops in the data flow graph. This brings two complications.; //; // First, the data flow analysis in Step 1 needs to be circular. For example,; // %generic.input = addrspacecast float addrspace(3)* %input to float*; // loop:; // %y = phi [ %generic.input, %y2 ]; // %y2 = getelementptr %y, 1; // %v = load %y2; // br ..., label %loop, ...; // proving %y specific requires proving both %generic.input and %y2 specific,; // but proving %y2 specific circles back to %y. To address this complication,; // the data flow analysis operates on a lattice:; // uninitialized > specific address spaces > generic.; // All address expressions (our implementation only considers phi, bitcast,; // addrspacecast, and getelementptr) start with the uninitialized address space.; // The monotone transfer function moves the address space of a pointer down a; // lattice path from uninitialized to specific and then to generic. A join; // operation of two different specific addre",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:3137,Performance,load,load,3137,"e NVPTX; // codegen is able to emit ld.shared.f32 for %v.; //; // Address space inference works in two steps. First, it uses a data-flow; // analysis to infer as many generic pointers as possible to point to only one; // specific address space. In the above example, it can prove that %1 only; // points to addrspace(3). This algorithm was published in; // CUDA: Compiling and optimizing for a GPU platform; // Chakrabarti, Grover, Aarts, Kong, Kudlur, Lin, Marathe, Murphy, Wang; // ICCS 2012; //; // Then, address space inference replaces all refinable generic pointers with; // equivalent specific pointers.; //; // The major challenge of implementing this optimization is handling PHINodes,; // which may create loops in the data flow graph. This brings two complications.; //; // First, the data flow analysis in Step 1 needs to be circular. For example,; // %generic.input = addrspacecast float addrspace(3)* %input to float*; // loop:; // %y = phi [ %generic.input, %y2 ]; // %y2 = getelementptr %y, 1; // %v = load %y2; // br ..., label %loop, ...; // proving %y specific requires proving both %generic.input and %y2 specific,; // but proving %y2 specific circles back to %y. To address this complication,; // the data flow analysis operates on a lattice:; // uninitialized > specific address spaces > generic.; // All address expressions (our implementation only considers phi, bitcast,; // addrspacecast, and getelementptr) start with the uninitialized address space.; // The monotone transfer function moves the address space of a pointer down a; // lattice path from uninitialized to specific and then to generic. A join; // operation of two different specific address spaces pushes the expression down; // to the generic address space. The analysis completes once it reaches a fixed; // point.; //; // Second, IR rewriting in Step 2 also needs to be circular. For example,; // converting %y to addrspace(3) requires the compiler to know the converted; // %y2, but converting %y2 needs the",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:526,Security,access,access,526,"//===- InferAddressSpace.cpp - --------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // CUDA C/C++ includes memory space designation as variable type qualifers (such; // as __global__ and __shared__). Knowing the space of a memory access allows; // CUDA compilers to emit faster PTX loads and stores. For example, a load from; // shared memory can be translated to `ld.shared` which is roughly 10% faster; // than a generic `ld` on an NVIDIA Tesla K40c.; //; // Unfortunately, type qualifiers only apply to variable declarations, so CUDA; // compilers must infer the memory space of an address expression from; // type-qualified variables.; //; // LLVM IR uses non-zero (so-called) specific address spaces to represent memory; // spaces (e.g. addrspace(3) means shared memory). The Clang frontend; // places only type-qualified variables in specific address spaces, and then; // conservatively `addrspacecast`s each type-qualified variable to addrspace(0); // (so-called the generic address space) for other instructions to use.; //; // For example, the Clang translates the following CUDA code; // __shared__ float a[10];; // float v = a[i];; // to; // %0 = addrspacecast [10 x float] addrspace(3)* @a to [10 x float]*; // %1 = gep [10 x float], [10 x float]* %0, i64 0, i64 %i; // %v = load float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:10,Deployability,update,update,10,"// Try to update the address space of V. If V is updated, returns true and; // false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:49,Deployability,update,updated,49,"// Try to update the address space of V. If V is updated, returns true and; // false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:21,Safety,safe,safe,21,"// Check it's really safe to treat that pair of `ptrtoint`/`inttoptr` as a; // no-op cast. Besides checking both of them are no-op casts, as the; // reinterpreted pointer may be used in other pointer arithmetic, we also; // need to double-check that through the target-specific hook. That ensures; // the underlying target also agrees that's a no-op address space cast and; // pointer bits are preserved.; // The current IR spec doesn't have clear rules on address space casts,; // especially a clear definition for pointer bits in non-default address; // spaces. It would be undefined if that pointer is dereferenced after an; // invalid reinterpret cast. Also, due to the unclearness for the meaning of; // bits in non-default address spaces in the current spec, the pointer; // arithmetic may also be undefined after invalid pointer reinterpret cast.; // However, as we confirm through the target hooks that it's a no-op; // addrspacecast, it doesn't matter since the bits should be the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:442,Usability,clear,clear,442,"// Check it's really safe to treat that pair of `ptrtoint`/`inttoptr` as a; // no-op cast. Besides checking both of them are no-op casts, as the; // reinterpreted pointer may be used in other pointer arithmetic, we also; // need to double-check that through the target-specific hook. That ensures; // the underlying target also agrees that's a no-op address space cast and; // pointer bits are preserved.; // The current IR spec doesn't have clear rules on address space casts,; // especially a clear definition for pointer bits in non-default address; // spaces. It would be undefined if that pointer is dereferenced after an; // invalid reinterpret cast. Also, due to the unclearness for the meaning of; // bits in non-default address spaces in the current spec, the pointer; // arithmetic may also be undefined after invalid pointer reinterpret cast.; // However, as we confirm through the target hooks that it's a no-op; // addrspacecast, it doesn't matter since the bits should be the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:495,Usability,clear,clear,495,"// Check it's really safe to treat that pair of `ptrtoint`/`inttoptr` as a; // no-op cast. Besides checking both of them are no-op casts, as the; // reinterpreted pointer may be used in other pointer arithmetic, we also; // need to double-check that through the target-specific hook. That ensures; // the underlying target also agrees that's a no-op address space cast and; // pointer bits are preserved.; // The current IR spec doesn't have clear rules on address space casts,; // especially a clear definition for pointer bits in non-default address; // spaces. It would be undefined if that pointer is dereferenced after an; // invalid reinterpret cast. Also, due to the unclearness for the meaning of; // bits in non-default address spaces in the current spec, the pointer; // arithmetic may also be undefined after invalid pointer reinterpret cast.; // However, as we confirm through the target hooks that it's a no-op; // addrspacecast, it doesn't matter since the bits should be the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:124,Performance,load,loads,124,"// Look at operations that may be interesting accelerate by moving to a known; // address space. We aim at generating after loads and stores, but pure; // addressing calculations may also be faster.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:97,Integrability,wrap,wrapped,97,"// If !IsNew, we will replace the Value with itself. However, replaced values; // are assumed to wrapped in an addrspacecast cast later so drop it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:102,Integrability,wrap,wrap,102,"// Constants need to be tracked through RAUW to handle cases with nested; // constant expressions, so wrap values in WeakTrackingVH.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:10,Deployability,update,update,10,// Try to update the address space of the stack top according to the; // address spaces of its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:22,Deployability,update,updates,22,"// Our algorithm only updates the address spaces of flat address; // expressions, which are those in InferredAddrSpace.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:55,Availability,down,down,55,"// Function updateAddressSpace moves the address space down a lattice; // path. Therefore, nothing to do if User is already inferred as flat (the; // bottom element in the lattice).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:12,Deployability,update,updateAddressSpace,12,"// Function updateAddressSpace moves the address space down a lattice; // path. Therefore, nothing to do if User is already inferred as flat (the; // bottom element in the lattice).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:10,Deployability,update,updates,10,"// If any updates are made, grabs its users to the worklist because; // their address spaces can also be possibly updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:114,Deployability,update,updated,114,"// If any updates are made, grabs its users to the worklist because; // their address spaces can also be possibly updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:153,Usability,simpl,simply,153,"/// \p returns true if \p U is the pointer operand of a memory instruction with; /// a single pointer operand that can have its address space changed by simply; /// mutating the use to a new value. If the memory instruction is volatile,; /// return true only if the target allows the memory instruction to be volatile; /// in the new address space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:4,Deployability,Update,Update,4,/// Update memory intrinsic uses that require more complex processing than; /// simple memory instructions. These require re-mangling and may have multiple; /// pointer operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:80,Usability,simpl,simple,80,/// Update memory intrinsic uses that require more complex processing than; /// simple memory instructions. These require re-mangling and may have multiple; /// pointer operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:61,Safety,safe,safe,61,"// If we already have a constant addrspacecast, it should be safe to cast it; // off.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:183,Performance,load,load,183,"// If V is used as the pointer operand of a compatible memory operation,; // sets the pointer operand to NewV. This replacement does not change; // the element type, so the resultant load/store is still valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAlignment.cpp:403,Performance,load,load,403,"//===- InferAlignment.cpp -------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Infer alignment for load, stores and other memory operations based on; // trailing zero known bits information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAlignment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAlignment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp:74,Usability,simpl,simplify,74,"// The first time through the loop, ToSimplify is empty and we try to; // simplify all instructions. On later iterations, ToSimplify is not; // empty and we only bother simplifying instructions that are in it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp:169,Usability,simpl,simplifying,169,"// The first time through the loop, ToSimplify is empty and we try to; // simplify all instructions. On later iterations, ToSimplify is not; // empty and we only bother simplifying instructions that are in it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp:20,Usability,simpl,simplifying,20,// Don't waste time simplifying dead/unused instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp:18,Usability,simpl,simplified,18,"// A call can get simplified, but it may not be trivially dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp:37,Usability,simpl,simplify,37,// Place the list of instructions to simplify on the next loop iteration; // into ToSimplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp:29,Usability,simpl,simplify,29,/// Remove instructions that simplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp:10,Integrability,interface,interface,10,// Public interface to the simplify instructions pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp:27,Usability,simpl,simplify,27,// Public interface to the simplify instructions pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IVUsersPrinter.cpp:38,Modifiability,Variab,Variable,38,"//===- IVUsersPrinter.cpp - Induction Variable Users Printer ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IVUsersPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IVUsersPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:3,Deployability,Update,Update,3,"// Update branch probability information according to conditional; // branch probability. This is usually made possible for cloned branches; // in inline instances by the context specific profile in the caller.; // For instance,; //; // [Block PredBB]; // [Branch PredBr]; // if (t) {; // Block A;; // } else {; // Block B;; // }; //; // [Block BB]; // cond = PN([true, %A], [..., %B]); // PHI node; // [Branch CondBr]; // if (cond) {; // ... // P(cond == true) = 1%; // }; //; // Here we know that when block A is taken, cond must be true, which means; // P(cond == true | A) = 1; //; // Given that P(cond == true) = P(cond == true | A) * P(A) +; // P(cond == true | B) * P(B); // we get:; // P(cond == true ) = P(A) + P(cond == true | B) * P(B); //; // which gives us:; // P(A) is less than P(cond == true), i.e.; // P(t == true) <= P(cond == true); //; // In other words, if we know P(cond == true) is unlikely, we know; // that P(t == true) is also unlikely.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:200,Performance,perform,performance,200,"// FIXME: We currently only set the profile data when it is missing.; // With PGO, this can be used to refine even existing profile data with; // context information. This needs to be done after more performance; // testing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:216,Testability,test,testing,216,"// FIXME: We currently only set the profile data when it is missing.; // With PGO, this can be used to refine even existing profile data with; // context information. This needs to be done after more performance; // testing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce the number of instructions duplicated when optimizing strictly for; // size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:53,Performance,optimiz,optimizing,53,// Reduce the number of instructions duplicated when optimizing strictly for; // size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:38,Availability,redundant,redundant,38,// Jump threading may have introduced redundant debug values into BB; // which should be removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:38,Safety,redund,redundant,38,// Jump threading may have introduced redundant debug values into BB; // which should be removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:77,Integrability,rout,routines,77,// Stop processing BB if it's the entry or is now deleted. The following; // routines attempt to eliminate BB and locating a suitable replacement; // for the entry is non-trivial.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:71,Safety,detect,detect,71,// Don't alter Loop headers and latches to ensure another pass can; // detect and transform nested loops later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:40,Safety,safe,safe,40,"// Replace uses of Cond with ToVal when safe to do so. If all uses are; // replaced, we can remove Cond. We cannot blindly replace all uses of Cond; // because we may incorrectly replace uses when guards/assumes are uses of; // of `Cond` and we used the guards/assume to reason about the `Cond` value; // at the end of block. RAUW unconditionally replaces all uses; // including the guards/assumes themselves and the uses before the; // guard/assume.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:811,Usability,simpl,simple,811,"/// findLoopHeaders - We do not want jump threading to turn proper loop; /// structures into irreducible loops. Doing this breaks up the loop nesting; /// hierarchy and pessimizes later transformations. To prevent this from; /// happening, we first have to find the loop headers. Here we approximate this; /// by finding targets of backedges in the CFG.; ///; /// Note that there definitely are cases when we want to allow threading of; /// edges across a loop header. For example, threading a jump from outside the; /// loop (the preheader) to an exit block of the loop is definitely profitable.; /// It is also almost always profitable to thread backedges from within the loop; /// to exit blocks, and is often profitable to thread backedges to other blocks; /// within the loop (forming a nested loop). This simple analysis is not rich; /// enough to track all of these properties and keep it up-to-date as the CFG; /// mutates, so we don't allow any of these transformations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:199,Integrability,depend,depends,199,"/// getKnownConstant - Helper method to determine if we can thread over a; /// terminator with the given value as its condition, and if so what value to; /// use for that. What kind of value this is depends on whether we want an; /// integer or a block address, but an undef is always accepted.; /// Returns null if Val is null or not an appropriate constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:259,Availability,avail,available,259,"// If I is a non-local compare-with-constant instruction, use more-rich; // 'getPredicateOnEdge' method. This would be able to handle value; // inequalities better, for example if the compare is ""X < 4"" and ""X < 3""; // is known true but ""X < 4"" itself is not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:10,Usability,simpl,simplify,10,// Try to simplify some other binary operator values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:34,Usability,simpl,simplify,34,// Try to use constant folding to simplify the binary operator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:10,Performance,perform,perform,10,"// Do not perform phi translation across a loop header phi, because this; // may result in comparison of values from two different loop iterations.; // FIXME: This check is broken if LoopHeaders is not populated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:18,Usability,simpl,simplification,18,// We can do this simplification if any comparisons fold to true or false.; // See if any do.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:273,Energy Efficiency,reduce,reduce,273,"/// GetBestDestForBranchOnUndef - If we determine that the specified block ends; /// in an undefined jump, decide which block is best to revector to.; ///; /// Since we can pick an arbitrary destination, we pick the successor with the; /// fewest predecessors. This should reduce the in-degree of the others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:128,Availability,alive,alive,128,"// If the block has its address taken, it may be a tree of dead constants; // hanging off of it. These shouldn't keep the block alive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:84,Usability,simpl,simplifies,84,"// If the block is trivially dead, just return and let the caller nuke it.; // This simplifies other transformations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:41,Energy Efficiency,reduce,reduce,41,// Run constant folding to see if we can reduce the condition to a simple; // constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:67,Usability,simpl,simple,67,// Run constant folding to see if we can reduce the condition to a simple; // constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:63,Usability,simpl,simplify,63,"// If the terminator of this block is branching on a constant, simplify the; // terminator to an unconditional branch. This can occur due to threading in; // other blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:30,Integrability,depend,depend,30,// All the rest of our checks depend on the condition being an instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:25,Performance,optimiz,optimization,25,// Some of the following optimization can safely work on the unfrozen cond.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:42,Safety,safe,safely,42,// Some of the following optimization can safely work on the unfrozen cond.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:10,Safety,safe,safely,10,"// We can safely replace *some* uses of the CondInst if it has; // exactly one value as returned by LVI. RAUW is incorrect in the; // presence of guards and assumes, that have the `Cond` as the use. This; // is because we use the guards/assume to reason about the `Cond` value; // at the end of block, but RAUW unconditionally replaces all uses; // including the guards/assumes themselves and the uses before the; // guard/assume.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:77,Integrability,depend,depends,77,"// We did not manage to simplify this branch, try to see whether; // CondCmp depends on a known phi-select pattern.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:24,Usability,simpl,simplify,24,"// We did not manage to simplify this branch, try to see whether; // CondCmp depends on a known phi-select pattern.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:204,Availability,redundant,redundant,204,"// Check for some cases that are worth simplifying. Right now we want to look; // for loads that are used by a switch or by the condition for the branch. If; // we see one, check to see if it's partially redundant. If so, insert a PHI; // which can then be used to thread the values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:86,Performance,load,loads,86,"// Check for some cases that are worth simplifying. Right now we want to look; // for loads that are used by a switch or by the condition for the branch. If; // we see one, check to see if it's partially redundant. If so, insert a PHI; // which can then be used to thread the values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:204,Safety,redund,redundant,204,"// Check for some cases that are worth simplifying. Right now we want to look; // for loads that are used by a switch or by the condition for the branch. If; // we see one, check to see if it's partially redundant. If so, insert a PHI; // which can then be used to thread the values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:39,Usability,simpl,simplifying,39,"// Check for some cases that are worth simplifying. Right now we want to look; // for loads that are used by a switch or by the condition for the branch. If; // we see one, check to see if it's partially redundant. If so, insert a PHI; // which can then be used to thread the values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:38,Performance,load,load,38,"// TODO: There are other places where load PRE would be profitable, such as; // more complex comparisons.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:167,Safety,predict,predictable,167,"// Handle a variety of cases where we are branching on something derived from; // a PHI node in the current block. If we can prove that any predecessors; // compute a predictable value based on a PHI node, thread those predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:114,Usability,simpl,simplify,114,"// If this is an otherwise-unfoldable branch on a phi node or freeze(phi) in; // the current block, see if we can simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:69,Usability,simpl,simplify,69,"// If this is an otherwise-unfoldable branch on a XOR, see if we can simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:66,Usability,simpl,simplify,66,// Search for a stronger dominating condition that can be used to simplify a; // conditional branch leaving BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:77,Availability,redundant,redundant,77,"/// simplifyPartiallyRedundantLoad - If LoadI is an obviously partially; /// redundant load instruction, eliminate it by replacing it with a PHI node.; /// This is an important optimization that encourages jump threading, and needs; /// to be run interlaced with other jump threading tasks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:40,Performance,Load,LoadI,40,"/// simplifyPartiallyRedundantLoad - If LoadI is an obviously partially; /// redundant load instruction, eliminate it by replacing it with a PHI node.; /// This is an important optimization that encourages jump threading, and needs; /// to be run interlaced with other jump threading tasks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:87,Performance,load,load,87,"/// simplifyPartiallyRedundantLoad - If LoadI is an obviously partially; /// redundant load instruction, eliminate it by replacing it with a PHI node.; /// This is an important optimization that encourages jump threading, and needs; /// to be run interlaced with other jump threading tasks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:177,Performance,optimiz,optimization,177,"/// simplifyPartiallyRedundantLoad - If LoadI is an obviously partially; /// redundant load instruction, eliminate it by replacing it with a PHI node.; /// This is an important optimization that encourages jump threading, and needs; /// to be run interlaced with other jump threading tasks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:77,Safety,redund,redundant,77,"/// simplifyPartiallyRedundantLoad - If LoadI is an obviously partially; /// redundant load instruction, eliminate it by replacing it with a PHI node.; /// This is an important optimization that encourages jump threading, and needs; /// to be run interlaced with other jump threading tasks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:4,Usability,simpl,simplifyPartiallyRedundantLoad,4,"/// simplifyPartiallyRedundantLoad - If LoadI is an obviously partially; /// redundant load instruction, eliminate it by replacing it with a PHI node.; /// This is an important optimization that encourages jump threading, and needs; /// to be run interlaced with other jump threading tasks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:35,Performance,load,loads,35,// Don't hack volatile and ordered loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:93,Availability,redundant,redundant,93,"// If the load is defined in a block with exactly one predecessor, it can't be; // partially redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:10,Performance,load,load,10,"// If the load is defined in a block with exactly one predecessor, it can't be; // partially redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:93,Safety,redund,redundant,93,"// If the load is defined in a block with exactly one predecessor, it can't be; // partially redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:62,Availability,redundant,redundant,62,"// If the load is defined in an EH pad, it can't be partially redundant,; // because the edges between the invoke and the EH pad cannot have other; // instructions between them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:10,Performance,load,load,10,"// If the load is defined in an EH pad, it can't be partially redundant,; // because the edges between the invoke and the EH pad cannot have other; // instructions between them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:62,Safety,redund,redundant,62,"// If the load is defined in an EH pad, it can't be partially redundant,; // because the edges between the invoke and the EH pad cannot have other; // instructions between them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:85,Availability,avail,available,85,"// If the loaded operand is defined in the LoadBB and its not a phi,; // it can't be available in predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:10,Performance,load,loaded,10,"// If the loaded operand is defined in the LoadBB and its not a phi,; // it can't be available in predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:43,Performance,Load,LoadBB,43,"// If the loaded operand is defined in the LoadBB and its not a phi,; // it can't be available in predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:39,Performance,load,load,39,"// Scan a few instructions up from the load, to see if it is obviously live at; // the entry to its block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:25,Deployability,update,updated,25,// The dominator tree is updated lazily and may not be valid at this point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:39,Availability,avail,available,39,"// If the value of the load is locally available within the block, just use; // it. This frequently occurs for reg2mem'd allocas.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:23,Performance,load,load,23,"// If the value of the load is locally available within the block, just use; // it. This frequently occurs for reg2mem'd allocas.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:32,Performance,load,load,32,"// If the returned value is the load itself, replace with poison. This can; // only happen in dead loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:129,Performance,load,load,129,"// Otherwise, if we scanned the whole block and got to the top of the block,; // we know the block is locally transparent to the load. If not, something; // might clobber its value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:17,Performance,load,loads,17,"// If all of the loads and stores that feed the value have the same AA tags,; // then we can propagate them onto any newly inserted loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:132,Performance,load,loads,132,"// If all of the loads and stores that feed the value have the same AA tags,; // then we can propagate them onto any newly inserted loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:112,Availability,avail,available,112,"// If we got here, the loaded value is transparent through to the start of the; // block. Check to see if it is available in any of the predecessor blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:23,Performance,load,loaded,23,"// If we got here, the loaded value is transparent through to the start of the; // block. Check to see if it is available in any of the predecessor blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:22,Performance,load,load,22,"// NOTE: We don't CSE load that is volatile or anything stronger than; // unordered, that should have been checked when we entered the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:75,Availability,avail,available,75,"// If this is a load on a phi pointer, phi-translate it and search; // for available load/store to the pointer in predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:16,Performance,load,load,16,"// If this is a load on a phi pointer, phi-translate it and search; // for available load/store to the pointer in predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:85,Performance,load,load,85,"// If this is a load on a phi pointer, phi-translate it and search; // for available load/store to the pointer in predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:33,Availability,redundant,redundant,33,"// If so, this load is partially redundant. Remember this info so that we; // can create a PHI node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:15,Performance,load,load,15,"// If so, this load is partially redundant. Remember this info so that we; // can create a PHI node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:33,Safety,redund,redundant,33,"// If so, this load is partially redundant. Remember this info so that we; // can create a PHI node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:29,Availability,avail,available,29,"// If the loaded value isn't available in any predecessor, it isn't partially; // redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:82,Availability,redundant,redundant,82,"// If the loaded value isn't available in any predecessor, it isn't partially; // redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:10,Performance,load,loaded,10,"// If the loaded value isn't available in any predecessor, it isn't partially; // redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:82,Safety,redund,redundant,82,"// If the loaded value isn't available in any predecessor, it isn't partially; // redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:29,Availability,avail,available,29,"// Okay, the loaded value is available in at least one (and maybe all!); // predecessors. If the value is unavailable in more than one unique; // predecessor, we want to insert a merge block for those common predecessors.; // This ensures that we only have to insert one reload, thus not increasing; // code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:13,Performance,load,loaded,13,"// Okay, the loaded value is available in at least one (and maybe all!); // predecessors. If the value is unavailable in more than one unique; // predecessor, we want to insert a merge block for those common predecessors.; // This ensures that we only have to insert one reload, thus not increasing; // code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:165,Performance,Load,LoadI,165,"// If the value is unavailable in one of predecessors, we will end up; // inserting a new instruction into them. It is only valid if all the; // instructions before LoadI are guaranteed to pass execution to its; // successor, or if LoadI is safe to speculate.; // TODO: If this logic becomes more complex, and we will perform PRE insertion; // farther than to a predecessor, we need to reuse the code from GVN's PRE.; // It requires domination tree analysis, so for this simple case it is an; // overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:232,Performance,Load,LoadI,232,"// If the value is unavailable in one of predecessors, we will end up; // inserting a new instruction into them. It is only valid if all the; // instructions before LoadI are guaranteed to pass execution to its; // successor, or if LoadI is safe to speculate.; // TODO: If this logic becomes more complex, and we will perform PRE insertion; // farther than to a predecessor, we need to reuse the code from GVN's PRE.; // It requires domination tree analysis, so for this simple case it is an; // overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:318,Performance,perform,perform,318,"// If the value is unavailable in one of predecessors, we will end up; // inserting a new instruction into them. It is only valid if all the; // instructions before LoadI are guaranteed to pass execution to its; // successor, or if LoadI is safe to speculate.; // TODO: If this logic becomes more complex, and we will perform PRE insertion; // farther than to a predecessor, we need to reuse the code from GVN's PRE.; // It requires domination tree analysis, so for this simple case it is an; // overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:241,Safety,safe,safe,241,"// If the value is unavailable in one of predecessors, we will end up; // inserting a new instruction into them. It is only valid if all the; // instructions before LoadI are guaranteed to pass execution to its; // successor, or if LoadI is safe to speculate.; // TODO: If this logic becomes more complex, and we will perform PRE insertion; // farther than to a predecessor, we need to reuse the code from GVN's PRE.; // It requires domination tree analysis, so for this simple case it is an; // overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:278,Testability,log,logic,278,"// If the value is unavailable in one of predecessors, we will end up; // inserting a new instruction into them. It is only valid if all the; // instructions before LoadI are guaranteed to pass execution to its; // successor, or if LoadI is safe to speculate.; // TODO: If this logic becomes more complex, and we will perform PRE insertion; // farther than to a predecessor, we need to reuse the code from GVN's PRE.; // It requires domination tree analysis, so for this simple case it is an; // overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:471,Usability,simpl,simple,471,"// If the value is unavailable in one of predecessors, we will end up; // inserting a new instruction into them. It is only valid if all the; // instructions before LoadI are guaranteed to pass execution to its; // successor, or if LoadI is safe to speculate.; // TODO: If this logic becomes more complex, and we will perform PRE insertion; // farther than to a predecessor, we need to reuse the code from GVN's PRE.; // It requires domination tree analysis, so for this simple case it is an; // overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:22,Availability,avail,available,22,"// If the value isn't available in all predecessors, then there will be; // exactly one where it isn't available. Insert a load on that edge and add; // it to the AvailablePreds list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:103,Availability,avail,available,103,"// If the value isn't available in all predecessors, then there will be; // exactly one where it isn't available. Insert a load on that edge and add; // it to the AvailablePreds list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:163,Availability,Avail,AvailablePreds,163,"// If the value isn't available in all predecessors, then there will be; // exactly one where it isn't available. Insert a load on that edge and add; // it to the AvailablePreds list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:123,Performance,load,load,123,"// If the value isn't available in all predecessors, then there will be; // exactly one where it isn't available. Insert a load on that edge and add; // it to the AvailablePreds list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:70,Availability,Avail,AvailablePreds,70,"// Now we know that each predecessor of this block has a value in; // AvailablePreds, sort them for efficient access as we're walking the preds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:100,Energy Efficiency,efficient,efficient,100,"// Now we know that each predecessor of this block has a value in; // AvailablePreds, sort them for efficient access as we're walking the preds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:110,Security,access,access,110,"// Now we know that each predecessor of this block has a value in; // AvailablePreds, sort them for efficient access as we're walking the preds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:61,Performance,load,load,61,// Create a PHI node at the start of the block for the PRE'd load value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:17,Availability,avail,available,17,"// If we have an available predecessor but it requires casting, insert the; // cast in the predecessor and use the cast. Note that we have to update the; // AvailablePreds vector as we go so that all of the PHI entries for this; // predecessor use the same bitcast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:157,Availability,Avail,AvailablePreds,157,"// If we have an available predecessor but it requires casting, insert the; // cast in the predecessor and use the cast. Note that we have to update the; // AvailablePreds vector as we go so that all of the PHI entries for this; // predecessor use the same bitcast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:142,Deployability,update,update,142,"// If we have an available predecessor but it requires casting, insert the; // cast in the predecessor and use the cast. Note that we have to update the; // AvailablePreds vector as we go so that all of the PHI entries for this; // predecessor use the same bitcast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:11,Deployability,update,update,11,// Finally update the terminator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:10,Safety,safe,safely,10,"// We can safely replace *some* uses of the CondInst if it has; // exactly one value as returned by LVI. RAUW is incorrect in the; // presence of guards and assumes, that have the `Cond` as the use. This; // is because we use the guards/assume to reason about the `Cond` value; // at the end of block, but RAUW unconditionally replaces all uses; // including the guards/assumes themselves and the uses before the; // guard/assume.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:275,Safety,avoid,avoid,275,"// Determine which is the most common successor. If we have many inputs and; // this block is a switch, we want to start by threading the batch that goes; // to the most popular destination first. If we only know about one; // threadable destination (the common case) we can avoid this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:161,Usability,simpl,simplifications,161,/// processBranchOnPHI - We have an otherwise unthreadable conditional branch on; /// a PHI node (or freeze PHI) in the current block. See if there are any; /// simplifications we can do based on inputs to the phi node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:152,Usability,simpl,simplifications,152,/// processBranchOnXOR - We have an otherwise unthreadable conditional branch on; /// a xor instruction in the current block. See if there are any; /// simplifications we can do based on inputs to the xor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:72,Performance,optimiz,optimization,72,"// If either the LHS or RHS of the xor is a constant, don't do this; // optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:237,Testability,log,logical,237,"// If we have a xor as the branch input to this block, and we know that the; // LHS or RHS of the xor in any predecessor is true/false, then we can clone; // the condition into the predecessor and fix that value to true, saving some; // logical ops on that path and encouraging other paths to simplify.; //; // This copies something like this:; //; // BB:; // %X = phi i1 [1], [%X']; // %Y = icmp eq i32 %A, %B; // %Z = xor i1 %X, %Y; // br i1 %Z, ...; //; // Into:; // BB':; // %Y = icmp ne i32 %A, %B; // br i1 %Y, ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:293,Usability,simpl,simplify,293,"// If we have a xor as the branch input to this block, and we know that the; // LHS or RHS of the xor in any predecessor is true/false, then we can clone; // the condition into the predecessor and fix that value to true, saving some; // logical ops on that path and encouraging other paths to simplify.; //; // This copies something like this:; //; // BB:; // %X = phi i1 [1], [%X']; // %Y = icmp eq i32 %A, %B; // %Z = xor i1 %X, %Y; // br i1 %Z, ...; //; // Into:; // BB':; // %Y = icmp ne i32 %A, %B; // br i1 %Y, ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:4,Deployability,Update,Update,4,/// Update the SSA form. NewBB contains instructions that are copied from BB.; /// ValueMapping maps old values in BB to new ones in NewBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:95,Deployability,update,update,95,"// If there were values defined in BB that are used outside the block, then we; // now have to update all uses of the value to use either the original value,; // the cloned value, or some PHI derived value. This can require arbitrary; // PHI insertion, of which we are prepared to do, clean these up now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:142,Modifiability,variab,variables,142,"/// Clone instructions in range [BI, BE) to NewBB. For PHI nodes, we only clone; /// arguments that come from PredBB. Return the map from the variables in the; /// source basic block to the variables in the newly created basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:190,Modifiability,variab,variables,190,"/// Clone instructions in range [BI, BE) to NewBB. For PHI nodes, we only clone; /// arguments that come from PredBB. Return the map from the variables in the; /// source basic block to the variables in the newly created basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:43,Modifiability,variab,variables,43,// Retargets llvm.dbg.value to any renamed variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:172,Modifiability,rewrite,rewrite,172,"// Clone the phi nodes of the source basic block into NewBB. The resulting; // phi nodes are trivial since NewBB only has one predecessor, but SSAUpdater; // might need to rewrite the operand of the cloned phi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:21,Deployability,patch,patch,21,// Remap operands to patch up intra-block references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:596,Usability,simpl,simplicity,596,"// Consider:; //; // PredBB:; // %var = phi i32* [ null, %bb1 ], [ @a, %bb2 ]; // %tobool = icmp eq i32 %cond, 0; // br i1 %tobool, label %BB, label ...; //; // BB:; // %cmp = icmp eq i32* %var, null; // br i1 %cmp, label ..., label ...; //; // We don't know the value of %var at BB even if we know which incoming edge; // we take to BB. However, once we duplicate PredBB for each of its incoming; // edges (say, PredBB1 and PredBB2), we know the value of %var in each copy of; // PredBB. Then we can thread edges PredBB1->BB and PredBB2->BB through BB.; // Require that BB end with a Branch for simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:155,Usability,simpl,simplicity,155,"// Require that PredBB end with a conditional Branch. If PredBB ends with an; // unconditional branch, we should be merging PredBB and BB instead. For; // simplicity, we don't deal with a switch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:3,Safety,Avoid,Avoid,3,// Avoid complication with duplicating EH pads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:46,Usability,simpl,simplicity,46,"// Find a predecessor that we can thread. For simplicity, we only consider a; // successor edge out of BB to which we thread exactly one incoming edge into; // PredBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:3,Deployability,Update,Update,3,"// Update the terminator of PredPredBB to jump to NewBB instead of PredBB.; // This eliminates predecessors from PredPredBB, which requires us to simplify; // any PHI nodes in PredBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:146,Usability,simpl,simplify,146,"// Update the terminator of PredPredBB to jump to NewBB instead of PredBB.; // This eliminates predecessors from PredPredBB, which requires us to simplify; // any PHI nodes in PredBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:43,Safety,safe,safe,43,/// tryThreadEdge - Thread an edge if it's safe and profitable to do so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:44,Safety,safe,safe,44,"/// threadEdge - We have decided that it is safe and profitable to factor the; /// blocks in PredBBs to one predecessor, then thread an edge from it to SuccBB; /// across BB. Transform the IR to reflect this change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:3,Deployability,Update,Update,3,"// Update the terminator of PredBB to jump to NewBB instead of BB. This; // eliminates predecessors from BB, which requires us to simplify any PHI; // nodes in BB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:130,Usability,simpl,simplify,130,"// Update the terminator of PredBB to jump to NewBB instead of BB. This; // eliminates predecessors from BB, which requires us to simplify any PHI; // nodes in BB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:23,Deployability,update,updates,23,// Enqueue required DT updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:3,Deployability,Update,Update,3,"// Update the edge weight from BB to SuccBB, which should be less than before.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:128,Availability,avail,available,128,"/// Create a new basic block that will be the predecessor of BB and successor of; /// all blocks in Preds. When profile data is available, update the frequency of; /// this new block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:139,Deployability,update,update,139,"/// Create a new basic block that will be the predecessor of BB and successor of; /// all blocks in Preds. When profile data is available, update the frequency of; /// this new block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:80,Deployability,update,update,80,"// Collect the frequencies of all predecessors of BB, which will be used to; // update the edge weight of the result of splitting predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:3,Deployability,Update,Update,3,// Update frequencies between Pred -> NewBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:4,Deployability,Update,Update,4,/// Update the block frequency of BB and branch weight and the metadata on the; /// edge BB->SuccBB. This is done by scaling the weight of BB->SuccBB by 1 -; /// Freq(PredBB->BB) / Freq(BB->SuccBB).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:56,Deployability,update,update,56,"// As the edge from PredBB to BB is deleted, we have to update the block; // frequency of BB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:11,Deployability,update,updated,11,// Collect updated outgoing edges' frequencies from BB and use them to update; // edge probabilities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:71,Deployability,update,update,71,// Collect updated outgoing edges' frequencies from BB and use them to update; // edge probabilities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:3,Deployability,Update,Update,3,// Update edge probabilities in BPI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:3,Deployability,Update,Update,3,"// Update the profile metadata as well.; //; // Don't do this if the profile of the transformed blocks was statically; // estimated. (This could occur despite the function having an entry; // frequency in completely cold parts of the CFG.); //; // In this case we don't want to suggest to subsequent passes that the; // calculated weights are fully consistent. Consider this graph:; //; // check_1; // 50% / |; // eq_1 | 50%; // \ |; // check_2; // 50% / |; // eq_2 | 50%; // \ |; // check_3; // 50% / |; // eq_3 | 50%; // \ |; //; // Assuming the blocks check_* all compare the same value against 1, 2 and 3,; // the overall probabilities are inconsistent; the total probability that the; // value is either 1, 2 or 3 is 150%.; //; // As a consequence if we thread eq_1 -> check_2 to check_3, check_2->check_3; // becomes 0%. This is even worse if the edge whose probability becomes 0% is; // the loop exit edge. Then based solely on static estimation we would assume; // the loop was extremely hot.; //; // FIXME this locally as well so that BPI and BFI are consistent as well. We; // shouldn't make edges extremely likely or unlikely based solely on static; // estimation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:21,Deployability,patch,patch,21,// Remap operands to patch up intra-block references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:64,Deployability,update,updated,64,"// If this instruction can be simplified after the operands are updated,; // just use the simplified value instead. This frequently happens due to; // phi translation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:30,Usability,simpl,simplified,30,"// If this instruction can be simplified after the operands are updated,; // just use the simplified value instead. This frequently happens due to; // phi translation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:90,Usability,simpl,simplified,90,"// If this instruction can be simplified after the operands are updated,; // just use the simplified value instead. This frequently happens due to; // phi translation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:3,Deployability,Update,Update,3,// Update Dominance from simplified New instruction operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:25,Usability,simpl,simplified,25,// Update Dominance from simplified New instruction operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:35,Deployability,update,update,35,// Create a conditional branch and update PHI nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:3,Deployability,Update,Update,3,// Update BPI if exists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:3,Deployability,Update,Update,3,// Update any other PHI nodes in BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:99,Usability,simpl,simplify,99,"// The second and third condition can be potentially relaxed. Currently; // the conditions help to simplify the code and allow us to reuse existing; // code, developed for tryToUnfoldSelect(CmpInst *, BasicBlock *)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:728,Performance,optimiz,optimizations,728,"/// tryToUnfoldSelectInCurrBB - Look for PHI/Select or PHI/CMP/Select in the; /// same BB in the form; /// bb:; /// %p = phi [false, %bb1], [true, %bb2], [false, %bb3], [true, %bb4], ...; /// %s = select %p, trueval, falseval; ///; /// or; ///; /// bb:; /// %p = phi [0, %bb1], [1, %bb2], [0, %bb3], [1, %bb4], ...; /// %c = cmp %p, 0; /// %s = select %c, trueval, falseval; ///; /// And expand the select into a branch structure. This later enables; /// jump-threading over bb in this pass.; ///; /// Using the similar approach of SimplifyCFG::FoldCondBranchOnPHI(), unfold; /// select if the associated PHI has at least one constant. If the unfolded; /// select is not jump-threaded, it will be folded again in the later; /// optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:532,Usability,Simpl,SimplifyCFG,532,"/// tryToUnfoldSelectInCurrBB - Look for PHI/Select or PHI/CMP/Select in the; /// same BB in the form; /// bb:; /// %p = phi [false, %bb1], [true, %bb2], [false, %bb3], [true, %bb4], ...; /// %s = select %p, trueval, falseval; ///; /// or; ///; /// bb:; /// %p = phi [0, %bb1], [1, %bb2], [0, %bb3], [1, %bb4], ...; /// %c = cmp %p, 0; /// %s = select %c, trueval, falseval; ///; /// And expand the select into a branch structure. This later enables; /// jump-threading over bb in this pass.; ///; /// Using the similar approach of SimplifyCFG::FoldCondBranchOnPHI(), unfold; /// select if the associated PHI has at least one constant. If the unfolded; /// select is not jump-threaded, it will be folded again in the later; /// optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:24,Energy Efficiency,reduce,reduce,24,// This transform would reduce the quality of msan diagnostics.; // Disable this transform under MemorySanitizer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:42,Deployability,update,update,42,"// BB's successors were moved to SplitBB, update DTU accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:214,Usability,simpl,simplest,214,"/// Try to propagate a guard from the current BB into one of its predecessors; /// in case if another branch of execution implies that the condition of this; /// guard is always true. Currently we only process the simplest case that; /// looks like:; ///; /// Start:; /// %cond = ...; /// br i1 %cond, label %T1, label %F1; /// T1:; /// br label %Merge; /// F1:; /// br label %Merge; /// Merge:; /// %condGuard = ...; /// call void(i1, ...) @llvm.experimental.guard( i1 %condGuard )[ ""deopt""() ]; ///; /// And cond either implies condGuard or !condGuard. In this case all the; /// instructions before the guard can be duplicated in both branches, and the; /// guard is then threaded to one of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:16,Safety,safe,safe,16,// True dest is safe if BranchCond => GuardCond.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:17,Safety,safe,safe,17,// False dest is safe if !BranchCond => GuardCond.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:66,Deployability,update,update,66,// TODO: We would like to preserve BPI/BFI. Enable once all paths update them.; // TODO: Would be nice to verify BPI/BFI consistency as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:3,Deployability,Update,Update,3,// Update DT/PDT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:3,Deployability,Update,Update,3,// Update analysis JumpThreading depends on and not explicitly preserved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:33,Integrability,depend,depends,33,// Update analysis JumpThreading depends on and not explicitly preserved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:140,Deployability,update,updated,140,"// Important note on validity of BPI/BFI. JumpThreading tries to preserve; // BPI/BFI as it goes. Thus if cached instance exists it will be updated.; // Otherwise, new instance of BPI/BFI is created (up to date by definition).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:106,Performance,cache,cached,106,"// Important note on validity of BPI/BFI. JumpThreading tries to preserve; // BPI/BFI as it goes. Thus if cached instance exists it will be updated.; // Otherwise, new instance of BPI/BFI is created (up to date by definition).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:974,Energy Efficiency,reduce,reduce,974,"----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // Hoisting operations out of loops is a canonicalization transform. It; // enables and simplifies subsequent optimizations in the middle-end.; // Rematerialization of hoisted instructions to reduce register pressure is the; // responsibility of the back-end, which has more accurate information about; // register pressure and also handles other optimizations than LICM that; // increase live-ranges.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary alloca'd variable. We then use; // the SSAUpdater to con",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:2007,Modifiability,variab,variable,2007,"m.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // Hoisting operations out of loops is a canonicalization transform. It; // enables and simplifies subsequent optimizations in the middle-end.; // Rematerialization of hoisted instructions to reduce register pressure is the; // responsibility of the back-end, which has more accurate information about; // register pressure and also handles other optimizations than LICM that; // increase live-ranges.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary alloca'd variable. We then use; // the SSAUpdater to construct the appropriate SSA form for the value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:393,Performance,perform,performs,393,"//===-- LICM.cpp - Loop Invariant Code Motion Pass ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // Hoisting operations out of loops is a canonicalization transform. It; // enables and simplifies subsequent optimizations in the middle-end.; // Rematerialization of hoisted instructions to reduce register pressure is the; // responsibility of the back-end, which has more accurate information about; // register pressure and also handles other optimizations than LICM that; // increase live-ranges.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary all",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:759,Performance,load,loads,759,"//===-- LICM.cpp - Loop Invariant Code Motion Pass ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // Hoisting operations out of loops is a canonicalization transform. It; // enables and simplifies subsequent optimizations in the middle-end.; // Rematerialization of hoisted instructions to reduce register pressure is the; // responsibility of the back-end, which has more accurate information about; // register pressure and also handles other optimizations than LICM that; // increase live-ranges.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary all",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:892,Performance,optimiz,optimizations,892,"//===-- LICM.cpp - Loop Invariant Code Motion Pass ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // Hoisting operations out of loops is a canonicalization transform. It; // enables and simplifies subsequent optimizations in the middle-end.; // Rematerialization of hoisted instructions to reduce register pressure is the; // responsibility of the back-end, which has more accurate information about; // register pressure and also handles other optimizations than LICM that; // increase live-ranges.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary all",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:1129,Performance,optimiz,optimizations,1129,"----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // Hoisting operations out of loops is a canonicalization transform. It; // enables and simplifies subsequent optimizations in the middle-end.; // Rematerialization of hoisted instructions to reduce register pressure is the; // responsibility of the back-end, which has more accurate information about; // register pressure and also handles other optimizations than LICM that; // increase live-ranges.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary alloca'd variable. We then use; // the SSAUpdater to con",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:1273,Performance,load,loads,1273,"m.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // Hoisting operations out of loops is a canonicalization transform. It; // enables and simplifies subsequent optimizations in the middle-end.; // Rematerialization of hoisted instructions to reduce register pressure is the; // responsibility of the back-end, which has more accurate information about; // register pressure and also handles other optimizations than LICM that; // increase live-ranges.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary alloca'd variable. We then use; // the SSAUpdater to construct the appropriate SSA form for the value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:1334,Performance,load,load,1334,"m.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // Hoisting operations out of loops is a canonicalization transform. It; // enables and simplifies subsequent optimizations in the middle-end.; // Rematerialization of hoisted instructions to reduce register pressure is the; // responsibility of the back-end, which has more accurate information about; // register pressure and also handles other optimizations than LICM that; // increase live-ranges.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary alloca'd variable. We then use; // the SSAUpdater to construct the appropriate SSA form for the value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:1767,Performance,load,loads,1767,"m.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // Hoisting operations out of loops is a canonicalization transform. It; // enables and simplifies subsequent optimizations in the middle-end.; // Rematerialization of hoisted instructions to reduce register pressure is the; // responsibility of the back-end, which has more accurate information about; // register pressure and also handles other optimizations than LICM that; // increase live-ranges.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary alloca'd variable. We then use; // the SSAUpdater to construct the appropriate SSA form for the value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:1931,Performance,load,loads,1931,"m.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // Hoisting operations out of loops is a canonicalization transform. It; // enables and simplifies subsequent optimizations in the middle-end.; // Rematerialization of hoisted instructions to reduce register pressure is the; // responsibility of the back-end, which has more accurate information about; // register pressure and also handles other optimizations than LICM that; // increase live-ranges.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary alloca'd variable. We then use; // the SSAUpdater to construct the appropriate SSA form for the value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:623,Safety,safe,safe,623,"//===-- LICM.cpp - Loop Invariant Code Motion Pass ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // Hoisting operations out of loops is a canonicalization transform. It; // enables and simplifies subsequent optimizations in the middle-end.; // Rematerialization of hoisted instructions to reduce register pressure is the; // responsibility of the back-end, which has more accurate information about; // register pressure and also handles other optimizations than LICM that; // increase live-ranges.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary all",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:870,Usability,simpl,simplifies,870,"//===-- LICM.cpp - Loop Invariant Code Motion Pass ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // Hoisting operations out of loops is a canonicalization transform. It; // enables and simplifies subsequent optimizations in the middle-end.; // Rematerialization of hoisted instructions to reduce register pressure is the; // responsibility of the back-end, which has more accurate information about; // register pressure and also handles other optimizations than LICM that; // increase live-ranges.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary all",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:401,Performance,optimiz,optimizeUses,401,"// Experimental option to allow imprecision in LICM in pathological cases, in; // exchange for faster compile. This is to be removed if MemorySSA starts to; // address the same issue. LICM calls MemorySSAWalker's; // getClobberingMemoryAccess, up to the value of the Cap, getting perfect; // accuracy. Afterwards, LICM will call into MemorySSA's getDefiningAccess,; // which may not be precise, since optimizeUses is capped. The result is; // correct, but we may not get as ""far up"" as possible to get which access is; // clobbering the one queried.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:508,Security,access,access,508,"// Experimental option to allow imprecision in LICM in pathological cases, in; // exchange for faster compile. This is to be removed if MemorySSA starts to; // address the same issue. LICM calls MemorySSAWalker's; // getClobberingMemoryAccess, up to the value of the Cap, getting perfect; // accuracy. Afterwards, LICM will call into MemorySSA's getDefiningAccess,; // which may not be precise, since optimizeUses is capped. The result is; // correct, but we may not get as ""far up"" as possible to get which access is; // clobbering the one queried.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:32,Performance,Optimiz,OptimizationRemarkEmitter,32,"// For the old PM, we can't use OptimizationRemarkEmitter as an analysis; // pass. Function analyses need to be preserved across loop transformations; // but ORE cannot be preserved (see comment before the pass definition).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:37,Performance,Optimiz,OptimizationRemarkEmitter,37,"// For the new PM, we also can't use OptimizationRemarkEmitter as an analysis; // pass. Function analyses need to be preserved across loop transformations; // but ORE cannot be preserved (see comment before the pass definition).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:37,Performance,Optimiz,OptimizationRemarkEmitter,37,"// For the new PM, we also can't use OptimizationRemarkEmitter as an analysis; // pass. Function analyses need to be preserved across loop transformations; // but ORE cannot be preserved (see comment before the pass definition).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:63,Performance,perform,performed,63,// If this loop has metadata indicating that LICM is not to be performed then; // just exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:401,Performance,perform,performance,401,"// Don't sink stores from loops with coroutine suspend instructions.; // LICM would sink instructions into the default destination of; // the coroutine switch. The default destination of the switch is to; // handle the case where the coroutine is suspended, by which point the; // coroutine frame may have been destroyed. No instruction can be sunk there.; // FIXME: This would unfortunately hurt the performance of coroutines, however; // there is currently no general solution for this. Similar issues could also; // potentially happen in other passes where instructions are being moved; // across that edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:16,Safety,safe,safety,16,// Compute loop safety information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:507,Performance,perform,perform,507,"// We want to visit all of the instructions in this loop... that are not parts; // of our subloops (they have already had their invariants hoisted out of; // their loop, into this loop, so there is no need to process the BODIES of; // the subloops).; //; // Traverse the body of the loop in depth first order on the dominator tree so; // that we are guaranteed to see definitions before we see uses. This allows; // us to sink instructions in one pass, without iteration. After sinking; // instructions, we perform another pass to hoist them out of the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:414,Availability,avail,available,414,"// Now that all loop invariants have been removed from the loop, promote any; // memory references to scalars that we can.; // Don't sink stores from loops without dedicated block exits. Exits; // containing indirect branches are not transformed by loop simplify,; // make sure we catch that. An additional load may be generated in the; // preheader for SSA updater, so also avoid sinking when no preheader; // is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:358,Deployability,update,updater,358,"// Now that all loop invariants have been removed from the loop, promote any; // memory references to scalars that we can.; // Don't sink stores from loops without dedicated block exits. Exits; // containing indirect branches are not transformed by loop simplify,; // make sure we catch that. An additional load may be generated in the; // preheader for SSA updater, so also avoid sinking when no preheader; // is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:307,Performance,load,load,307,"// Now that all loop invariants have been removed from the loop, promote any; // memory references to scalars that we can.; // Don't sink stores from loops without dedicated block exits. Exits; // containing indirect branches are not transformed by loop simplify,; // make sure we catch that. An additional load may be generated in the; // preheader for SSA updater, so also avoid sinking when no preheader; // is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:375,Safety,avoid,avoid,375,"// Now that all loop invariants have been removed from the loop, promote any; // memory references to scalars that we can.; // Don't sink stores from loops without dedicated block exits. Exits; // containing indirect branches are not transformed by loop simplify,; // make sure we catch that. An additional load may be generated in the; // preheader for SSA updater, so also avoid sinking when no preheader; // is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:254,Usability,simpl,simplify,254,"// Now that all loop invariants have been removed from the loop, promote any; // memory references to scalars that we can.; // Don't sink stores from loops without dedicated block exits. Exits; // containing indirect branches are not transformed by loop simplify,; // make sure we catch that. An additional load may be generated in the; // preheader for SSA updater, so also avoid sinking when no preheader; // is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:24,Security,access,accesses,24,"// Promoting one set of accesses may make the pointers for another set; // loop invariant, so run this in a loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:262,Safety,avoid,avoiding,262,"// The common successor has to be dominated by the branch, as otherwise; // there will be some other path to the successor that will not be; // controlled by this branch so any phi we hoist would be controlled by the; // wrong condition. This also takes care of avoiding hoisting of loop back; // edges.; // TODO: In some cases this could be relaxed if the successor is dominated; // by another block that's been hoisted and we can guarantee that the; // control flow has been replicated exactly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:49,Integrability,depend,depends,49,// Which blocks are predecessors via this branch depends on if the; // branch is triangle-like or diamond-like.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:156,Safety,safe,safe,156,// Try hoisting the instruction out to the preheader. We can only do; // this if all of the operands of the instruction are loop invariant and; // if it is safe to hoist the instruction. We also check block frequency; // to make sure instruction only gets hoisted into colder blocks.; // TODO: It may be safe to hoist if we are hoisting to a conditional block; // and we have accurately duplicated the control flow from the loop header; // to that block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:304,Safety,safe,safe,304,// Try hoisting the instruction out to the preheader. We can only do; // this if all of the operands of the instruction are loop invariant and; // if it is safe to hoist the instruction. We also check block frequency; // to make sure instruction only gets hoisted into colder blocks.; // TODO: It may be safe to hoist if we are hoisting to a conditional block; // and we have accurately duplicated the control flow from the loop header; // to that block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:203,Performance,load,loads,203,"// Return true if LI is invariant within scope of the loop. LI is invariant if; // CurLoop is dominated by an invariant.start representing the same memory; // location and size as the memory location LI loads from, and also the; // invariant.start has no uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:351,Modifiability,variab,variable,351,"// It is not currently possible for clang to generate an invariant.start; // intrinsic with scalable vector types because we don't support thread local; // sizeless types and we don't permit sizeless types in structs or classes.; // Furthermore, even if support is added for this in future the intrinsic; // itself is defined to have a size of -1 for variable sized objects. This; // makes it impossible to verify if the intrinsic envelops our region of; // interest. For example, both <vscale x 32 x i8> and <vscale x 16 x i8>; // types would have a -1 parameter, but the former is clearly double the size; // of the latter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:92,Performance,scalab,scalable,92,"// It is not currently possible for clang to generate an invariant.start; // intrinsic with scalable vector types because we don't support thread local; // sizeless types and we don't permit sizeless types in structs or classes.; // Furthermore, even if support is added for this in future the intrinsic; // itself is defined to have a size of -1 for variable sized objects. This; // makes it impossible to verify if the intrinsic envelops our region of; // interest. For example, both <vscale x 32 x i8> and <vscale x 16 x i8>; // types would have a -1 parameter, but the former is clearly double the size; // of the latter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:583,Usability,clear,clearly,583,"// It is not currently possible for clang to generate an invariant.start; // intrinsic with scalable vector types because we don't support thread local; // sizeless types and we don't permit sizeless types in structs or classes.; // Furthermore, even if support is added for this in future the intrinsic; // itself is defined to have a size of -1 for variable sized objects. This; // makes it impossible to verify if the intrinsic envelops our region of; // interest. For example, both <vscale x 32 x i8> and <vscale x 16 x i8>; // types would have a -1 parameter, but the former is clearly double the size; // of the latter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:28,Performance,load,load,28,"// Traverse all uses of the load operand value, to see if invariant.start is; // one of the uses, and whether it dominates the load instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:127,Performance,load,load,127,"// Traverse all uses of the load operand value, to see if invariant.start is; // one of the uses, and whether it dominates the load instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:24,Performance,Load,Load,24,// Avoid traversing for Load operand with high number of users.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:3,Safety,Avoid,Avoid,3,// Avoid traversing for Load operand with high number of users.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:66,Performance,load,load,66,"// If there are escaping uses of invariant.start instruction, the load maybe; // non-invariant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:51,Modifiability,variab,variable,51,// The intrinsic supports having a -1 argument for variable sized objects; // so we should check for that here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:58,Performance,load,load,58,"// Confirm the invariant.start location size contains the load operand size; // in bits. Also, the invariant.start should dominate the load, and we; // should not hoist the load out of a loop that contains this dominating; // invariant.start.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:135,Performance,load,load,135,"// Confirm the invariant.start location size contains the load operand size; // in bits. Also, the invariant.start should dominate the load, and we; // should not hoist the load out of a loop that contains this dominating; // invariant.start.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:173,Performance,load,load,173,"// Confirm the invariant.start location size contains the load operand size; // in bits. Also, the invariant.start should dominate the load, and we; // should not hoist the load out of a loop that contains this dominating; // invariant.start.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:193,Safety,safe,safety,193,/// Return true if-and-only-if we know how to (mechanically) both hoist and; /// sink a given instruction out of a loop. Does not address legality; /// concerns such as aliasing or speculation safety.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:3,Performance,Load,Loads,3,// Loads have extra constraints we have to verify before we can hoist them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:47,Performance,load,loads,47,"// Don't sink/hoist volatile or ordered atomic loads!; // Loads from constant memory are always safe to move, even if they end up; // in the same alias set as something that ends up being modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:58,Performance,Load,Loads,58,"// Don't sink/hoist volatile or ordered atomic loads!; // Loads from constant memory are always safe to move, even if they end up; // in the same alias set as something that ends up being modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:96,Safety,safe,safe,96,"// Don't sink/hoist volatile or ordered atomic loads!; // Loads from constant memory are always safe to move, even if they end up; // in the same alias set as something that ends up being modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:36,Performance,load,loads,36,// Don't risk duplicating unordered loads; // This checks for an invariant.start dominating the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:96,Performance,load,load,96,// Don't risk duplicating unordered loads; // This checks for an invariant.start dominating the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:9,Safety,risk,risk,9,// Don't risk duplicating unordered loads; // This checks for an invariant.start dominating the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:68,Performance,load,load,68,// Check loop-invariant address because this may also be a sinkable load; // whose address is not necessarily loop-invariant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:180,Safety,safe,safe,180,// Convergent attribute has been used on operations that involve; // inter-thread communication which results are implicitly affected by the; // enclosing control flows. It is not safe to hoist or sink such operations; // across control flow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:10,Usability,simpl,simple,10,// Handle simple cases by querying alias analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:268,Security,access,access,268,// FIXME: we don't handle the semantics of thread local well. So that the; // address of thread locals are fake constants in coroutines. So We forbid; // to treat onlyReadsMemory call in coroutines as constants now. Note that; // it is possible to hide a thread local access in a onlyReadsMemory call.; // Remove this check after we handle the semantics of thread locals well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:250,Modifiability,extend,extend,250,"// Don't sink/hoist volatile or ordered atomic store!; // We can only hoist a store that we can prove writes a value which is not; // read or overwritten within the loop. For those cases, we fallback to; // load store promotion instead. TODO: We can extend this to cases where; // there is exactly one write to the location and that write dominates an; // arbitrary number of reads in the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:207,Performance,load,load,207,"// Don't sink/hoist volatile or ordered atomic store!; // We can only hoist a store that we can prove writes a value which is not; // read or overwritten within the loop. For those cases, we fallback to; // load store promotion instead. TODO: We can extend this to cases where; // there is exactly one write to the location and that write dominates an; // arbitrary number of reads in the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:21,Security,access,accesses,21,"// If there are more accesses than the Promotion cap, then give up as we're; // not walking a list that long.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:263,Deployability,update,update,263,"// If there are interfering Uses (i.e. their defining access is in the; // loop), or ordered loads (stored as Defs!), don't move this store.; // Could do better here, but this is conservatively correct.; // TODO: Cache set of Uses on the first walk in runOnLoop, update when; // moving accesses. Can also extend to dominating uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:305,Modifiability,extend,extend,305,"// If there are interfering Uses (i.e. their defining access is in the; // loop), or ordered loads (stored as Defs!), don't move this store.; // Could do better here, but this is conservatively correct.; // TODO: Cache set of Uses on the first walk in runOnLoop, update when; // moving accesses. Can also extend to dominating uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:93,Performance,load,loads,93,"// If there are interfering Uses (i.e. their defining access is in the; // loop), or ordered loads (stored as Defs!), don't move this store.; // Could do better here, but this is conservatively correct.; // TODO: Cache set of Uses on the first walk in runOnLoop, update when; // moving accesses. Can also extend to dominating uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:213,Performance,Cache,Cache,213,"// If there are interfering Uses (i.e. their defining access is in the; // loop), or ordered loads (stored as Defs!), don't move this store.; // Could do better here, but this is conservatively correct.; // TODO: Cache set of Uses on the first walk in runOnLoop, update when; // moving accesses. Can also extend to dominating uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:54,Security,access,access,54,"// If there are interfering Uses (i.e. their defining access is in the; // loop), or ordered loads (stored as Defs!), don't move this store.; // Could do better here, but this is conservatively correct.; // TODO: Cache set of Uses on the first walk in runOnLoop, update when; // moving accesses. Can also extend to dominating uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:286,Security,access,accesses,286,"// If there are interfering Uses (i.e. their defining access is in the; // loop), or ordered loads (stored as Defs!), don't move this store.; // Could do better here, but this is conservatively correct.; // TODO: Cache set of Uses on the first walk in runOnLoop, update when; // moving accesses. Can also extend to dominating uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:49,Performance,load,loads,49,"// Disable hoisting past potentially interfering loads. Optimized; // Uses may point to an access outside the loop, as getClobbering; // checks the previous iteration when walking the backedge.; // FIXME: More precise: no Uses that alias SI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:56,Performance,Optimiz,Optimized,56,"// Disable hoisting past potentially interfering loads. Optimized; // Uses may point to an access outside the loop, as getClobbering; // checks the previous iteration when walking the backedge.; // FIXME: More precise: no Uses that alias SI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:91,Security,access,access,91,"// Disable hoisting past potentially interfering loads. Optimized; // Uses may point to an access outside the loop, as getClobbering; // checks the previous iteration when walking the backedge.; // FIXME: More precise: no Uses that alias SI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:144,Performance,perform,performed,144,// Check if the call may read from the memory location written; // to by SI. Check CI's attributes and arguments; the number of; // such checks performed is limited above by NoOfMemAccTooLarge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:89,Availability,fault,fault,89,"// We've established mechanical ability and aliasing, it's up to the caller; // to check fault safety",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:95,Safety,safe,safety,95,"// We've established mechanical ability and aliasing, it's up to the caller; // to check fault safety",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:24,Usability,simpl,simply,24,"// For a GEP, we cannot simply use getInstructionCost because currently; // it optimistically assumes that a GEP will fold into addressing mode; // regardless of its users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:288,Performance,load,load,288,"/// Return true if the only users of this instruction are outside of; /// the loop. If this is true, we can sink the instruction to the exit; /// blocks of the loop.; ///; /// We also return true if the instruction could be folded away in lowering.; /// (e.g., a GEP can be folded into a load as an addressing mode in the loop).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:51,Safety,Avoid,Avoid,51,// We need to sink a callsite to a unique funclet. Avoid sinking if the; // phi use is too muddled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:64,Security,access,access,64,// Create a new MemoryAccess and let MemorySSA set its defining access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:259,Usability,simpl,simple,259,"// It's not impossible to split EHPad blocks, but if BlockColors already exist; // it require updating BlockColors for all offspring blocks accordingly. By; // skipping such corner case, we can make updating BlockColors after splitting; // predecessor fairly simple.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:80,Security,expose,exposed,80,"// Split predecessors of the loop exit to make instructions in the loop are; // exposed to exit blocks through trivially replaceable PHIs while keeping the; // loop in the canonical form where each predecessor of each exit block should; // be contained within the loop. For example, this will convert the loop below; // from; //; // LB1:; // %v1 =; // br %LE, %LB2; // LB2:; // %v2 =; // br %LE, %LB1; // LE:; // %p = phi [%v1, %LB1], [%v2, %LB2] <-- non-trivially replaceable; //; // to; //; // LB1:; // %v1 =; // br %LE.split, %LB2; // LB2:; // %v2 =; // br %LE.split2, %LB1; // LE.split:; // %p1 = phi [%v1, %LB1] <-- trivially replaceable; // br %LE; // LE.split2:; // %p2 = phi [%v2, %LB2] <-- trivially replaceable; // br %LE; // LE:; // %p = phi [%p1, %LE.split], [%p2, %LE.split2]; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:99,Usability,simpl,simply,99,"// Since we do not allow splitting EH-block with BlockColors in; // canSplitPredecessors(), we can simply assign predecessor's color to; // the new block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:121,Deployability,patch,patches,121,"/// When an instruction is found to only be used outside of the loop, this; /// function moves it to the exit blocks and patches up SSA form as needed.; /// This method is guaranteed to remove the original instruction from its; /// position, and may either delete it or move it to outside of the loop.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:82,Safety,safe,safe,82,"/// When an instruction is found to only use loop invariant operands that; /// is safe to hoist, this instruction is called to do the dirty work.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:19,Integrability,depend,dependent,19,"// Metadata can be dependent on conditions we are hoisting above.; // Conservatively strip all metadata on the instruction unless we were; // guaranteed to execute I if we entered the loop, in which case the metadata; // is valid in the loop preheader.; // Similarly, If I is a call and it is not guaranteed to execute in the loop,; // then moving to the preheader means we should strip attributes on the call; // that can cause UB since we may be hoisting above conditions that allowed; // inferring those attributes. They may not be valid at the preheader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:178,Performance,optimiz,optimization,178,"// The check on hasMetadataOtherThanDebugLoc is to prevent us from burning; // time in isGuaranteedToExecute if we don't actually have anything to; // drop. It is a compile time optimization, not required for correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:157,Deployability,update,updater,157,"// Insert stores after in the loop exit blocks. Each exit block gets a; // store of the live-out values that feed them. Since we've already told; // the SSA updater about the defs in the loop and the preheader; // definition, it is all set and we can start using it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:19,Safety,safe,safety,19,"// FIXME: true for safety, false may still be correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:10,Performance,perform,perform,10,"// We can perform the captured-before check against any instruction in the; // loop header, as the loop header is reachable from any instruction inside; // the loop.; // TODO: ReturnCaptures=true shouldn't be necessary here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:108,Performance,load,loads,108,"// namespace; /// Try to promote memory values to scalars by sinking stores out of the; /// loop and moving loads to before the loop. We do this by looping over; /// the stores in the loop, looking for stores to Must pointers which are; /// loop invariant.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:31,Performance,load,load,31,"// It is not safe to promote a load/store from the loop if the load/store is; // conditional. For example, turning:; //; // for () { if (c) *P += 1; }; //; // into:; //; // tmp = *P; for () { if (c) tmp +=1; } *P = tmp;; //; // is not safe, because *P may only be valid to access if 'c' is true.; //; // The safety property divides into two parts:; // p1) The memory may not be dereferenceable on entry to the loop. In this; // case, we can't insert the required load in the preheader.; // p2) The memory model does not allow us to insert a store along any dynamic; // path which did not originally have one.; //; // If at least one store is guaranteed to execute, both properties are; // satisfied, and promotion is legal.; //; // This, however, is not a necessary condition. Even if no store/load is; // guaranteed to execute, we can still establish these properties.; // We can establish (p1) by proving that hoisting the load into the preheader; // is safe (i.e. proving dereferenceability on all paths through the loop). We; // can use any access within the alias set to prove dereferenceability,; // since they're all must alias.; //; // There are two ways establish (p2):; // a) Prove the location is thread-local. In this case the memory model; // requirement does not apply, and stores are safe to insert.; // b) Prove a store dominates every exit block. In this case, if an exit; // blocks is reached, the original dynamic path would have taken us through; // the store, so inserting a store into the exit block is safe. Note that this; // is different from the store being guaranteed to execute. For instance,; // if an exception is thrown on the first iteration of the loop, the original; // store is never executed, but the exit blocks are not executed either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:63,Performance,load,load,63,"// It is not safe to promote a load/store from the loop if the load/store is; // conditional. For example, turning:; //; // for () { if (c) *P += 1; }; //; // into:; //; // tmp = *P; for () { if (c) tmp +=1; } *P = tmp;; //; // is not safe, because *P may only be valid to access if 'c' is true.; //; // The safety property divides into two parts:; // p1) The memory may not be dereferenceable on entry to the loop. In this; // case, we can't insert the required load in the preheader.; // p2) The memory model does not allow us to insert a store along any dynamic; // path which did not originally have one.; //; // If at least one store is guaranteed to execute, both properties are; // satisfied, and promotion is legal.; //; // This, however, is not a necessary condition. Even if no store/load is; // guaranteed to execute, we can still establish these properties.; // We can establish (p1) by proving that hoisting the load into the preheader; // is safe (i.e. proving dereferenceability on all paths through the loop). We; // can use any access within the alias set to prove dereferenceability,; // since they're all must alias.; //; // There are two ways establish (p2):; // a) Prove the location is thread-local. In this case the memory model; // requirement does not apply, and stores are safe to insert.; // b) Prove a store dominates every exit block. In this case, if an exit; // blocks is reached, the original dynamic path would have taken us through; // the store, so inserting a store into the exit block is safe. Note that this; // is different from the store being guaranteed to execute. For instance,; // if an exception is thrown on the first iteration of the loop, the original; // store is never executed, but the exit blocks are not executed either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:463,Performance,load,load,463,"// It is not safe to promote a load/store from the loop if the load/store is; // conditional. For example, turning:; //; // for () { if (c) *P += 1; }; //; // into:; //; // tmp = *P; for () { if (c) tmp +=1; } *P = tmp;; //; // is not safe, because *P may only be valid to access if 'c' is true.; //; // The safety property divides into two parts:; // p1) The memory may not be dereferenceable on entry to the loop. In this; // case, we can't insert the required load in the preheader.; // p2) The memory model does not allow us to insert a store along any dynamic; // path which did not originally have one.; //; // If at least one store is guaranteed to execute, both properties are; // satisfied, and promotion is legal.; //; // This, however, is not a necessary condition. Even if no store/load is; // guaranteed to execute, we can still establish these properties.; // We can establish (p1) by proving that hoisting the load into the preheader; // is safe (i.e. proving dereferenceability on all paths through the loop). We; // can use any access within the alias set to prove dereferenceability,; // since they're all must alias.; //; // There are two ways establish (p2):; // a) Prove the location is thread-local. In this case the memory model; // requirement does not apply, and stores are safe to insert.; // b) Prove a store dominates every exit block. In this case, if an exit; // blocks is reached, the original dynamic path would have taken us through; // the store, so inserting a store into the exit block is safe. Note that this; // is different from the store being guaranteed to execute. For instance,; // if an exception is thrown on the first iteration of the loop, the original; // store is never executed, but the exit blocks are not executed either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:794,Performance,load,load,794,"// It is not safe to promote a load/store from the loop if the load/store is; // conditional. For example, turning:; //; // for () { if (c) *P += 1; }; //; // into:; //; // tmp = *P; for () { if (c) tmp +=1; } *P = tmp;; //; // is not safe, because *P may only be valid to access if 'c' is true.; //; // The safety property divides into two parts:; // p1) The memory may not be dereferenceable on entry to the loop. In this; // case, we can't insert the required load in the preheader.; // p2) The memory model does not allow us to insert a store along any dynamic; // path which did not originally have one.; //; // If at least one store is guaranteed to execute, both properties are; // satisfied, and promotion is legal.; //; // This, however, is not a necessary condition. Even if no store/load is; // guaranteed to execute, we can still establish these properties.; // We can establish (p1) by proving that hoisting the load into the preheader; // is safe (i.e. proving dereferenceability on all paths through the loop). We; // can use any access within the alias set to prove dereferenceability,; // since they're all must alias.; //; // There are two ways establish (p2):; // a) Prove the location is thread-local. In this case the memory model; // requirement does not apply, and stores are safe to insert.; // b) Prove a store dominates every exit block. In this case, if an exit; // blocks is reached, the original dynamic path would have taken us through; // the store, so inserting a store into the exit block is safe. Note that this; // is different from the store being guaranteed to execute. For instance,; // if an exception is thrown on the first iteration of the loop, the original; // store is never executed, but the exit blocks are not executed either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:925,Performance,load,load,925,"// It is not safe to promote a load/store from the loop if the load/store is; // conditional. For example, turning:; //; // for () { if (c) *P += 1; }; //; // into:; //; // tmp = *P; for () { if (c) tmp +=1; } *P = tmp;; //; // is not safe, because *P may only be valid to access if 'c' is true.; //; // The safety property divides into two parts:; // p1) The memory may not be dereferenceable on entry to the loop. In this; // case, we can't insert the required load in the preheader.; // p2) The memory model does not allow us to insert a store along any dynamic; // path which did not originally have one.; //; // If at least one store is guaranteed to execute, both properties are; // satisfied, and promotion is legal.; //; // This, however, is not a necessary condition. Even if no store/load is; // guaranteed to execute, we can still establish these properties.; // We can establish (p1) by proving that hoisting the load into the preheader; // is safe (i.e. proving dereferenceability on all paths through the loop). We; // can use any access within the alias set to prove dereferenceability,; // since they're all must alias.; //; // There are two ways establish (p2):; // a) Prove the location is thread-local. In this case the memory model; // requirement does not apply, and stores are safe to insert.; // b) Prove a store dominates every exit block. In this case, if an exit; // blocks is reached, the original dynamic path would have taken us through; // the store, so inserting a store into the exit block is safe. Note that this; // is different from the store being guaranteed to execute. For instance,; // if an exception is thrown on the first iteration of the loop, the original; // store is never executed, but the exit blocks are not executed either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:13,Safety,safe,safe,13,"// It is not safe to promote a load/store from the loop if the load/store is; // conditional. For example, turning:; //; // for () { if (c) *P += 1; }; //; // into:; //; // tmp = *P; for () { if (c) tmp +=1; } *P = tmp;; //; // is not safe, because *P may only be valid to access if 'c' is true.; //; // The safety property divides into two parts:; // p1) The memory may not be dereferenceable on entry to the loop. In this; // case, we can't insert the required load in the preheader.; // p2) The memory model does not allow us to insert a store along any dynamic; // path which did not originally have one.; //; // If at least one store is guaranteed to execute, both properties are; // satisfied, and promotion is legal.; //; // This, however, is not a necessary condition. Even if no store/load is; // guaranteed to execute, we can still establish these properties.; // We can establish (p1) by proving that hoisting the load into the preheader; // is safe (i.e. proving dereferenceability on all paths through the loop). We; // can use any access within the alias set to prove dereferenceability,; // since they're all must alias.; //; // There are two ways establish (p2):; // a) Prove the location is thread-local. In this case the memory model; // requirement does not apply, and stores are safe to insert.; // b) Prove a store dominates every exit block. In this case, if an exit; // blocks is reached, the original dynamic path would have taken us through; // the store, so inserting a store into the exit block is safe. Note that this; // is different from the store being guaranteed to execute. For instance,; // if an exception is thrown on the first iteration of the loop, the original; // store is never executed, but the exit blocks are not executed either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:235,Safety,safe,safe,235,"// It is not safe to promote a load/store from the loop if the load/store is; // conditional. For example, turning:; //; // for () { if (c) *P += 1; }; //; // into:; //; // tmp = *P; for () { if (c) tmp +=1; } *P = tmp;; //; // is not safe, because *P may only be valid to access if 'c' is true.; //; // The safety property divides into two parts:; // p1) The memory may not be dereferenceable on entry to the loop. In this; // case, we can't insert the required load in the preheader.; // p2) The memory model does not allow us to insert a store along any dynamic; // path which did not originally have one.; //; // If at least one store is guaranteed to execute, both properties are; // satisfied, and promotion is legal.; //; // This, however, is not a necessary condition. Even if no store/load is; // guaranteed to execute, we can still establish these properties.; // We can establish (p1) by proving that hoisting the load into the preheader; // is safe (i.e. proving dereferenceability on all paths through the loop). We; // can use any access within the alias set to prove dereferenceability,; // since they're all must alias.; //; // There are two ways establish (p2):; // a) Prove the location is thread-local. In this case the memory model; // requirement does not apply, and stores are safe to insert.; // b) Prove a store dominates every exit block. In this case, if an exit; // blocks is reached, the original dynamic path would have taken us through; // the store, so inserting a store into the exit block is safe. Note that this; // is different from the store being guaranteed to execute. For instance,; // if an exception is thrown on the first iteration of the loop, the original; // store is never executed, but the exit blocks are not executed either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:308,Safety,safe,safety,308,"// It is not safe to promote a load/store from the loop if the load/store is; // conditional. For example, turning:; //; // for () { if (c) *P += 1; }; //; // into:; //; // tmp = *P; for () { if (c) tmp +=1; } *P = tmp;; //; // is not safe, because *P may only be valid to access if 'c' is true.; //; // The safety property divides into two parts:; // p1) The memory may not be dereferenceable on entry to the loop. In this; // case, we can't insert the required load in the preheader.; // p2) The memory model does not allow us to insert a store along any dynamic; // path which did not originally have one.; //; // If at least one store is guaranteed to execute, both properties are; // satisfied, and promotion is legal.; //; // This, however, is not a necessary condition. Even if no store/load is; // guaranteed to execute, we can still establish these properties.; // We can establish (p1) by proving that hoisting the load into the preheader; // is safe (i.e. proving dereferenceability on all paths through the loop). We; // can use any access within the alias set to prove dereferenceability,; // since they're all must alias.; //; // There are two ways establish (p2):; // a) Prove the location is thread-local. In this case the memory model; // requirement does not apply, and stores are safe to insert.; // b) Prove a store dominates every exit block. In this case, if an exit; // blocks is reached, the original dynamic path would have taken us through; // the store, so inserting a store into the exit block is safe. Note that this; // is different from the store being guaranteed to execute. For instance,; // if an exception is thrown on the first iteration of the loop, the original; // store is never executed, but the exit blocks are not executed either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:956,Safety,safe,safe,956,"// It is not safe to promote a load/store from the loop if the load/store is; // conditional. For example, turning:; //; // for () { if (c) *P += 1; }; //; // into:; //; // tmp = *P; for () { if (c) tmp +=1; } *P = tmp;; //; // is not safe, because *P may only be valid to access if 'c' is true.; //; // The safety property divides into two parts:; // p1) The memory may not be dereferenceable on entry to the loop. In this; // case, we can't insert the required load in the preheader.; // p2) The memory model does not allow us to insert a store along any dynamic; // path which did not originally have one.; //; // If at least one store is guaranteed to execute, both properties are; // satisfied, and promotion is legal.; //; // This, however, is not a necessary condition. Even if no store/load is; // guaranteed to execute, we can still establish these properties.; // We can establish (p1) by proving that hoisting the load into the preheader; // is safe (i.e. proving dereferenceability on all paths through the loop). We; // can use any access within the alias set to prove dereferenceability,; // since they're all must alias.; //; // There are two ways establish (p2):; // a) Prove the location is thread-local. In this case the memory model; // requirement does not apply, and stores are safe to insert.; // b) Prove a store dominates every exit block. In this case, if an exit; // blocks is reached, the original dynamic path would have taken us through; // the store, so inserting a store into the exit block is safe. Note that this; // is different from the store being guaranteed to execute. For instance,; // if an exception is thrown on the first iteration of the loop, the original; // store is never executed, but the exit blocks are not executed either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:1299,Safety,safe,safe,1299,"// It is not safe to promote a load/store from the loop if the load/store is; // conditional. For example, turning:; //; // for () { if (c) *P += 1; }; //; // into:; //; // tmp = *P; for () { if (c) tmp +=1; } *P = tmp;; //; // is not safe, because *P may only be valid to access if 'c' is true.; //; // The safety property divides into two parts:; // p1) The memory may not be dereferenceable on entry to the loop. In this; // case, we can't insert the required load in the preheader.; // p2) The memory model does not allow us to insert a store along any dynamic; // path which did not originally have one.; //; // If at least one store is guaranteed to execute, both properties are; // satisfied, and promotion is legal.; //; // This, however, is not a necessary condition. Even if no store/load is; // guaranteed to execute, we can still establish these properties.; // We can establish (p1) by proving that hoisting the load into the preheader; // is safe (i.e. proving dereferenceability on all paths through the loop). We; // can use any access within the alias set to prove dereferenceability,; // since they're all must alias.; //; // There are two ways establish (p2):; // a) Prove the location is thread-local. In this case the memory model; // requirement does not apply, and stores are safe to insert.; // b) Prove a store dominates every exit block. In this case, if an exit; // blocks is reached, the original dynamic path would have taken us through; // the store, so inserting a store into the exit block is safe. Note that this; // is different from the store being guaranteed to execute. For instance,; // if an exception is thrown on the first iteration of the loop, the original; // store is never executed, but the exit blocks are not executed either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:1525,Safety,safe,safe,1525,"// It is not safe to promote a load/store from the loop if the load/store is; // conditional. For example, turning:; //; // for () { if (c) *P += 1; }; //; // into:; //; // tmp = *P; for () { if (c) tmp +=1; } *P = tmp;; //; // is not safe, because *P may only be valid to access if 'c' is true.; //; // The safety property divides into two parts:; // p1) The memory may not be dereferenceable on entry to the loop. In this; // case, we can't insert the required load in the preheader.; // p2) The memory model does not allow us to insert a store along any dynamic; // path which did not originally have one.; //; // If at least one store is guaranteed to execute, both properties are; // satisfied, and promotion is legal.; //; // This, however, is not a necessary condition. Even if no store/load is; // guaranteed to execute, we can still establish these properties.; // We can establish (p1) by proving that hoisting the load into the preheader; // is safe (i.e. proving dereferenceability on all paths through the loop). We; // can use any access within the alias set to prove dereferenceability,; // since they're all must alias.; //; // There are two ways establish (p2):; // a) Prove the location is thread-local. In this case the memory model; // requirement does not apply, and stores are safe to insert.; // b) Prove a store dominates every exit block. In this case, if an exit; // blocks is reached, the original dynamic path would have taken us through; // the store, so inserting a store into the exit block is safe. Note that this; // is different from the store being guaranteed to execute. For instance,; // if an exception is thrown on the first iteration of the loop, the original; // store is never executed, but the exit blocks are not executed either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:273,Security,access,access,273,"// It is not safe to promote a load/store from the loop if the load/store is; // conditional. For example, turning:; //; // for () { if (c) *P += 1; }; //; // into:; //; // tmp = *P; for () { if (c) tmp +=1; } *P = tmp;; //; // is not safe, because *P may only be valid to access if 'c' is true.; //; // The safety property divides into two parts:; // p1) The memory may not be dereferenceable on entry to the loop. In this; // case, we can't insert the required load in the preheader.; // p2) The memory model does not allow us to insert a store along any dynamic; // path which did not originally have one.; //; // If at least one store is guaranteed to execute, both properties are; // satisfied, and promotion is legal.; //; // This, however, is not a necessary condition. Even if no store/load is; // guaranteed to execute, we can still establish these properties.; // We can establish (p1) by proving that hoisting the load into the preheader; // is safe (i.e. proving dereferenceability on all paths through the loop). We; // can use any access within the alias set to prove dereferenceability,; // since they're all must alias.; //; // There are two ways establish (p2):; // a) Prove the location is thread-local. In this case the memory model; // requirement does not apply, and stores are safe to insert.; // b) Prove a store dominates every exit block. In this case, if an exit; // blocks is reached, the original dynamic path would have taken us through; // the store, so inserting a store into the exit block is safe. Note that this; // is different from the store being guaranteed to execute. For instance,; // if an exception is thrown on the first iteration of the loop, the original; // store is never executed, but the exit blocks are not executed either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:1045,Security,access,access,1045,"// It is not safe to promote a load/store from the loop if the load/store is; // conditional. For example, turning:; //; // for () { if (c) *P += 1; }; //; // into:; //; // tmp = *P; for () { if (c) tmp +=1; } *P = tmp;; //; // is not safe, because *P may only be valid to access if 'c' is true.; //; // The safety property divides into two parts:; // p1) The memory may not be dereferenceable on entry to the loop. In this; // case, we can't insert the required load in the preheader.; // p2) The memory model does not allow us to insert a store along any dynamic; // path which did not originally have one.; //; // If at least one store is guaranteed to execute, both properties are; // satisfied, and promotion is legal.; //; // This, however, is not a necessary condition. Even if no store/load is; // guaranteed to execute, we can still establish these properties.; // We can establish (p1) by proving that hoisting the load into the preheader; // is safe (i.e. proving dereferenceability on all paths through the loop). We; // can use any access within the alias set to prove dereferenceability,; // since they're all must alias.; //; // There are two ways establish (p2):; // a) Prove the location is thread-local. In this case the memory model; // requirement does not apply, and stores are safe to insert.; // b) Prove a store dominates every exit block. In this case, if an exit; // blocks is reached, the original dynamic path would have taken us through; // the store, so inserting a store into the exit block is safe. Note that this; // is different from the store being guaranteed to execute. For instance,; // if an exception is thrown on the first iteration of the loop, the original; // store is never executed, but the exit blocks are not executed either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:31,Safety,Safe,Safe,31,"// Goes from Unknown to either Safe or Unsafe, but can't switch between them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:39,Safety,Unsafe,Unsafe,39,"// Goes from Unknown to either Safe or Unsafe, but can't switch between them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:32,Security,access,access,32,// Keep track of which types of access we see,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:92,Safety,safe,safe,92,"// If there are reads outside the promoted set, then promoting stores is; // definitely not safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:336,Performance,load,load,336,"// If a loop can throw, we have to insert a store along each unwind edge.; // That said, we can't actually make the unwind edge explicit. Therefore,; // we have to prove that the store is dead along the unwind edge. We do; // this by proving that the caller can't have a reference to the object; // after return and thus can't possibly load from the object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:129,Performance,load,loaded,129,"// Check that all accesses to pointers in the alias set use the same type.; // We cannot (yet) promote a memory location that is loaded and stored in; // different sizes. While we are at it, collect alignment and AA info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:18,Security,access,accesses,18,"// Check that all accesses to pointers in the alias set use the same type.; // We cannot (yet) promote a memory location that is loaded and stored in; // different sizes. While we are at it, collect alignment and AA info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:22,Performance,load,load,22,"// If there is an non-load/store instruction in the loop, we can't promote; // it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:23,Performance,load,load,23,// Note that proving a load safe to speculate requires proving; // sufficient alignment at the target location. Proving it guaranteed; // to execute does as well. Thus we can increase our guaranteed; // alignment as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:28,Safety,safe,safe,28,// Note that proving a load safe to speculate requires proving; // sufficient alignment at the target location. Proving it guaranteed; // to execute does as well. Thus we can increase our guaranteed; // alignment as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:180,Safety,safe,safe,180,"// If the store is guaranteed to execute, both properties are satisfied.; // We may want to check if a store is guaranteed to execute even if we; // already know that promotion is safe, since it may have higher; // alignment than any other guaranteed stores, in which case we can; // raise the alignment on the promoted store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:47,Safety,safe,safe,47,"// If a store dominates all exit blocks, it is safe to sink.; // As explained above, if an exit block was executed, a dominating; // store must have been executed at least once, so we are not; // introducing stores on paths that did not have them.; // Note that this only looks at explicit exit blocks. If we ever; // start sinking stores into unwind edges (see above), this will break.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:9,Performance,load,load,9,// Not a load or store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:16,Performance,load,load,16,"// On the first load/store, just take its AA tags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:201,Availability,down,downgrade,201,"// If we found both an unordered atomic instruction and a non-atomic memory; // access, bail. We can't blindly promote non-atomic to atomic since we; // might not be able to lower the result. We can't downgrade since that; // would violate memory model. Also, align 0 is an error for atomics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:274,Availability,error,error,274,"// If we found both an unordered atomic instruction and a non-atomic memory; // access, bail. We can't blindly promote non-atomic to atomic since we; // might not be able to lower the result. We can't downgrade since that; // would violate memory model. Also, align 0 is an error for atomics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:80,Security,access,access,80,"// If we found both an unordered atomic instruction and a non-atomic memory; // access, bail. We can't blindly promote non-atomic to atomic since we; // might not be able to lower the result. We can't downgrade since that; // would violate memory model. Also, align 0 is an error for atomics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:32,Performance,load,load,32,"// If we're inserting an atomic load in the preheader, we must be able to; // lower it. We're only guaranteed to be able to lower naturally aligned; // atomics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:41,Performance,load,load,41,"// If we couldn't prove we can hoist the load, bail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:28,Performance,load,load,28,"// We know we can hoist the load, but don't have a guaranteed store.; // Check whether the location is writable and thread-local. If it is, then we; // can insert stores along paths which originally didn't have them without; // violating the memory model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:67,Performance,load,load,67,"// If we've still failed to prove we can sink the store, hoist the load; // only, if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:26,Performance,load,load,26,"// If we cannot hoist the load either, give up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:25,Integrability,interface,interface,25,// We use the SSAUpdater interface to insert phi nodes as required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite all the loads in the loop and remember all the definitions from; // stores in the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:19,Performance,load,loads,19,// Rewrite all the loads in the loop and remember all the definitions from; // stores in the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:36,Performance,load,load,36,"// If the SSAUpdater didn't use the load in the preheader, just zap it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:91,Performance,load,loads,91,"// The bool indicates whether there might be reads outside the set, in which; // case only loads may be promoted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:44,Security,access,accesses,44,// Populate AST with potentially promotable accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:92,Security,access,access,92,// Nothing to promote...; // Discard any sets for which there is an aliasing non-promotable access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:45,Safety,safe,safety,45,"// For hoisting, use the walker to determine safety",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:91,Performance,load,loaded,91,"// If hoisting an invariant group, we only need to check that there; // is no store to the loaded pointer between the start of the loop,; // and the load (since all values must be the same).; // This can be checked in two conditions:; // 1) if the memoryaccess is outside the loop; // 2) the earliest access is at the loop header,; // if the memory loaded is the phi node",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:149,Performance,load,load,149,"// If hoisting an invariant group, we only need to check that there; // is no store to the loaded pointer between the start of the loop,; // and the load (since all values must be the same).; // This can be checked in two conditions:; // 1) if the memoryaccess is outside the loop; // 2) the earliest access is at the loop header,; // if the memory loaded is the phi node",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:349,Performance,load,loaded,349,"// If hoisting an invariant group, we only need to check that there; // is no store to the loaded pointer between the start of the loop,; // and the load (since all values must be the same).; // This can be checked in two conditions:; // 1) if the memoryaccess is outside the loop; // 2) the earliest access is at the loop header,; // if the memory loaded is the phi node",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:301,Security,access,access,301,"// If hoisting an invariant group, we only need to check that there; // is no store to the loaded pointer between the start of the loop,; // and the load (since all values must be the same).; // This can be checked in two conditions:; // 1) if the memoryaccess is outside the loop; // 2) the earliest access is at the loop header,; // if the memory loaded is the phi node",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:241,Performance,load,load,241,"// For sinking, we'd need to check all Defs below this use. The getClobbering; // call will look on the backedge of the loop, but will check aliasing with; // the instructions on the previous iteration.; // For example:; // for (i ... ); // load a[i] ( Use (LoE); // store a[i] ( 1 = Def (2), with 2 = Phi for the loop.; // i++;; // The load sees no clobbering inside the loop, as the backedge alias check; // does phi translation, and will check aliasing against store a[i-1].; // However sinking the load outside the loop, below the store is incorrect.; // For now, only sink if there are no Defs in the loop, and the existing ones; // precede the use and are in the same block.; // FIXME: Increase precision: Safe to sink if Use post dominates the Def;; // needs PostDominatorTreeAnalysis.; // FIXME: More precise: no Defs that alias this Use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:337,Performance,load,load,337,"// For sinking, we'd need to check all Defs below this use. The getClobbering; // call will look on the backedge of the loop, but will check aliasing with; // the instructions on the previous iteration.; // For example:; // for (i ... ); // load a[i] ( Use (LoE); // store a[i] ( 1 = Def (2), with 2 = Phi for the loop.; // i++;; // The load sees no clobbering inside the loop, as the backedge alias check; // does phi translation, and will check aliasing against store a[i-1].; // However sinking the load outside the loop, below the store is incorrect.; // For now, only sink if there are no Defs in the loop, and the existing ones; // precede the use and are in the same block.; // FIXME: Increase precision: Safe to sink if Use post dominates the Def;; // needs PostDominatorTreeAnalysis.; // FIXME: More precise: no Defs that alias this Use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:502,Performance,load,load,502,"// For sinking, we'd need to check all Defs below this use. The getClobbering; // call will look on the backedge of the loop, but will check aliasing with; // the instructions on the previous iteration.; // For example:; // for (i ... ); // load a[i] ( Use (LoE); // store a[i] ( 1 = Def (2), with 2 = Phi for the loop.; // i++;; // The load sees no clobbering inside the loop, as the backedge alias check; // does phi translation, and will check aliasing against store a[i-1].; // However sinking the load outside the loop, below the store is incorrect.; // For now, only sink if there are no Defs in the loop, and the existing ones; // precede the use and are in the same block.; // FIXME: Increase precision: Safe to sink if Use post dominates the Def;; // needs PostDominatorTreeAnalysis.; // FIXME: More precise: no Defs that alias this Use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:712,Safety,Safe,Safe,712,"// For sinking, we'd need to check all Defs below this use. The getClobbering; // call will look on the backedge of the loop, but will check aliasing with; // the instructions on the previous iteration.; // For example:; // for (i ... ); // load a[i] ( Use (LoE); // store a[i] ( 1 = Def (2), with 2 = Phi for the loop.; // i++;; // The load sees no clobbering inside the loop, as the backedge alias check; // does phi translation, and will check aliasing against store a[i-1].; // However sinking the load outside the loop, below the store is incorrect.; // For now, only sink if there are no Defs in the loop, and the existing ones; // precede the use and are in the same block.; // FIXME: Increase precision: Safe to sink if Use post dominates the Def;; // needs PostDominatorTreeAnalysis.; // FIXME: More precise: no Defs that alias this Use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:11,Usability,simpl,simplify,11,"/// Try to simplify things like (A < INV_1 AND icmp A < INV_2) into (A <; /// min(INV_1, INV_2)), if INV_1 and INV_2 are both loop invariants and their; /// minimun can be computed outside of loop, and X is not a loop-invariant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:121,Testability,log,logical,121,"// We are about to create a new guaranteed use for RHS2 which might not exist; // before (if it was a non-taken input of logical and/or instruction). If it; // was poison, we need to freeze it. Note that no new use for LHS and RHS1 are; // introduced, so they don't need this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:117,Usability,simpl,simplicity,117,"// The swapped GEPs are inbounds if both original GEPs are inbounds; // and the sign of the offsets is the same. For simplicity, only; // handle both offsets being non-negative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:251,Safety,avoid,avoid,251,"// In order to turn ""LV + C1 < C2"" into ""LV < C2 - C1"", we need to be able to; // freely move values from left side of inequality to right side (just as in; // normal linear arithmetics). Overflows make things much more complicated, so; // we want to avoid this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:251,Safety,avoid,avoid,251,"// In order to turn ""LV - C1 < C2"" into ""LV < C2 + C1"", we need to be able to; // freely move values from left side of inequality to right side (just as in; // normal linear arithmetics). Overflows make things much more complicated, so; // we want to avoid this. Likewise, for ""C1 - LV < C2"" we need to prove that; // ""C1 - C2"" does not overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize complex patterns, such as (x < INV1 && x < INV2), turning them; // into (x < min(INV1, INV2)), and hoisting the invariant part of this; // expression out of the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopAccessAnalysisPrinter.cpp:44,Security,Access,Access,44,"//===- LoopAccessAnalysisPrinter.cpp - Loop Access Analysis Printer --------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopAccessAnalysisPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopAccessAnalysisPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp:40,Deployability,update,update,40,"// If the Cond.AddRecValue is PHI node, update Cond.NonPHIAddRecValue with; // value from backedge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp:31,Modifiability,variab,variable,31,// Allowed AddRec as induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp:20,Usability,simpl,simplified,20,// Check loop is in simplified form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp:3,Deployability,Update,Update,3,// Update phi nodes in header of post-loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp:65,Deployability,update,update,65,"// If the exiting block is loop latch, the phi does not have the update at; // last iteration. In this case, update lcssa phi with value from backedge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp:109,Deployability,update,update,109,"// If the exiting block is loop latch, the phi does not have the update at; // last iteration. In this case, update lcssa phi with value from backedge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp:3,Deployability,Update,Update,3,// Update the start value of phi node in post-loop with the LCSSA phi node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp:3,Deployability,Update,Update,3,// Update phi node in exit block of post-loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp:3,Deployability,Update,Update,3,// Update dominator tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp:14,Performance,cache,cached,14,// Invalidate cached SE information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopBoundSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp:31,Security,access,accesses,31,/// Check if the stride of the accesses is large enough to; /// warrant a prefetch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp:184,Performance,Cache,CacheLineSize,184,"// If PrefetchDistance is not set, don't run the pass. This gives an; // opportunity for targets to run this pass for selected subtargets only; // (whose TTI sets PrefetchDistance and CacheLineSize).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp:146,Security,access,accesses,146,/// A record for a potential prefetch made during the initial scan of the; /// loop. This is used to let a single prefetch target multiple memory accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp:37,Security,access,access,37,/// True if targeting a write memory access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp:115,Deployability,update,updated,115,"/// Add the instruction \param I to this prefetch. If it's not the first; /// one, 'InsertPt' and 'Writes' will be updated as required.; /// \param PtrDiff the known constant address difference to the first added; /// instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp:47,Performance,cache,cache,47,"// We don't want to double prefetch individual cache lines. If this; // access is known to be within one cache line of some other one that; // has already been prefetched, then don't prefetch this one as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp:105,Performance,cache,cache,105,"// We don't want to double prefetch individual cache lines. If this; // access is known to be within one cache line of some other one that; // has already been prefetched, then don't prefetch this one as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp:72,Security,access,access,72,"// We don't want to double prefetch individual cache lines. If this; // access is known to be within one cache line of some other one that; // has already been prefetched, then don't prefetch this one as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp:30,Security,access,accesses,30,// Check if the stride of the accesses is large enough to warrant a; // prefetch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp:139,Performance,load,loads,139,"// Make sure that no instructions in the block have potential side-effects.; // This includes instructions that could write to memory, and loads that are; // marked volatile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp:28,Performance,cache,cache,28,// Quick hack: do not flood cache with non-instruction values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp:22,Performance,cache,cached,22,// Do we already know cached result?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp:11,Performance,optimiz,optimization,11,"// For the optimization to be correct, we need RPOT to have a property that; // each block is processed after all its predecessors, which may only be; // violated for headers of the current loop and all nested loops. Irreducible; // CFG provides multiple ways to break this assumption, so we do not want to; // deal with it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp:13,Usability,simpl,simplify,13,// Failed to simplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp:503,Safety,safe,safety,503,"/// Remove a loop if it is dead.; ///; /// A loop is considered dead either if it does not impact the observable; /// behavior of the program other than finite running time, or if it is; /// required to make progress by an attribute such as 'mustprogress' or; /// 'llvm.loop.mustprogress' and does not make any. This may remove; /// infinite loops that have been required to make progress.; ///; /// This entire process relies pretty heavily on LoopSimplify form and LCSSA in; /// order to make various safety checks work.; ///; /// \returns true if any changes were made. This may mutate the loop even if it; /// is unable to delete it due to hoisting trivially loop invariant; /// instructions out of the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp:136,Availability,avail,available,136,"// We can only remove the loop if there is a preheader that we can branch from; // after removing it. Also, if LoopSimplify form is not available, stay out; // of trouble.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp:216,Testability,log,logic,216,"// We require that the loop has at most one exit block. Otherwise, we'd be in; // the situation of needing to be able to solve statically which exit block; // will be branched to, or trying to preserve the branching logic in a loop; // invariant manner.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp:32,Performance,Optimiz,OptimizationRemarkEmitter,32,"// For the new PM, we can't use OptimizationRemarkEmitter as an analysis; // pass. Function analyses need to be preserved across loop transformations; // but ORE cannot be preserved (see comment before the pass definition).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:507,Integrability,depend,dependence,507,"//===- LoopDistribute.cpp - Loop Distribution Pass ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Loop Distribution Pass. Its main focus is to; // distribute loops that cannot be vectorized due to dependence cycles. It; // tries to isolate the offending dependences into a new loop allowing; // vectorization of the remaining parts.; //; // For dependence analysis, the pass uses the LoopVectorizer's; // LoopAccessAnalysis. Because this analysis presumes no change in the order of; // memory operations, special care is taken to preserve the lexical order of; // these operations.; //; // Similarly to the Vectorizer, the pass also supports loop versioning to; // run-time disambiguate potentially overlapping arrays.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:564,Integrability,depend,dependences,564,"//===- LoopDistribute.cpp - Loop Distribution Pass ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Loop Distribution Pass. Its main focus is to; // distribute loops that cannot be vectorized due to dependence cycles. It; // tries to isolate the offending dependences into a new loop allowing; // vectorization of the remaining parts.; //; // For dependence analysis, the pass uses the LoopVectorizer's; // LoopAccessAnalysis. Because this analysis presumes no change in the order of; // memory operations, special care is taken to preserve the lexical order of; // these operations.; //; // Similarly to the Vectorizer, the pass also supports loop versioning to; // run-time disambiguate potentially overlapping arrays.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:655,Integrability,depend,dependence,655,"//===- LoopDistribute.cpp - Loop Distribution Pass ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Loop Distribution Pass. Its main focus is to; // distribute loops that cannot be vectorized due to dependence cycles. It; // tries to isolate the offending dependences into a new loop allowing; // vectorization of the remaining parts.; //; // For dependence analysis, the pass uses the LoopVectorizer's; // LoopAccessAnalysis. Because this analysis presumes no change in the order of; // memory operations, special care is taken to preserve the lexical order of; // these operations.; //; // Similarly to the Vectorizer, the pass also supports loop versioning to; // run-time disambiguate potentially overlapping arrays.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:46,Integrability,depend,dependence,46,/// Returns whether this partition contains a dependence cycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:15,Security,access,accessors,15,/// Collection accessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:112,Integrability,depend,dependent,112,/// Populates the partition with a transitive closure of all the; /// instructions that the seeded instructions dependent on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:41,Integrability,depend,dependence,41,// FIXME: We currently don't use control-dependence but simply include all; // blocks (possibly empty at the end) and let simplifycfg mostly clean this; // up.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:56,Usability,simpl,simply,56,// FIXME: We currently don't use control-dependence but simply include all; // blocks (possibly empty at the end) and let simplifycfg mostly clean this; // up.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:122,Usability,simpl,simplifycfg,122,// FIXME: We currently don't use control-dependence but simply include all; // blocks (possibly empty at the end) and let simplifycfg mostly clean this; // up.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:126,Integrability,depend,depend,126,// Follow the use-def chains to form a transitive closure of all the; // instructions that the originally seeded instructions depend on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:45,Integrability,depend,depend,45,// Insert instructions from the loop that we depend on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:40,Deployability,Update,Updates,40,/// Clones the original loop.; ///; /// Updates LoopInfo and DominatorTree using the information that block \p; /// LoopDomBB dominates the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:86,Deployability,update,update,86,"// Delete the instructions backwards, as it has a reduced likelihood of; // having to update as many def-use and use-def chains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:50,Energy Efficiency,reduce,reduced,50,"// Delete the instructions backwards, as it has a reduced likelihood of; // having to update as many def-use and use-def chains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:38,Integrability,depend,dependence,38,/// Whether this partition contains a dependence cycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:69,Integrability,depend,dependence,69,"/// Adds \p Inst into a partition that is not marked to contain; /// dependence cycles.; ///; // Initially we isolate memory instructions into as many partitions as; // possible, then later we may merge them back together.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:184,Integrability,depend,dependency,184,/// Merges partitions in order to ensure that no loads are duplicated.; ///; /// We can't duplicate loads because that could potentially reorder them.; /// LoopAccessAnalysis provides dependency information with the context that; /// the order of memory operation is preserved.; ///; /// Return if any partitions were merged.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:49,Performance,load,loads,49,/// Merges partitions in order to ensure that no loads are duplicated.; ///; /// We can't duplicate loads because that could potentially reorder them.; /// LoopAccessAnalysis provides dependency information with the context that; /// the order of memory operation is preserved.; ///; /// Return if any partitions were merged.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:100,Performance,load,loads,100,/// Merges partitions in order to ensure that no loads are duplicated.; ///; /// We can't duplicate loads because that could potentially reorder them.; /// LoopAccessAnalysis provides dependency information with the context that; /// the order of memory operation is preserved.; ///; /// Return if any partitions were merged.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:99,Performance,load,load,99,// Step through the partitions and create equivalence between partitions; // that contain the same load. Also put partitions in between them in the; // same equivalence class to avoid reordering of memory operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:178,Safety,avoid,avoid,178,// Step through the partitions and create equivalence between partitions; // that contain the same load. Also put partitions in between them in the; // same equivalence class to avoid reordering of memory operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:8,Performance,load,load,8,"// If a load occurs in two partitions PartI and PartJ, merge all; // partitions (PartI, PartJ] into PartI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:9,Performance,perform,performs,9,/// This performs the main chunk of the work of cloning the loops for; /// the partitions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:151,Deployability,update,update,151,// Create a loop for each partition except the last. Clone the original; // loop before PH along with adding a preheader for the cloned loop. Then; // update PH to point to the newly added preheader.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:31,Deployability,update,update,31,// Now go in forward order and update the immediate dominator for the; // preheaders with the exiting block of the previous loop. Dominance; // within the loop is updated in cloneLoopWithPreheader.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:163,Deployability,update,updated,163,// Now go in forward order and update the immediate dominator for the; // preheaders with the exiting block of the previous loop. Dominance; // within the loop is updated in cloneLoopWithPreheader.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:94,Integrability,depend,dependences,94,"/// For each memory instruction, this class maintains difference of the; /// number of unsafe dependences that start out from this instruction minus; /// those that end here.; ///; /// By traversing the memory instructions in program order and accumulating this; /// number, we know whether any unsafe dependence crosses over a program point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:302,Integrability,depend,dependence,302,"/// For each memory instruction, this class maintains difference of the; /// number of unsafe dependences that start out from this instruction minus; /// those that end here.; ///; /// By traversing the memory instructions in program order and accumulating this; /// number, we know whether any unsafe dependence crosses over a program point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:87,Safety,unsafe,unsafe,87,"/// For each memory instruction, this class maintains difference of the; /// number of unsafe dependences that start out from this instruction minus; /// those that end here.; ///; /// By traversing the memory instructions in program order and accumulating this; /// number, we know whether any unsafe dependence crosses over a program point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:295,Safety,unsafe,unsafe,295,"/// For each memory instruction, this class maintains difference of the; /// number of unsafe dependences that start out from this instruction minus; /// those that end here.; ///; /// By traversing the memory instructions in program order and accumulating this; /// number, we know whether any unsafe dependence crosses over a program point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:21,Performance,perform,performing,21,/// The actual class performing the per-loop work.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:74,Integrability,depend,dependence,74,"// Currently, we only distribute to isolate the part of the loop with; // dependence cycles to enable partial vectorization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:164,Integrability,depend,dependences,164,"// First, go through each memory operation and assign them to consecutive; // partitions (the order of partitions follows program order). Put those; // with unsafe dependences into ""cyclic"" partition otherwise put each store; // in its own ""non-cyclic"" partition (we'll merge these later).; //; // Note that a memory operation (e.g. Load2 below) at a program point that; // has an unsafe dependence (Store3->Load1) spanning over it must be; // included in the same cyclic partition as the dependent operations. This; // is to preserve the original program order after distribution. E.g.:; //; // NumUnsafeDependencesStartOrEnd NumUnsafeDependencesActive; // Load1 -. 1 0->1; // Load2 | /Unsafe/ 0 1; // Store3 -' -1 1->0; // Load4 0 0; //; // NumUnsafeDependencesActive > 0 indicates this situation and in this case; // we just keep assigning to the same cyclic partition until; // NumUnsafeDependencesActive reaches 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:388,Integrability,depend,dependence,388,"// First, go through each memory operation and assign them to consecutive; // partitions (the order of partitions follows program order). Put those; // with unsafe dependences into ""cyclic"" partition otherwise put each store; // in its own ""non-cyclic"" partition (we'll merge these later).; //; // Note that a memory operation (e.g. Load2 below) at a program point that; // has an unsafe dependence (Store3->Load1) spanning over it must be; // included in the same cyclic partition as the dependent operations. This; // is to preserve the original program order after distribution. E.g.:; //; // NumUnsafeDependencesStartOrEnd NumUnsafeDependencesActive; // Load1 -. 1 0->1; // Load2 | /Unsafe/ 0 1; // Store3 -' -1 1->0; // Load4 0 0; //; // NumUnsafeDependencesActive > 0 indicates this situation and in this case; // we just keep assigning to the same cyclic partition until; // NumUnsafeDependencesActive reaches 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:489,Integrability,depend,dependent,489,"// First, go through each memory operation and assign them to consecutive; // partitions (the order of partitions follows program order). Put those; // with unsafe dependences into ""cyclic"" partition otherwise put each store; // in its own ""non-cyclic"" partition (we'll merge these later).; //; // Note that a memory operation (e.g. Load2 below) at a program point that; // has an unsafe dependence (Store3->Load1) spanning over it must be; // included in the same cyclic partition as the dependent operations. This; // is to preserve the original program order after distribution. E.g.:; //; // NumUnsafeDependencesStartOrEnd NumUnsafeDependencesActive; // Load1 -. 1 0->1; // Load2 | /Unsafe/ 0 1; // Store3 -' -1 1->0; // Load4 0 0; //; // NumUnsafeDependencesActive > 0 indicates this situation and in this case; // we just keep assigning to the same cyclic partition until; // NumUnsafeDependencesActive reaches 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:157,Safety,unsafe,unsafe,157,"// First, go through each memory operation and assign them to consecutive; // partitions (the order of partitions follows program order). Put those; // with unsafe dependences into ""cyclic"" partition otherwise put each store; // in its own ""non-cyclic"" partition (we'll merge these later).; //; // Note that a memory operation (e.g. Load2 below) at a program point that; // has an unsafe dependence (Store3->Load1) spanning over it must be; // included in the same cyclic partition as the dependent operations. This; // is to preserve the original program order after distribution. E.g.:; //; // NumUnsafeDependencesStartOrEnd NumUnsafeDependencesActive; // Load1 -. 1 0->1; // Load2 | /Unsafe/ 0 1; // Store3 -' -1 1->0; // Load4 0 0; //; // NumUnsafeDependencesActive > 0 indicates this situation and in this case; // we just keep assigning to the same cyclic partition until; // NumUnsafeDependencesActive reaches 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:381,Safety,unsafe,unsafe,381,"// First, go through each memory operation and assign them to consecutive; // partitions (the order of partitions follows program order). Put those; // with unsafe dependences into ""cyclic"" partition otherwise put each store; // in its own ""non-cyclic"" partition (we'll merge these later).; //; // Note that a memory operation (e.g. Load2 below) at a program point that; // has an unsafe dependence (Store3->Load1) spanning over it must be; // included in the same cyclic partition as the dependent operations. This; // is to preserve the original program order after distribution. E.g.:; //; // NumUnsafeDependencesStartOrEnd NumUnsafeDependencesActive; // Load1 -. 1 0->1; // Load2 | /Unsafe/ 0 1; // Store3 -' -1 1->0; // Load4 0 0; //; // NumUnsafeDependencesActive > 0 indicates this situation and in this case; // we just keep assigning to the same cyclic partition until; // NumUnsafeDependencesActive reaches 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:687,Safety,Unsafe,Unsafe,687,"// First, go through each memory operation and assign them to consecutive; // partitions (the order of partitions follows program order). Put those; // with unsafe dependences into ""cyclic"" partition otherwise put each store; // in its own ""non-cyclic"" partition (we'll merge these later).; //; // Note that a memory operation (e.g. Load2 below) at a program point that; // has an unsafe dependence (Store3->Load1) spanning over it must be; // included in the same cyclic partition as the dependent operations. This; // is to preserve the original program order after distribution. E.g.:; //; // NumUnsafeDependencesStartOrEnd NumUnsafeDependencesActive; // Load1 -. 1 0->1; // Load2 | /Unsafe/ 0 1; // Store3 -' -1 1->0; // Load4 0 0; //; // NumUnsafeDependencesActive > 0 indicates this situation and in this case; // we just keep assigning to the same cyclic partition until; // NumUnsafeDependencesActive reaches 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:6,Deployability,update,update,6,"// We update NumUnsafeDependencesActive post-instruction, catch the; // start of a dependence directly via NumUnsafeDependencesStartOrEnd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:83,Integrability,depend,dependence,83,"// We update NumUnsafeDependencesActive post-instruction, catch the; // start of a dependence directly via NumUnsafeDependencesStartOrEnd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:164,Performance,load,load,164,// Add partitions for values used outside. These partitions can be out of; // order from the original program order. This is OK because if the; // partition uses a load we will merge this partition with the original; // partition of the load that we set up in the previous loop (see; // mergeToAvoidDuplicatedLoads).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:237,Performance,load,load,237,// Add partitions for values used outside. These partitions can be out of; // order from the original program order. This is OK because if the; // partition uses a load we will merge this partition with the original; // partition of the load that we set up in the previous loop (see; // mergeToAvoidDuplicatedLoads).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:51,Performance,load,loads,51,"// In order to preserve original lexical order for loads, keep them in the; // partition that we set up in the MemoryInstructionDependences loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:18,Usability,simpl,simple,18,"// To keep things simple have an empty preheader before we version or clone; // the loop. (Also split if this has no predecessor, i.e. entry, because we; // rely on PH having a predecessor.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:51,Modifiability,inherit,inherit,51,"// The unversioned loop will not be changed, so we inherit all attributes; // from the original loop, but remove the loop distribution metadata to; // avoid to distribute it again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:151,Safety,avoid,avoid,151,"// The unversioned loop will not be changed, so we inherit all attributes; // from the original loop, but remove the loop distribution metadata to; // avoid to distribute it again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:243,Safety,safe,safely,243,/// Filter out checks between pointers from the same partition.; ///; /// \p PtrToPartition contains the partition number for pointers. Partition; /// number -1 means that the pointer is used in multiple partitions. In this; /// case we can't safely omit the check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:760,Modifiability,variab,variables,760,"//===- LoopFlatten.cpp - Loop flattening pass------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass flattens pairs nested loops into a single loop.; //; // The intention is to optimise loop nests like this, which together access an; // array linearly:; //; // for (int i = 0; i < N; ++i); // for (int j = 0; j < M; ++j); // f(A[i*M+j]);; //; // into one loop:; //; // for (int i = 0; i < (N*M); ++i); // f(A[i]);; //; // It can also flatten loops where the induction variables are not used in the; // loop. This is only worth doing if the induction variables are only used in an; // expression like i*M+j. If they had any other uses, we would have to insert a; // div/mod to reconstruct the original values, so this wouldn't be profitable.; //; // We also need to prove that N*M will not overflow. The preferred solution is; // to widen the IV, which avoids overflow checks, so that is tried first. If; // the IV cannot be widened, then we try to determine that this new tripcount; // expression won't overflow.; //; // Q: Does LoopFlatten use SCEV?; // Short answer: Yes and no.; //; // Long answer:; // For this transformation to be valid, we require all uses of the induction; // variables to be linear expressions of the form i*M+j. The different Loop; // APIs are used to get some loop components like the induction variable,; // compare statement, etc. In addition, we do some pattern matching to find the; // linear expressions and other loop components like the loop increment. The; // latter are examples of expressions that do use the induction variable, but; // are safe to ignore when we check all uses to be of the form i*M+j. We keep; // track of all of this in bookkeeping struct FlattenInfo.;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:842,Modifiability,variab,variables,842,"//===- LoopFlatten.cpp - Loop flattening pass------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass flattens pairs nested loops into a single loop.; //; // The intention is to optimise loop nests like this, which together access an; // array linearly:; //; // for (int i = 0; i < N; ++i); // for (int j = 0; j < M; ++j); // f(A[i*M+j]);; //; // into one loop:; //; // for (int i = 0; i < (N*M); ++i); // f(A[i]);; //; // It can also flatten loops where the induction variables are not used in the; // loop. This is only worth doing if the induction variables are only used in an; // expression like i*M+j. If they had any other uses, we would have to insert a; // div/mod to reconstruct the original values, so this wouldn't be profitable.; //; // We also need to prove that N*M will not overflow. The preferred solution is; // to widen the IV, which avoids overflow checks, so that is tried first. If; // the IV cannot be widened, then we try to determine that this new tripcount; // expression won't overflow.; //; // Q: Does LoopFlatten use SCEV?; // Short answer: Yes and no.; //; // Long answer:; // For this transformation to be valid, we require all uses of the induction; // variables to be linear expressions of the form i*M+j. The different Loop; // APIs are used to get some loop components like the induction variable,; // compare statement, etc. In addition, we do some pattern matching to find the; // linear expressions and other loop components like the loop increment. The; // latter are examples of expressions that do use the induction variable, but; // are safe to ignore when we check all uses to be of the form i*M+j. We keep; // track of all of this in bookkeeping struct FlattenInfo.;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:1476,Modifiability,variab,variables,1476,"-----------===//; //; // This pass flattens pairs nested loops into a single loop.; //; // The intention is to optimise loop nests like this, which together access an; // array linearly:; //; // for (int i = 0; i < N; ++i); // for (int j = 0; j < M; ++j); // f(A[i*M+j]);; //; // into one loop:; //; // for (int i = 0; i < (N*M); ++i); // f(A[i]);; //; // It can also flatten loops where the induction variables are not used in the; // loop. This is only worth doing if the induction variables are only used in an; // expression like i*M+j. If they had any other uses, we would have to insert a; // div/mod to reconstruct the original values, so this wouldn't be profitable.; //; // We also need to prove that N*M will not overflow. The preferred solution is; // to widen the IV, which avoids overflow checks, so that is tried first. If; // the IV cannot be widened, then we try to determine that this new tripcount; // expression won't overflow.; //; // Q: Does LoopFlatten use SCEV?; // Short answer: Yes and no.; //; // Long answer:; // For this transformation to be valid, we require all uses of the induction; // variables to be linear expressions of the form i*M+j. The different Loop; // APIs are used to get some loop components like the induction variable,; // compare statement, etc. In addition, we do some pattern matching to find the; // linear expressions and other loop components like the loop increment. The; // latter are examples of expressions that do use the induction variable, but; // are safe to ignore when we check all uses to be of the form i*M+j. We keep; // track of all of this in bookkeeping struct FlattenInfo.; // We assume the loops to be canonical, i.e. starting at 0 and increment with; // 1. This makes RHS of the compare the loop tripcount (with the right; // predicate). We use SCEV to then sanity check that this tripcount matches; // with the tripcount as computed by SCEV.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:1614,Modifiability,variab,variable,1614,"-----------===//; //; // This pass flattens pairs nested loops into a single loop.; //; // The intention is to optimise loop nests like this, which together access an; // array linearly:; //; // for (int i = 0; i < N; ++i); // for (int j = 0; j < M; ++j); // f(A[i*M+j]);; //; // into one loop:; //; // for (int i = 0; i < (N*M); ++i); // f(A[i]);; //; // It can also flatten loops where the induction variables are not used in the; // loop. This is only worth doing if the induction variables are only used in an; // expression like i*M+j. If they had any other uses, we would have to insert a; // div/mod to reconstruct the original values, so this wouldn't be profitable.; //; // We also need to prove that N*M will not overflow. The preferred solution is; // to widen the IV, which avoids overflow checks, so that is tried first. If; // the IV cannot be widened, then we try to determine that this new tripcount; // expression won't overflow.; //; // Q: Does LoopFlatten use SCEV?; // Short answer: Yes and no.; //; // Long answer:; // For this transformation to be valid, we require all uses of the induction; // variables to be linear expressions of the form i*M+j. The different Loop; // APIs are used to get some loop components like the induction variable,; // compare statement, etc. In addition, we do some pattern matching to find the; // linear expressions and other loop components like the loop increment. The; // latter are examples of expressions that do use the induction variable, but; // are safe to ignore when we check all uses to be of the form i*M+j. We keep; // track of all of this in bookkeeping struct FlattenInfo.; // We assume the loops to be canonical, i.e. starting at 0 and increment with; // 1. This makes RHS of the compare the loop tripcount (with the right; // predicate). We use SCEV to then sanity check that this tripcount matches; // with the tripcount as computed by SCEV.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:1848,Modifiability,variab,variable,1848,"-----------===//; //; // This pass flattens pairs nested loops into a single loop.; //; // The intention is to optimise loop nests like this, which together access an; // array linearly:; //; // for (int i = 0; i < N; ++i); // for (int j = 0; j < M; ++j); // f(A[i*M+j]);; //; // into one loop:; //; // for (int i = 0; i < (N*M); ++i); // f(A[i]);; //; // It can also flatten loops where the induction variables are not used in the; // loop. This is only worth doing if the induction variables are only used in an; // expression like i*M+j. If they had any other uses, we would have to insert a; // div/mod to reconstruct the original values, so this wouldn't be profitable.; //; // We also need to prove that N*M will not overflow. The preferred solution is; // to widen the IV, which avoids overflow checks, so that is tried first. If; // the IV cannot be widened, then we try to determine that this new tripcount; // expression won't overflow.; //; // Q: Does LoopFlatten use SCEV?; // Short answer: Yes and no.; //; // Long answer:; // For this transformation to be valid, we require all uses of the induction; // variables to be linear expressions of the form i*M+j. The different Loop; // APIs are used to get some loop components like the induction variable,; // compare statement, etc. In addition, we do some pattern matching to find the; // linear expressions and other loop components like the loop increment. The; // latter are examples of expressions that do use the induction variable, but; // are safe to ignore when we check all uses to be of the form i*M+j. We keep; // track of all of this in bookkeeping struct FlattenInfo.; // We assume the loops to be canonical, i.e. starting at 0 and increment with; // 1. This makes RHS of the compare the loop tripcount (with the right; // predicate). We use SCEV to then sanity check that this tripcount matches; // with the tripcount as computed by SCEV.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:1144,Safety,avoid,avoids,1144,"v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass flattens pairs nested loops into a single loop.; //; // The intention is to optimise loop nests like this, which together access an; // array linearly:; //; // for (int i = 0; i < N; ++i); // for (int j = 0; j < M; ++j); // f(A[i*M+j]);; //; // into one loop:; //; // for (int i = 0; i < (N*M); ++i); // f(A[i]);; //; // It can also flatten loops where the induction variables are not used in the; // loop. This is only worth doing if the induction variables are only used in an; // expression like i*M+j. If they had any other uses, we would have to insert a; // div/mod to reconstruct the original values, so this wouldn't be profitable.; //; // We also need to prove that N*M will not overflow. The preferred solution is; // to widen the IV, which avoids overflow checks, so that is tried first. If; // the IV cannot be widened, then we try to determine that this new tripcount; // expression won't overflow.; //; // Q: Does LoopFlatten use SCEV?; // Short answer: Yes and no.; //; // Long answer:; // For this transformation to be valid, we require all uses of the induction; // variables to be linear expressions of the form i*M+j. The different Loop; // APIs are used to get some loop components like the induction variable,; // compare statement, etc. In addition, we do some pattern matching to find the; // linear expressions and other loop components like the loop increment. The; // latter are examples of expressions that do use the induction variable, but; // are safe to ignore when we check all uses to be of the form i*M+j. We keep; // track of all of this in bookkeeping struct FlattenInfo.; // We assume the loops to be canonical, i.e. starting at 0 and increment with; // 1. This makes RHS of the compare the loop tripcount (with",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:1870,Safety,safe,safe,1870,"-----------===//; //; // This pass flattens pairs nested loops into a single loop.; //; // The intention is to optimise loop nests like this, which together access an; // array linearly:; //; // for (int i = 0; i < N; ++i); // for (int j = 0; j < M; ++j); // f(A[i*M+j]);; //; // into one loop:; //; // for (int i = 0; i < (N*M); ++i); // f(A[i]);; //; // It can also flatten loops where the induction variables are not used in the; // loop. This is only worth doing if the induction variables are only used in an; // expression like i*M+j. If they had any other uses, we would have to insert a; // div/mod to reconstruct the original values, so this wouldn't be profitable.; //; // We also need to prove that N*M will not overflow. The preferred solution is; // to widen the IV, which avoids overflow checks, so that is tried first. If; // the IV cannot be widened, then we try to determine that this new tripcount; // expression won't overflow.; //; // Q: Does LoopFlatten use SCEV?; // Short answer: Yes and no.; //; // Long answer:; // For this transformation to be valid, we require all uses of the induction; // variables to be linear expressions of the form i*M+j. The different Loop; // APIs are used to get some loop components like the induction variable,; // compare statement, etc. In addition, we do some pattern matching to find the; // linear expressions and other loop components like the loop increment. The; // latter are examples of expressions that do use the induction variable, but; // are safe to ignore when we check all uses to be of the form i*M+j. We keep; // track of all of this in bookkeeping struct FlattenInfo.; // We assume the loops to be canonical, i.e. starting at 0 and increment with; // 1. This makes RHS of the compare the loop tripcount (with the right; // predicate). We use SCEV to then sanity check that this tripcount matches; // with the tripcount as computed by SCEV.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:2188,Safety,sanity check,sanity check,2188,"-----------===//; //; // This pass flattens pairs nested loops into a single loop.; //; // The intention is to optimise loop nests like this, which together access an; // array linearly:; //; // for (int i = 0; i < N; ++i); // for (int j = 0; j < M; ++j); // f(A[i*M+j]);; //; // into one loop:; //; // for (int i = 0; i < (N*M); ++i); // f(A[i]);; //; // It can also flatten loops where the induction variables are not used in the; // loop. This is only worth doing if the induction variables are only used in an; // expression like i*M+j. If they had any other uses, we would have to insert a; // div/mod to reconstruct the original values, so this wouldn't be profitable.; //; // We also need to prove that N*M will not overflow. The preferred solution is; // to widen the IV, which avoids overflow checks, so that is tried first. If; // the IV cannot be widened, then we try to determine that this new tripcount; // expression won't overflow.; //; // Q: Does LoopFlatten use SCEV?; // Short answer: Yes and no.; //; // Long answer:; // For this transformation to be valid, we require all uses of the induction; // variables to be linear expressions of the form i*M+j. The different Loop; // APIs are used to get some loop components like the induction variable,; // compare statement, etc. In addition, we do some pattern matching to find the; // linear expressions and other loop components like the loop increment. The; // latter are examples of expressions that do use the induction variable, but; // are safe to ignore when we check all uses to be of the form i*M+j. We keep; // track of all of this in bookkeeping struct FlattenInfo.; // We assume the loops to be canonical, i.e. starting at 0 and increment with; // 1. This makes RHS of the compare the loop tripcount (with the right; // predicate). We use SCEV to then sanity check that this tripcount matches; // with the tripcount as computed by SCEV.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:515,Security,access,access,515,"//===- LoopFlatten.cpp - Loop flattening pass------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass flattens pairs nested loops into a single loop.; //; // The intention is to optimise loop nests like this, which together access an; // array linearly:; //; // for (int i = 0; i < N; ++i); // for (int j = 0; j < M; ++j); // f(A[i*M+j]);; //; // into one loop:; //; // for (int i = 0; i < (N*M); ++i); // f(A[i]);; //; // It can also flatten loops where the induction variables are not used in the; // loop. This is only worth doing if the induction variables are only used in an; // expression like i*M+j. If they had any other uses, we would have to insert a; // div/mod to reconstruct the original values, so this wouldn't be profitable.; //; // We also need to prove that N*M will not overflow. The preferred solution is; // to widen the IV, which avoids overflow checks, so that is tried first. If; // the IV cannot be widened, then we try to determine that this new tripcount; // expression won't overflow.; //; // Q: Does LoopFlatten use SCEV?; // Short answer: Yes and no.; //; // Long answer:; // For this transformation to be valid, we require all uses of the induction; // variables to be linear expressions of the form i*M+j. The different Loop; // APIs are used to get some loop components like the induction variable,; // compare statement, etc. In addition, we do some pattern matching to find the; // linear expressions and other loop components like the loop increment. The; // latter are examples of expressions that do use the induction variable, but; // are safe to ignore when we check all uses to be of the form i*M+j. We keep; // track of all of this in bookkeeping struct FlattenInfo.;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:41,Modifiability,variab,variables,41,"// We require all uses of both induction variables to match this pattern:; //; // (OuterPHI * InnerTripCount) + InnerPHI; //; // I.e., it needs to be a linear expression of the induction variables and the; // inner loop trip count. We keep track of all different expressions on which; // checks will be performed in this bookkeeping struct.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:187,Modifiability,variab,variables,187,"// We require all uses of both induction variables to match this pattern:; //; // (OuterPHI * InnerTripCount) + InnerPHI; //; // I.e., it needs to be a linear expression of the induction variables and the; // inner loop trip count. We keep track of all different expressions on which; // checks will be performed in this bookkeeping struct.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:303,Performance,perform,performed,303,"// We require all uses of both induction variables to match this pattern:; //; // (OuterPHI * InnerTripCount) + InnerPHI; //; // I.e., it needs to be a linear expression of the induction variables and the; // inner loop trip count. We keep track of all different expressions on which; // checks will be performed in this bookkeeping struct.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:13,Modifiability,variab,variables,13,"// induction variables, which are; // expected to start at zero and; // increment by one on each loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:21,Modifiability,variab,variables,21,// Uses of induction variables in,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:7,Safety,safe,safe,7,// are safe to ignore.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:40,Deployability,update,updated,40,// The instruction that needs to be; // updated with new tripcount.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:136,Modifiability,variab,variables,136,"// Matches the same pattern as above, except it also looks for truncs; // on the phi, which can be the result of widening the induction variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:16,Modifiability,extend,extends,16,// Look through extends if the IV has been widened. Don't look through; // extends if we already looked through a trunc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:75,Modifiability,extend,extends,75,// Look through extends if the IV has been widened. Don't look through; // extends if we already looked through a trunc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:92,Performance,perform,performed,92,"// Evaluating in the trip count's type can not overflow here as the overflow; // checks are performed in checkOverflow, but are first tried to avoid by; // widening the IV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:143,Safety,avoid,avoid,143,"// Evaluating in the trip count's type can not overflow here as the overflow; // checks are performed in checkOverflow, but are first tried to avoid by; // widening the IV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:12,Modifiability,extend,extended,12,// Find the extended backedge taken count and extended trip count using; // SCEV. One of these should now match the RHS of the compare.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:46,Modifiability,extend,extended,46,// Find the extended backedge taken count and extended trip count using; // SCEV. One of these should now match the RHS of the compare.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:23,Modifiability,variab,variable,23,"// Finds the induction variable, increment and trip count for a simple loop that; // we can flatten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:64,Usability,simpl,simple,64,"// Finds the induction variable, increment and trip count for a simple loop that; // we can flatten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:65,Modifiability,variab,variable,65,"// Currently, to simplify the implementation, the Loop induction variable must; // start at zero and increment with a step size of one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:17,Usability,simpl,simplify,17,"// Currently, to simplify the implementation, the Loop induction variable must; // start at zero and increment with a step size of one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:111,Modifiability,variab,variables,111,"// Find the induction PHI. If there is no induction PHI, we can't do the; // transformation. TODO: could other variables trigger this? Do we have to; // search for the best one?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:194,Modifiability,variab,variable,194,// Find increment and trip count.; // There are exactly 2 incoming values to the induction phi; one from the; // pre-header and one from the latch. The incoming latch value is the; // increment variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:139,Modifiability,variab,variable,139,"// The trip count is the RHS of the compare. If this doesn't match the trip; // count computed by SCEV then this is because the trip count variable; // has been widened so the types don't match, or because it is a constant and; // another transformation has changed the compare (e.g. icmp ult %inc,; // tripcount -> icmp ult %j, tripcount-1), or both.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:457,Integrability,depend,dependency,457,"// All PHIs in the inner and outer headers must either be:; // - The induction PHI, which we are going to rewrite as one induction in; // the new loop. This is already checked by findLoopComponents.; // - An outer header PHI with all incoming values from outside the loop.; // LoopSimplify guarantees we have a pre-header, so we don't need to; // worry about that here.; // - Pairs of PHIs in the inner and outer headers, which implement a; // loop-carried dependency that will still be valid in the new loop. To; // be valid, this variable must be modified only in the inner loop.; // The set of PHI nodes in the outer loop header that we know will still be; // valid after the transformation. These will not need to be modified (with; // the exception of the induction variable), but we do need to check that; // there are no unsafe PHI nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:106,Modifiability,rewrite,rewrite,106,"// All PHIs in the inner and outer headers must either be:; // - The induction PHI, which we are going to rewrite as one induction in; // the new loop. This is already checked by findLoopComponents.; // - An outer header PHI with all incoming values from outside the loop.; // LoopSimplify guarantees we have a pre-header, so we don't need to; // worry about that here.; // - Pairs of PHIs in the inner and outer headers, which implement a; // loop-carried dependency that will still be valid in the new loop. To; // be valid, this variable must be modified only in the inner loop.; // The set of PHI nodes in the outer loop header that we know will still be; // valid after the transformation. These will not need to be modified (with; // the exception of the induction variable), but we do need to check that; // there are no unsafe PHI nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:532,Modifiability,variab,variable,532,"// All PHIs in the inner and outer headers must either be:; // - The induction PHI, which we are going to rewrite as one induction in; // the new loop. This is already checked by findLoopComponents.; // - An outer header PHI with all incoming values from outside the loop.; // LoopSimplify guarantees we have a pre-header, so we don't need to; // worry about that here.; // - Pairs of PHIs in the inner and outer headers, which implement a; // loop-carried dependency that will still be valid in the new loop. To; // be valid, this variable must be modified only in the inner loop.; // The set of PHI nodes in the outer loop header that we know will still be; // valid after the transformation. These will not need to be modified (with; // the exception of the induction variable), but we do need to check that; // there are no unsafe PHI nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:771,Modifiability,variab,variable,771,"// All PHIs in the inner and outer headers must either be:; // - The induction PHI, which we are going to rewrite as one induction in; // the new loop. This is already checked by findLoopComponents.; // - An outer header PHI with all incoming values from outside the loop.; // LoopSimplify guarantees we have a pre-header, so we don't need to; // worry about that here.; // - Pairs of PHIs in the inner and outer headers, which implement a; // loop-carried dependency that will still be valid in the new loop. To; // be valid, this variable must be modified only in the inner loop.; // The set of PHI nodes in the outer loop header that we know will still be; // valid after the transformation. These will not need to be modified (with; // the exception of the induction variable), but we do need to check that; // there are no unsafe PHI nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:828,Safety,unsafe,unsafe,828,"// All PHIs in the inner and outer headers must either be:; // - The induction PHI, which we are going to rewrite as one induction in; // the new loop. This is already checked by findLoopComponents.; // - An outer header PHI with all incoming values from outside the loop.; // LoopSimplify guarantees we have a pre-header, so we don't need to; // worry about that here.; // - Pairs of PHIs in the inner and outer headers, which implement a; // loop-carried dependency that will still be valid in the new loop. To; // be valid, this variable must be modified only in the inner loop.; // The set of PHI nodes in the outer loop header that we know will still be; // valid after the transformation. These will not need to be modified (with; // the exception of the induction variable), but we do need to check that; // there are no unsafe PHI nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:37,Modifiability,variab,variable,37,// Multiplies of the outer iteration variable and inner iteration; // count will be optimised out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:41,Modifiability,variab,variables,41,"// We require all uses of both induction variables to match this pattern:; //; // (OuterPHI * InnerTripCount) + InnerPHI; //; // Any uses of the induction variables not matching that pattern would; // require a div/mod to reconstruct in the flattened loop, so the; // transformation wouldn't be profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:155,Modifiability,variab,variables,155,"// We require all uses of both induction variables to match this pattern:; //; // (OuterPHI * InnerTripCount) + InnerPHI; //; // Any uses of the induction variables not matching that pattern would; // require a div/mod to reconstruct in the flattened loop, so the; // transformation wouldn't be profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:53,Modifiability,variab,variable,53,"// Check that all uses of the inner loop's induction variable match the; // expected pattern, recording the uses of the outer IV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:28,Integrability,depend,dependant,28,// Return an OverflowResult dependant on if overflow of the multiplication of; // InnerTripCount and OuterTripCount can be assumed not to happen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:17,Testability,test,testing,17,// For debugging/testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:174,Integrability,wrap,wrap,174,"// The IV is used as the operand of a GEP which dominates the loop; // latch, and the IV is at least as wide as the address space of the; // GEP. In this case, the GEP would wrap around the address space; // before the IV increment wraps, which would be UB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:232,Integrability,wrap,wraps,232,"// The IV is used as the operand of a GEP which dominates the loop; // latch, and the IV is at least as wide as the address space of the; // GEP. In this case, the GEP would wrap around the address space; // before the IV increment wraps, which would be UB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:86,Modifiability,variab,variable,86,"// Find the values in the loop that can be replaced with the linearized; // induction variable, and check that there are no other uses of the inner; // or outer induction variable. If there were, we could still do this; // transformation, but we'd have to insert a div/mod to calculate the; // original IVs, so it wouldn't be profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:171,Modifiability,variab,variable,171,"// Find the values in the loop that can be replaced with the linearized; // induction variable, and check that there are no other uses of the inner; // or outer induction variable. If there were, we could still do this; // transformation, but we'd have to insert a div/mod to calculate the; // original IVs, so it wouldn't be profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:3,Deployability,Update,Update,3,// Update the DomTree and MemorySSA.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:76,Modifiability,variab,variables,76,// Replace all uses of the polynomial calculated from the two induction; // variables with the one new one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:110,Availability,avail,available,110,"// If both induction types are less than the maximum legal integer width,; // promote both to the widest type available so we know calculating; // (OuterTripCount * InnerTripCount) as the new trip count is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:206,Safety,safe,safe,206,"// If both induction types are less than the maximum legal integer width,; // promote both to the widest type available so we know calculating; // (OuterTripCount * InnerTripCount) as the new trip count is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:100,Performance,perform,performed,100,"// Add the narrow phi to list, so that it will be adjusted later when the; // the transformation is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:39,Modifiability,variab,variables,39,// Check if we can widen the induction variables to avoid overflow checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:52,Safety,avoid,avoid,52,// Check if we can widen the induction variables to avoid overflow checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:199,Performance,perform,performing,199,"// It can happen that after widening of the IV, flattening may not be; // possible/happening, e.g. when it is deemed unprofitable. So bail here if; // that is the case.; // TODO: IV widening without performing the actual flattening transformation; // is not ideal. While this codegen change should not matter much, it is an; // unnecessary change which is better to avoid. It's unlikely this happens; // often, because if it's unprofitibale after widening, it should be; // unprofitabe before widening as checked in the first round of checks. But; // 'RepeatedInstructionThreshold' is set to only 2, which can probably be; // relaxed. Because this is making a code change (the IV widening, but not; // the flattening), we return true here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:366,Safety,avoid,avoid,366,"// It can happen that after widening of the IV, flattening may not be; // possible/happening, e.g. when it is deemed unprofitable. So bail here if; // that is the case.; // TODO: IV widening without performing the actual flattening transformation; // is not ideal. While this codegen change should not matter much, it is an; // unnecessary change which is better to avoid. It's unlikely this happens; // often, because if it's unprofitibale after widening, it should be; // unprofitabe before widening as checked in the first round of checks. But; // 'RepeatedInstructionThreshold' is set to only 2, which can probably be; // relaxed. Because this is making a code change (the IV widening, but not; // the flattening), we return true here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:30,Performance,perform,perform,30,"// If we have widened and can perform the transformation, do that here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:75,Modifiability,variab,variable,75,"// Otherwise, if we haven't widened the IV, check if the new iteration; // variable might overflow. In this case, we need to version the loop, and; // select the original version at runtime if the iteration space is too; // large.; // TODO: We currently don't version the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:56,Usability,simpl,simplified,56,"// The loop flattening pass requires loops to be; // in simplified form, and also needs LCSSA. Running; // this pass will simplify all loops that contain inner loops,; // regardless of whether anything ends up being flattened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:122,Usability,simpl,simplify,122,"// The loop flattening pass requires loops to be; // in simplified form, and also needs LCSSA. Running; // this pass will simplify all loops that contain inner loops,; // regardless of whether anything ends up being flattened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:1251,Integrability,depend,dependencies,1251,"dentifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements the loop fusion pass.; /// The implementation is largely based on the following document:; ///; /// Code Transformations to Augment the Scope of Loop Fusion in a; /// Production Compiler; /// Christopher Mark Barton; /// MSc Thesis; /// https://webdocs.cs.ualberta.ca/~amaral/thesis/ChristopherBartonMSc.pdf; ///; /// The general approach taken is to collect sets of control flow equivalent; /// loops and test whether they can be fused. The necessary conditions for; /// fusion are:; /// 1. The loops must be adjacent (there cannot be any statements between; /// the two loops).; /// 2. The loops must be conforming (they must execute the same number of; /// iterations).; /// 3. The loops must be control flow equivalent (if one loop executes, the; /// other is guaranteed to execute).; /// 4. There cannot be any negative distance dependencies between the loops.; /// If all of these conditions are satisfied, it is safe to fuse the loops.; ///; /// This implementation creates FusionCandidates that represent the loop and the; /// necessary information needed by fusion. It then operates on the fusion; /// candidates, first confirming that the candidate is eligible for fusion. The; /// candidates are then collected into control flow equivalent sets, sorted in; /// dominance order. Each set of control flow equivalent candidates is then; /// traversed, attempting to fuse pairs of candidates in the set. If all; /// requirements for fusion are met, the two candidates are fused, creating a; /// new (fused) candidate which is then added back into the set to consider for; /// additional fusion.; ///; /// This implementation currently does not make any modifications to remove; /// conditions for fusion. Code transformations to make loops conform to each of; /// the conditions for fusion are discussed in more detail in t",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:1336,Safety,safe,safe,1336,"-------------------------------------------------===//; ///; /// \file; /// This file implements the loop fusion pass.; /// The implementation is largely based on the following document:; ///; /// Code Transformations to Augment the Scope of Loop Fusion in a; /// Production Compiler; /// Christopher Mark Barton; /// MSc Thesis; /// https://webdocs.cs.ualberta.ca/~amaral/thesis/ChristopherBartonMSc.pdf; ///; /// The general approach taken is to collect sets of control flow equivalent; /// loops and test whether they can be fused. The necessary conditions for; /// fusion are:; /// 1. The loops must be adjacent (there cannot be any statements between; /// the two loops).; /// 2. The loops must be conforming (they must execute the same number of; /// iterations).; /// 3. The loops must be control flow equivalent (if one loop executes, the; /// other is guaranteed to execute).; /// 4. There cannot be any negative distance dependencies between the loops.; /// If all of these conditions are satisfied, it is safe to fuse the loops.; ///; /// This implementation creates FusionCandidates that represent the loop and the; /// necessary information needed by fusion. It then operates on the fusion; /// candidates, first confirming that the candidate is eligible for fusion. The; /// candidates are then collected into control flow equivalent sets, sorted in; /// dominance order. Each set of control flow equivalent candidates is then; /// traversed, attempting to fuse pairs of candidates in the set. If all; /// requirements for fusion are met, the two candidates are fused, creating a; /// new (fused) candidate which is then added back into the set to consider for; /// additional fusion.; ///; /// This implementation currently does not make any modifications to remove; /// conditions for fusion. Code transformations to make loops conform to each of; /// the conditions for fusion are discussed in more detail in the document; /// above. These can be added to the current implementation i",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:823,Testability,test,test,823,"//===- LoopFuse.cpp - Loop Fusion Pass ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements the loop fusion pass.; /// The implementation is largely based on the following document:; ///; /// Code Transformations to Augment the Scope of Loop Fusion in a; /// Production Compiler; /// Christopher Mark Barton; /// MSc Thesis; /// https://webdocs.cs.ualberta.ca/~amaral/thesis/ChristopherBartonMSc.pdf; ///; /// The general approach taken is to collect sets of control flow equivalent; /// loops and test whether they can be fused. The necessary conditions for; /// fusion are:; /// 1. The loops must be adjacent (there cannot be any statements between; /// the two loops).; /// 2. The loops must be conforming (they must execute the same number of; /// iterations).; /// 3. The loops must be control flow equivalent (if one loop executes, the; /// other is guaranteed to execute).; /// 4. There cannot be any negative distance dependencies between the loops.; /// If all of these conditions are satisfied, it is safe to fuse the loops.; ///; /// This implementation creates FusionCandidates that represent the loop and the; /// necessary information needed by fusion. It then operates on the fusion; /// candidates, first confirming that the candidate is eligible for fusion. The; /// candidates are then collected into control flow equivalent sets, sorted in; /// dominance order. Each set of control flow equivalent candidates is then; /// traversed, attempting to fuse pairs of candidates in the set. If all; /// requirements for fusion are met, the two candidates are fused, creating a; /// new (fused) candidate which is then added back into the set to consider for; /// a",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:191,Performance,cache,caches,191,"/// This class is used to represent a candidate for loop fusion. When it is; /// constructed, it checks the conditions for loop fusion to ensure that it; /// represents a valid candidate. It caches several parts of a loop that are; /// used throughout loop fusion (e.g., loop preheader, loop header, etc) instead; /// of continually querying the underlying Loop to retrieve these values. It is; /// assumed these will not change throughout loop fusion.; ///; /// The invalidate method should be used to indicate that the FusionCandidate is; /// no longer a valid candidate for fusion. Similarly, the isValid() method can; /// be used to ensure that the FusionCandidate is still valid for fusion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:4,Performance,Cache,Cache,4,/// Cache of parts of the loop used throughout loop fusion. These should not; /// need to change throughout the analysis and transformation.; /// These parts are cached to avoid repeatedly looking up in the Loop class.; /// Preheader of the loop this candidate represents,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:162,Performance,cache,cached,162,/// Cache of parts of the loop used throughout loop fusion. These should not; /// need to change throughout the analysis and transformation.; /// These parts are cached to avoid repeatedly looking up in the Loop class.; /// Preheader of the loop this candidate represents,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:172,Safety,avoid,avoid,172,/// Cache of parts of the loop used throughout loop fusion. These should not; /// need to change throughout the analysis and transformation.; /// These parts are cached to avoid repeatedly looking up in the Loop class.; /// Preheader of the loop this candidate represents,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:92,Deployability,update,updated,92,"/// After Peeling the loop is modified quite a bit, hence all of the Blocks; /// need to be updated accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:286,Deployability,update,update,286,"// This is only used internally for now, to clear the MemWrites and MemReads; // list and setting Valid to false. I can't envision other uses of this right; // now, since once FusionCandidates are put into the FusionCandidateSet they; // are immutable. Thus, any time we need to change/update a FusionCandidate,; // we must create a new one and insert it into the FusionCandidateSet to; // ensure the FusionCandidateSet remains ordered correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:44,Usability,clear,clear,44,"// This is only used internally for now, to clear the MemWrites and MemReads; // list and setting Valid to false. I can't envision other uses of this right; // now, since once FusionCandidates are put into the FusionCandidateSet they; // are immutable. Thus, any time we need to change/update a FusionCandidate,; // we must create a new one and insert it into the FusionCandidateSet to; // ensure the FusionCandidateSet remains ordered correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:28,Modifiability,variab,variable,28,// Do not save PDT to local variable as it is only used in asserts and thus; // will trigger an unused variable warning if building without asserts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:103,Modifiability,variab,variable,103,// Do not save PDT to local variable as it is only used in asserts and thus; // will trigger an unused variable warning if building without asserts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:59,Testability,assert,asserts,59,// Do not save PDT to local variable as it is only used in asserts and thus; // will trigger an unused variable warning if building without asserts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:140,Testability,assert,asserts,140,// Do not save PDT to local variable as it is only used in asserts and thus; // will trigger an unused variable warning if building without asserts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:306,Deployability,patch,patch,306,"// Set of Control Flow Equivalent (CFE) Fusion Candidates, sorted in dominance; // order. Thus, if FC0 comes *before* FC1 in a FusionCandidateSet, then FC0; // dominates FC1 and FC1 post-dominates FC0.; // std::set was chosen because we want a sorted data structure with stable; // iterators. A subsequent patch to loop fusion will enable fusing non-adjacent; // loops by moving intervening code around. When this intervening code contains; // loops, those loops will be moved also. The corresponding FusionCandidates; // will also need to be moved accordingly. As this is done, having stable; // iterators will simplify the logic. Similarly, having an efficient insert that; // keeps the FusionCandidateSet sorted will also simplify the implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:653,Energy Efficiency,efficient,efficient,653,"// Set of Control Flow Equivalent (CFE) Fusion Candidates, sorted in dominance; // order. Thus, if FC0 comes *before* FC1 in a FusionCandidateSet, then FC0; // dominates FC1 and FC1 post-dominates FC0.; // std::set was chosen because we want a sorted data structure with stable; // iterators. A subsequent patch to loop fusion will enable fusing non-adjacent; // loops by moving intervening code around. When this intervening code contains; // loops, those loops will be moved also. The corresponding FusionCandidates; // will also need to be moved accordingly. As this is done, having stable; // iterators will simplify the logic. Similarly, having an efficient insert that; // keeps the FusionCandidateSet sorted will also simplify the implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:625,Testability,log,logic,625,"// Set of Control Flow Equivalent (CFE) Fusion Candidates, sorted in dominance; // order. Thus, if FC0 comes *before* FC1 in a FusionCandidateSet, then FC0; // dominates FC1 and FC1 post-dominates FC0.; // std::set was chosen because we want a sorted data structure with stable; // iterators. A subsequent patch to loop fusion will enable fusing non-adjacent; // loops by moving intervening code around. When this intervening code contains; // loops, those loops will be moved also. The corresponding FusionCandidates; // will also need to be moved accordingly. As this is done, having stable; // iterators will simplify the logic. Similarly, having an efficient insert that; // keeps the FusionCandidateSet sorted will also simplify the implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:612,Usability,simpl,simplify,612,"// Set of Control Flow Equivalent (CFE) Fusion Candidates, sorted in dominance; // order. Thus, if FC0 comes *before* FC1 in a FusionCandidateSet, then FC0; // dominates FC1 and FC1 post-dominates FC0.; // std::set was chosen because we want a sorted data structure with stable; // iterators. A subsequent patch to loop fusion will enable fusing non-adjacent; // loops by moving intervening code around. When this intervening code contains; // loops, those loops will be moved also. The corresponding FusionCandidates; // will also need to be moved accordingly. As this is done, having stable; // iterators will simplify the logic. Similarly, having an efficient insert that; // keeps the FusionCandidateSet sorted will also simplify the implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:725,Usability,simpl,simplify,725,"// Set of Control Flow Equivalent (CFE) Fusion Candidates, sorted in dominance; // order. Thus, if FC0 comes *before* FC1 in a FusionCandidateSet, then FC0; // dominates FC1 and FC1 post-dominates FC0.; // std::set was chosen because we want a sorted data structure with stable; // iterators. A subsequent patch to loop fusion will enable fusing non-adjacent; // loops by moving intervening code around. When this intervening code contains; // loops, those loops will be moved also. The corresponding FusionCandidates; // will also need to be moved accordingly. As this is done, having stable; // iterators will simplify the logic. Similarly, having an efficient insert that; // keeps the FusionCandidateSet sorted will also simplify the implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:4,Testability,Test,Test,4,"/// Test whether a given loop has been removed from the function, and thus is; /// no longer valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:82,Usability,clear,clear,82,// Finished analyzing candidates at this level.; // Descend to the next level and clear all of the candidates currently; // collected. Note that it will not be possible to fuse any of the; // existing candidates with new candidates because the new candidates will; // be at a different nest level and thus not be control flow equivalent; // with all of the candidates collected so far.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:200,Modifiability,evolve,evolve,200,"/// Determine if it is beneficial to fuse two loops.; ///; /// For now, this method simply returns true because we want to fuse as much; /// as possible (primarily to test the pass). This method will evolve, over; /// time, to add heuristics for profitability of fusion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:167,Testability,test,test,167,"/// Determine if it is beneficial to fuse two loops.; ///; /// For now, this method simply returns true because we want to fuse as much; /// as possible (primarily to test the pass). This method will evolve, over; /// time, to add heuristics for profitability of fusion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:84,Usability,simpl,simply,84,"/// Determine if it is beneficial to fuse two loops.; ///; /// For now, this method simply returns true because we want to fuse as much; /// as possible (primarily to test the pass). This method will evolve, over; /// time, to add heuristics for profitability of fusion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:445,Performance,perform,performed,445,"/// Determine if two fusion candidates have the same trip count (i.e., they; /// execute the same number of iterations).; ///; /// This function will return a pair of values. The first is a boolean,; /// stating whether or not the two candidates are known at compile time to; /// have the same TripCount. The second is the difference in the two; /// TripCounts. This information can be used later to determine whether or not; /// peeling can be performed on either one of the candidates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:20,Deployability,update,update,20,// Peeling does not update the PDT,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:457,Deployability,update,update,457,"// In this case the iterations of the loop are constant, so the first; // loop will execute completely (will not jump from one of; // the peeled blocks to the second loop). Here we are updating the; // branch conditions of each of the peeled blocks, such that it will; // branch to its successor which is not the preheader of the second loop; // in the case of unguarded loops, or the succesors of the exit block of; // the first loop otherwise. Doing this update will ensure that the entry; // block of the first loop dominates the entry block of the second loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:122,Availability,error,errors,122,"// Cannot modify the predecessors inside the above loop as it will cause; // the iterators to be nullptrs, causing memory errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:3,Integrability,Depend,Dependent,3,"// Dependent on peeling being performed on the first loop, and; // assuming all other conditions for fusion return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:30,Performance,perform,performed,30,"// Dependent on peeling being performed on the first loop, and; // assuming all other conditions for fusion return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:13,Integrability,depend,dependencies,13,// Check the dependencies across the loops and do not fuse if it would; // violate them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:16,Safety,safe,safe,16,"// If it is not safe to hoist/sink all instructions in the; // pre-header, we cannot fuse these loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:141,Performance,perform,perform,141,"// All analysis has completed and has determined that fusion is legal; // and profitable. At this point, start transforming the code and; // perform fusion.; // Execute the hoist/sink operations on preheader instructions",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:119,Performance,perform,performed,119,// Peel the loop after determining that fusion is legal. The Loops; // will still be safe to fuse after the peeling is performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:85,Safety,safe,safe,85,// Peel the loop after determining that fusion is legal. The Loops; // will still be safe to fuse after the peeling is performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:24,Performance,Optimiz,Optimization,24,"// Report fusion to the Optimization Remarks.; // Note this needs to be done *before* performFusion because; // performFusion will change the original loops, making it not; // possible to identify them after fusion is complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:86,Performance,perform,performFusion,86,"// Report fusion to the Optimization Remarks.; // Note this needs to be done *before* performFusion because; // performFusion will change the original loops, making it not; // possible to identify them after fusion is complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:112,Performance,perform,performFusion,112,"// Report fusion to the Optimization Remarks.; // Note this needs to be done *before* performFusion because; // performFusion will change the original loops, making it not; // possible to identify them after fusion is complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:101,Safety,Safe,SafeToHoist,101,// Returns true if the instruction \p I can be hoisted to the end of the; // preheader of \p FC0. \p SafeToHoist contains the instructions that are; // known to be safe to hoist. The instructions encountered that cannot be; // hoisted are in \p NotHoisting.; // TODO: Move functionality into CodeMoverUtils,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:164,Safety,safe,safe,164,// Returns true if the instruction \p I can be hoisted to the end of the; // preheader of \p FC0. \p SafeToHoist contains the instructions that are; // known to be safe to hoist. The instructions encountered that cannot be; // hoisted are in \p NotHoisting.; // TODO: Move functionality into CodeMoverUtils,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:44,Safety,safe,safe,44,"// If this isn't a memory inst, hoisting is safe",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:3,Integrability,Depend,Dependency,3,"// Dependency is not read-before-write, write-before-read or; // write-before-write",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:3,Integrability,Depend,Dependency,3,// Dependency is not read-before-write,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:3,Integrability,Depend,Dependency,3,// Dependency is not write-before-read or write-before-write,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:43,Safety,safe,safe,43,"// If this isn't a memory inst, sinking is safe",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:3,Integrability,Depend,Dependency,3,// Dependency is not write-before-read,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:3,Integrability,Depend,Dependency,3,// Dependency is not write-before-write or read-before-write,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:143,Integrability,depend,dependence,143,"// If the instruction has side-effects, give up.; // TODO: The case of mayReadFromMemory we can handle but requires; // additional work with a dependence analysis so for now we give; // up on memory reads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:4,Modifiability,Rewrite,Rewrite,4,/// Rewrite all additive recurrences in a SCEV to use a new loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:88,Integrability,depend,dependence,88,/// Return false if the access functions of \p I0 and \p I1 could cause; /// a negative dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:24,Security,access,access,24,/// Return false if the access functions of \p I0 and \p I1 could cause; /// a negative dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:144,Testability,test,test,144,// TODO: isKnownPredicate doesnt work well when one SCEV is loop carried (by; // L0) and the other is not. We could check if it is monotone and test; // the beginning and end value instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:23,Integrability,depend,dependences,23,/// Return true if the dependences between @p I0 (in @p L0) and @p I1 (in; /// @p L1) allow loop fusion of @p L0 and @p L1. The dependence analyses; /// specified by @p DepChoice are used to determine this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:128,Integrability,depend,dependence,128,/// Return true if the dependences between @p I0 (in @p L0) and @p I1 (in; /// @p L1) allow loop fusion of @p L0 and @p L1. The dependence analyses; /// specified by @p DepChoice are used to determine this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:33,Integrability,depend,dependence,33,// TODO: Can we actually use the dependence info analysis here?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:14,Integrability,depend,dependence,14,/// Perform a dependence check and return if @p FC0 and @p FC1 can be fused.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:4,Performance,Perform,Perform,4,/// Perform a dependence check and return if @p FC0 and @p FC1 can be fused.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:118,Safety,safe,safe,118,"// Walk through all uses in FC1. For each use, find the reaching def. If the; // def is located in FC0 then it is not safe to fuse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:592,Deployability,update,update,592,"/// Fuse two fusion candidates, creating a new fused loop.; ///; /// This method contains the mechanics of fusing two loops, represented by \p; /// FC0 and \p FC1. It is assumed that \p FC0 dominates \p FC1 and \p FC1; /// postdominates \p FC0 (making them control flow equivalent). It also; /// assumes that the other conditions for fusion have been met: adjacent,; /// identical trip counts, and no negative distance dependencies exist that; /// would prevent fusion. Thus, there is no checking for these conditions in; /// this method.; ///; /// Fusion is performed by rewiring the CFG to update successor blocks of the; /// components of tho loop. Specifically, the following changes are done:; ///; /// 1. The preheader of \p FC1 is removed as it is no longer necessary; /// (because it is currently only a single statement block).; /// 2. The latch of \p FC0 is modified to jump to the header of \p FC1.; /// 3. The latch of \p FC1 i modified to jump to the header of \p FC0.; /// 4. All blocks from \p FC1 are removed from FC1 and added to FC0.; ///; /// All of these modifications are done with dominator tree updates, thus; /// keeping the dominator (and post dominator) information up-to-date.; ///; /// This can be improved in the future by actually merging blocks during; /// fusion. For example, the preheader of \p FC1 can be merged with the; /// preheader of \p FC0. This would allow loops with more than a single; /// statement in the preheader to be fused. Similarly, the latch blocks of the; /// two loops could also be fused into a single block. This will require; /// analysis to prove it is safe to move the contents of the block past; /// existing code, which currently has not been implemented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:1118,Deployability,update,updates,1118,"/// Fuse two fusion candidates, creating a new fused loop.; ///; /// This method contains the mechanics of fusing two loops, represented by \p; /// FC0 and \p FC1. It is assumed that \p FC0 dominates \p FC1 and \p FC1; /// postdominates \p FC0 (making them control flow equivalent). It also; /// assumes that the other conditions for fusion have been met: adjacent,; /// identical trip counts, and no negative distance dependencies exist that; /// would prevent fusion. Thus, there is no checking for these conditions in; /// this method.; ///; /// Fusion is performed by rewiring the CFG to update successor blocks of the; /// components of tho loop. Specifically, the following changes are done:; ///; /// 1. The preheader of \p FC1 is removed as it is no longer necessary; /// (because it is currently only a single statement block).; /// 2. The latch of \p FC0 is modified to jump to the header of \p FC1.; /// 3. The latch of \p FC1 i modified to jump to the header of \p FC0.; /// 4. All blocks from \p FC1 are removed from FC1 and added to FC0.; ///; /// All of these modifications are done with dominator tree updates, thus; /// keeping the dominator (and post dominator) information up-to-date.; ///; /// This can be improved in the future by actually merging blocks during; /// fusion. For example, the preheader of \p FC1 can be merged with the; /// preheader of \p FC0. This would allow loops with more than a single; /// statement in the preheader to be fused. Similarly, the latch blocks of the; /// two loops could also be fused into a single block. This will require; /// analysis to prove it is safe to move the contents of the block past; /// existing code, which currently has not been implemented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:419,Integrability,depend,dependencies,419,"/// Fuse two fusion candidates, creating a new fused loop.; ///; /// This method contains the mechanics of fusing two loops, represented by \p; /// FC0 and \p FC1. It is assumed that \p FC0 dominates \p FC1 and \p FC1; /// postdominates \p FC0 (making them control flow equivalent). It also; /// assumes that the other conditions for fusion have been met: adjacent,; /// identical trip counts, and no negative distance dependencies exist that; /// would prevent fusion. Thus, there is no checking for these conditions in; /// this method.; ///; /// Fusion is performed by rewiring the CFG to update successor blocks of the; /// components of tho loop. Specifically, the following changes are done:; ///; /// 1. The preheader of \p FC1 is removed as it is no longer necessary; /// (because it is currently only a single statement block).; /// 2. The latch of \p FC0 is modified to jump to the header of \p FC1.; /// 3. The latch of \p FC1 i modified to jump to the header of \p FC0.; /// 4. All blocks from \p FC1 are removed from FC1 and added to FC0.; ///; /// All of these modifications are done with dominator tree updates, thus; /// keeping the dominator (and post dominator) information up-to-date.; ///; /// This can be improved in the future by actually merging blocks during; /// fusion. For example, the preheader of \p FC1 can be merged with the; /// preheader of \p FC0. This would allow loops with more than a single; /// statement in the preheader to be fused. Similarly, the latch blocks of the; /// two loops could also be fused into a single block. This will require; /// analysis to prove it is safe to move the contents of the block past; /// existing code, which currently has not been implemented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:559,Performance,perform,performed,559,"/// Fuse two fusion candidates, creating a new fused loop.; ///; /// This method contains the mechanics of fusing two loops, represented by \p; /// FC0 and \p FC1. It is assumed that \p FC0 dominates \p FC1 and \p FC1; /// postdominates \p FC0 (making them control flow equivalent). It also; /// assumes that the other conditions for fusion have been met: adjacent,; /// identical trip counts, and no negative distance dependencies exist that; /// would prevent fusion. Thus, there is no checking for these conditions in; /// this method.; ///; /// Fusion is performed by rewiring the CFG to update successor blocks of the; /// components of tho loop. Specifically, the following changes are done:; ///; /// 1. The preheader of \p FC1 is removed as it is no longer necessary; /// (because it is currently only a single statement block).; /// 2. The latch of \p FC0 is modified to jump to the header of \p FC1.; /// 3. The latch of \p FC1 i modified to jump to the header of \p FC0.; /// 4. All blocks from \p FC1 are removed from FC1 and added to FC0.; ///; /// All of these modifications are done with dominator tree updates, thus; /// keeping the dominator (and post dominator) information up-to-date.; ///; /// This can be improved in the future by actually merging blocks during; /// fusion. For example, the preheader of \p FC1 can be merged with the; /// preheader of \p FC0. This would allow loops with more than a single; /// statement in the preheader to be fused. Similarly, the latch blocks of the; /// two loops could also be fused into a single block. This will require; /// analysis to prove it is safe to move the contents of the block past; /// existing code, which currently has not been implemented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:1612,Safety,safe,safe,1612,"/// Fuse two fusion candidates, creating a new fused loop.; ///; /// This method contains the mechanics of fusing two loops, represented by \p; /// FC0 and \p FC1. It is assumed that \p FC0 dominates \p FC1 and \p FC1; /// postdominates \p FC0 (making them control flow equivalent). It also; /// assumes that the other conditions for fusion have been met: adjacent,; /// identical trip counts, and no negative distance dependencies exist that; /// would prevent fusion. Thus, there is no checking for these conditions in; /// this method.; ///; /// Fusion is performed by rewiring the CFG to update successor blocks of the; /// components of tho loop. Specifically, the following changes are done:; ///; /// 1. The preheader of \p FC1 is removed as it is no longer necessary; /// (because it is currently only a single statement block).; /// 2. The latch of \p FC0 is modified to jump to the header of \p FC1.; /// 3. The latch of \p FC1 i modified to jump to the header of \p FC0.; /// 4. All blocks from \p FC1 are removed from FC1 and added to FC0.; ///; /// All of these modifications are done with dominator tree updates, thus; /// keeping the dominator (and post dominator) information up-to-date.; ///; /// This can be improved in the future by actually merging blocks during; /// fusion. For example, the preheader of \p FC1 can be merged with the; /// preheader of \p FC0. This would allow loops with more than a single; /// statement in the preheader to be fused. Similarly, the latch blocks of the; /// two loops could also be fused into a single block. This will require; /// analysis to prove it is safe to move the contents of the block past; /// existing code, which currently has not been implemented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:171,Testability,log,logic,171,// Fusing guarded loops is handled slightly differently than non-guarded; // loops and has been broken out into a separate method instead of trying to; // intersperse the logic within a single method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:229,Testability,test,test,229,"// Remember the phi nodes originally in the header of FC0 in order to rewire; // them later. However, this is only necessary if the new loop carried; // values might not dominate the exiting branch. While we do not generally; // test if this is the case but simply insert intermediate phi nodes, we; // need to make sure these intermediate phi nodes have different; // predecessors. To this end, we filter the special case where the exiting; // block is the latch block of the first loop. Nothing needs to be done; // anyway as all loop carried values dominate the latch and thereby also the; // exiting branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:258,Usability,simpl,simply,258,"// Remember the phi nodes originally in the header of FC0 in order to rewire; // them later. However, this is only necessary if the new loop carried; // values might not dominate the exiting branch. While we do not generally; // test if this is the case but simply insert intermediate phi nodes, we; // need to make sure these intermediate phi nodes have different; // predecessors. To this end, we filter the special case where the exiting; // block is the latch block of the first loop. Nothing needs to be done; // anyway as all loop carried values dominate the latch and thereby also the; // exiting branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:36,Deployability,update,update,36,// Then modify the control flow and update DT and PDT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:955,Usability,simpl,simpler,955,"// The old exiting block of the first loop (FC0) has to jump to the header; // of the second as we need to execute the code in the second header block; // regardless of the trip count. That is, if the trip count is 0, so the; // back edge is never taken, we still have to execute both loop headers,; // especially (but not only!) if the second is a do-while style loop.; // However, doing so might invalidate the phi nodes of the first loop as; // the new values do only need to dominate their latch and not the exiting; // predicate. To remedy this potential problem we always introduce phi; // nodes in the header of the second loop later that select the loop carried; // value, if the second header was reached through an old latch of the; // first, or undef otherwise. This is sound as exiting the first implies the; // second will exit too, __without__ taking the back-edge. [Their; // trip-counts are equal after all.; // KB: Would this sequence be simpler to just make FC0.ExitingBlock go; // to FC1.Header? I think this is basically what the three sequences are; // trying to accomplish; however, doing this directly in the CFG may mean; // the DT/PDT becomes invalid",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:89,Deployability,update,updates,89,// If FC0.Latch and FC0.ExitingBlock are the same then we have already; // performed the updates above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:75,Performance,perform,performed,75,// If FC0.Latch and FC0.ExitingBlock are the same then we have already; // performed the updates above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:3,Deployability,Update,Update,3,// Update DT/PDT,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:83,Deployability,update,updated,83,// Move instructions from FC0.Latch to FC1.Latch.; // Note: mergeLatch requires an updated DT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:233,Performance,Optimiz,OptimizationRemarkMissed,233,"/// Report details on loop fusion opportunities.; ///; /// This template function can be used to report both successful and missed; /// loop fusion opportunities, based on the RemarkKind. The RemarkKind should; /// be one of:; /// - OptimizationRemarkMissed to report when loop fusion is unsuccessful; /// given two valid fusion candidates.; /// - OptimizationRemark to report successful fusion of two fusion; /// candidates.; /// The remarks will be printed using the form:; /// <path/filename>:<line number>:<column number>: [<function name>]:; /// <Cand1 Preheader> and <Cand2 Preheader>: <Stat Description>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:348,Performance,Optimiz,OptimizationRemark,348,"/// Report details on loop fusion opportunities.; ///; /// This template function can be used to report both successful and missed; /// loop fusion opportunities, based on the RemarkKind. The RemarkKind should; /// be one of:; /// - OptimizationRemarkMissed to report when loop fusion is unsuccessful; /// given two valid fusion candidates.; /// - OptimizationRemark to report successful fusion of two fusion; /// candidates.; /// The remarks will be printed using the form:; /// <path/filename>:<line number>:<column number>: [<function name>]:; /// <Cand1 Preheader> and <Cand2 Preheader>: <Stat Description>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:692,Deployability,update,updated,692,"/// Fuse two guarded fusion candidates, creating a new fused loop.; ///; /// Fusing guarded loops is handled much the same way as fusing non-guarded; /// loops. The rewiring of the CFG is slightly different though, because of; /// the presence of the guards around the loops and the exit blocks after the; /// loop body. As such, the new loop is rewired as follows:; /// 1. Keep the guard branch from FC0 and use the non-loop block target; /// from the FC1 guard branch.; /// 2. Remove the exit block from FC0 (this exit block should be empty; /// right now).; /// 3. Remove the guard branch for FC1; /// 4. Remove the preheader for FC1.; /// The exit block successor for the latch of FC0 is updated to be the header; /// of FC1 and the non-exit block successor of the latch of FC1 is updated to; /// be the header of FC0, thus creating the fused loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:785,Deployability,update,updated,785,"/// Fuse two guarded fusion candidates, creating a new fused loop.; ///; /// Fusing guarded loops is handled much the same way as fusing non-guarded; /// loops. The rewiring of the CFG is slightly different though, because of; /// the presence of the guards around the loops and the exit blocks after the; /// loop body. As such, the new loop is rewired as follows:; /// 1. Keep the guard branch from FC0 and use the non-loop block target; /// from the FC1 guard branch.; /// 2. Remove the exit block from FC0 (this exit block should be empty; /// right now).; /// 3. Remove the guard branch for FC1; /// 4. Remove the preheader for FC1.; /// The exit block successor for the latch of FC0 is updated to be the header; /// of FC1 and the non-exit block successor of the latch of FC1 is updated to; /// be the header of FC0, thus creating the fused loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:81,Deployability,Update,Update,81,"////////////////////////////////////////////////////////////////////////////; // Update the Loop Guard; ////////////////////////////////////////////////////////////////////////////; // The guard for FC0 is updated to guard both FC0 and FC1. This is done by; // changing the NonLoopGuardBlock for FC0 to the NonLoopGuardBlock for FC1.; // Thus, one path from the guard goes to the preheader for FC0 (and thus; // executes the new fused loop) and the other path goes to the NonLoopBlock; // for FC1 (where FC1 guard would have gone if FC1 was not executed).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:206,Deployability,update,updated,206,"////////////////////////////////////////////////////////////////////////////; // Update the Loop Guard; ////////////////////////////////////////////////////////////////////////////; // The guard for FC0 is updated to guard both FC0 and FC1. This is done by; // changing the NonLoopGuardBlock for FC0 to the NonLoopGuardBlock for FC1.; // Thus, one path from the guard goes to the preheader for FC0 (and thus; // executes the new fused loop) and the other path goes to the NonLoopBlock; // for FC1 (where FC1 guard would have gone if FC1 was not executed).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:229,Testability,test,test,229,"// Remember the phi nodes originally in the header of FC0 in order to rewire; // them later. However, this is only necessary if the new loop carried; // values might not dominate the exiting branch. While we do not generally; // test if this is the case but simply insert intermediate phi nodes, we; // need to make sure these intermediate phi nodes have different; // predecessors. To this end, we filter the special case where the exiting; // block is the latch block of the first loop. Nothing needs to be done; // anyway as all loop carried values dominate the latch and thereby also the; // exiting branch.; // KB: This is no longer necessary because FC0.ExitingBlock == FC0.Latch; // (because the loops are rotated. Thus, nothing will ever be added to; // OriginalFC0PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:258,Usability,simpl,simply,258,"// Remember the phi nodes originally in the header of FC0 in order to rewire; // them later. However, this is only necessary if the new loop carried; // values might not dominate the exiting branch. While we do not generally; // test if this is the case but simply insert intermediate phi nodes, we; // need to make sure these intermediate phi nodes have different; // predecessors. To this end, we filter the special case where the exiting; // block is the latch block of the first loop. Nothing needs to be done; // anyway as all loop carried values dominate the latch and thereby also the; // exiting branch.; // KB: This is no longer necessary because FC0.ExitingBlock == FC0.Latch; // (because the loops are rotated. Thus, nothing will ever be added to; // OriginalFC0PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:3,Deployability,Update,Update,3,// Update the latches; // Replace latch terminator destinations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:89,Deployability,update,updates,89,// If FC0.Latch and FC0.ExitingBlock are the same then we have already; // performed the updates above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:75,Performance,perform,performed,75,// If FC0.Latch and FC0.ExitingBlock are the same then we have already; // performed the updates above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:26,Deployability,update,updates,26,// All done; // Apply the updates to the Dominator Tree and cleanup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:3,Deployability,Update,Update,3,// Update DT/PDT,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:83,Deployability,update,updated,83,// Move instructions from FC0.Latch to FC1.Latch.; // Note: mergeLatch requires an updated DT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:176,Integrability,depend,dependency,176,// Ensure loops are in simplifed form which is a pre-requisite for loop fusion; // pass. Added only for new PM since the legacy PM has already added; // LoopSimplify pass as a dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:23,Usability,simpl,simplifed,23,// Ensure loops are in simplifed form which is a pre-requisite for loop fusion; // pass. Added only for new PM since the legacy PM has already added; // LoopSimplify pass as a dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:536,Performance,perform,performance,536,"//===- LoopIdiomRecognize.cpp - Loop idiom recognition --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements an idiom recognizer that transforms simple loops into a; // non-loop form. In cases that this kicks in, it can be a significant; // performance win.; //; // If compiling for code size we avoid idiom recognition if the resulting; // code could be larger than the code for the original loop. One way this could; // happen is if the loop is not removable after idiom recognition due to the; // presence of non-idiom instructions. The initial implementation of the; // heuristics applies to idioms in multi-block loops.; //; //===----------------------------------------------------------------------===//; //; // TODO List:; //; // Future loop memory idioms to recognize:; // memcmp, strlen, etc.; // Future floating point idioms to recognize in -ffast-math mode:; // fpowi; //; // This could recognize common matrix multiplies and dot product idioms and; // replace them with calls to BLAS (if linked in??).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:591,Safety,avoid,avoid,591,"//===- LoopIdiomRecognize.cpp - Loop idiom recognition --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements an idiom recognizer that transforms simple loops into a; // non-loop form. In cases that this kicks in, it can be a significant; // performance win.; //; // If compiling for code size we avoid idiom recognition if the resulting; // code could be larger than the code for the original loop. One way this could; // happen is if the loop is not removable after idiom recognition due to the; // presence of non-idiom instructions. The initial implementation of the; // heuristics applies to idioms in multi-block loops.; //; //===----------------------------------------------------------------------===//; //; // TODO List:; //; // Future loop memory idioms to recognize:; // memcmp, strlen, etc.; // Future floating point idioms to recognize in -ffast-math mode:; // fpowi; //; // This could recognize common matrix multiplies and dot product idioms and; // replace them with calls to BLAS (if linked in??).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:440,Usability,simpl,simple,440,"//===- LoopIdiomRecognize.cpp - Loop idiom recognition --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements an idiom recognizer that transforms simple loops into a; // non-loop form. In cases that this kicks in, it can be a significant; // performance win.; //; // If compiling for code size we avoid idiom recognition if the resulting; // code could be larger than the code for the original loop. One way this could; // happen is if the loop is not removable after idiom recognition due to the; // presence of non-idiom instructions. The initial implementation of the; // heuristics applies to idioms in multi-block loops.; //; //===----------------------------------------------------------------------===//; //; // TODO List:; //; // Future loop memory idioms to recognize:; // memcmp, strlen, etc.; // Future floating point idioms to recognize in -ffast-math mode:; // fpowi; //; // This could recognize common matrix multiplies and dot product idioms and; // replace them with calls to BLAS (if linked in??).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:50,Availability,error,errors,50,// Dummy retval never to be used. Allows catching errors in retval; // handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:37,Performance,Optimiz,OptimizationRemarkEmitter,37,"// For the new PM, we also can't use OptimizationRemarkEmitter as an analysis; // pass. Function analyses need to be preserved across loop transformations; // but ORE cannot be preserved (see comment before the pass definition).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:77,Performance,optimiz,optimized,77,"// If this loop executes exactly one time, then it should be peeled, not; // optimized by this pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:73,Safety,safe,safe,73,"/// getMemSetPatternValue - If a strided store of the specified value is safe to; /// turn into a memset_pattern16, return a ConstantArray of 16 bytes that should; /// be passed in. Otherwise, return null.; ///; /// Note that we don't ever attempt to use memset_pattern8 or 4, because these; /// just replicate their input array and then pass on to memset_pattern16.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:40,Energy Efficiency,power,power,40,// Only handle simple values that are a power of two bytes in size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:15,Usability,simpl,simple,15,// Only handle simple values that are a power of two bytes in size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:16,Usability,simpl,simple,16,// We only want simple or unordered-atomic stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:3,Safety,Avoid,Avoid,3,// Avoid merging nontemporal stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:88,Performance,scalab,scalable,88,"// Reject stores that are so large that they overflow an unsigned.; // When storing out scalable vectors we bail out for now, since the code; // below currently only works for constant strides.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:44,Performance,load,load,44,// The store must be feeding a non-volatile load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:27,Performance,load,loads,27,// Only allow non-volatile loads,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:41,Performance,load,loads,41,// Only allow simple or unordered-atomic loads,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:14,Usability,simpl,simple,14,// Only allow simple or unordered-atomic loads,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:113,Performance,load,load,113,"// See if the pointer expression is an AddRec like {base,+,1} on the current; // loop, which indicates a strided load. If we have something else, it's a; // random load we can't handle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:164,Performance,load,load,164,"// See if the pointer expression is an AddRec like {base,+,1} on the current; // loop, which indicates a strided load. If we have something else, it's a; // random load we can't handle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:17,Performance,load,load,17,// The store and load must share the same stride.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:45,Performance,optimiz,optimized,45,"// Look for store instructions, which may be optimized to memset/memcpy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:82,Performance,optimiz,optimized,82,"// Look for a single store or sets of stores with a common base, which can be; // optimized into a memset (memset_pattern). The latter most commonly happens; // with structs and handunrolled loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize the store into a memcpy, if it feeds an similarly strided load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:70,Performance,load,load,70,"// Optimize the store into a memcpy, if it feeds an similarly strided load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:17,Performance,optimiz,optimize,17,// See if we can optimize just this store in isolation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:46,Performance,optimiz,optimized,46,"// Look for memory instructions, which may be optimized to a larger one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:14,Performance,load,load,14,"// See if the load and store pointer expressions are AddRec like {base,+,1} on; // the current loop, which indicates a strided load and store. If we have; // something else, it's a random load or store we can't handle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:127,Performance,load,load,127,"// See if the load and store pointer expressions are AddRec like {base,+,1} on; // the current loop, which indicates a strided load and store. If we have; // something else, it's a random load or store we can't handle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:188,Performance,load,load,188,"// See if the load and store pointer expressions are AddRec like {base,+,1} on; // the current loop, which indicates a strided load and store. If we have; // something else, it's a random load or store we can't handle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:16,Performance,load,load,16,// Check if the load stride matches the store stride.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:85,Performance,optimiz,optimization,85,"// If an expression is covered by the loop guard, compare again and; // proceed with optimization if equal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:68,Security,access,access,68,"/// mayLoopAccessLocation - Return true if the specified loop might access the; /// specified pointer location, which is a loop-strided access. The 'Access'; /// argument specifies what the verboten forms of access are (read or write).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:136,Security,access,access,136,"/// mayLoopAccessLocation - Return true if the specified loop might access the; /// specified pointer location, which is a loop-strided access. The 'Access'; /// argument specifies what the verboten forms of access are (read or write).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:149,Security,Access,Access,149,"/// mayLoopAccessLocation - Return true if the specified loop might access the; /// specified pointer location, which is a loop-strided access. The 'Access'; /// argument specifies what the verboten forms of access are (read or write).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:208,Security,access,access,208,"/// mayLoopAccessLocation - Return true if the specified loop might access the; /// specified pointer location, which is a loop-strided access. The 'Access'; /// argument specifies what the verboten forms of access are (read or write).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:66,Security,access,access,66,"// Get the location that may be stored across the loop. Since the access is; // strided positively through memory, we say that the modified location starts; // at the pointer and has infinite size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:67,Security,access,access,67,"// If the loop iterates a fixed number of times, we can refine the access size; // to be exactly the size of the memset, which is (BECount+1)*StoreSize",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:107,Integrability,depend,dependencies,107,// TODO: ideally we should still be able to generate memset if SCEV expander; // is taught to generate the dependencies at the latest point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:163,Safety,unsafe,unsafe,163,"// Okay, we have a strided store ""p[i]"" of a splattable value. We can turn; // this into a memset in the loop preheader now if we want. However, this; // would be unsafe to do if there is anything else in the loop that may read; // or write to the aliased location. Check for any overlap by generating the; // base pointer and checking the region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:294,Modifiability,variab,variable,294,"// From here on out, conservatively report to the pass manager that we've; // changed the IR, even if we later clean up these added instructions. There; // may be structural differences e.g. in the order of use lists not accounted; // for in just a textual dump of the IR. This is written as a variable, even; // though statically all the places this dominates could be replaced with; // 'true', with the hope that anyone trying to be clever / ""more precise"" with; // the return value will read this comment, and leave them alone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:107,Integrability,depend,dependencies,107,// TODO: ideally we should still be able to generate memset if SCEV expander; // is taught to generate the dependencies at the latest point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:37,Performance,load,load,37,/// If the stored value is a strided load in the same loop with the same stride; /// this may be transformable into a memcpy. This kicks in for stuff like; /// for (i) A[i] = B[i];,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:44,Performance,load,load,44,// The store must be feeding a non-volatile load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:113,Performance,load,load,113,"// See if the pointer expression is an AddRec like {base,+,1} on the current; // loop, which indicates a strided load. If we have something else, it's a; // random load we can't handle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:164,Performance,load,load,164,"// See if the pointer expression is an AddRec like {base,+,1} on the current; // loop, which indicates a strided load. If we have something else, it's a; // random load we can't handle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:15,Performance,Load,LoadBasePtr,15,// Ensure that LoadBasePtr is after StoreBasePtr or before StoreBasePtr; // for negative stride.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:15,Performance,Load,LoadBasePtr,15,// Ensure that LoadBasePtr is after StoreBasePtr or before StoreBasePtr; // for negative stride. LoadBasePtr shouldn't overlap with StoreBasePtr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:97,Performance,Load,LoadBasePtr,97,// Ensure that LoadBasePtr is after StoreBasePtr or before StoreBasePtr; // for negative stride. LoadBasePtr shouldn't overlap with StoreBasePtr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:45,Performance,load,loaded,45,"// Okay, we have a strided store ""p[i]"" of a loaded value. We can turn; // this into a memcpy in the loop preheader now if we want. However, this; // would be unsafe to do if there is anything else in the loop that may read; // or write the memory region we're storing to. This includes the load that; // feeds the stores. Check for an alias by generating the base address and; // checking everything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:291,Performance,load,load,291,"// Okay, we have a strided store ""p[i]"" of a loaded value. We can turn; // this into a memcpy in the loop preheader now if we want. However, this; // would be unsafe to do if there is anything else in the loop that may read; // or write the memory region we're storing to. This includes the load that; // feeds the stores. Check for an alias by generating the base address and; // checking everything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:159,Safety,unsafe,unsafe,159,"// Okay, we have a strided store ""p[i]"" of a loaded value. We can turn; // this into a memcpy in the loop preheader now if we want. However, this; // would be unsafe to do if there is anything else in the loop that may read; // or write the memory region we're storing to. This includes the load that; // feeds the stores. Check for an alias by generating the base address and; // checking everything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:294,Modifiability,variab,variable,294,"// From here on out, conservatively report to the pass manager that we've; // changed the IR, even if we later clean up these added instructions. There; // may be structural differences e.g. in the order of use lists not accounted; // for in just a textual dump of the IR. This is written as a variable, even; // though statically all the places this dominates could be replaced with; // 'true', with the hope that anyone trying to be clever / ""more precise"" with; // the return value will read this comment, and leave them alone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:67,Security,access,access,67,// For memmove case it's not enough to guarantee that loop doesn't access; // TheStore and TheLoad. Additionally we need to make sure that TheStore is; // the only user of TheLoad.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:83,Performance,load,load,83,"// If the store is a memcpy instruction, we must check if it will write to; // the load memory locations. So remove it from the ignored stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:23,Safety,safe,safe,23,"// Okay, everything is safe, we can transform this!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:68,Performance,load,load,68,"// Check whether to generate an unordered atomic memcpy:; // If the load or store are atomic, then they must necessarily be unordered; // by previous checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:47,Performance,load,load,47,"// We cannot allow unaligned ops for unordered load/store, so reject; // anything where the alignment isn't at least the element size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:65,Performance,load,loads,65,"// If the element.atomic memcpy is not lowered into explicit; // loads/stores later, then it will be lowered into an element-size; // specific lib call. If the lib call doesn't exist for our store size, then; // we shouldn't generate the memcpy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:51,Performance,load,loads,51,// Create the call.; // Note that unordered atomic loads/stores are *required* by the spec to; // have an alignment but non-atomic loads/stores may not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:131,Performance,load,loads,131,// Create the call.; // Note that unordered atomic loads/stores are *required* by the spec to; // have an alignment but non-atomic loads/stores may not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:34,Safety,avoid,avoid,34,// When compiling for codesize we avoid idiom recognition for a multi-block loop; // unless it is a loop_memset idiom or a memset/memcpy idiom in a nested loop.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:84,Modifiability,variab,variable,84,"/// Check if the given conditional branch is based on the comparison between; /// a variable and zero, and if the variable is non-zero or zero (JmpOnZero is; /// true), the control yields to the loop entry. If the branch matches the; /// behavior, the variable involved in the comparison is returned. This function; /// will be called to see if the precondition and postcondition of the loop are; /// in desirable form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:114,Modifiability,variab,variable,114,"/// Check if the given conditional branch is based on the comparison between; /// a variable and zero, and if the variable is non-zero or zero (JmpOnZero is; /// true), the control yields to the loop entry. If the branch matches the; /// behavior, the variable involved in the comparison is returned. This function; /// will be called to see if the precondition and postcondition of the loop are; /// in desirable form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:252,Modifiability,variab,variable,252,"/// Check if the given conditional branch is based on the comparison between; /// a variable and zero, and if the variable is non-zero or zero (JmpOnZero is; /// true), the control yields to the loop entry. If the branch matches the; /// behavior, the variable involved in the comparison is returned. This function; /// will be called to see if the precondition and postcondition of the loop are; /// in desirable form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:27,Modifiability,variab,variable,27,// Check if the recurrence variable `VarX` is in the right form to create; // the idiom. Returns the value coerced to a PHINode if so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:33,Safety,detect,detected,33,"/// Return true iff the idiom is detected in the loop.; ///; /// Additionally:; /// 1) \p CntInst is set to the instruction counting the population bit.; /// 2) \p CntPhi is set to the corresponding phi node.; /// 3) \p Var is set to the value whose population bits are being counted.; ///; /// The core idiom we are trying to detect is:; /// \code; /// if (x0 != 0); /// goto loop-exit // the precondition of the loop; /// cnt0 = init-val;; /// do {; /// x1 = phi (x0, x2);; /// cnt1 = phi(cnt0, cnt2);; ///; /// cnt2 = cnt1 + 1;; /// ...; /// x2 = x1 & (x1 - 1);; /// ...; /// } while(x != 0);; ///; /// loop-exit:; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:327,Safety,detect,detect,327,"/// Return true iff the idiom is detected in the loop.; ///; /// Additionally:; /// 1) \p CntInst is set to the instruction counting the population bit.; /// 2) \p CntPhi is set to the corresponding phi node.; /// 3) \p Var is set to the value whose population bits are being counted.; ///; /// The core idiom we are trying to detect is:; /// \code; /// if (x0 != 0); /// goto loop-exit // the precondition of the loop; /// cnt0 = init-val;; /// do {; /// x1 = phi (x0, x2);; /// cnt1 = phi(cnt0, cnt2);; ///; /// cnt2 = cnt1 + 1;; /// ...; /// x2 = x1 & (x1 - 1);; /// ...; /// } while(x != 0);; ///; /// loop-exit:; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:11,Safety,detect,detect,11,"// step 2: detect instructions corresponding to ""x2 = x1 & (x1 - 1)""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:35,Modifiability,variab,variable,35,// step 3: Check the recurrence of variable X,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:32,Safety,detect,detected,32,"/// Return true if the idiom is detected in the loop.; ///; /// Additionally:; /// 1) \p CntInst is set to the instruction Counting Leading Zeros (CTLZ); /// or nullptr if there is no such.; /// 2) \p CntPhi is set to the corresponding phi node; /// or nullptr if there is no such.; /// 3) \p Var is set to the value whose CTLZ could be used.; /// 4) \p DefX is set to the instruction calculating Loop exit condition.; ///; /// The core idiom we are trying to detect is:; /// \code; /// if (x0 == 0); /// goto loop-exit // the precondition of the loop; /// cnt0 = init-val;; /// do {; /// x = phi (x0, x.next); //PhiX; /// cnt = phi(cnt0, cnt.next);; ///; /// cnt.next = cnt + 1;; /// ...; /// x.next = x >> 1; // DefX; /// ...; /// } while(x.next != 0);; ///; /// loop-exit:; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:460,Safety,detect,detect,460,"/// Return true if the idiom is detected in the loop.; ///; /// Additionally:; /// 1) \p CntInst is set to the instruction Counting Leading Zeros (CTLZ); /// or nullptr if there is no such.; /// 2) \p CntPhi is set to the corresponding phi node; /// or nullptr if there is no such.; /// 3) \p Var is set to the value whose CTLZ could be used.; /// 4) \p DefX is set to the instruction calculating Loop exit condition.; ///; /// The core idiom we are trying to detect is:; /// \code; /// if (x0 == 0); /// goto loop-exit // the precondition of the loop; /// cnt0 = init-val;; /// do {; /// x = phi (x0, x.next); //PhiX; /// cnt = phi(cnt0, cnt.next);; ///; /// cnt.next = cnt + 1;; /// ...; /// x.next = x >> 1; // DefX; /// ...; /// } while(x.next != 0);; ///; /// loop-exit:; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:11,Safety,detect,detect,11,"// step 2: detect instructions corresponding to ""x.next = x >> 1 or x << 1""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:35,Modifiability,variab,variable,35,// step 3: Check the recurrence of variable X,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:210,Performance,optimiz,optimized,210,"// step 4: Find the instruction which count the CTLZ: cnt.next = cnt + 1; // or cnt.next = cnt + -1.; // TODO: We can skip the step. If loop trip count is known (CTLZ),; // then all uses of ""cnt.next"" could be optimized to the trip count; // plus ""cnt0"". Currently it is not optimized.; // This step could be used to detect POPCNT instruction:; // cnt.next = cnt + (x.next & 1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:275,Performance,optimiz,optimized,275,"// step 4: Find the instruction which count the CTLZ: cnt.next = cnt + 1; // or cnt.next = cnt + -1.; // TODO: We can skip the step. If loop trip count is known (CTLZ),; // then all uses of ""cnt.next"" could be optimized to the trip count; // plus ""cnt0"". Currently it is not optimized.; // This step could be used to detect POPCNT instruction:; // cnt.next = cnt + (x.next & 1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:317,Safety,detect,detect,317,"// step 4: Find the instruction which count the CTLZ: cnt.next = cnt + 1; // or cnt.next = cnt + -1.; // TODO: We can skip the step. If loop trip count is known (CTLZ),; // then all uses of ""cnt.next"" could be optimized to the trip count; // plus ""cnt0"". Currently it is not optimized.; // This step could be used to detect POPCNT instruction:; // cnt.next = cnt + (x.next & 1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:9,Safety,safe,safe,9,// It is safe to assume Preheader exist as it was checked in; // parent function RunOnLoop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:78,Safety,detect,detected,78,"/// Recognizes a population count idiom in a non-countable loop.; ///; /// If detected, transforms the relevant code to issue the popcount intrinsic; /// function call, and returns true; otherwise, returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:189,Availability,down,downstream,189,"// Step 2: Replace the precondition from ""if (x == 0) goto loop-exit"" to; // ""if (NewCount == 0) loop-exit"". Without this change, the intrinsic; // function would be partial dead code, and downstream passes will drag; // it back from the precondition block to the preheader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:639,Availability,alive,alive,639,"// Step 3: Note that the population count is exactly the trip count of the; // loop in question, which enable us to convert the loop from noncountable; // loop into a countable one. The benefit is twofold:; //; // - If the loop only counts population, the entire loop becomes dead after; // the transformation. It is a lot easier to prove a countable loop dead; // than to prove a noncountable one. (In some C dialects, an infinite loop; // isn't dead even if it computes nothing useful. In general, DCE needs; // to prove a noncountable loop finite before safely delete it.); //; // - If the loop also performs something else, it remains alive.; // Since it is transformed to countable form, it can be aggressively; // optimized by some optimizations which are in general not applicable; // to a noncountable loop.; //; // After this step, this loop (conceptually) would look like following:; // newcnt = __builtin_ctpop(x);; // t = newcnt;; // if (x); // do { cnt++; x &= x-1; t--) } while (t > 0);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:603,Performance,perform,performs,603,"// Step 3: Note that the population count is exactly the trip count of the; // loop in question, which enable us to convert the loop from noncountable; // loop into a countable one. The benefit is twofold:; //; // - If the loop only counts population, the entire loop becomes dead after; // the transformation. It is a lot easier to prove a countable loop dead; // than to prove a noncountable one. (In some C dialects, an infinite loop; // isn't dead even if it computes nothing useful. In general, DCE needs; // to prove a noncountable loop finite before safely delete it.); //; // - If the loop also performs something else, it remains alive.; // Since it is transformed to countable form, it can be aggressively; // optimized by some optimizations which are in general not applicable; // to a noncountable loop.; //; // After this step, this loop (conceptually) would look like following:; // newcnt = __builtin_ctpop(x);; // t = newcnt;; // if (x); // do { cnt++; x &= x-1; t--) } while (t > 0);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:720,Performance,optimiz,optimized,720,"// Step 3: Note that the population count is exactly the trip count of the; // loop in question, which enable us to convert the loop from noncountable; // loop into a countable one. The benefit is twofold:; //; // - If the loop only counts population, the entire loop becomes dead after; // the transformation. It is a lot easier to prove a countable loop dead; // than to prove a noncountable one. (In some C dialects, an infinite loop; // isn't dead even if it computes nothing useful. In general, DCE needs; // to prove a noncountable loop finite before safely delete it.); //; // - If the loop also performs something else, it remains alive.; // Since it is transformed to countable form, it can be aggressively; // optimized by some optimizations which are in general not applicable; // to a noncountable loop.; //; // After this step, this loop (conceptually) would look like following:; // newcnt = __builtin_ctpop(x);; // t = newcnt;; // if (x); // do { cnt++; x &= x-1; t--) } while (t > 0);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:738,Performance,optimiz,optimizations,738,"// Step 3: Note that the population count is exactly the trip count of the; // loop in question, which enable us to convert the loop from noncountable; // loop into a countable one. The benefit is twofold:; //; // - If the loop only counts population, the entire loop becomes dead after; // the transformation. It is a lot easier to prove a countable loop dead; // than to prove a noncountable one. (In some C dialects, an infinite loop; // isn't dead even if it computes nothing useful. In general, DCE needs; // to prove a noncountable loop finite before safely delete it.); //; // - If the loop also performs something else, it remains alive.; // Since it is transformed to countable form, it can be aggressively; // optimized by some optimizations which are in general not applicable; // to a noncountable loop.; //; // After this step, this loop (conceptually) would look like following:; // newcnt = __builtin_ctpop(x);; // t = newcnt;; // if (x); // do { cnt++; x &= x-1; t--) } while (t > 0);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:557,Safety,safe,safely,557,"// Step 3: Note that the population count is exactly the trip count of the; // loop in question, which enable us to convert the loop from noncountable; // loop into a countable one. The benefit is twofold:; //; // - If the loop only counts population, the entire loop becomes dead after; // the transformation. It is a lot easier to prove a countable loop dead; // than to prove a noncountable one. (In some C dialects, an infinite loop; // isn't dead even if it computes nothing useful. In general, DCE needs; // to prove a noncountable loop finite before safely delete it.); //; // - If the loop also performs something else, it remains alive.; // Since it is transformed to countable form, it can be aggressively; // optimized by some optimizations which are in general not applicable; // to a noncountable loop.; //; // After this step, this loop (conceptually) would look like following:; // newcnt = __builtin_ctpop(x);; // t = newcnt;; // if (x); // do { cnt++; x &= x-1; t--) } while (t > 0);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:32,Safety,detect,detected,32,"/// Return true if the idiom is detected in the loop.; ///; /// The core idiom we are trying to detect is:; /// \code; /// entry:; /// <...>; /// %bitmask = shl i32 1, %bitpos; /// br label %loop; ///; /// loop:; /// %x.curr = phi i32 [ %x, %entry ], [ %x.next, %loop ]; /// %x.curr.bitmasked = and i32 %x.curr, %bitmask; /// %x.curr.isbitunset = icmp eq i32 %x.curr.bitmasked, 0; /// %x.next = shl i32 %x.curr, 1; /// <...>; /// br i1 %x.curr.isbitunset, label %loop, label %end; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:96,Safety,detect,detect,96,"/// Return true if the idiom is detected in the loop.; ///; /// The core idiom we are trying to detect is:; /// \code; /// entry:; /// <...>; /// %bitmask = shl i32 1, %bitpos; /// br label %loop; ///; /// loop:; /// %x.curr = phi i32 [ %x, %entry ], [ %x.next, %loop ]; /// %x.curr.bitmasked = and i32 %x.curr, %bitmask; /// %x.curr.isbitunset = icmp eq i32 %x.curr.bitmasked, 0; /// %x.next = shl i32 %x.curr, 1; /// <...>; /// br i1 %x.curr.isbitunset, label %loop, label %end; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:687,Availability,mask,mask,687,"/// Look for the following loop:; /// \code; /// entry:; /// <...>; /// %bitmask = shl i32 1, %bitpos; /// br label %loop; ///; /// loop:; /// %x.curr = phi i32 [ %x, %entry ], [ %x.next, %loop ]; /// %x.curr.bitmasked = and i32 %x.curr, %bitmask; /// %x.curr.isbitunset = icmp eq i32 %x.curr.bitmasked, 0; /// %x.next = shl i32 %x.curr, 1; /// <...>; /// br i1 %x.curr.isbitunset, label %loop, label %end; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode; ///; /// And transform it into:; /// \code; /// entry:; /// %bitmask = shl i32 1, %bitpos; /// %lowbitmask = add i32 %bitmask, -1; /// %mask = or i32 %lowbitmask, %bitmask; /// %x.masked = and i32 %x, %mask; /// %x.masked.numleadingzeros = call i32 @llvm.ctlz.i32(i32 %x.masked,; /// i1 true); /// %x.masked.numactivebits = sub i32 32, %x.masked.numleadingzeros; /// %x.masked.leadingonepos = add i32 %x.masked.numactivebits, -1; /// %backedgetakencount = sub i32 %bitpos, %x.masked.leadingonepos; /// %tripcount = add i32 %backedgetakencount, 1; /// %x.curr = shl i32 %x, %backedgetakencount; /// %x.next = shl i32 %x, %tripcount; /// br label %loop; ///; /// loop:; /// %loop.iv = phi i32 [ 0, %entry ], [ %loop.iv.next, %loop ]; /// %loop.iv.next = add nuw i32 %loop.iv, 1; /// %loop.ivcheck = icmp eq i32 %loop.iv.next, %tripcount; /// <...>; /// br i1 %loop.ivcheck, label %end, label %loop; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:731,Availability,mask,masked,731,"/// Look for the following loop:; /// \code; /// entry:; /// <...>; /// %bitmask = shl i32 1, %bitpos; /// br label %loop; ///; /// loop:; /// %x.curr = phi i32 [ %x, %entry ], [ %x.next, %loop ]; /// %x.curr.bitmasked = and i32 %x.curr, %bitmask; /// %x.curr.isbitunset = icmp eq i32 %x.curr.bitmasked, 0; /// %x.next = shl i32 %x.curr, 1; /// <...>; /// br i1 %x.curr.isbitunset, label %loop, label %end; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode; ///; /// And transform it into:; /// \code; /// entry:; /// %bitmask = shl i32 1, %bitpos; /// %lowbitmask = add i32 %bitmask, -1; /// %mask = or i32 %lowbitmask, %bitmask; /// %x.masked = and i32 %x, %mask; /// %x.masked.numleadingzeros = call i32 @llvm.ctlz.i32(i32 %x.masked,; /// i1 true); /// %x.masked.numactivebits = sub i32 32, %x.masked.numleadingzeros; /// %x.masked.leadingonepos = add i32 %x.masked.numactivebits, -1; /// %backedgetakencount = sub i32 %bitpos, %x.masked.leadingonepos; /// %tripcount = add i32 %backedgetakencount, 1; /// %x.curr = shl i32 %x, %backedgetakencount; /// %x.next = shl i32 %x, %tripcount; /// br label %loop; ///; /// loop:; /// %loop.iv = phi i32 [ 0, %entry ], [ %loop.iv.next, %loop ]; /// %loop.iv.next = add nuw i32 %loop.iv, 1; /// %loop.ivcheck = icmp eq i32 %loop.iv.next, %tripcount; /// <...>; /// br i1 %loop.ivcheck, label %end, label %loop; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:753,Availability,mask,mask,753,"/// Look for the following loop:; /// \code; /// entry:; /// <...>; /// %bitmask = shl i32 1, %bitpos; /// br label %loop; ///; /// loop:; /// %x.curr = phi i32 [ %x, %entry ], [ %x.next, %loop ]; /// %x.curr.bitmasked = and i32 %x.curr, %bitmask; /// %x.curr.isbitunset = icmp eq i32 %x.curr.bitmasked, 0; /// %x.next = shl i32 %x.curr, 1; /// <...>; /// br i1 %x.curr.isbitunset, label %loop, label %end; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode; ///; /// And transform it into:; /// \code; /// entry:; /// %bitmask = shl i32 1, %bitpos; /// %lowbitmask = add i32 %bitmask, -1; /// %mask = or i32 %lowbitmask, %bitmask; /// %x.masked = and i32 %x, %mask; /// %x.masked.numleadingzeros = call i32 @llvm.ctlz.i32(i32 %x.masked,; /// i1 true); /// %x.masked.numactivebits = sub i32 32, %x.masked.numleadingzeros; /// %x.masked.leadingonepos = add i32 %x.masked.numactivebits, -1; /// %backedgetakencount = sub i32 %bitpos, %x.masked.leadingonepos; /// %tripcount = add i32 %backedgetakencount, 1; /// %x.curr = shl i32 %x, %backedgetakencount; /// %x.next = shl i32 %x, %tripcount; /// br label %loop; ///; /// loop:; /// %loop.iv = phi i32 [ 0, %entry ], [ %loop.iv.next, %loop ]; /// %loop.iv.next = add nuw i32 %loop.iv, 1; /// %loop.ivcheck = icmp eq i32 %loop.iv.next, %tripcount; /// <...>; /// br i1 %loop.ivcheck, label %end, label %loop; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:766,Availability,mask,masked,766,"/// Look for the following loop:; /// \code; /// entry:; /// <...>; /// %bitmask = shl i32 1, %bitpos; /// br label %loop; ///; /// loop:; /// %x.curr = phi i32 [ %x, %entry ], [ %x.next, %loop ]; /// %x.curr.bitmasked = and i32 %x.curr, %bitmask; /// %x.curr.isbitunset = icmp eq i32 %x.curr.bitmasked, 0; /// %x.next = shl i32 %x.curr, 1; /// <...>; /// br i1 %x.curr.isbitunset, label %loop, label %end; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode; ///; /// And transform it into:; /// \code; /// entry:; /// %bitmask = shl i32 1, %bitpos; /// %lowbitmask = add i32 %bitmask, -1; /// %mask = or i32 %lowbitmask, %bitmask; /// %x.masked = and i32 %x, %mask; /// %x.masked.numleadingzeros = call i32 @llvm.ctlz.i32(i32 %x.masked,; /// i1 true); /// %x.masked.numactivebits = sub i32 32, %x.masked.numleadingzeros; /// %x.masked.leadingonepos = add i32 %x.masked.numactivebits, -1; /// %backedgetakencount = sub i32 %bitpos, %x.masked.leadingonepos; /// %tripcount = add i32 %backedgetakencount, 1; /// %x.curr = shl i32 %x, %backedgetakencount; /// %x.next = shl i32 %x, %tripcount; /// br label %loop; ///; /// loop:; /// %loop.iv = phi i32 [ 0, %entry ], [ %loop.iv.next, %loop ]; /// %loop.iv.next = add nuw i32 %loop.iv, 1; /// %loop.ivcheck = icmp eq i32 %loop.iv.next, %tripcount; /// <...>; /// br i1 %loop.ivcheck, label %end, label %loop; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:822,Availability,mask,masked,822,"/// Look for the following loop:; /// \code; /// entry:; /// <...>; /// %bitmask = shl i32 1, %bitpos; /// br label %loop; ///; /// loop:; /// %x.curr = phi i32 [ %x, %entry ], [ %x.next, %loop ]; /// %x.curr.bitmasked = and i32 %x.curr, %bitmask; /// %x.curr.isbitunset = icmp eq i32 %x.curr.bitmasked, 0; /// %x.next = shl i32 %x.curr, 1; /// <...>; /// br i1 %x.curr.isbitunset, label %loop, label %end; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode; ///; /// And transform it into:; /// \code; /// entry:; /// %bitmask = shl i32 1, %bitpos; /// %lowbitmask = add i32 %bitmask, -1; /// %mask = or i32 %lowbitmask, %bitmask; /// %x.masked = and i32 %x, %mask; /// %x.masked.numleadingzeros = call i32 @llvm.ctlz.i32(i32 %x.masked,; /// i1 true); /// %x.masked.numactivebits = sub i32 32, %x.masked.numleadingzeros; /// %x.masked.leadingonepos = add i32 %x.masked.numactivebits, -1; /// %backedgetakencount = sub i32 %bitpos, %x.masked.leadingonepos; /// %tripcount = add i32 %backedgetakencount, 1; /// %x.curr = shl i32 %x, %backedgetakencount; /// %x.next = shl i32 %x, %tripcount; /// br label %loop; ///; /// loop:; /// %loop.iv = phi i32 [ 0, %entry ], [ %loop.iv.next, %loop ]; /// %loop.iv.next = add nuw i32 %loop.iv, 1; /// %loop.ivcheck = icmp eq i32 %loop.iv.next, %tripcount; /// <...>; /// br i1 %loop.ivcheck, label %end, label %loop; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:852,Availability,mask,masked,852,"/// Look for the following loop:; /// \code; /// entry:; /// <...>; /// %bitmask = shl i32 1, %bitpos; /// br label %loop; ///; /// loop:; /// %x.curr = phi i32 [ %x, %entry ], [ %x.next, %loop ]; /// %x.curr.bitmasked = and i32 %x.curr, %bitmask; /// %x.curr.isbitunset = icmp eq i32 %x.curr.bitmasked, 0; /// %x.next = shl i32 %x.curr, 1; /// <...>; /// br i1 %x.curr.isbitunset, label %loop, label %end; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode; ///; /// And transform it into:; /// \code; /// entry:; /// %bitmask = shl i32 1, %bitpos; /// %lowbitmask = add i32 %bitmask, -1; /// %mask = or i32 %lowbitmask, %bitmask; /// %x.masked = and i32 %x, %mask; /// %x.masked.numleadingzeros = call i32 @llvm.ctlz.i32(i32 %x.masked,; /// i1 true); /// %x.masked.numactivebits = sub i32 32, %x.masked.numleadingzeros; /// %x.masked.leadingonepos = add i32 %x.masked.numactivebits, -1; /// %backedgetakencount = sub i32 %bitpos, %x.masked.leadingonepos; /// %tripcount = add i32 %backedgetakencount, 1; /// %x.curr = shl i32 %x, %backedgetakencount; /// %x.next = shl i32 %x, %tripcount; /// br label %loop; ///; /// loop:; /// %loop.iv = phi i32 [ 0, %entry ], [ %loop.iv.next, %loop ]; /// %loop.iv.next = add nuw i32 %loop.iv, 1; /// %loop.ivcheck = icmp eq i32 %loop.iv.next, %tripcount; /// <...>; /// br i1 %loop.ivcheck, label %end, label %loop; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:890,Availability,mask,masked,890,"/// Look for the following loop:; /// \code; /// entry:; /// <...>; /// %bitmask = shl i32 1, %bitpos; /// br label %loop; ///; /// loop:; /// %x.curr = phi i32 [ %x, %entry ], [ %x.next, %loop ]; /// %x.curr.bitmasked = and i32 %x.curr, %bitmask; /// %x.curr.isbitunset = icmp eq i32 %x.curr.bitmasked, 0; /// %x.next = shl i32 %x.curr, 1; /// <...>; /// br i1 %x.curr.isbitunset, label %loop, label %end; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode; ///; /// And transform it into:; /// \code; /// entry:; /// %bitmask = shl i32 1, %bitpos; /// %lowbitmask = add i32 %bitmask, -1; /// %mask = or i32 %lowbitmask, %bitmask; /// %x.masked = and i32 %x, %mask; /// %x.masked.numleadingzeros = call i32 @llvm.ctlz.i32(i32 %x.masked,; /// i1 true); /// %x.masked.numactivebits = sub i32 32, %x.masked.numleadingzeros; /// %x.masked.leadingonepos = add i32 %x.masked.numactivebits, -1; /// %backedgetakencount = sub i32 %bitpos, %x.masked.leadingonepos; /// %tripcount = add i32 %backedgetakencount, 1; /// %x.curr = shl i32 %x, %backedgetakencount; /// %x.next = shl i32 %x, %tripcount; /// br label %loop; ///; /// loop:; /// %loop.iv = phi i32 [ 0, %entry ], [ %loop.iv.next, %loop ]; /// %loop.iv.next = add nuw i32 %loop.iv, 1; /// %loop.ivcheck = icmp eq i32 %loop.iv.next, %tripcount; /// <...>; /// br i1 %loop.ivcheck, label %end, label %loop; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:921,Availability,mask,masked,921,"/// Look for the following loop:; /// \code; /// entry:; /// <...>; /// %bitmask = shl i32 1, %bitpos; /// br label %loop; ///; /// loop:; /// %x.curr = phi i32 [ %x, %entry ], [ %x.next, %loop ]; /// %x.curr.bitmasked = and i32 %x.curr, %bitmask; /// %x.curr.isbitunset = icmp eq i32 %x.curr.bitmasked, 0; /// %x.next = shl i32 %x.curr, 1; /// <...>; /// br i1 %x.curr.isbitunset, label %loop, label %end; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode; ///; /// And transform it into:; /// \code; /// entry:; /// %bitmask = shl i32 1, %bitpos; /// %lowbitmask = add i32 %bitmask, -1; /// %mask = or i32 %lowbitmask, %bitmask; /// %x.masked = and i32 %x, %mask; /// %x.masked.numleadingzeros = call i32 @llvm.ctlz.i32(i32 %x.masked,; /// i1 true); /// %x.masked.numactivebits = sub i32 32, %x.masked.numleadingzeros; /// %x.masked.leadingonepos = add i32 %x.masked.numactivebits, -1; /// %backedgetakencount = sub i32 %bitpos, %x.masked.leadingonepos; /// %tripcount = add i32 %backedgetakencount, 1; /// %x.curr = shl i32 %x, %backedgetakencount; /// %x.next = shl i32 %x, %tripcount; /// br label %loop; ///; /// loop:; /// %loop.iv = phi i32 [ 0, %entry ], [ %loop.iv.next, %loop ]; /// %loop.iv.next = add nuw i32 %loop.iv, 1; /// %loop.ivcheck = icmp eq i32 %loop.iv.next, %tripcount; /// <...>; /// br i1 %loop.ivcheck, label %end, label %loop; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:955,Availability,mask,masked,955,"/// Look for the following loop:; /// \code; /// entry:; /// <...>; /// %bitmask = shl i32 1, %bitpos; /// br label %loop; ///; /// loop:; /// %x.curr = phi i32 [ %x, %entry ], [ %x.next, %loop ]; /// %x.curr.bitmasked = and i32 %x.curr, %bitmask; /// %x.curr.isbitunset = icmp eq i32 %x.curr.bitmasked, 0; /// %x.next = shl i32 %x.curr, 1; /// <...>; /// br i1 %x.curr.isbitunset, label %loop, label %end; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode; ///; /// And transform it into:; /// \code; /// entry:; /// %bitmask = shl i32 1, %bitpos; /// %lowbitmask = add i32 %bitmask, -1; /// %mask = or i32 %lowbitmask, %bitmask; /// %x.masked = and i32 %x, %mask; /// %x.masked.numleadingzeros = call i32 @llvm.ctlz.i32(i32 %x.masked,; /// i1 true); /// %x.masked.numactivebits = sub i32 32, %x.masked.numleadingzeros; /// %x.masked.leadingonepos = add i32 %x.masked.numactivebits, -1; /// %backedgetakencount = sub i32 %bitpos, %x.masked.leadingonepos; /// %tripcount = add i32 %backedgetakencount, 1; /// %x.curr = shl i32 %x, %backedgetakencount; /// %x.next = shl i32 %x, %tripcount; /// br label %loop; ///; /// loop:; /// %loop.iv = phi i32 [ 0, %entry ], [ %loop.iv.next, %loop ]; /// %loop.iv.next = add nuw i32 %loop.iv, 1; /// %loop.ivcheck = icmp eq i32 %loop.iv.next, %tripcount; /// <...>; /// br i1 %loop.ivcheck, label %end, label %loop; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:1027,Availability,mask,masked,1027,"/// Look for the following loop:; /// \code; /// entry:; /// <...>; /// %bitmask = shl i32 1, %bitpos; /// br label %loop; ///; /// loop:; /// %x.curr = phi i32 [ %x, %entry ], [ %x.next, %loop ]; /// %x.curr.bitmasked = and i32 %x.curr, %bitmask; /// %x.curr.isbitunset = icmp eq i32 %x.curr.bitmasked, 0; /// %x.next = shl i32 %x.curr, 1; /// <...>; /// br i1 %x.curr.isbitunset, label %loop, label %end; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode; ///; /// And transform it into:; /// \code; /// entry:; /// %bitmask = shl i32 1, %bitpos; /// %lowbitmask = add i32 %bitmask, -1; /// %mask = or i32 %lowbitmask, %bitmask; /// %x.masked = and i32 %x, %mask; /// %x.masked.numleadingzeros = call i32 @llvm.ctlz.i32(i32 %x.masked,; /// i1 true); /// %x.masked.numactivebits = sub i32 32, %x.masked.numleadingzeros; /// %x.masked.leadingonepos = add i32 %x.masked.numactivebits, -1; /// %backedgetakencount = sub i32 %bitpos, %x.masked.leadingonepos; /// %tripcount = add i32 %backedgetakencount, 1; /// %x.curr = shl i32 %x, %backedgetakencount; /// %x.next = shl i32 %x, %tripcount; /// br label %loop; ///; /// loop:; /// %loop.iv = phi i32 [ 0, %entry ], [ %loop.iv.next, %loop ]; /// %loop.iv.next = add nuw i32 %loop.iv, 1; /// %loop.ivcheck = icmp eq i32 %loop.iv.next, %tripcount; /// <...>; /// br i1 %loop.ivcheck, label %end, label %loop; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:7,Modifiability,rewrite,rewrite,7,"// The rewrite is considered to be unprofitable iff and only iff the; // intrinsic/shift we'll use are not cheap. Note that we are okay with *just*; // making the loop countable, even if nothing else changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:104,Safety,safe,safe,104,"// We know loop's backedge-taken count, but what's loop's trip count?; // Note that while NUW is always safe, while NSW is only for bitwidths != 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:83,Safety,safe,safe,83,"// Step 2: Compute the recurrence's final value without a loop.; // NewX is always safe to compute, because `LoopBackedgeTakenCount`; // will always be smaller than `bitwidth(X)`, i.e. we never get poison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:284,Safety,safe,safe,284,"// Rewriting XNext is more complicated, however, because `X << LoopTripCount`; // will be poison iff `LoopTripCount == bitwidth(X)` (which will happen; // iff `BitPos` is `bitwidth(x) - 1` and `X` is `1`). So unless we know; // that isn't the case, we'll need to emit an alternative, safe IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:11,Modifiability,Rewrite,Rewrite,11,"// Step 4: Rewrite the loop into a countable form, with canonical IV.; // The new canonical induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:102,Modifiability,variab,variable,102,"// Step 4: Rewrite the loop into a countable form, with canonical IV.; // The new canonical induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:59,Safety,safe,safe,59,"// The induction itself.; // Note that while NUW is always safe, while NSW is only for bitwidths != 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:32,Safety,detect,detected,32,"/// Return true if the idiom is detected in the loop.; ///; /// The core idiom we are trying to detect is:; /// \code; /// entry:; /// <...>; /// %start = <...>; /// %extraoffset = <...>; /// <...>; /// br label %for.cond; ///; /// loop:; /// %iv = phi i8 [ %start, %entry ], [ %iv.next, %for.cond ]; /// %nbits = add nsw i8 %iv, %extraoffset; /// %val.shifted = {{l,a}shr,shl} i8 %val, %nbits; /// %val.shifted.iszero = icmp eq i8 %val.shifted, 0; /// %iv.next = add i8 %iv, 1; /// <...>; /// br i1 %val.shifted.iszero, label %end, label %loop; ///; /// end:; /// %iv.res = phi i8 [ %iv, %loop ] <...>; /// %nbits.res = phi i8 [ %nbits, %loop ] <...>; /// %val.shifted.res = phi i8 [ %val.shifted, %loop ] <...>; /// %val.shifted.iszero.res = phi i1 [ %val.shifted.iszero, %loop ] <...>; /// %iv.next.res = phi i8 [ %iv.next, %loop ] <...>; /// <...>; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:96,Safety,detect,detect,96,"/// Return true if the idiom is detected in the loop.; ///; /// The core idiom we are trying to detect is:; /// \code; /// entry:; /// <...>; /// %start = <...>; /// %extraoffset = <...>; /// <...>; /// br label %for.cond; ///; /// loop:; /// %iv = phi i8 [ %start, %entry ], [ %iv.next, %for.cond ]; /// %nbits = add nsw i8 %iv, %extraoffset; /// %val.shifted = {{l,a}shr,shl} i8 %val, %nbits; /// %val.shifted.iszero = icmp eq i8 %val.shifted, 0; /// %iv.next = add i8 %iv, 1; /// <...>; /// br i1 %val.shifted.iszero, label %end, label %loop; ///; /// end:; /// %iv.res = phi i8 [ %iv, %loop ] <...>; /// %nbits.res = phi i8 [ %nbits, %loop ] <...>; /// %val.shifted.res = phi i8 [ %val.shifted, %loop ] <...>; /// %val.shifted.iszero.res = phi i1 [ %val.shifted.iszero, %loop ] <...>; /// %iv.next.res = phi i8 [ %iv.next, %loop ] <...>; /// <...>; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:177,Testability,log,logical,177,"// The new, countable, loop will certainly only run a known number of; // iterations, It won't be infinite. But the old loop might be infinite; // under certain conditions. For logical shifts, the value will become zero; // after at most bitwidth(%Val) loop iterations. However, for arithmetic; // right-shift, iff the sign bit was set, the value will never become zero,; // and the loop may never finish.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:7,Modifiability,rewrite,rewrite,7,"// The rewrite is considered to be unprofitable iff and only iff the; // intrinsic we'll use are not cheap. Note that we are okay with *just*; // making the loop countable, even if nothing else changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:82,Modifiability,variab,variable,82,// Step 2: Adjust the successor basic block to recieve the original; // induction variable's final value instead of the orig. IV itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:11,Modifiability,Rewrite,Rewrite,11,"// Step 3: Rewrite the loop into a countable form, with canonical IV.; // The new canonical induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:102,Modifiability,variab,variable,102,"// Step 3: Rewrite the loop into a countable form, with canonical IV.; // The new canonical induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:393,Performance,perform,performs,393,"//===- LoopInstSimplify.cpp - Loop Instruction Simplification Pass --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs lightweight instruction simplification on loop bodies.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:47,Usability,Simpl,Simplification,47,"//===- LoopInstSimplify.cpp - Loop Instruction Simplification Pass --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs lightweight instruction simplification on loop bodies.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:426,Usability,simpl,simplification,426,"//===- LoopInstSimplify.cpp - Loop Instruction Simplification Pass --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs lightweight instruction simplification on loop bodies.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:189,Deployability,update,updated,189,"// On the first pass over the loop body we try to simplify every instruction.; // On subsequent passes, we can restrict this to only simplifying instructions; // where the inputs have been updated. We end up needing two sets: one; // containing the instructions we are simplifying in *this* pass, and one for; // the instructions we will want to simplify in the *next* pass. We use; // pointers so we can swap between two stably allocated sets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:429,Energy Efficiency,allocate,allocated,429,"// On the first pass over the loop body we try to simplify every instruction.; // On subsequent passes, we can restrict this to only simplifying instructions; // where the inputs have been updated. We end up needing two sets: one; // containing the instructions we are simplifying in *this* pass, and one for; // the instructions we will want to simplify in the *next* pass. We use; // pointers so we can swap between two stably allocated sets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:50,Usability,simpl,simplify,50,"// On the first pass over the loop body we try to simplify every instruction.; // On subsequent passes, we can restrict this to only simplifying instructions; // where the inputs have been updated. We end up needing two sets: one; // containing the instructions we are simplifying in *this* pass, and one for; // the instructions we will want to simplify in the *next* pass. We use; // pointers so we can swap between two stably allocated sets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:133,Usability,simpl,simplifying,133,"// On the first pass over the loop body we try to simplify every instruction.; // On subsequent passes, we can restrict this to only simplifying instructions; // where the inputs have been updated. We end up needing two sets: one; // containing the instructions we are simplifying in *this* pass, and one for; // the instructions we will want to simplify in the *next* pass. We use; // pointers so we can swap between two stably allocated sets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:269,Usability,simpl,simplifying,269,"// On the first pass over the loop body we try to simplify every instruction.; // On subsequent passes, we can restrict this to only simplifying instructions; // where the inputs have been updated. We end up needing two sets: one; // containing the instructions we are simplifying in *this* pass, and one for; // the instructions we will want to simplify in the *next* pass. We use; // pointers so we can swap between two stably allocated sets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:346,Usability,simpl,simplify,346,"// On the first pass over the loop body we try to simplify every instruction.; // On subsequent passes, we can restrict this to only simplifying instructions; // where the inputs have been updated. We end up needing two sets: one; // containing the instructions we are simplifying in *this* pass, and one for; // the instructions we will want to simplify in the *next* pass. We use; // pointers so we can swap between two stably allocated sets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:9,Usability,simpl,simplifying,9,// While simplifying we may discover dead code or cause code to become dead.; // Keep track of all such instructions and we will delete them at the end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:212,Usability,simpl,simplifications,212,// First we want to create an RPO traversal of the loop body. By processing in; // RPO we can ensure that definitions are processed prior to uses (for non PHI; // uses) in all cases. This ensures we maximize the simplifications in each; // iteration over the loop and minimizes the possible causes for continuing to; // iterate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:52,Safety,detect,detect,52,// We special case the first iteration which we can detect due to the; // empty `ToSimplify` set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:18,Usability,simpl,simplifying,18,"// If we are only simplifying targeted instructions and the user is an; // instruction in the loop body, add it to our set of targeted; // instructions. Because we process defs before uses (outside of PHIs); // we won't have visited it yet.; //; // We also skip any uses outside of the loop being simplified. Those; // should always be PHI nodes due to LCSSA form, and we don't want to; // try to simplify those away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:297,Usability,simpl,simplified,297,"// If we are only simplifying targeted instructions and the user is an; // instruction in the loop body, add it to our set of targeted; // instructions. Because we process defs before uses (outside of PHIs); // we won't have visited it yet.; //; // We also skip any uses outside of the loop being simplified. Those; // should always be PHI nodes due to LCSSA form, and we don't want to; // try to simplify those away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:397,Usability,simpl,simplify,397,"// If we are only simplifying targeted instructions and the user is an; // instruction in the loop body, add it to our set of targeted; // instructions. Because we process defs before uses (outside of PHIs); // we won't have visited it yet.; //; // We also skip any uses outside of the loop being simplified. Those; // should always be PHI nodes due to LCSSA form, and we don't want to; // try to simplify those away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:44,Usability,simpl,simplified,44,"// If we never found a PHI that needs to be simplified in the next; // iteration, we're done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:480,Performance,cache,cache-friendly,480,"//===- LoopInterchange.cpp - Loop interchange pass-------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This Pass handles loop interchange transform.; // This pass interchanges loops to provide a more cache-friendly memory access; // patterns.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:502,Security,access,access,502,"//===- LoopInterchange.cpp - Loop interchange pass-------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This Pass handles loop interchange transform.; // This pass interchanges loops to provide a more cache-friendly memory access; // patterns.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:49,Integrability,depend,dependencies,49,// end anonymous namespace; // Maximum number of dependencies that can be handled in the dependency matrix.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:89,Integrability,depend,dependency,89,// end anonymous namespace; // Maximum number of dependencies that can be handled in the dependency matrix.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:33,Performance,load,loads,33,// Scan the BB and collect legal loads and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:16,Integrability,depend,dependencies,16,// Ignore Input dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:32,Integrability,depend,dependencies,32,"// Track Output, Flow, and Anti dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:55,Deployability,Update,Update,55,// A loop is moved from index 'from' to an index 'to'. Update the Dependence; // matrix by exchanging the two columns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:66,Integrability,Depend,Dependence,66,// A loop is moved from index 'from' to an index 'to'. Update the Dependence; // matrix by exchanging the two columns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:4,Integrability,Interface,Interface,4,/// Interface to emit optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:22,Performance,optimiz,optimization,22,/// Interface to emit optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:4,Integrability,Interface,Interface,4,/// Interface to emit optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:22,Performance,optimiz,optimization,22,/// Interface to emit optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:4,Integrability,Interface,Interface,4,/// Interface to emit optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:22,Performance,optimiz,optimization,22,/// Interface to emit optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:87,Integrability,depend,dependence,87,// TODO: Add a better heuristic to select the loop to be interchanged based; // on the dependence matrix. Currently we select the innermost loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:45,Performance,cache,cache,45,"// Obtain the loop vector returned from loop cache analysis beforehand,; // and put each <Loop, index> pair into a map for constant time query; // later. Indices in loop vector reprsent the optimal order of the; // corresponding loop, e.g., given a loopnest with depth N, index 0; // indicates the loop should be placed as the outermost loop and index N; // indicates the loop should be placed as the innermost loop.; //; // For the old pass manager CacheCost would be null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:450,Performance,Cache,CacheCost,450,"// Obtain the loop vector returned from loop cache analysis beforehand,; // and put each <Loop, index> pair into a map for constant time query; // later. Indices in loop vector reprsent the optimal order of the; // corresponding loop, e.g., given a loopnest with depth N, index 0; // indicates the loop should be placed as the outermost loop and index N; // indicates the loop should be placed as the innermost loop.; //; // For the old pass manager CacheCost would be null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:49,Security,access,access,49,"// We try to achieve the globally optimal memory access for the loopnest,; // and do interchange based on a bubble-sort fasion. We start from; // the innermost loop, move it outwards to the best possible position; // and repeat this process.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:23,Deployability,update,update,23,"// Loops interchanged, update LoopList accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:3,Deployability,Update,Update,3,// Update the DependencyMatrix,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:14,Integrability,Depend,DependencyMatrix,14,// Update the DependencyMatrix,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:9,Safety,abort,abort,9,// Early abort if there was no interchange during an entire round of; // moving loops outwards.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:121,Safety,unsafe,unsafe,121,// We do not have any basic block in between now make sure the outer header; // and outer loop latch doesn't contain any unsafe instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:64,Safety,unsafe,unsafe,64,// Also make sure the inner loop preheader does not contain any unsafe; // instructions. Note that all instructions in the preheader will be moved to; // the outer loop header when interchanging.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:117,Safety,safe,safe,117,"// The inner loop exit block does flow to the outer loop latch and not some; // other BBs, now make sure it contains safe instructions, since it will be; // moved into the (new) inner loop after interchange.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:49,Modifiability,variab,variable,49,"// Check if V only involves inner loop induction variable.; // Return true if V is InnerInduction, or a cast from; // InnerInduction, or a binary operator that involves; // InnerInduction and a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:103,Modifiability,variab,variables,103,"// In case of multiple inner loop indvars, it is okay if LHS and RHS; // are both inner indvar related variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:82,Modifiability,variab,variable,82,// Otherwise we check if the cmp instruction compares an inner indvar; // related variable (Left) with a outer loop invariant (Right).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:13,Modifiability,variab,variables,13,// Reduction variables cannot be constants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:3,Safety,Detect,Detect,3,// Detect floating point reduction only when it can be reordered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:224,Availability,avail,available,224,"// We currently support LCSSA PHI nodes in the outer loop exit, if their; // incoming values do not come from the outer loop latch or if the; // outer loop latch has a single predecessor. In that case, the value will; // be available if both the inner and outer loop conditions are true, which; // will still be true after interchanging. If we have multiple predecessor,; // that may not be the case, e.g. because the outer loop latch may be executed; // if the inner loop is not executed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:545,Deployability,update,update,545,"// The incoming value is defined in the outer loop latch. Currently we; // only support that in case the outer loop latch has a single predecessor.; // This guarantees that the outer loop latch is executed if and only if; // the inner loop is executed (because tightlyNested() guarantees that the; // outer loop header only branches to the inner loop or the outer loop; // latch).; // FIXME: We could weaken this logic and allow multiple predecessors,; // if the values are produced outside the loop latch. We would need; // additional logic to update the PHI nodes in the exit block as; // well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:413,Testability,log,logic,413,"// The incoming value is defined in the outer loop latch. Currently we; // only support that in case the outer loop latch has a single predecessor.; // This guarantees that the outer loop latch is executed if and only if; // the inner loop is executed (because tightlyNested() guarantees that the; // outer loop header only branches to the inner loop or the outer loop; // latch).; // FIXME: We could weaken this logic and allow multiple predecessors,; // if the values are produced outside the loop latch. We would need; // additional logic to update the PHI nodes in the exit block as; // well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:536,Testability,log,logic,536,"// The incoming value is defined in the outer loop latch. Currently we; // only support that in case the outer loop latch has a single predecessor.; // This guarantees that the outer loop latch is executed if and only if; // the inner loop is executed (because tightlyNested() guarantees that the; // outer loop header only branches to the inner loop or the outer loop; // latch).; // FIXME: We could weaken this logic and allow multiple predecessors,; // if the values are produced outside the loop latch. We would need; // additional logic to update the PHI nodes in the exit block as; // well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:222,Availability,avail,available,222,"// In case of multi-level nested loops, it may occur that lcssa phis exist in; // the latch of InnerLoop, i.e., when defs of the incoming values are further; // inside the loopnest. Sometimes those incoming values are not available; // after interchange, since the original inner latch will become the new outer; // latch which may have predecessor paths that do not include those incoming; // values.; // TODO: Handle transformation of lcssa phis in the InnerLoop latch in case of; // multi-level loop nests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:147,Availability,avail,available,147,"// If the original outer latch has only one predecessor, then values defined; // further inside the looploop, e.g., in the innermost loop, will be available; // at the new outer latch after interchange.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:356,Availability,avail,available,356,"// The outer latch has more than one predecessors, i.e., the inner; // exit and the inner header.; // PHI nodes in the inner latch are lcssa phis where the incoming values; // are defined further inside the loopnest. Check if those phis are used; // in the original inner latch. If that is the case then bail out since; // those incoming values may not be available at the new outer latch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:49,Performance,cache,cache,49,"// This is the new cost model returned from loop cache analysis.; // A smaller index means the loop should be placed an outer loop, and vice; // versa.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:113,Modifiability,variab,variables,113,// Legacy cost model: this is rough cost estimation algorithm. It counts the; // good and bad order of induction variables in the instruction and allows; // reordering if number of bad orders is more than good.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:62,Integrability,depend,dependency,62,"// If the inner loop is loop independent or doesn't carry any dependency; // it is not profitable to move this to outer position, since we are; // likely able to do inner loop vectorization already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:21,Integrability,depend,dependence,21,"// If inner loop has dependence and outer loop is loop independent then it; // is/ profitable to interchange to enable inner loop parallelism.; // If there are no dependences, interchanging will not improve anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:163,Integrability,depend,dependences,163,"// If inner loop has dependence and outer loop is loop independent then it; // is/ profitable to interchange to enable inner loop parallelism.; // If there are no dependences, interchanging will not improve anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:79,Performance,cache,cache,79,"// isProfitable() is structured to avoid endless loop interchange.; // If loop cache analysis could decide the profitability then,; // profitability check will stop and return the analysis result.; // If cache analysis failed to analyze the loopnest (e.g.,; // due to delinearization issues) then only check whether it is; // profitable for InstrOrderCost. Likewise, if InstrOrderCost failed to; // analysis the profitability then only, isProfitableForVectorization; // will decide.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:204,Performance,cache,cache,204,"// isProfitable() is structured to avoid endless loop interchange.; // If loop cache analysis could decide the profitability then,; // profitability check will stop and return the analysis result.; // If cache analysis failed to analyze the loopnest (e.g.,; // due to delinearization issues) then only check whether it is; // profitable for InstrOrderCost. Likewise, if InstrOrderCost failed to; // analysis the profitability then only, isProfitableForVectorization; // will decide.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:35,Safety,avoid,avoid,35,"// isProfitable() is structured to avoid endless loop interchange.; // If loop cache analysis could decide the profitability then,; // profitability check will stop and return the analysis result.; // If cache analysis failed to analyze the loopnest (e.g.,; // due to delinearization issues) then only check whether it is; // profitable for InstrOrderCost. Likewise, if InstrOrderCost failed to; // analysis the profitability then only, isProfitableForVectorization; // will decide.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:4,Deployability,Update,Update,4,"/// Update LoopInfo, after interchanging. NewInner and NewOuter refer to the; /// new inner and outer loop after interchanging: NewInner is the original; /// outer loop and NewOuter is the original inner loop.; ///; /// Before interchanging, we have the following structure; /// Outer preheader; // Outer header; // Inner preheader; // Inner header; // Inner body; // Inner latch; // outer bbs; // Outer latch; //; // After interchanging:; // Inner preheader; // Inner header; // Outer preheader; // Outer header; // Inner body; // outer bbs; // Outer latch; // Inner latch",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:52,Deployability,Update,Update,52,// Duplicate instruction and move it the new latch. Update uses that; // have been moved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:57,Integrability,depend,depend,57,"// Instructions in the original inner loop preheader may depend on values; // defined in the outer loop header. Move them there, because the original; // inner loop preheader will become the entry into the interchanged loop nest.; // Currently we move all instructions and rely on LICM to move invariant; // instructions outside the loop nest.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:3,Deployability,Update,Update,3,"// Update BI to jump to NewBB instead of OldBB. Records updates to the; // dominator tree in DTUpdates. If \p MustUpdateOnce is true, assert that; // \p OldBB is exactly once in BI's successor list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:56,Deployability,update,updates,56,"// Update BI to jump to NewBB instead of OldBB. Records updates to the; // dominator tree in DTUpdates. If \p MustUpdateOnce is true, assert that; // \p OldBB is exactly once in BI's successor list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:134,Testability,assert,assert,134,"// Update BI to jump to NewBB instead of OldBB. Records updates to the; // dominator tree in DTUpdates. If \p MustUpdateOnce is true, assert that; // \p OldBB is exactly once in BI's successor list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:96,Deployability,update,updated,96,// Skip Phis with incoming values defined in the inner loop. Those should; // already have been updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:7,Deployability,update,update,7,// Now update the reduction PHIs in the inner and outer loop headers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:3,Deployability,Update,Update,3,// Update the incoming blocks for moved PHI nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:499,Integrability,depend,dependences,499,"//===- LoopLoadElimination.cpp - Loop Load Elimination Pass ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement a loop-aware load elimination pass.; //; // It uses LoopAccessAnalysis to identify loop-carried dependences with a; // distance of one between stores and loads. These form the candidates for the; // transformation. The source value of each store then propagated to the user; // of the corresponding load. This makes the load dead.; //; // The pass can also version the loop and add memchecks in order to prove that; // may-aliasing stores can't change the value in memory before it's read by the; // load.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:38,Performance,Load,Load,38,"//===- LoopLoadElimination.cpp - Loop Load Elimination Pass ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement a loop-aware load elimination pass.; //; // It uses LoopAccessAnalysis to identify loop-carried dependences with a; // distance of one between stores and loads. These form the candidates for the; // transformation. The source value of each store then propagated to the user; // of the corresponding load. This makes the load dead.; //; // The pass can also version the loop and add memchecks in order to prove that; // may-aliasing stores can't change the value in memory before it's read by the; // load.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:416,Performance,load,load,416,"//===- LoopLoadElimination.cpp - Loop Load Elimination Pass ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement a loop-aware load elimination pass.; //; // It uses LoopAccessAnalysis to identify loop-carried dependences with a; // distance of one between stores and loads. These form the candidates for the; // transformation. The source value of each store then propagated to the user; // of the corresponding load. This makes the load dead.; //; // The pass can also version the loop and add memchecks in order to prove that; // may-aliasing stores can't change the value in memory before it's read by the; // load.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:557,Performance,load,loads,557,"//===- LoopLoadElimination.cpp - Loop Load Elimination Pass ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement a loop-aware load elimination pass.; //; // It uses LoopAccessAnalysis to identify loop-carried dependences with a; // distance of one between stores and loads. These form the candidates for the; // transformation. The source value of each store then propagated to the user; // of the corresponding load. This makes the load dead.; //; // The pass can also version the loop and add memchecks in order to prove that; // may-aliasing stores can't change the value in memory before it's read by the; // load.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:702,Performance,load,load,702,"//===- LoopLoadElimination.cpp - Loop Load Elimination Pass ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement a loop-aware load elimination pass.; //; // It uses LoopAccessAnalysis to identify loop-carried dependences with a; // distance of one between stores and loads. These form the candidates for the; // transformation. The source value of each store then propagated to the user; // of the corresponding load. This makes the load dead.; //; // The pass can also version the loop and add memchecks in order to prove that; // may-aliasing stores can't change the value in memory before it's read by the; // load.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:723,Performance,load,load,723,"//===- LoopLoadElimination.cpp - Loop Load Elimination Pass ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement a loop-aware load elimination pass.; //; // It uses LoopAccessAnalysis to identify loop-carried dependences with a; // distance of one between stores and loads. These form the candidates for the; // transformation. The source value of each store then propagated to the user; // of the corresponding load. This makes the load dead.; //; // The pass can also version the loop and add memchecks in order to prove that; // may-aliasing stores can't change the value in memory before it's read by the; // load.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:903,Performance,load,load,903,"//===- LoopLoadElimination.cpp - Loop Load Elimination Pass ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement a loop-aware load elimination pass.; //; // It uses LoopAccessAnalysis to identify loop-carried dependences with a; // distance of one between stores and loads. These form the candidates for the; // transformation. The source value of each store then propagated to the user; // of the corresponding load. This makes the load dead.; //; // The pass can also version the loop and add memchecks in order to prove that; // may-aliasing stores can't change the value in memory before it's read by the; // load.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:23,Integrability,depend,dependence,23,/// Return true if the dependence from the store to the load has an; /// absolute distance of one.; /// E.g. A[i+1] = A[i] (or A[i-1] = A[i] for descending loop),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:56,Performance,load,load,56,/// Return true if the dependence from the store to the load has an; /// absolute distance of one.; /// E.g. A[i+1] = A[i] (or A[i-1] = A[i] for descending loop),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:454,Energy Efficiency,efficient,efficiently,454,"// TODO: This check for stride values other than 1 and -1 can be eliminated.; // However, doing so may cause the LoopAccessAnalysis to overcompensate,; // generating numerous non-wrap runtime checks that may undermine the; // benefits of load elimination. To safely implement support for non-unit; // strides, we would need to ensure either that the processed case does not; // require these additional checks, or improve the LAA to handle them more; // efficiently, or potentially both.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:179,Integrability,wrap,wrap,179,"// TODO: This check for stride values other than 1 and -1 can be eliminated.; // However, doing so may cause the LoopAccessAnalysis to overcompensate,; // generating numerous non-wrap runtime checks that may undermine the; // benefits of load elimination. To safely implement support for non-unit; // strides, we would need to ensure either that the processed case does not; // require these additional checks, or improve the LAA to handle them more; // efficiently, or potentially both.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:238,Performance,load,load,238,"// TODO: This check for stride values other than 1 and -1 can be eliminated.; // However, doing so may cause the LoopAccessAnalysis to overcompensate,; // generating numerous non-wrap runtime checks that may undermine the; // benefits of load elimination. To safely implement support for non-unit; // strides, we would need to ensure either that the processed case does not; // require these additional checks, or improve the LAA to handle them more; // efficiently, or potentially both.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:259,Safety,safe,safely,259,"// TODO: This check for stride values other than 1 and -1 can be eliminated.; // However, doing so may cause the LoopAccessAnalysis to overcompensate,; // generating numerous non-wrap runtime checks that may undermine the; // benefits of load elimination. To safely implement support for non-unit; // strides, we would need to ensure either that the processed case does not; // require these additional checks, or improve the LAA to handle them more; // efficiently, or potentially both.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:30,Integrability,wrap,wrapping,30,// We don't need to check non-wrapping here because forward/backward; // dependence wouldn't be valid if these weren't monotonic accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:73,Integrability,depend,dependence,73,// We don't need to check non-wrapping here because forward/backward; // dependence wouldn't be valid if these weren't monotonic accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:129,Security,access,accesses,129,// We don't need to check non-wrapping here because forward/backward; // dependence wouldn't be valid if these weren't monotonic accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:142,Performance,load,loaded,142,"// end anonymous namespace; /// Check if the store dominates all latches, so as long as there is no; /// intervening store this value will be loaded in the next iteration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:23,Performance,load,load,23,/// Return true if the load is not executed on all paths in the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:55,Integrability,depend,dependences,55,"/// Look through the loop-carried and loop-independent dependences in; /// this loop and find store->load dependences.; ///; /// Note that no candidate is returned if LAA has failed to analyze the loop; /// (e.g. if it's not bottom-tested, contains volatile memops, etc.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:106,Integrability,depend,dependences,106,"/// Look through the loop-carried and loop-independent dependences in; /// this loop and find store->load dependences.; ///; /// Note that no candidate is returned if LAA has failed to analyze the loop; /// (e.g. if it's not bottom-tested, contains volatile memops, etc.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:101,Performance,load,load,101,"/// Look through the loop-carried and loop-independent dependences in; /// this loop and find store->load dependences.; ///; /// Note that no candidate is returned if LAA has failed to analyze the loop; /// (e.g. if it's not bottom-tested, contains volatile memops, etc.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:232,Testability,test,tested,232,"/// Look through the loop-carried and loop-independent dependences in; /// this loop and find store->load dependences.; ///; /// Note that no candidate is returned if LAA has failed to analyze the loop; /// (e.g. if it's not bottom-tested, contains volatile memops, etc.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:20,Integrability,depend,dependences,20,// Find store->load dependences (consequently true dep). Both lexically; // forward and backward dependences qualify. Disqualify loads that have; // other unknown dependences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:97,Integrability,depend,dependences,97,// Find store->load dependences (consequently true dep). Both lexically; // forward and backward dependences qualify. Disqualify loads that have; // other unknown dependences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:163,Integrability,depend,dependences,163,// Find store->load dependences (consequently true dep). Both lexically; // forward and backward dependences qualify. Disqualify loads that have; // other unknown dependences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:15,Performance,load,load,15,// Find store->load dependences (consequently true dep). Both lexically; // forward and backward dependences qualify. Disqualify loads that have; // other unknown dependences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:129,Performance,load,loads,129,// Find store->load dependences (consequently true dep). Both lexically; // forward and backward dependences qualify. Disqualify loads that have; // other unknown dependences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:142,Integrability,depend,depending,142,"/// If a load has multiple candidates associated (i.e. different; /// stores), it means that it could be forwarding from multiple stores; /// depending on control flow. Remove these candidates.; ///; /// Here, we rely on LAA to include the relevant loop-independent dependences.; /// LAA is known to omit these in the very simple case when the read and the; /// write within an alias set always takes place using the *same* pointer.; ///; /// However, we know that this is not the case here, i.e. we can rely on LAA; /// to provide us with loop-independent dependences for the cases we're; /// interested. Consider the case for example where a loop-independent; /// dependece S1->S2 invalidates the forwarding S3->S2.; ///; /// A[i] = ... (S1); /// ... = A[i] (S2); /// A[i+1] = ... (S3); ///; /// LAA will perform dependence analysis here because there are two; /// *different* pointers involved in the same alias set (&A[i] and &A[i+1]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:266,Integrability,depend,dependences,266,"/// If a load has multiple candidates associated (i.e. different; /// stores), it means that it could be forwarding from multiple stores; /// depending on control flow. Remove these candidates.; ///; /// Here, we rely on LAA to include the relevant loop-independent dependences.; /// LAA is known to omit these in the very simple case when the read and the; /// write within an alias set always takes place using the *same* pointer.; ///; /// However, we know that this is not the case here, i.e. we can rely on LAA; /// to provide us with loop-independent dependences for the cases we're; /// interested. Consider the case for example where a loop-independent; /// dependece S1->S2 invalidates the forwarding S3->S2.; ///; /// A[i] = ... (S1); /// ... = A[i] (S2); /// A[i+1] = ... (S3); ///; /// LAA will perform dependence analysis here because there are two; /// *different* pointers involved in the same alias set (&A[i] and &A[i+1]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:557,Integrability,depend,dependences,557,"/// If a load has multiple candidates associated (i.e. different; /// stores), it means that it could be forwarding from multiple stores; /// depending on control flow. Remove these candidates.; ///; /// Here, we rely on LAA to include the relevant loop-independent dependences.; /// LAA is known to omit these in the very simple case when the read and the; /// write within an alias set always takes place using the *same* pointer.; ///; /// However, we know that this is not the case here, i.e. we can rely on LAA; /// to provide us with loop-independent dependences for the cases we're; /// interested. Consider the case for example where a loop-independent; /// dependece S1->S2 invalidates the forwarding S3->S2.; ///; /// A[i] = ... (S1); /// ... = A[i] (S2); /// A[i+1] = ... (S3); ///; /// LAA will perform dependence analysis here because there are two; /// *different* pointers involved in the same alias set (&A[i] and &A[i+1]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:666,Integrability,depend,dependece,666,"/// If a load has multiple candidates associated (i.e. different; /// stores), it means that it could be forwarding from multiple stores; /// depending on control flow. Remove these candidates.; ///; /// Here, we rely on LAA to include the relevant loop-independent dependences.; /// LAA is known to omit these in the very simple case when the read and the; /// write within an alias set always takes place using the *same* pointer.; ///; /// However, we know that this is not the case here, i.e. we can rely on LAA; /// to provide us with loop-independent dependences for the cases we're; /// interested. Consider the case for example where a loop-independent; /// dependece S1->S2 invalidates the forwarding S3->S2.; ///; /// A[i] = ... (S1); /// ... = A[i] (S2); /// A[i+1] = ... (S3); ///; /// LAA will perform dependence analysis here because there are two; /// *different* pointers involved in the same alias set (&A[i] and &A[i+1]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:815,Integrability,depend,dependence,815,"/// If a load has multiple candidates associated (i.e. different; /// stores), it means that it could be forwarding from multiple stores; /// depending on control flow. Remove these candidates.; ///; /// Here, we rely on LAA to include the relevant loop-independent dependences.; /// LAA is known to omit these in the very simple case when the read and the; /// write within an alias set always takes place using the *same* pointer.; ///; /// However, we know that this is not the case here, i.e. we can rely on LAA; /// to provide us with loop-independent dependences for the cases we're; /// interested. Consider the case for example where a loop-independent; /// dependece S1->S2 invalidates the forwarding S3->S2.; ///; /// A[i] = ... (S1); /// ... = A[i] (S2); /// A[i+1] = ... (S3); ///; /// LAA will perform dependence analysis here because there are two; /// *different* pointers involved in the same alias set (&A[i] and &A[i+1]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:9,Performance,load,load,9,"/// If a load has multiple candidates associated (i.e. different; /// stores), it means that it could be forwarding from multiple stores; /// depending on control flow. Remove these candidates.; ///; /// Here, we rely on LAA to include the relevant loop-independent dependences.; /// LAA is known to omit these in the very simple case when the read and the; /// write within an alias set always takes place using the *same* pointer.; ///; /// However, we know that this is not the case here, i.e. we can rely on LAA; /// to provide us with loop-independent dependences for the cases we're; /// interested. Consider the case for example where a loop-independent; /// dependece S1->S2 invalidates the forwarding S3->S2.; ///; /// A[i] = ... (S1); /// ... = A[i] (S2); /// A[i+1] = ... (S3); ///; /// LAA will perform dependence analysis here because there are two; /// *different* pointers involved in the same alias set (&A[i] and &A[i+1]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:807,Performance,perform,perform,807,"/// If a load has multiple candidates associated (i.e. different; /// stores), it means that it could be forwarding from multiple stores; /// depending on control flow. Remove these candidates.; ///; /// Here, we rely on LAA to include the relevant loop-independent dependences.; /// LAA is known to omit these in the very simple case when the read and the; /// write within an alias set always takes place using the *same* pointer.; ///; /// However, we know that this is not the case here, i.e. we can rely on LAA; /// to provide us with loop-independent dependences for the cases we're; /// interested. Consider the case for example where a loop-independent; /// dependece S1->S2 invalidates the forwarding S3->S2.; ///; /// A[i] = ... (S1); /// ... = A[i] (S2); /// A[i+1] = ... (S3); ///; /// LAA will perform dependence analysis here because there are two; /// *different* pointers involved in the same alias set (&A[i] and &A[i+1]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:323,Usability,simpl,simple,323,"/// If a load has multiple candidates associated (i.e. different; /// stores), it means that it could be forwarding from multiple stores; /// depending on control flow. Remove these candidates.; ///; /// Here, we rely on LAA to include the relevant loop-independent dependences.; /// LAA is known to omit these in the very simple case when the read and the; /// write within an alias set always takes place using the *same* pointer.; ///; /// However, we know that this is not the case here, i.e. we can rely on LAA; /// to provide us with loop-independent dependences for the cases we're; /// interested. Consider the case for example where a loop-independent; /// dependece S1->S2 invalidates the forwarding S3->S2.; ///; /// A[i] = ... (S1); /// ... = A[i] (S2); /// A[i+1] = ... (S3); ///; /// LAA will perform dependence analysis here because there are two; /// *different* pointers involved in the same alias set (&A[i] and &A[i+1]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:43,Performance,load,load,43,// Already multiple stores forward to this load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:171,Integrability,depend,dependence,171,// Handle the very basic case when the two stores are in the same block; // so deciding which one forwards is easy. The later one forwards as; // long as they both have a dependence distance of one to the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:205,Performance,load,load,205,// Handle the very basic case when the two stores are in the same block; // so deciding which one forwards is easy. The later one forwards as; // long as they both have a dependence distance of one to the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:65,Performance,load,load,65,"// They are in the same block, the later one will forward to the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:186,Performance,load,load,186,"/// Given two pointers operations by their RuntimePointerChecking; /// indices, return true if they require an alias check.; ///; /// We need a check if one is a pointer for a candidate load and the other is; /// a pointer for a possibly intervening store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:95,Performance,load,load,95,/// Return pointers that are possibly written to on the path from a; /// forwarding store to a load.; ///; /// These pointers need to be alias-checked against the forwarding candidates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:68,Performance,load,loads,68,"// From FirstStore to LastLoad neither of the elimination candidate loads; // should overlap with any of the stores.; //; // E.g.:; //; // st1 C[i]; // ld1 B[i] <-------,; // ld0 A[i] <----, | * LastLoad; // ... | |; // st2 E[i] | |; // st3 B[i+1] -- | -' * FirstStore; // st0 A[i+1] ---'; // st4 D[i]; //; // st0 forwards to ld0 if the accesses in st4 and st1 don't overlap with; // ld0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:337,Security,access,accesses,337,"// From FirstStore to LastLoad neither of the elimination candidate loads; // should overlap with any of the stores.; //; // E.g.:; //; // st1 C[i]; // ld1 B[i] <-------,; // ld0 A[i] <----, | * LastLoad; // ... | |; // st2 E[i] | |; // st3 B[i+1] -- | -' * FirstStore; // st0 A[i+1] ---'; // st4 D[i]; //; // st0 forwards to ld0 if the accesses in st4 and st1 don't overlap with; // ld0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:160,Performance,load,load,160,"// We're looking for stores after the first forwarding store until the end; // of the loop, then from the beginning of the loop until the last; // forwarded-to load. Collect the pointer for the stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:41,Performance,load,loads,41,// Collect the pointers of the candidate loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:4,Performance,Perform,Perform,4,/// Perform the transformation for a candidate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:18,Performance,load,load,18,"// loop:; // %x = load %gep_i; // = ... %x; // store %y, %gep_i_plus_1; //; // =>; //; // ph:; // %x.initial = load %gep_0; // loop:; // %x.storeforward = phi [%x.initial, %ph] [%y, %loop]; // %x = load %gep_i <---- now dead; // = ... %x.storeforward; // store %y, %gep_i_plus_1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:111,Performance,load,load,111,"// loop:; // %x = load %gep_i; // = ... %x; // store %y, %gep_i_plus_1; //; // =>; //; // ph:; // %x.initial = load %gep_0; // loop:; // %x.storeforward = phi [%x.initial, %ph] [%y, %loop]; // %x = load %gep_i <---- now dead; // = ... %x.storeforward; // store %y, %gep_i_plus_1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:198,Performance,load,load,198,"// loop:; // %x = load %gep_i; // = ... %x; // store %y, %gep_i_plus_1; //; // =>; //; // ph:; // %x.initial = load %gep_0; // loop:; // %x.storeforward = phi [%x.initial, %ph] [%y, %loop]; // %x = load %gep_i <---- now dead; // = ... %x.storeforward; // store %y, %gep_i_plus_1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:48,Performance,load,load,48,"/// Top-level driver for each loop: find store->load forwarding; /// candidates, add run-time checks and perform transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:105,Performance,perform,perform,105,"/// Top-level driver for each loop: find store->load forwarding; /// candidates, add run-time checks and perform transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:391,Integrability,depend,dependences,391,"// Look for store-to-load forwarding cases across the; // backedge. E.g.:; //; // loop:; // %x = load %gep_i; // = ... %x; // store %y, %gep_i_plus_1; //; // =>; //; // ph:; // %x.initial = load %gep_0; // loop:; // %x.storeforward = phi [%x.initial, %ph] [%y, %loop]; // %x = load %gep_i <---- now dead; // = ... %x.storeforward; // store %y, %gep_i_plus_1; // First start with store->load dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:21,Performance,load,load,21,"// Look for store-to-load forwarding cases across the; // backedge. E.g.:; //; // loop:; // %x = load %gep_i; // = ... %x; // store %y, %gep_i_plus_1; //; // =>; //; // ph:; // %x.initial = load %gep_0; // loop:; // %x.storeforward = phi [%x.initial, %ph] [%y, %loop]; // %x = load %gep_i <---- now dead; // = ... %x.storeforward; // store %y, %gep_i_plus_1; // First start with store->load dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:97,Performance,load,load,97,"// Look for store-to-load forwarding cases across the; // backedge. E.g.:; //; // loop:; // %x = load %gep_i; // = ... %x; // store %y, %gep_i_plus_1; //; // =>; //; // ph:; // %x.initial = load %gep_0; // loop:; // %x.storeforward = phi [%x.initial, %ph] [%y, %loop]; // %x = load %gep_i <---- now dead; // = ... %x.storeforward; // store %y, %gep_i_plus_1; // First start with store->load dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:190,Performance,load,load,190,"// Look for store-to-load forwarding cases across the; // backedge. E.g.:; //; // loop:; // %x = load %gep_i; // = ... %x; // store %y, %gep_i_plus_1; //; // =>; //; // ph:; // %x.initial = load %gep_0; // loop:; // %x.storeforward = phi [%x.initial, %ph] [%y, %loop]; // %x = load %gep_i <---- now dead; // = ... %x.storeforward; // store %y, %gep_i_plus_1; // First start with store->load dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:277,Performance,load,load,277,"// Look for store-to-load forwarding cases across the; // backedge. E.g.:; //; // loop:; // %x = load %gep_i; // = ... %x; // store %y, %gep_i_plus_1; //; // =>; //; // ph:; // %x.initial = load %gep_0; // loop:; // %x.storeforward = phi [%x.initial, %ph] [%y, %loop]; // %x = load %gep_i <---- now dead; // = ... %x.storeforward; // store %y, %gep_i_plus_1; // First start with store->load dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:386,Performance,load,load,386,"// Look for store-to-load forwarding cases across the; // backedge. E.g.:; //; // loop:; // %x = load %gep_i; // = ... %x; // store %y, %gep_i_plus_1; //; // =>; //; // ph:; // %x.initial = load %gep_0; // loop:; // %x.storeforward = phi [%x.initial, %ph] [%y, %loop]; // %x = load %gep_i <---- now dead; // = ... %x.storeforward; // store %y, %gep_i_plus_1; // First start with store->load dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:30,Performance,load,load,30,// Generate an index for each load and store according to the original; // program order. This will be used later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:57,Performance,load,load,57,"// To keep things simple for now, remove those where the load is potentially; // fed by multiple stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:18,Usability,simpl,simple,18,"// To keep things simple for now, remove those where the load is potentially; // fed by multiple stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:39,Availability,avail,available,39,// Make sure that the stored values is available everywhere in the loop in; // the next iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:10,Performance,load,load,10,// If the load is conditional we can't hoist its 0-iteration instance to; // the preheader because that would make it unconditional. Thus we would; // access a memory location that the original loop did not access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:151,Security,access,access,151,// If the load is conditional we can't hoist its 0-iteration instance to; // the preheader because that would make it unconditional. Thus we would; // access a memory location that the original loop did not access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:207,Security,access,access,207,// If the load is conditional we can't hoist its 0-iteration instance to; // the preheader because that would make it unconditional. Thus we would; // access a memory location that the original loop did not access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:84,Performance,load,load,84,"// Check whether the SCEV difference is the same as the induction step,; // thus we load the value in the next iteration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:69,Performance,load,load,69,"// Next, propagate the value stored by the store to the users of the load.; // Also for the first iteration, generate the initial value of the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:143,Performance,load,load,143,"// Next, propagate the value stored by the store to the users of the load.; // Also for the first iteration, generate the initial value of the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:13,Performance,load,load,13,/// Maps the load/store instructions to their index according to; /// program order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:256,Performance,optimiz,optimizes,256,// Build up a worklist of inner-loops to transform to avoid iterator; // invalidation.; // FIXME: This logic comes from other passes that actually change the loop; // nest structure. It isn't clear this is necessary (or useful) for a pass; // which merely optimizes the use of loads in a loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:277,Performance,load,loads,277,// Build up a worklist of inner-loops to transform to avoid iterator; // invalidation.; // FIXME: This logic comes from other passes that actually change the loop; // nest structure. It isn't clear this is necessary (or useful) for a pass; // which merely optimizes the use of loads in a loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:54,Safety,avoid,avoid,54,// Build up a worklist of inner-loops to transform to avoid iterator; // invalidation.; // FIXME: This logic comes from other passes that actually change the loop; // nest structure. It isn't clear this is necessary (or useful) for a pass; // which merely optimizes the use of loads in a loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:103,Testability,log,logic,103,// Build up a worklist of inner-loops to transform to avoid iterator; // invalidation.; // FIXME: This logic comes from other passes that actually change the loop; // nest structure. It isn't clear this is necessary (or useful) for a pass; // which merely optimizes the use of loads in a loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:192,Usability,clear,clear,192,// Build up a worklist of inner-loops to transform to avoid iterator; // invalidation.; // FIXME: This logic comes from other passes that actually change the loop; // nest structure. It isn't clear this is necessary (or useful) for a pass; // which merely optimizes the use of loads in a loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:22,Performance,perform,performed,22,// The actual work is performed by LoadEliminationForLoop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:35,Performance,Load,LoadEliminationForLoop,35,// The actual work is performed by LoadEliminationForLoop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:91,Deployability,update,updates,91,/// Explicitly specialize the pass manager's run method to handle loop nest; /// structure updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:28,Safety,abort,abort,28,"// If the loop was deleted, abort the run and return to the outer walk.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:3,Deployability,Update,Update,3,// Update the analysis manager as each pass runs and potentially; // invalidates analyses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:167,Availability,failure,failures,167,"// After running the loop pass, the parent loop might change and we need to; // notify the updater, otherwise U.ParentL might gets outdated and triggers; // assertion failures in addSiblingLoops and addChildLoops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:91,Deployability,update,updater,91,"// After running the loop pass, the parent loop might change and we need to; // notify the updater, otherwise U.ParentL might gets outdated and triggers; // assertion failures in addSiblingLoops and addChildLoops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:157,Testability,assert,assertion,157,"// After running the loop pass, the parent loop might change and we need to; // notify the updater, otherwise U.ParentL might gets outdated and triggers; // assertion failures in addSiblingLoops and addChildLoops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:114,Usability,simpl,simply,114,// Run all loop passes on loop \p L. Loop-nest passes don't run either because; // \p L is not a top-level one or simply because there are no loop-nest passes; // in the pass manager at all.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:28,Safety,abort,abort,28,"// If the loop was deleted, abort the run and return to the outer walk.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:3,Deployability,Update,Update,3,// Update the analysis manager as each pass runs and potentially; // invalidates analyses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:167,Availability,failure,failures,167,"// After running the loop pass, the parent loop might change and we need to; // notify the updater, otherwise U.ParentL might gets outdated and triggers; // assertion failures in addSiblingLoops and addChildLoops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:91,Deployability,update,updater,91,"// After running the loop pass, the parent loop might change and we need to; // notify the updater, otherwise U.ParentL might gets outdated and triggers; // assertion failures in addSiblingLoops and addChildLoops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:157,Testability,assert,assertion,157,"// After running the loop pass, the parent loop might change and we need to; // notify the updater, otherwise U.ParentL might gets outdated and triggers; // assertion failures in addSiblingLoops and addChildLoops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:85,Deployability,pipeline,pipeline,85,"// Before we even compute any loop analyses, first run a miniature function; // pass pipeline to put loops into their canonical form. Note that we can; // directly build up function analyses after this as the function pass; // manager handles all the invalidation at that layer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:96,Deployability,pipeline,pipeline,96,// Check the PassInstrumentation's BeforePass callbacks before running the; // canonicalization pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:206,Performance,cache,cached,206,// Setup the loop analysis manager from its proxy. It is important that; // this is only done when there are loops to process and we have built the; // LoopStandardAnalysisResults object. The loop analyses cached in this; // manager have access to those analysis results and so it must invalidate; // itself when they go away.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:238,Security,access,access,238,// Setup the loop analysis manager from its proxy. It is important that; // this is only done when there are loops to process and we have built the; // LoopStandardAnalysisResults object. The loop analyses cached in this; // manager have access to those analysis results and so it must invalidate; // itself when they go away.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:79,Deployability,update,update,79,// Register the worklist and loop analysis manager so that loop passes can; // update them when they mutate the loop nest structure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:13,Deployability,update,update,13,// Reset the update structure for this loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:34,Testability,assert,asserts,34,// Save a parent loop pointer for asserts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:98,Integrability,contract,contract,98,"// We know that the loop pass couldn't have invalidated any other; // loop's analyses (that's the contract of a loop pass), so directly; // handle the loop analysis manager's invalidation here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:1478,Modifiability,variab,variable,1478,"dening checks across loop iterations. For example, it will; // convert; //; // for (i = 0; i < n; i++) {; // guard(i < len);; // ...; // }; //; // to; //; // for (i = 0; i < n; i++) {; // guard(n - 1 < len);; // ...; // }; //; // After this transformation the condition of the guard is loop invariant, so; // loop-unswitch can later unswitch the loop by this condition which basically; // predicates the loop by the widened condition:; //; // if (n - 1 < len); // for (i = 0; i < n; i++) {; // ...; // }; // else; // deoptimize; //; // It's tempting to rely on SCEV here, but it has proven to be problematic.; // Generally the facts SCEV provides about the increment step of add; // recurrences are true if the backedge of the loop is taken, which implicitly; // assumes that the guard doesn't fail. Using these facts to optimize the; // guard results in a circular logic where the guard is optimized under the; // assumption that it never fails.; //; // For example, in the loop below the induction variable will be marked as nuw; // basing on the guard. Basing on nuw the guard predicate will be considered; // monotonic. Given a monotonic condition it's tempting to replace the induction; // variable in the condition with its value on the last iteration. But this; // transformation is not correct, e.g. e = 4, b = 5 breaks the loop.; //; // for (int i = b; i != e; i++); // guard(i u< len); //; // One of the ways to reason about this problem is to use an inductive proof; // approach. Given the loop:; //; // if (B(0)) {; // do {; // I = PHI(0, I.INC); // I.INC = I + Step; // guard(G(I));; // } while (B(I));; // }; //; // where B(x) and G(x) are predicates that map integers to booleans, we want a; // loop invariant expression M such the following program has the same semantics; // as the above:; //; // if (B(0)) {; // do {; // I = PHI(0, I.INC); // I.INC = I + Step; // guard(G(0) && M);; // } while (B(I));; // }; //; // One solution for M is M = forall X . (G(X) && B(X)) => G(X + Step);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:1673,Modifiability,variab,variable,1673,"ard(n - 1 < len);; // ...; // }; //; // After this transformation the condition of the guard is loop invariant, so; // loop-unswitch can later unswitch the loop by this condition which basically; // predicates the loop by the widened condition:; //; // if (n - 1 < len); // for (i = 0; i < n; i++) {; // ...; // }; // else; // deoptimize; //; // It's tempting to rely on SCEV here, but it has proven to be problematic.; // Generally the facts SCEV provides about the increment step of add; // recurrences are true if the backedge of the loop is taken, which implicitly; // assumes that the guard doesn't fail. Using these facts to optimize the; // guard results in a circular logic where the guard is optimized under the; // assumption that it never fails.; //; // For example, in the loop below the induction variable will be marked as nuw; // basing on the guard. Basing on nuw the guard predicate will be considered; // monotonic. Given a monotonic condition it's tempting to replace the induction; // variable in the condition with its value on the last iteration. But this; // transformation is not correct, e.g. e = 4, b = 5 breaks the loop.; //; // for (int i = b; i != e; i++); // guard(i u< len); //; // One of the ways to reason about this problem is to use an inductive proof; // approach. Given the loop:; //; // if (B(0)) {; // do {; // I = PHI(0, I.INC); // I.INC = I + Step; // guard(G(I));; // } while (B(I));; // }; //; // where B(x) and G(x) are predicates that map integers to booleans, we want a; // loop invariant expression M such the following program has the same semantics; // as the above:; //; // if (B(0)) {; // do {; // I = PHI(0, I.INC); // I.INC = I + Step; // guard(G(0) && M);; // } while (B(I));; // }; //; // One solution for M is M = forall X . (G(X) && B(X)) => G(X + Step); //; // Informal proof that the transformation above is correct:; //; // By the definition of guards we can rewrite the guard condition to:; // G(I) && G(0) && M; //; // Let's prove that for",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:2587,Modifiability,rewrite,rewrite,2587,"onic condition it's tempting to replace the induction; // variable in the condition with its value on the last iteration. But this; // transformation is not correct, e.g. e = 4, b = 5 breaks the loop.; //; // for (int i = b; i != e; i++); // guard(i u< len); //; // One of the ways to reason about this problem is to use an inductive proof; // approach. Given the loop:; //; // if (B(0)) {; // do {; // I = PHI(0, I.INC); // I.INC = I + Step; // guard(G(I));; // } while (B(I));; // }; //; // where B(x) and G(x) are predicates that map integers to booleans, we want a; // loop invariant expression M such the following program has the same semantics; // as the above:; //; // if (B(0)) {; // do {; // I = PHI(0, I.INC); // I.INC = I + Step; // guard(G(0) && M);; // } while (B(I));; // }; //; // One solution for M is M = forall X . (G(X) && B(X)) => G(X + Step); //; // Informal proof that the transformation above is correct:; //; // By the definition of guards we can rewrite the guard condition to:; // G(I) && G(0) && M; //; // Let's prove that for each iteration of the loop:; // G(0) && M => G(I); // And the condition above can be simplified to G(Start) && M.; //; // Induction base.; // G(0) && M => G(0); //; // Induction step. Assuming G(0) && M => G(I) on the subsequent; // iteration:; //; // B(I) is true because it's the backedge condition.; // G(I) is true because the backedge is guarded by this condition.; //; // So M = forall X . (G(X) && B(X)) => G(X + Step) implies G(I + Step).; //; // Note that we can use anything stronger than M, i.e. any condition which; // implies M.; //; // When S = 1 (i.e. forward iterating loop), the transformation is supported; // when:; // * The loop has a single latch with the condition of the form:; // B(X) = latchStart + X <pred> latchLimit,; // where <pred> is u<, u<=, s<, or s<=.; // * The guard condition is of the form; // G(X) = guardStart + X u< guardLimit; //; // For the ult latch comparison case M is:; // forall X . guardStart + X u",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:1299,Performance,optimiz,optimize,1299,"-------------------===//; //; // The LoopPredication pass tries to convert loop variant range checks to loop; // invariant by widening checks across loop iterations. For example, it will; // convert; //; // for (i = 0; i < n; i++) {; // guard(i < len);; // ...; // }; //; // to; //; // for (i = 0; i < n; i++) {; // guard(n - 1 < len);; // ...; // }; //; // After this transformation the condition of the guard is loop invariant, so; // loop-unswitch can later unswitch the loop by this condition which basically; // predicates the loop by the widened condition:; //; // if (n - 1 < len); // for (i = 0; i < n; i++) {; // ...; // }; // else; // deoptimize; //; // It's tempting to rely on SCEV here, but it has proven to be problematic.; // Generally the facts SCEV provides about the increment step of add; // recurrences are true if the backedge of the loop is taken, which implicitly; // assumes that the guard doesn't fail. Using these facts to optimize the; // guard results in a circular logic where the guard is optimized under the; // assumption that it never fails.; //; // For example, in the loop below the induction variable will be marked as nuw; // basing on the guard. Basing on nuw the guard predicate will be considered; // monotonic. Given a monotonic condition it's tempting to replace the induction; // variable in the condition with its value on the last iteration. But this; // transformation is not correct, e.g. e = 4, b = 5 breaks the loop.; //; // for (int i = b; i != e; i++); // guard(i u< len); //; // One of the ways to reason about this problem is to use an inductive proof; // approach. Given the loop:; //; // if (B(0)) {; // do {; // I = PHI(0, I.INC); // I.INC = I + Step; // guard(G(I));; // } while (B(I));; // }; //; // where B(x) and G(x) are predicates that map integers to booleans, we want a; // loop invariant expression M such the following program has the same semantics; // as the above:; //; // if (B(0)) {; // do {; // I = PHI(0, I.INC); // I.INC = I + ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:1369,Performance,optimiz,optimized,1369,"-------------------===//; //; // The LoopPredication pass tries to convert loop variant range checks to loop; // invariant by widening checks across loop iterations. For example, it will; // convert; //; // for (i = 0; i < n; i++) {; // guard(i < len);; // ...; // }; //; // to; //; // for (i = 0; i < n; i++) {; // guard(n - 1 < len);; // ...; // }; //; // After this transformation the condition of the guard is loop invariant, so; // loop-unswitch can later unswitch the loop by this condition which basically; // predicates the loop by the widened condition:; //; // if (n - 1 < len); // for (i = 0; i < n; i++) {; // ...; // }; // else; // deoptimize; //; // It's tempting to rely on SCEV here, but it has proven to be problematic.; // Generally the facts SCEV provides about the increment step of add; // recurrences are true if the backedge of the loop is taken, which implicitly; // assumes that the guard doesn't fail. Using these facts to optimize the; // guard results in a circular logic where the guard is optimized under the; // assumption that it never fails.; //; // For example, in the loop below the induction variable will be marked as nuw; // basing on the guard. Basing on nuw the guard predicate will be considered; // monotonic. Given a monotonic condition it's tempting to replace the induction; // variable in the condition with its value on the last iteration. But this; // transformation is not correct, e.g. e = 4, b = 5 breaks the loop.; //; // for (int i = b; i != e; i++); // guard(i u< len); //; // One of the ways to reason about this problem is to use an inductive proof; // approach. Given the loop:; //; // if (B(0)) {; // do {; // I = PHI(0, I.INC); // I.INC = I + Step; // guard(G(I));; // } while (B(I));; // }; //; // where B(x) and G(x) are predicates that map integers to booleans, we want a; // loop invariant expression M such the following program has the same semantics; // as the above:; //; // if (B(0)) {; // do {; // I = PHI(0, I.INC); // I.INC = I + ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:1344,Testability,log,logic,1344,"-------------------===//; //; // The LoopPredication pass tries to convert loop variant range checks to loop; // invariant by widening checks across loop iterations. For example, it will; // convert; //; // for (i = 0; i < n; i++) {; // guard(i < len);; // ...; // }; //; // to; //; // for (i = 0; i < n; i++) {; // guard(n - 1 < len);; // ...; // }; //; // After this transformation the condition of the guard is loop invariant, so; // loop-unswitch can later unswitch the loop by this condition which basically; // predicates the loop by the widened condition:; //; // if (n - 1 < len); // for (i = 0; i < n; i++) {; // ...; // }; // else; // deoptimize; //; // It's tempting to rely on SCEV here, but it has proven to be problematic.; // Generally the facts SCEV provides about the increment step of add; // recurrences are true if the backedge of the loop is taken, which implicitly; // assumes that the guard doesn't fail. Using these facts to optimize the; // guard results in a circular logic where the guard is optimized under the; // assumption that it never fails.; //; // For example, in the loop below the induction variable will be marked as nuw; // basing on the guard. Basing on nuw the guard predicate will be considered; // monotonic. Given a monotonic condition it's tempting to replace the induction; // variable in the condition with its value on the last iteration. But this; // transformation is not correct, e.g. e = 4, b = 5 breaks the loop.; //; // for (int i = b; i != e; i++); // guard(i u< len); //; // One of the ways to reason about this problem is to use an inductive proof; // approach. Given the loop:; //; // if (B(0)) {; // do {; // I = PHI(0, I.INC); // I.INC = I + Step; // guard(G(I));; // } while (B(I));; // }; //; // where B(x) and G(x) are predicates that map integers to booleans, we want a; // loop invariant expression M such the following program has the same semantics; // as the above:; //; // if (B(0)) {; // do {; // I = PHI(0, I.INC); // I.INC = I + ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:2755,Usability,simpl,simplified,2755,"onic condition it's tempting to replace the induction; // variable in the condition with its value on the last iteration. But this; // transformation is not correct, e.g. e = 4, b = 5 breaks the loop.; //; // for (int i = b; i != e; i++); // guard(i u< len); //; // One of the ways to reason about this problem is to use an inductive proof; // approach. Given the loop:; //; // if (B(0)) {; // do {; // I = PHI(0, I.INC); // I.INC = I + Step; // guard(G(I));; // } while (B(I));; // }; //; // where B(x) and G(x) are predicates that map integers to booleans, we want a; // loop invariant expression M such the following program has the same semantics; // as the above:; //; // if (B(0)) {; // do {; // I = PHI(0, I.INC); // I.INC = I + Step; // guard(G(0) && M);; // } while (B(I));; // }; //; // One solution for M is M = forall X . (G(X) && B(X)) => G(X + Step); //; // Informal proof that the transformation above is correct:; //; // By the definition of guards we can rewrite the guard condition to:; // G(I) && G(0) && M; //; // Let's prove that for each iteration of the loop:; // G(0) && M => G(I); // And the condition above can be simplified to G(Start) && M.; //; // Induction base.; // G(0) && M => G(0); //; // Induction step. Assuming G(0) && M => G(I) on the subsequent; // iteration:; //; // B(I) is true because it's the backedge condition.; // G(I) is true because the backedge is guarded by this condition.; //; // So M = forall X . (G(X) && B(X)) => G(X + Step) implies G(I + Step).; //; // Note that we can use anything stronger than M, i.e. any condition which; // implies M.; //; // When S = 1 (i.e. forward iterating loop), the transformation is supported; // when:; // * The loop has a single latch with the condition of the form:; // B(X) = latchStart + X <pred> latchLimit,; // where <pred> is u<, u<=, s<, or s<=.; // * The guard condition is of the form; // G(X) = guardStart + X u< guardLimit; //; // For the ult latch comparison case M is:; // forall X . guardStart + X u",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:28,Modifiability,variab,variable,28,"/// Represents an induction variable check:; /// icmp Pred, <induction variable>, <loop invariant limit>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:71,Modifiability,variab,variable,71,"/// Represents an induction variable check:; /// icmp Pred, <induction variable>, <loop invariant limit>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:55,Safety,safe,safe,55,"/// Return an insertion point suitable for inserting a safe to speculate; /// instruction whose only user will be 'User' which has operands 'Ops'. A; /// trivial result would be the at the User itself, but we try to return a; /// loop invariant location if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:166,Safety,safe,safety,166,/// Return true if the value is known to produce a single fixed value across; /// all iterations on which it executes. Note that this does not imply; /// speculation safety. That must be established separately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:23,Safety,safe,safe,23,"// Returns true if its safe to truncate the IV to RangeCheckType.; // When the IV type is wider than the range operand type, we can still do loop; // predication, by generating SCEVs for the range and latch that are of the; // same type. We achieve this by generating a SCEV truncate expression for the; // latch IV. This is done iff truncation of the IV is a safe operation,; // without loss of information.; // Another way to achieve this is by generating a wider type SCEV for the; // range check operand, however, this needs a more involved check that; // operands do not overflow. This can lead to loss of information when the; // range operand is of the form: add i32 %offset, %iv. We need to prove that; // sext(x + y) is same as sext(x) + sext(y).; // This function returns true if we can safely represent the IV type in; // the RangeCheckType without loss of information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:360,Safety,safe,safe,360,"// Returns true if its safe to truncate the IV to RangeCheckType.; // When the IV type is wider than the range operand type, we can still do loop; // predication, by generating SCEVs for the range and latch that are of the; // same type. We achieve this by generating a SCEV truncate expression for the; // latch IV. This is done iff truncation of the IV is a safe operation,; // without loss of information.; // Another way to achieve this is by generating a wider type SCEV for the; // range check operand, however, this needs a more involved check that; // operands do not overflow. This can lead to loss of information when the; // range operand is of the form: add i32 %offset, %iv. We need to prove that; // sext(x + y) is same as sext(x) + sext(y).; // This function returns true if we can safely represent the IV type in; // the RangeCheckType without loss of information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:797,Safety,safe,safely,797,"// Returns true if its safe to truncate the IV to RangeCheckType.; // When the IV type is wider than the range operand type, we can still do loop; // predication, by generating SCEVs for the range and latch that are of the; // same type. We achieve this by generating a SCEV truncate expression for the; // latch IV. This is done iff truncation of the IV is a safe operation,; // without loss of information.; // Another way to achieve this is by generating a wider type SCEV for the; // range check operand, however, this needs a more involved check that; // operands do not overflow. This can lead to loss of information when the; // range operand is of the form: add i32 %offset, %iv. We need to prove that; // sext(x + y) is same as sext(x) + sext(y).; // This function returns true if we can safely represent the IV type in; // the RangeCheckType without loss of information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:231,Integrability,wrap,wraps,231,"// This check makes sure that the IV does not change sign during loop; // iterations. Consider latchType = i64, LatchStart = 5, Pred = ICMP_SGE,; // LatchEnd = 2, rangeCheckType = i32. If it's not a monotonic predicate, the; // IV wraps around, and the truncation of the IV would lose the range of; // iterations between 2^32 and 2^64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:146,Safety,safe,safe,146,// The active bits should be less than the bits in the RangeCheckType. This; // guarantees that truncating the latch check to RangeCheckType is a safe; // operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:106,Safety,safe,safe,106,// Return an LoopICmp describing a latch check equivlent to LatchCheck but with; // the requested type if safe to do so. May involve the use of a new IV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:14,Safety,safe,safely,14,// We can now safely identify the truncated version of the IV and limit for; // RangeCheckType.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:541,Safety,safe,safe,541,"// Handling expressions which produce invariant results, but *haven't* yet; // been removed from the loop serves two important purposes.; // 1) Most importantly, it resolves a pass ordering cycle which would; // otherwise need us to iteration licm, loop-predication, and either; // loop-unswitch or loop-peeling to make progress on examples with lots of; // predicable range checks in a row. (Since, in the general case, we can't; // hoist the length checks until the dominating checks have been discharged; // as we can't prove doing so is safe.); // 2) As a nice side effect, this exposes the value of peeling or unswitching; // much more obviously in the IR. Otherwise, the cost modeling for other; // transforms would end up needing to duplicate all of this logic to model a; // check which becomes predictable based on a modeled peel or unswitch.; //; // The cost of doing so in the worst case is an extra fill from the stack in; // the loop to materialize the loop invariant test value instead of checking; // against the original IV which is presumable in a register inside the loop.; // Such cases are presumably rare, and hint at missing oppurtunities for; // other passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:803,Safety,predict,predictable,803,"// Handling expressions which produce invariant results, but *haven't* yet; // been removed from the loop serves two important purposes.; // 1) Most importantly, it resolves a pass ordering cycle which would; // otherwise need us to iteration licm, loop-predication, and either; // loop-unswitch or loop-peeling to make progress on examples with lots of; // predicable range checks in a row. (Since, in the general case, we can't; // hoist the length checks until the dominating checks have been discharged; // as we can't prove doing so is safe.); // 2) As a nice side effect, this exposes the value of peeling or unswitching; // much more obviously in the IR. Otherwise, the cost modeling for other; // transforms would end up needing to duplicate all of this logic to model a; // check which becomes predictable based on a modeled peel or unswitch.; //; // The cost of doing so in the worst case is an extra fill from the stack in; // the loop to materialize the loop invariant test value instead of checking; // against the original IV which is presumable in a register inside the loop.; // Such cases are presumably rare, and hint at missing oppurtunities for; // other passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:583,Security,expose,exposes,583,"// Handling expressions which produce invariant results, but *haven't* yet; // been removed from the loop serves two important purposes.; // 1) Most importantly, it resolves a pass ordering cycle which would; // otherwise need us to iteration licm, loop-predication, and either; // loop-unswitch or loop-peeling to make progress on examples with lots of; // predicable range checks in a row. (Since, in the general case, we can't; // hoist the length checks until the dominating checks have been discharged; // as we can't prove doing so is safe.); // 2) As a nice side effect, this exposes the value of peeling or unswitching; // much more obviously in the IR. Otherwise, the cost modeling for other; // transforms would end up needing to duplicate all of this logic to model a; // check which becomes predictable based on a modeled peel or unswitch.; //; // The cost of doing so in the worst case is an extra fill from the stack in; // the loop to materialize the loop invariant test value instead of checking; // against the original IV which is presumable in a register inside the loop.; // Such cases are presumably rare, and hint at missing oppurtunities for; // other passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:762,Testability,log,logic,762,"// Handling expressions which produce invariant results, but *haven't* yet; // been removed from the loop serves two important purposes.; // 1) Most importantly, it resolves a pass ordering cycle which would; // otherwise need us to iteration licm, loop-predication, and either; // loop-unswitch or loop-peeling to make progress on examples with lots of; // predicable range checks in a row. (Since, in the general case, we can't; // hoist the length checks until the dominating checks have been discharged; // as we can't prove doing so is safe.); // 2) As a nice side effect, this exposes the value of peeling or unswitching; // much more obviously in the IR. Otherwise, the cost modeling for other; // transforms would end up needing to duplicate all of this logic to model a; // check which becomes predictable based on a modeled peel or unswitch.; //; // The cost of doing so in the worst case is an extra fill from the stack in; // the loop to materialize the loop invariant test value instead of checking; // against the original IV which is presumable in a register inside the loop.; // Such cases are presumably rare, and hint at missing oppurtunities for; // other passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:981,Testability,test,test,981,"// Handling expressions which produce invariant results, but *haven't* yet; // been removed from the loop serves two important purposes.; // 1) Most importantly, it resolves a pass ordering cycle which would; // otherwise need us to iteration licm, loop-predication, and either; // loop-unswitch or loop-peeling to make progress on examples with lots of; // predicable range checks in a row. (Since, in the general case, we can't; // hoist the length checks until the dominating checks have been discharged; // as we can't prove doing so is safe.); // 2) As a nice side effect, this exposes the value of peeling or unswitching; // much more obviously in the IR. Otherwise, the cost modeling for other; // transforms would end up needing to duplicate all of this logic to model a; // check which becomes predictable based on a modeled peel or unswitch.; //; // The cost of doing so in the worst case is an extra fill from the stack in; // the loop to materialize the loop invariant test value instead of checking; // against the original IV which is presumable in a register inside the loop.; // Such cases are presumably rare, and hint at missing oppurtunities for; // other passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:168,Integrability,depend,depends,168,// Generate the widened condition for the forward loop:; // guardStart u< guardLimit &&; // latchLimit <pred> guardLimit - 1 - guardStart + latchStart; // where <pred> depends on the latch condition predicate. See the file; // header comment for the reasoning.; // guardLimit - guardStart + latchStart - 1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:117,Safety,safe,safety,117,"// Subtlety: We need all the values to be *invariant* across all iterations,; // but we only need to check expansion safety for those which *aren't*; // already guaranteed to dominate the guard.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:117,Safety,safe,safety,117,"// Subtlety: We need all the values to be *invariant* across all iterations,; // but we only need to check expansion safety for those which *aren't*; // already guaranteed to dominate the guard.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:31,Testability,log,logic,31,"// At the moment, our matching logic for wideable conditions implicitly; // assumes we preserve the form: (br (and Cond, WC())). FIXME",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:168,Safety,predict,predict,168,// Walk back through any unconditional executed blocks and see if we can find; // a widenable condition which seems to control execution of this loop. Note; // that we predict that maythrow calls are likely untaken and thus that it's; // profitable to widen a branch before a maythrow call with a condition; // afterwards even though that may cause the slow path to run in a case where; // it wouldn't have otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:209,Usability,simpl,simplify,209,"/// This implements an analogous, but entirely distinct transform from the main; /// loop predication transform. This one is phrased in terms of using a; /// widenable branch *outside* the loop to allow us to simplify loop exits in a; /// following loop. This is close in spirit to the IndVarSimplify transform; /// of the same name, but is materially different widening loosens legality; /// sharply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:388,Availability,down,down,388,"// The transformation performed here aims to widen a widenable condition; // above the loop such that all analyzeable exit leading to deopt are dead.; // It assumes that the latch is the dominant exit for profitability and that; // exits branching to deoptimizing blocks are rarely taken. It relies on the; // semantics of widenable expressions for legality. (i.e. being able to fall; // down the widenable path spuriously allows us to ignore exit order,; // unanalyzeable exits, side effects, exceptional exits, and other challenges; // which restrict the applicability of the non-WC based version of this; // transform in IndVarSimplify.); //; // NOTE ON POISON/UNDEF - We're hoisting an expression above guards which may; // imply flags on the expression being hoisted and inserting new uses (flags; // are only correct for current uses). The result is that we may be; // inserting a branch on the value which can be either poison or undef. In; // this case, the branch can legally go either way; we just need to avoid; // introducing UB. This is achieved through the use of the freeze; // instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:22,Performance,perform,performed,22,"// The transformation performed here aims to widen a widenable condition; // above the loop such that all analyzeable exit leading to deopt are dead.; // It assumes that the latch is the dominant exit for profitability and that; // exits branching to deoptimizing blocks are rarely taken. It relies on the; // semantics of widenable expressions for legality. (i.e. being able to fall; // down the widenable path spuriously allows us to ignore exit order,; // unanalyzeable exits, side effects, exceptional exits, and other challenges; // which restrict the applicability of the non-WC based version of this; // transform in IndVarSimplify.); //; // NOTE ON POISON/UNDEF - We're hoisting an expression above guards which may; // imply flags on the expression being hoisted and inserting new uses (flags; // are only correct for current uses). The result is that we may be; // inserting a branch on the value which can be either poison or undef. In; // this case, the branch can legally go either way; we just need to avoid; // introducing UB. This is achieved through the use of the freeze; // instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:1016,Safety,avoid,avoid,1016,"// The transformation performed here aims to widen a widenable condition; // above the loop such that all analyzeable exit leading to deopt are dead.; // It assumes that the latch is the dominant exit for profitability and that; // exits branching to deoptimizing blocks are rarely taken. It relies on the; // semantics of widenable expressions for legality. (i.e. being able to fall; // down the widenable path spuriously allows us to ignore exit order,; // unanalyzeable exits, side effects, exceptional exits, and other challenges; // which restrict the applicability of the non-WC based version of this; // transform in IndVarSimplify.); //; // NOTE ON POISON/UNDEF - We're hoisting an expression above guards which may; // imply flags on the expression being hoisted and inserting new uses (flags; // are only correct for current uses). The result is that we may be; // inserting a branch on the value which can be either poison or undef. In; // this case, the branch can legally go either way; we just need to avoid; // introducing UB. This is achieved through the use of the freeze; // instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:336,Performance,perform,perform,336,"// profitability - want hot exit in analyzeable set; // At this point, we have found an analyzeable latch, and a widenable; // condition above the loop. If we have a widenable exit within the loop; // (for which we can't compute exit counts), drop the ability to further; // widen so that we gain ability to analyze it's exit count and perform this; // transform. TODO: It'd be nice to know for sure the exit became; // analyzeable after dropping widenability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:411,Safety,avoid,avoid,411,"// The use of umin(all analyzeable exits) instead of latch is subtle, but; // important for profitability. We may have a loop which hasn't been fully; // canonicalized just yet. If the exit we chose to widen is provably never; // taken, we want the widened form to *also* be provably never taken. We; // can't guarantee this as a current unanalyzeable exit may later become; // analyzeable, but we can at least avoid the obvious cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:58,Modifiability,rewrite,rewrite,58,"// If our exiting block exits multiple loops, we can only rewrite the; // innermost one. Otherwise, we're changing how many times the innermost; // loop runs before it exits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:9,Modifiability,rewrite,rewrite,9,// Can't rewrite non-branch yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:351,Safety,avoid,avoids,351,"/// Here we can be fairly sure that executing this exit will most likely; /// lead to executing llvm.experimental.deoptimize.; /// This is a profitability heuristic, not a legality constraint.; // If we found a widenable exit condition, do two things:; // 1) fold the widened exit test into the widenable condition; // 2) fold the branch to untaken - avoids infinite looping",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:281,Testability,test,test,281,"/// Here we can be fairly sure that executing this exit will most likely; /// lead to executing llvm.experimental.deoptimize.; /// This is a profitability heuristic, not a legality constraint.; // If we found a widenable exit condition, do two things:; // 1) fold the widened exit test into the widenable condition; // 2) fold the branch to untaken - avoids infinite looping",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:406,Usability,simpl,simple,406,"//===- LoopReroll.cpp - Loop rerolling pass -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements a simple loop reroller.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:16,Deployability,rolling,rolling,16,"// This loop re-rolling transformation aims to transform loops like this:; //; // int foo(int a);; // void bar(int *x) {; // for (int i = 0; i < 500; i += 3) {; // foo(i);; // foo(i+1);; // foo(i+2);; // }; // }; //; // into a loop like this:; //; // void bar(int *x) {; // for (int i = 0; i < 500; ++i); // foo(i);; // }; //; // It does this by looking for loops that, besides the latch code, are composed; // of isomorphic DAGs of instructions, with each DAG rooted at some increment; // to the induction variable, and where each DAG is isomorphic to the DAG; // rooted at the induction variable (excepting the sub-DAGs which root the; // other induction-variable increments). In other words, we're looking for loop; // bodies of the form:; //; // %iv = phi [ (preheader, ...), (body, %iv.next) ]; // f(%iv); // %iv.1 = add %iv, 1 <-- a root increment; // f(%iv.1); // %iv.2 = add %iv, 2 <-- a root increment; // f(%iv.2); // %iv.scale_m_1 = add %iv, scale-1 <-- a root increment; // f(%iv.scale_m_1); // ...; // %iv.next = add %iv, scale; // %cmp = icmp(%iv, ...); // br %cmp, header, exit; //; // where each f(i) is a set of instructions that, collectively, are a function; // only of i (and other loop-invariant values).; //; // As a special case, we can also reroll loops like this:; //; // int foo(int);; // void bar(int *x) {; // for (int i = 0; i < 500; ++i) {; // x[3*i] = foo(0);; // x[3*i+1] = foo(0);; // x[3*i+2] = foo(0);; // }; // }; //; // into this:; //; // void bar(int *x) {; // for (int i = 0; i < 1500; ++i); // x[i] = foo(0);; // }; //; // in which case, we're looking for inputs like this:; //; // %iv = phi [ (preheader, ...), (body, %iv.next) ]; // %scaled.iv = mul %iv, scale; // f(%scaled.iv); // %scaled.iv.1 = add %scaled.iv, 1; // f(%scaled.iv.1); // %scaled.iv.2 = add %scaled.iv, 2; // f(%scaled.iv.2); // %scaled.iv.scale_m_1 = add %scaled.iv, scale-1; // f(%scaled.iv.scale_m_1); // ...; // %iv.next = add %iv, 1; // %cmp = icmp(%iv, ...); // br %cmp, header, exit",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:507,Modifiability,variab,variable,507,"// This loop re-rolling transformation aims to transform loops like this:; //; // int foo(int a);; // void bar(int *x) {; // for (int i = 0; i < 500; i += 3) {; // foo(i);; // foo(i+1);; // foo(i+2);; // }; // }; //; // into a loop like this:; //; // void bar(int *x) {; // for (int i = 0; i < 500; ++i); // foo(i);; // }; //; // It does this by looking for loops that, besides the latch code, are composed; // of isomorphic DAGs of instructions, with each DAG rooted at some increment; // to the induction variable, and where each DAG is isomorphic to the DAG; // rooted at the induction variable (excepting the sub-DAGs which root the; // other induction-variable increments). In other words, we're looking for loop; // bodies of the form:; //; // %iv = phi [ (preheader, ...), (body, %iv.next) ]; // f(%iv); // %iv.1 = add %iv, 1 <-- a root increment; // f(%iv.1); // %iv.2 = add %iv, 2 <-- a root increment; // f(%iv.2); // %iv.scale_m_1 = add %iv, scale-1 <-- a root increment; // f(%iv.scale_m_1); // ...; // %iv.next = add %iv, scale; // %cmp = icmp(%iv, ...); // br %cmp, header, exit; //; // where each f(i) is a set of instructions that, collectively, are a function; // only of i (and other loop-invariant values).; //; // As a special case, we can also reroll loops like this:; //; // int foo(int);; // void bar(int *x) {; // for (int i = 0; i < 500; ++i) {; // x[3*i] = foo(0);; // x[3*i+1] = foo(0);; // x[3*i+2] = foo(0);; // }; // }; //; // into this:; //; // void bar(int *x) {; // for (int i = 0; i < 1500; ++i); // x[i] = foo(0);; // }; //; // in which case, we're looking for inputs like this:; //; // %iv = phi [ (preheader, ...), (body, %iv.next) ]; // %scaled.iv = mul %iv, scale; // f(%scaled.iv); // %scaled.iv.1 = add %scaled.iv, 1; // f(%scaled.iv.1); // %scaled.iv.2 = add %scaled.iv, 2; // f(%scaled.iv.2); // %scaled.iv.scale_m_1 = add %scaled.iv, scale-1; // f(%scaled.iv.scale_m_1); // ...; // %iv.next = add %iv, 1; // %cmp = icmp(%iv, ...); // br %cmp, header, exit",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:589,Modifiability,variab,variable,589,"// This loop re-rolling transformation aims to transform loops like this:; //; // int foo(int a);; // void bar(int *x) {; // for (int i = 0; i < 500; i += 3) {; // foo(i);; // foo(i+1);; // foo(i+2);; // }; // }; //; // into a loop like this:; //; // void bar(int *x) {; // for (int i = 0; i < 500; ++i); // foo(i);; // }; //; // It does this by looking for loops that, besides the latch code, are composed; // of isomorphic DAGs of instructions, with each DAG rooted at some increment; // to the induction variable, and where each DAG is isomorphic to the DAG; // rooted at the induction variable (excepting the sub-DAGs which root the; // other induction-variable increments). In other words, we're looking for loop; // bodies of the form:; //; // %iv = phi [ (preheader, ...), (body, %iv.next) ]; // f(%iv); // %iv.1 = add %iv, 1 <-- a root increment; // f(%iv.1); // %iv.2 = add %iv, 2 <-- a root increment; // f(%iv.2); // %iv.scale_m_1 = add %iv, scale-1 <-- a root increment; // f(%iv.scale_m_1); // ...; // %iv.next = add %iv, scale; // %cmp = icmp(%iv, ...); // br %cmp, header, exit; //; // where each f(i) is a set of instructions that, collectively, are a function; // only of i (and other loop-invariant values).; //; // As a special case, we can also reroll loops like this:; //; // int foo(int);; // void bar(int *x) {; // for (int i = 0; i < 500; ++i) {; // x[3*i] = foo(0);; // x[3*i+1] = foo(0);; // x[3*i+2] = foo(0);; // }; // }; //; // into this:; //; // void bar(int *x) {; // for (int i = 0; i < 1500; ++i); // x[i] = foo(0);; // }; //; // in which case, we're looking for inputs like this:; //; // %iv = phi [ (preheader, ...), (body, %iv.next) ]; // %scaled.iv = mul %iv, scale; // f(%scaled.iv); // %scaled.iv.1 = add %scaled.iv, 1; // f(%scaled.iv.1); // %scaled.iv.2 = add %scaled.iv, 2; // f(%scaled.iv.2); // %scaled.iv.scale_m_1 = add %scaled.iv, scale-1; // f(%scaled.iv.scale_m_1); // ...; // %iv.next = add %iv, 1; // %cmp = icmp(%iv, ...); // br %cmp, header, exit",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:657,Modifiability,variab,variable,657,"// This loop re-rolling transformation aims to transform loops like this:; //; // int foo(int a);; // void bar(int *x) {; // for (int i = 0; i < 500; i += 3) {; // foo(i);; // foo(i+1);; // foo(i+2);; // }; // }; //; // into a loop like this:; //; // void bar(int *x) {; // for (int i = 0; i < 500; ++i); // foo(i);; // }; //; // It does this by looking for loops that, besides the latch code, are composed; // of isomorphic DAGs of instructions, with each DAG rooted at some increment; // to the induction variable, and where each DAG is isomorphic to the DAG; // rooted at the induction variable (excepting the sub-DAGs which root the; // other induction-variable increments). In other words, we're looking for loop; // bodies of the form:; //; // %iv = phi [ (preheader, ...), (body, %iv.next) ]; // f(%iv); // %iv.1 = add %iv, 1 <-- a root increment; // f(%iv.1); // %iv.2 = add %iv, 2 <-- a root increment; // f(%iv.2); // %iv.scale_m_1 = add %iv, scale-1 <-- a root increment; // f(%iv.scale_m_1); // ...; // %iv.next = add %iv, scale; // %cmp = icmp(%iv, ...); // br %cmp, header, exit; //; // where each f(i) is a set of instructions that, collectively, are a function; // only of i (and other loop-invariant values).; //; // As a special case, we can also reroll loops like this:; //; // int foo(int);; // void bar(int *x) {; // for (int i = 0; i < 500; ++i) {; // x[3*i] = foo(0);; // x[3*i+1] = foo(0);; // x[3*i+2] = foo(0);; // }; // }; //; // into this:; //; // void bar(int *x) {; // for (int i = 0; i < 1500; ++i); // x[i] = foo(0);; // }; //; // in which case, we're looking for inputs like this:; //; // %iv = phi [ (preheader, ...), (body, %iv.next) ]; // %scaled.iv = mul %iv, scale; // f(%scaled.iv); // %scaled.iv.1 = add %scaled.iv, 1; // f(%scaled.iv.1); // %scaled.iv.2 = add %scaled.iv, 2; // f(%scaled.iv.2); // %scaled.iv.scale_m_1 = add %scaled.iv, scale-1; // f(%scaled.iv.scale_m_1); // ...; // %iv.next = add %iv, 1; // %cmp = icmp(%iv, ...); // br %cmp, header, exit",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:47,Modifiability,variab,variables,47,/// The bitvector index used by loop induction variables and other; /// instructions that belong to all iterations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:25,Modifiability,variab,variable,25,// Map between induction variable and its increment,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:36,Modifiability,variab,variables,36,"// For loop with multiple induction variables, remember the ones used only to; // control the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:368,Energy Efficiency,reduce,reduced,368,// Setup to track possible reductions corresponding to the provided; // rerolling scale. Only reductions with a number of non-PHI instructions; // that is divisible by the scale are considered. Three instructions sets; // are filled in:; // - A set of all possible instructions in eligible reductions.; // - A set of all PHIs in eligible reductions; // - A set of all reduced values (last instructions) in eligible; // reductions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:36,Modifiability,variab,variable,36,"// A DAGRootSet models an induction variable being used in a rerollable; // loop. For example,; //; // x[i*3+0] = y1; // x[i*3+1] = y2; // x[i*3+2] = y3; //; // Base instruction -> i*3; // +---+----+; // / | \; // ST[y1] +1 +2 <-- Roots; // | |; // ST[y2] ST[y3]; //; // There may be multiple DAGRoots, for example:; //; // x[i*2+0] = ... (1); // x[i*2+1] = ... (1); // x[i*2+4] = ... (2); // x[i*2+5] = ... (2); // x[(i+1234)*2+5678] = ... (3); // x[(i+1234)*2+5679] = ... (3); //; // The loop will be rerolled by adding a new loop induction variable,; // one for the Base instruction in each DAGRootSet.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:543,Modifiability,variab,variable,543,"// A DAGRootSet models an induction variable being used in a rerollable; // loop. For example,; //; // x[i*3+0] = y1; // x[i*3+1] = y2; // x[i*3+2] = y3; //; // Base instruction -> i*3; // +---+----+; // / | \; // ST[y1] +1 +2 <-- Roots; // | |; // ST[y2] ST[y3]; //; // There may be multiple DAGRoots, for example:; //; // x[i*2+0] = ... (1); // x[i*2+1] = ... (1); // x[i*2+4] = ... (2); // x[i*2+5] = ... (2); // x[(i+1234)*2+5678] = ... (3); // x[(i+1234)*2+5679] = ... (3); //; // The loop will be rerolled by adding a new loop induction variable,; // one for the Base instruction in each DAGRootSet.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:92,Modifiability,variab,variable,92,"// The set of all DAG roots, and state tracking of all roots; // for a particular induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:54,Modifiability,variab,variable,54,/// Stage 1: Find all the DAG roots for the induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:13,Security,Validat,Validate,13,/// Stage 2: Validate if the found roots are valid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:48,Performance,perform,perform,48,"/// Stage 3: Assuming validate() returned true, perform the; /// replacement.; /// @param BackedgeTakenCount The backedge-taken count of L.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:22,Security,validat,validate,22,"/// Stage 3: Assuming validate() returned true, perform the; /// replacement.; /// @param BackedgeTakenCount The backedge-taken count of L.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:22,Modifiability,variab,variable,22,// The loop induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:25,Modifiability,variab,variable,25,// Map between induction variable and its increment,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:23,Modifiability,extend,extending,23,// Skip SExt if we are extending an nsw value; // TODO: Allow ZExt too,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:38,Modifiability,variab,variables,38,// Collect the list of loop induction variables with respect to which it might; // be possible to reroll the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:38,Modifiability,variab,variable,38,"// Add the remainder of the reduction-variable chain to the instruction vector; // (the initial PHINode has already been added). If successful, the object is; // marked as valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:17,Modifiability,variab,variable,17,"// The reduction variable must be a chain of single-use instructions; // (including the PHI), except for the last value (which is used by the PHI; // and also outside the loop).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:44,Modifiability,variab,variables,44,// Collect the vector of possible reduction variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:637,Deployability,update,update,637,"// Collect the set of all users of the provided root instruction. This set of; // users contains not only the direct users of the root instruction, but also; // all users of those users, and so on. There are two exceptions:; //; // 1. Instructions in the set of excluded instructions are never added to the; // use set (even if they are users). This is used, for example, to exclude; // including root increments in the use set of the primary IV.; //; // 2. Instructions in the set of final instructions are added to the use set; // if they are users, but their users are not added. This is used, for; // example, to prevent a reduction update from forcing all later reduction; // updates into the use set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:681,Deployability,update,updates,681,"// Collect the set of all users of the provided root instruction. This set of; // users contains not only the direct users of the root instruction, but also; // all users of those users, and so on. There are two exceptions:; //; // 1. Instructions in the set of excluded instructions are never added to the; // use set (even if they are users). This is used, for example, to exclude; // including root increments in the use set of the primary IV.; //; // 2. Instructions in the set of final instructions are added to the use set; // if they are users, but their users are not added. This is used, for; // example, to prevent a reduction update from forcing all later reduction; // updates into the use set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:11,Integrability,wrap,wrap-around,11,"// Ignore ""wrap-around"" uses to PHIs of this loop's header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:29,Usability,simpl,simple,29,"/// Return true if IVU is a ""simple"" arithmetic operation.; /// This is used for narrowing the search space for DAGRoots; only arithmetic; /// and GEPs can be part of a DAGRoot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:133,Performance,optimiz,optimized,133,"// If we found non-loop-inc, non-root users of Base, assume they are; // for the zeroth root index. This is because ""add %a, 0"" gets optimized; // away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:85,Usability,simpl,simple,85,// Does the user look like it could be part of a root set?; // All its users must be simple arithmetic ops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:33,Integrability,depend,depends,33,/// Return true if instruction I depends on any instruction between; /// Start and End.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:884,Availability,down,down,884,"// We now need to check for equivalence of the use graph of each root with; // that of the primary induction variable (excluding the roots). Our goal; // here is not to solve the full graph isomorphism problem, but rather to; // catch common cases without a lot of work. As a result, we will assume; // that the relative order of the instructions in each unrolled iteration; // is the same (although we will not make an assumption about how the; // different iterations are intermixed). Note that while the order must be; // the same, the instructions may not be in the same basic block.; // An array of just the possible reductions for this scale factor. When we; // collect the set of all users of some root instructions, these reduction; // instructions are treated as 'final' (their uses are not considered).; // This is important because we don't want the root use set to search down; // the reduction chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:109,Modifiability,variab,variable,109,"// We now need to check for equivalence of the use graph of each root with; // that of the primary induction variable (excluding the roots). Our goal; // here is not to solve the full graph isomorphism problem, but rather to; // catch common cases without a lot of work. As a result, we will assume; // that the relative order of the instructions in each unrolled iteration; // is the same (although we will not make an assumption about how the; // different iterations are intermixed). Note that while the order must be; // the same, the instructions may not be in the same basic block.; // An array of just the possible reductions for this scale factor. When we; // collect the set of all users of some root instructions, these reduction; // instructions are treated as 'final' (their uses are not considered).; // This is important because we don't want the root use set to search down; // the reduction chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:213,Energy Efficiency,efficient,efficiently,213,"// Last chance saloon. We don't try and solve the full isomorphism; // problem, but try and at least catch the case where two instructions; // *of different types* are round the wrong way. We won't be able to; // efficiently tell, given two ADD instructions, which way around we; // should match them, but given an ADD and a SUB, we can at least infer; // which one is which.; //; // This should allow us to deal with a greater subset of the isomorphism; // problem. It does however change a linear algorithm into a quadratic; // one, so limit the number of probes we do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:117,Performance,optimiz,optimization,117,"// Note: This is specifically guarded by a check on isa<PHINode>,; // which while a valid (somewhat arbitrary) micro-optimization, is; // needed because otherwise isSafeToSpeculativelyExecute returns; // false on PHI nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:102,Integrability,depend,depend,102,"// Make sure that we don't alias with any instruction in the alias set; // tracker. If we do, then we depend on a future iteration, and we; // can't reroll.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:271,Integrability,depend,dependencies,271,"// If we've past an instruction from a future iteration that may have; // side effects, and this instruction might also, then we can't reorder; // them, and this matching fails. As an exception, we allow the alias; // set tracker to handle regular (unordered) load/store dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:260,Performance,load,load,260,"// If we've past an instruction from a future iteration that may have; // side effects, and this instruction might also, then we can't reorder; // them, and this matching fails. As an exception, we allow the alias; // set tracker to handle regular (unordered) load/store dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite each BaseInst using SCEV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:28,Modifiability,variab,variable,28,// Insert the new induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:3,Security,Validat,Validate,3,"// Validate the selected reductions. All iterations must have an isomorphic; // part of the reduction chain and, for non-associative reductions, the chain; // entries must appear in order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:132,Energy Efficiency,reduce,reduced,132,"// For all selected reductions, remove all parts except those in the first; // iteration (and the PHI). Replace outside uses of the reduced value with uses; // of the first-iteration reduced value (in other words, reroll the selected; // reductions).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:183,Energy Efficiency,reduce,reduced,183,"// For all selected reductions, remove all parts except those in the first; // iteration (and the PHI). Replace outside uses of the reduced value with uses; // of the first-iteration reduced value (in other words, reroll the selected; // reductions).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:1591,Integrability,depend,dependency,1591," <-- a root increment; // f(%iv.1); // %iv.2 = add %iv, 2 <-- a root increment; // f(%iv.2); // %iv.scale_m_1 = add %iv, scale-1 <-- a root increment; // f(%iv.scale_m_1); // ...; // %iv.next = add %iv, scale; // %cmp = icmp(%iv, ...); // br %cmp, header, exit; //; // Notably, we do not require that f(%iv), f(%iv.1), etc. be isolated groups of; // instructions. In other words, the instructions in f(%iv), f(%iv.1), etc. can; // be intermixed with eachother. The restriction imposed by this algorithm is; // that the relative order of the isomorphic instructions in f(%iv), f(%iv.1),; // etc. be the same.; //; // First, we collect the use set of %iv, excluding the other increment roots.; // This gives us f(%iv). Then we iterate over the loop instructions (scale-1); // times, having collected the use set of f(%iv.(i+1)), during which we:; // - Ensure that the next unmatched instruction in f(%iv) is isomorphic to; // the next unmatched instruction in f(%iv.(i+1)).; // - Ensure that both matched instructions don't have any external users; // (with the exception of last-in-chain reduction instructions).; // - Track the (aliasing) write set, and other side effects, of all; // instructions that belong to future iterations that come before the matched; // instructions. If the matched instructions read from that write set, then; // f(%iv) or f(%iv.(i+1)) has some dependency on instructions in; // f(%iv.(j+1)) for some j > i, and we cannot reroll the loop. Similarly,; // if any of these future instructions had side effects (could not be; // speculatively executed), and so do the matched instructions, when we; // cannot reorder those side-effect-producing instructions, and rerolling; // fails.; //; // Finally, we make sure that all loop instructions are either loop increment; // roots, belong to simple latch code, parts of validated reductions, part of; // f(%iv) or part of some f(%iv.i). If all of that is true (and all reductions; // have been validated), then we reroll the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:67,Modifiability,variab,variable,67,"// Reroll the provided loop with respect to the provided induction variable.; // Generally, we're looking for a loop like this:; //; // %iv = phi [ (preheader, ...), (body, %iv.next) ]; // f(%iv); // %iv.1 = add %iv, 1 <-- a root increment; // f(%iv.1); // %iv.2 = add %iv, 2 <-- a root increment; // f(%iv.2); // %iv.scale_m_1 = add %iv, scale-1 <-- a root increment; // f(%iv.scale_m_1); // ...; // %iv.next = add %iv, scale; // %cmp = icmp(%iv, ...); // br %cmp, header, exit; //; // Notably, we do not require that f(%iv), f(%iv.1), etc. be isolated groups of; // instructions. In other words, the instructions in f(%iv), f(%iv.1), etc. can; // be intermixed with eachother. The restriction imposed by this algorithm is; // that the relative order of the isomorphic instructions in f(%iv), f(%iv.1),; // etc. be the same.; //; // First, we collect the use set of %iv, excluding the other increment roots.; // This gives us f(%iv). Then we iterate over the loop instructions (scale-1); // times, having collected the use set of f(%iv.(i+1)), during which we:; // - Ensure that the next unmatched instruction in f(%iv) is isomorphic to; // the next unmatched instruction in f(%iv.(i+1)).; // - Ensure that both matched instructions don't have any external users; // (with the exception of last-in-chain reduction instructions).; // - Track the (aliasing) write set, and other side effects, of all; // instructions that belong to future iterations that come before the matched; // instructions. If the matched instructions read from that write set, then; // f(%iv) or f(%iv.(i+1)) has some dependency on instructions in; // f(%iv.(j+1)) for some j > i, and we cannot reroll the loop. Similarly,; // if any of these future instructions had side effects (could not be; // speculatively executed), and so do the matched instructions, when we; // cannot reorder those side-effect-producing instructions, and rerolling; // fails.; //; // Finally, we make sure that all loop instructions are either loop in",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:2058,Security,validat,validated,2058," <-- a root increment; // f(%iv.1); // %iv.2 = add %iv, 2 <-- a root increment; // f(%iv.2); // %iv.scale_m_1 = add %iv, scale-1 <-- a root increment; // f(%iv.scale_m_1); // ...; // %iv.next = add %iv, scale; // %cmp = icmp(%iv, ...); // br %cmp, header, exit; //; // Notably, we do not require that f(%iv), f(%iv.1), etc. be isolated groups of; // instructions. In other words, the instructions in f(%iv), f(%iv.1), etc. can; // be intermixed with eachother. The restriction imposed by this algorithm is; // that the relative order of the isomorphic instructions in f(%iv), f(%iv.1),; // etc. be the same.; //; // First, we collect the use set of %iv, excluding the other increment roots.; // This gives us f(%iv). Then we iterate over the loop instructions (scale-1); // times, having collected the use set of f(%iv.(i+1)), during which we:; // - Ensure that the next unmatched instruction in f(%iv) is isomorphic to; // the next unmatched instruction in f(%iv.(i+1)).; // - Ensure that both matched instructions don't have any external users; // (with the exception of last-in-chain reduction instructions).; // - Track the (aliasing) write set, and other side effects, of all; // instructions that belong to future iterations that come before the matched; // instructions. If the matched instructions read from that write set, then; // f(%iv) or f(%iv.(i+1)) has some dependency on instructions in; // f(%iv.(j+1)) for some j > i, and we cannot reroll the loop. Similarly,; // if any of these future instructions had side effects (could not be; // speculatively executed), and so do the matched instructions, when we; // cannot reorder those side-effect-producing instructions, and rerolling; // fails.; //; // Finally, we make sure that all loop instructions are either loop increment; // roots, belong to simple latch code, parts of validated reductions, part of; // f(%iv) or part of some f(%iv.i). If all of that is true (and all reductions; // have been validated), then we reroll the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:2182,Security,validat,validated,2182," <-- a root increment; // f(%iv.1); // %iv.2 = add %iv, 2 <-- a root increment; // f(%iv.2); // %iv.scale_m_1 = add %iv, scale-1 <-- a root increment; // f(%iv.scale_m_1); // ...; // %iv.next = add %iv, scale; // %cmp = icmp(%iv, ...); // br %cmp, header, exit; //; // Notably, we do not require that f(%iv), f(%iv.1), etc. be isolated groups of; // instructions. In other words, the instructions in f(%iv), f(%iv.1), etc. can; // be intermixed with eachother. The restriction imposed by this algorithm is; // that the relative order of the isomorphic instructions in f(%iv), f(%iv.1),; // etc. be the same.; //; // First, we collect the use set of %iv, excluding the other increment roots.; // This gives us f(%iv). Then we iterate over the loop instructions (scale-1); // times, having collected the use set of f(%iv.(i+1)), during which we:; // - Ensure that the next unmatched instruction in f(%iv) is isomorphic to; // the next unmatched instruction in f(%iv.(i+1)).; // - Ensure that both matched instructions don't have any external users; // (with the exception of last-in-chain reduction instructions).; // - Track the (aliasing) write set, and other side effects, of all; // instructions that belong to future iterations that come before the matched; // instructions. If the matched instructions read from that write set, then; // f(%iv) or f(%iv.(i+1)) has some dependency on instructions in; // f(%iv.(j+1)) for some j > i, and we cannot reroll the loop. Similarly,; // if any of these future instructions had side effects (could not be; // speculatively executed), and so do the matched instructions, when we; // cannot reorder those side-effect-producing instructions, and rerolling; // fails.; //; // Finally, we make sure that all loop instructions are either loop increment; // roots, belong to simple latch code, parts of validated reductions, part of; // f(%iv) or part of some f(%iv.i). If all of that is true (and all reductions; // have been validated), then we reroll the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:2030,Usability,simpl,simple,2030," <-- a root increment; // f(%iv.1); // %iv.2 = add %iv, 2 <-- a root increment; // f(%iv.2); // %iv.scale_m_1 = add %iv, scale-1 <-- a root increment; // f(%iv.scale_m_1); // ...; // %iv.next = add %iv, scale; // %cmp = icmp(%iv, ...); // br %cmp, header, exit; //; // Notably, we do not require that f(%iv), f(%iv.1), etc. be isolated groups of; // instructions. In other words, the instructions in f(%iv), f(%iv.1), etc. can; // be intermixed with eachother. The restriction imposed by this algorithm is; // that the relative order of the isomorphic instructions in f(%iv), f(%iv.1),; // etc. be the same.; //; // First, we collect the use set of %iv, excluding the other increment roots.; // This gives us f(%iv). Then we iterate over the loop instructions (scale-1); // times, having collected the use set of f(%iv.(i+1)), during which we:; // - Ensure that the next unmatched instruction in f(%iv) is isomorphic to; // the next unmatched instruction in f(%iv.(i+1)).; // - Ensure that both matched instructions don't have any external users; // (with the exception of last-in-chain reduction instructions).; // - Track the (aliasing) write set, and other side effects, of all; // instructions that belong to future iterations that come before the matched; // instructions. If the matched instructions read from that write set, then; // f(%iv) or f(%iv.(i+1)) has some dependency on instructions in; // f(%iv.(j+1)) for some j > i, and we cannot reroll the loop. Similarly,; // if any of these future instructions had side effects (could not be; // speculatively executed), and so do the matched instructions, when we; // cannot reorder those side-effect-producing instructions, and rerolling; // fails.; //; // Finally, we make sure that all loop instructions are either loop increment; // roots, belong to simple latch code, parts of validated reductions, part of; // f(%iv) or part of some f(%iv.i). If all of that is true (and all reductions; // have been validated), then we reroll the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:24,Security,validat,validated,24,"// At this point, we've validated the rerolling, and we're committed to; // making changes!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:40,Modifiability,variab,variable,40,"// First, we need to find the induction variable with respect to which we can; // reroll (there may be several possible options).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRotation.cpp:50,Availability,avail,available,50,// Not requiring MemorySSA and getting it only if available will split; // the loop pass pipeline when LoopRotate is being run first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRotation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRotation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRotation.cpp:89,Deployability,pipeline,pipeline,89,// Not requiring MemorySSA and getting it only if available will split; // the loop pass pipeline when LoopRotate is being run first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRotation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRotation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:614,Performance,perform,perform,614,"//===--------- LoopSimplifyCFG.cpp - Loop CFG Simplification Pass ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Loop SimplifyCFG Pass. This pass is responsible for; // basic loop CFG cleanup, primarily to assist other loop passes. If you; // encounter a noncanonical CFG construct that causes another loop pass to; // perform suboptimally, this is the place to fix it up.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:46,Usability,Simpl,Simplification,46,"//===--------- LoopSimplifyCFG.cpp - Loop CFG Simplification Pass ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Loop SimplifyCFG Pass. This pass is responsible for; // basic loop CFG cleanup, primarily to assist other loop passes. If you; // encounter a noncanonical CFG construct that causes another loop pass to; // perform suboptimally, this is the place to fix it up.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:413,Usability,Simpl,SimplifyCFG,413,"//===--------- LoopSimplifyCFG.cpp - Loop CFG Simplification Pass ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Loop SimplifyCFG Pass. This pass is responsible for; // basic loop CFG cleanup, primarily to assist other loop passes. If you; // encounter a noncanonical CFG construct that causes another loop pass to; // perform suboptimally, this is the place to fix it up.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:465,Modifiability,variab,variable,465,"// Whether or not the current loop will still exist after terminator constant; // folding will be done. In theory, there are two ways how it can happen:; // 1. Loop's latch(es) become unreachable from loop header;; // 2. Loop's header becomes unreachable from method entry.; // In practice, the second situation is impossible because we only modify the; // current loop and its preheader and do not affect preheader's reachibility; // from any other block. So this variable set to true means that loop's latch; // has become unreachable from loop header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:176,Deployability,update,updates,176,// The blocks that have terminators with constant condition that can be; // folded. Note: fold candidates should be in L but not in any of its; // subloops to avoid complex LI updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:159,Safety,avoid,avoid,159,// The blocks that have terminators with constant condition that can be; // folded. Note: fold candidates should be in L but not in any of its; // subloops to avoid complex LI updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:176,Usability,simpl,simplify,176,"// Now, all exit blocks that are not marked as live are dead, if all their; // predecessors are in the loop. This may not be the case, as the input loop; // may not by in loop-simplify/canonical form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:482,Safety,avoid,avoid,482,"/// We need to preserve static reachibility of all loop exit blocks (this is); /// required by loop pass manager. In order to do it, we make the following; /// trick:; ///; /// preheader:; /// <preheader code>; /// br label %loop_header; ///; /// loop_header:; /// ...; /// br i1 false, label %dead_exit, label %loop_block; /// ...; ///; /// We cannot simply remove edge from the loop to dead exit because in this; /// case dead_exit (and its successors) may become unreachable. To avoid that,; /// we insert the following fictive preheader:; ///; /// preheader:; /// <preheader code>; /// switch i32 0, label %preheader-split,; /// [i32 1, label %dead_exit_1],; /// [i32 2, label %dead_exit_2],; /// ...; /// [i32 N, label %dead_exit_N],; ///; /// preheader-split:; /// br label %loop_header; ///; /// loop_header:; /// ...; /// br i1 false, label %dead_exit_N, label %loop_block; /// ...; ///; /// Doing so, we preserve static reachibility of all dead exits and can later; /// remove edges from the loop to these blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:352,Usability,simpl,simply,352,"/// We need to preserve static reachibility of all loop exit blocks (this is); /// required by loop pass manager. In order to do it, we make the following; /// trick:; ///; /// preheader:; /// <preheader code>; /// br label %loop_header; ///; /// loop_header:; /// ...; /// br i1 false, label %dead_exit, label %loop_block; /// ...; ///; /// We cannot simply remove edge from the loop to dead exit because in this; /// case dead_exit (and its successors) may become unreachable. To avoid that,; /// we insert the following fictive preheader:; ///; /// preheader:; /// <preheader code>; /// switch i32 0, label %preheader-split,; /// [i32 1, label %dead_exit_1],; /// [i32 2, label %dead_exit_2],; /// ...; /// [i32 N, label %dead_exit_N],; ///; /// preheader-split:; /// br label %loop_header; ///; /// loop_header:; /// ...; /// br i1 false, label %dead_exit_N, label %loop_block; /// ...; ///; /// Doing so, we preserve static reachibility of all dead exits and can later; /// remove edges from the loop to these blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:18,Deployability,update,updates,18,// We need all DT updates to be done before forming LCSSA.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:2,Deployability,Update,UpdateDT,2,/*UpdateDT=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:13,Deployability,update,updates,13,// Clear all updates now. Facilitates deletes that follow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:3,Usability,Clear,Clear,3,// Clear all updates now. Facilitates deletes that follow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:2,Deployability,Update,UpdateDT,2,/*UpdateDT=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:90,Deployability,update,updates,90,/// Delete loop blocks that have become unreachable after folding. Make all; /// relevant updates to DT and LI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:116,Availability,redundant,redundant,116,"// If TheOnlySucc was BB's successor more than once, after transform it; // will be its successor only once. Remove redundant inputs from; // TheOnlySucc's Phis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:116,Safety,redund,redundant,116,"// If TheOnlySucc was BB's successor more than once, after transform it; // will be its successor only once. Remove redundant inputs from; // TheOnlySucc's Phis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:15,Availability,avail,available,15,// Collect all available information about status of blocks after constant; // folding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:19,Deployability,update,updates,19,"// If we didn't do updates inside deleteDeadLoopBlocks, do them here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:18,Usability,simpl,simple,18,"// To keep things simple, only process loops with single latch. We; // canonicalize most loops to this form. We can support multi-latch if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:41,Safety,avoid,avoid,41,// Copy blocks into a temporary array to avoid iterator invalidation issues; // as we remove them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp:1097,Safety,avoid,avoid,1097,"/// Return a set of basic blocks to insert sinked instructions.; ///; /// The returned set of basic blocks (BBsToSinkInto) should satisfy:; ///; /// * Inside the loop \p L; /// * For each UseBB in \p UseBBs, there is at least one BB in BBsToSinkInto; /// that domintates the UseBB; /// * Has minimum total frequency that is no greater than preheader frequency; ///; /// The purpose of the function is to find the optimal sinking points to; /// minimize execution cost, which is defined as ""sum of frequency of; /// BBsToSinkInto"".; /// As a result, the returned BBsToSinkInto needs to have minimum total; /// frequency.; /// Additionally, if the total frequency of BBsToSinkInto exceeds preheader; /// frequency, the optimal solution is not sinking (return empty set).; ///; /// \p ColdLoopBBs is used to help find the optimal sinking locations.; /// It stores a list of BBs that is:; ///; /// * Inside the loop \p L; /// * Has a frequency no larger than the loop's preheader; /// * Sorted by BB frequency; ///; /// The complexity of the function is O(UseBBs.size() * ColdLoopBBs.size()).; /// To avoid expensive computation, we cap the maximum UseBBs.size() in its; /// caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp:93,Safety,avoid,avoid,93,// findBBsToSinkInto is O(BBs.size() * ColdLoopBBs.size()). We cap the max; // BBs.size() to avoid expensive computation.; // FIXME: Handle code size growth for min_size and opt_size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp:10,Performance,Optimiz,Optimize,10,// FIXME: Optimize the efficiency for cloned value replacement. The current; // implementation is O(SortedBBsToSinkInto.size() * I.num_uses()).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp:64,Security,access,access,64,// Create a new MemoryAccess and let MemorySSA set its defining access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp:88,Safety,avoid,avoid,88,// If there are no basic blocks with lower frequency than the preheader then; // we can avoid the detailed analysis as we will never find profitable sinking; // opportunities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp:67,Integrability,depend,depends,67,"// Traverse preheader's instructions in reverse order because if A depends; // on B (A appears after B), A needs to be sunk first before B can be; // sinked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp:48,Availability,avail,available,48,"// Enable LoopSink only when runtime profile is available.; // With static profile, the sinking decision may be sub-optimal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:797,Availability,avail,available,797,"//===- LoopStrengthReduce.cpp - Strength Reduce IVs in Loops --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into forms suitable for efficient execution; // on the target.; //; // This pass performs a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; // Terminology note: this code has a lot of handling for ""post-increment"" or; // ""post-inc"" users. This is not talking about post-increment addressing modes;; // it is instead talking about code like this:; //; // %i = phi [ 0, %entry ], [ %i.next, %latch ]; // ...; // %i.next = add %i, 1; // %c = icmp eq %i.next, %n; //; // The SCEV for %i is {0,+,1}<%L>. The SCEV for %i.next is {1,+,1}<%L>, however; // it's useful to think about these as the same register, with some uses using; // the value of the register before the add and some using it after. In this; // example, the icmp is a post-increment user, since it uses %i.next, which is; // the value of the induction variable after the increment. The other common; // case of post-increment users is users outside the loop.; //; // TODO: More sophistication in the way Formulae are generated and filtered.; //; // TODO: Handle multiple loops at a time.; //; // TODO: Should the addressing mode BaseGV be changed to a ConstantExpr instead; // of a GlobalValue?; //; // TODO: When truncation is free, truncate ICmp users' operands",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:41,Energy Efficiency,Reduce,Reduce,41,"//===- LoopStrengthReduce.cpp - Strength Reduce IVs in Loops --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into forms suitable for efficient execution; // on the target.; //; // This pass performs a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; // Terminology note: this code has a lot of handling for ""post-increment"" or; // ""post-inc"" users. This is not talking about post-increment addressing modes;; // it is instead talking about code like this:; //; // %i = phi [ 0, %entry ], [ %i.next, %latch ]; // ...; // %i.next = add %i, 1; // %c = icmp eq %i.next, %n; //; // The SCEV for %i is {0,+,1}<%L>. The SCEV for %i.next is {1,+,1}<%L>, however; // it's useful to think about these as the same register, with some uses using; // the value of the register before the add and some using it after. In this; // example, the icmp is a post-increment user, since it uses %i.next, which is; // the value of the induction variable after the increment. The other common; // case of post-increment users is users outside the loop.; //; // TODO: More sophistication in the way Formulae are generated and filtered.; //; // TODO: Handle multiple loops at a time.; //; // TODO: Should the addressing mode BaseGV be changed to a ConstantExpr instead; // of a GlobalValue?; //; // TODO: When truncation is free, truncate ICmp users' operands",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:516,Energy Efficiency,efficient,efficient,516,"//===- LoopStrengthReduce.cpp - Strength Reduce IVs in Loops --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into forms suitable for efficient execution; // on the target.; //; // This pass performs a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; // Terminology note: this code has a lot of handling for ""post-increment"" or; // ""post-inc"" users. This is not talking about post-increment addressing modes;; // it is instead talking about code like this:; //; // %i = phi [ 0, %entry ], [ %i.next, %latch ]; // ...; // %i.next = add %i, 1; // %c = icmp eq %i.next, %n; //; // The SCEV for %i is {0,+,1}<%L>. The SCEV for %i.next is {1,+,1}<%L>, however; // it's useful to think about these as the same register, with some uses using; // the value of the register before the add and some using it after. In this; // example, the icmp is a post-increment user, since it uses %i.next, which is; // the value of the induction variable after the increment. The other common; // case of post-increment users is users outside the loop.; //; // TODO: More sophistication in the way Formulae are generated and filtered.; //; // TODO: Handle multiple loops at a time.; //; // TODO: Should the addressing mode BaseGV be changed to a ConstantExpr instead; // of a GlobalValue?; //; // TODO: When truncation is free, truncate ICmp users' operands",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:441,Modifiability,variab,variables,441,"//===- LoopStrengthReduce.cpp - Strength Reduce IVs in Loops --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into forms suitable for efficient execution; // on the target.; //; // This pass performs a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; // Terminology note: this code has a lot of handling for ""post-increment"" or; // ""post-inc"" users. This is not talking about post-increment addressing modes;; // it is instead talking about code like this:; //; // %i = phi [ 0, %entry ], [ %i.next, %latch ]; // ...; // %i.next = add %i, 1; // %c = icmp eq %i.next, %n; //; // The SCEV for %i is {0,+,1}<%L>. The SCEV for %i.next is {1,+,1}<%L>, however; // it's useful to think about these as the same register, with some uses using; // the value of the register before the add and some using it after. In this; // example, the icmp is a post-increment user, since it uses %i.next, which is; // the value of the induction variable after the increment. The other common; // case of post-increment users is users outside the loop.; //; // TODO: More sophistication in the way Formulae are generated and filtered.; //; // TODO: Handle multiple loops at a time.; //; // TODO: Should the addressing mode BaseGV be changed to a ConstantExpr instead; // of a GlobalValue?; //; // TODO: When truncation is free, truncate ICmp users' operands",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:704,Modifiability,variab,variable,704,"//===- LoopStrengthReduce.cpp - Strength Reduce IVs in Loops --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into forms suitable for efficient execution; // on the target.; //; // This pass performs a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; // Terminology note: this code has a lot of handling for ""post-increment"" or; // ""post-inc"" users. This is not talking about post-increment addressing modes;; // it is instead talking about code like this:; //; // %i = phi [ 0, %entry ], [ %i.next, %latch ]; // ...; // %i.next = add %i, 1; // %c = icmp eq %i.next, %n; //; // The SCEV for %i is {0,+,1}<%L>. The SCEV for %i.next is {1,+,1}<%L>, however; // it's useful to think about these as the same register, with some uses using; // the value of the register before the add and some using it after. In this; // example, the icmp is a post-increment user, since it uses %i.next, which is; // the value of the induction variable after the increment. The other common; // case of post-increment users is users outside the loop.; //; // TODO: More sophistication in the way Formulae are generated and filtered.; //; // TODO: Handle multiple loops at a time.; //; // TODO: Should the addressing mode BaseGV be changed to a ConstantExpr instead; // of a GlobalValue?; //; // TODO: When truncation is free, truncate ICmp users' operands",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:721,Modifiability,rewrite,rewrites,721,"//===- LoopStrengthReduce.cpp - Strength Reduce IVs in Loops --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into forms suitable for efficient execution; // on the target.; //; // This pass performs a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; // Terminology note: this code has a lot of handling for ""post-increment"" or; // ""post-inc"" users. This is not talking about post-increment addressing modes;; // it is instead talking about code like this:; //; // %i = phi [ 0, %entry ], [ %i.next, %latch ]; // ...; // %i.next = add %i, 1; // %c = icmp eq %i.next, %n; //; // The SCEV for %i is {0,+,1}<%L>. The SCEV for %i.next is {1,+,1}<%L>, however; // it's useful to think about these as the same register, with some uses using; // the value of the register before the add and some using it after. In this; // example, the icmp is a post-increment user, since it uses %i.next, which is; // the value of the induction variable after the increment. The other common; // case of post-increment users is users outside the loop.; //; // TODO: More sophistication in the way Formulae are generated and filtered.; //; // TODO: Handle multiple loops at a time.; //; // TODO: Should the addressing mode BaseGV be changed to a ConstantExpr instead; // of a GlobalValue?; //; // TODO: When truncation is free, truncate ICmp users' operands",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:901,Modifiability,variab,variables,901,"//===- LoopStrengthReduce.cpp - Strength Reduce IVs in Loops --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into forms suitable for efficient execution; // on the target.; //; // This pass performs a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; // Terminology note: this code has a lot of handling for ""post-increment"" or; // ""post-inc"" users. This is not talking about post-increment addressing modes;; // it is instead talking about code like this:; //; // %i = phi [ 0, %entry ], [ %i.next, %latch ]; // ...; // %i.next = add %i, 1; // %c = icmp eq %i.next, %n; //; // The SCEV for %i is {0,+,1}<%L>. The SCEV for %i.next is {1,+,1}<%L>, however; // it's useful to think about these as the same register, with some uses using; // the value of the register before the add and some using it after. In this; // example, the icmp is a post-increment user, since it uses %i.next, which is; // the value of the induction variable after the increment. The other common; // case of post-increment users is users outside the loop.; //; // TODO: More sophistication in the way Formulae are generated and filtered.; //; // TODO: Handle multiple loops at a time.; //; // TODO: Should the addressing mode BaseGV be changed to a ConstantExpr instead; // of a GlobalValue?; //; // TODO: When truncation is free, truncate ICmp users' operands",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:1590,Modifiability,variab,variable,1590," a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; // Terminology note: this code has a lot of handling for ""post-increment"" or; // ""post-inc"" users. This is not talking about post-increment addressing modes;; // it is instead talking about code like this:; //; // %i = phi [ 0, %entry ], [ %i.next, %latch ]; // ...; // %i.next = add %i, 1; // %c = icmp eq %i.next, %n; //; // The SCEV for %i is {0,+,1}<%L>. The SCEV for %i.next is {1,+,1}<%L>, however; // it's useful to think about these as the same register, with some uses using; // the value of the register before the add and some using it after. In this; // example, the icmp is a post-increment user, since it uses %i.next, which is; // the value of the induction variable after the increment. The other common; // case of post-increment users is users outside the loop.; //; // TODO: More sophistication in the way Formulae are generated and filtered.; //; // TODO: Handle multiple loops at a time.; //; // TODO: Should the addressing mode BaseGV be changed to a ConstantExpr instead; // of a GlobalValue?; //; // TODO: When truncation is free, truncate ICmp users' operands to make it a; // smaller encoding (on x86 at least).; //; // TODO: When a negated register is used by an add (such as in a list of; // multiple base registers, or as the increment expression in an addrec),; // we may not actually need both reg and (-1 * reg) in registers; the; // negation can be implemented by using a sub instead of an add. The; // lack of support for taking this into consideration when making; // register pressure decisions is partly worked around by the ""Special""; // use kind.; //; //===---------------------------------------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:573,Performance,perform,performs,573,"//===- LoopStrengthReduce.cpp - Strength Reduce IVs in Loops --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into forms suitable for efficient execution; // on the target.; //; // This pass performs a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; // Terminology note: this code has a lot of handling for ""post-increment"" or; // ""post-inc"" users. This is not talking about post-increment addressing modes;; // it is instead talking about code like this:; //; // %i = phi [ 0, %entry ], [ %i.next, %latch ]; // ...; // %i.next = add %i, 1; // %c = icmp eq %i.next, %n; //; // The SCEV for %i is {0,+,1}<%L>. The SCEV for %i.next is {1,+,1}<%L>, however; // it's useful to think about these as the same register, with some uses using; // the value of the register before the add and some using it after. In this; // example, the icmp is a post-increment user, since it uses %i.next, which is; // the value of the induction variable after the increment. The other common; // case of post-increment users is users outside the loop.; //; // TODO: More sophistication in the way Formulae are generated and filtered.; //; // TODO: Handle multiple loops at a time.; //; // TODO: Should the addressing mode BaseGV be changed to a ConstantExpr instead; // of a GlobalValue?; //; // TODO: When truncation is free, truncate ICmp users' operands",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:829,Performance,perform,performs,829,"//===- LoopStrengthReduce.cpp - Strength Reduce IVs in Loops --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into forms suitable for efficient execution; // on the target.; //; // This pass performs a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; // Terminology note: this code has a lot of handling for ""post-increment"" or; // ""post-inc"" users. This is not talking about post-increment addressing modes;; // it is instead talking about code like this:; //; // %i = phi [ 0, %entry ], [ %i.next, %latch ]; // ...; // %i.next = add %i, 1; // %c = icmp eq %i.next, %n; //; // The SCEV for %i is {0,+,1}<%L>. The SCEV for %i.next is {1,+,1}<%L>, however; // it's useful to think about these as the same register, with some uses using; // the value of the register before the add and some using it after. In this; // example, the icmp is a post-increment user, since it uses %i.next, which is; // the value of the induction variable after the increment. The other common; // case of post-increment users is users outside the loop.; //; // TODO: More sophistication in the way Formulae are generated and filtered.; //; // TODO: Handle multiple loops at a time.; //; // TODO: Should the addressing mode BaseGV be changed to a ConstantExpr instead; // of a GlobalValue?; //; // TODO: When truncation is free, truncate ICmp users' operands",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:857,Performance,optimiz,optimizations,857,"//===- LoopStrengthReduce.cpp - Strength Reduce IVs in Loops --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into forms suitable for efficient execution; // on the target.; //; // This pass performs a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; // Terminology note: this code has a lot of handling for ""post-increment"" or; // ""post-inc"" users. This is not talking about post-increment addressing modes;; // it is instead talking about code like this:; //; // %i = phi [ 0, %entry ], [ %i.next, %latch ]; // ...; // %i.next = add %i, 1; // %c = icmp eq %i.next, %n; //; // The SCEV for %i is {0,+,1}<%L>. The SCEV for %i.next is {1,+,1}<%L>, however; // it's useful to think about these as the same register, with some uses using; // the value of the register before the add and some using it after. In this; // example, the icmp is a post-increment user, since it uses %i.next, which is; // the value of the induction variable after the increment. The other common; // case of post-increment users is users outside the loop.; //; // TODO: More sophistication in the way Formulae are generated and filtered.; //; // TODO: Handle multiple loops at a time.; //; // TODO: Should the addressing mode BaseGV be changed to a ConstantExpr instead; // of a GlobalValue?; //; // TODO: When truncation is free, truncate ICmp users' operands",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:10,Testability,test,test,10,// Stress test IV chain generation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:33,Security,access,accessed,33,/// Used in situations where the accessed memory type is unknown.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:3,Deployability,Update,Update,3,// Update RegUses. The data structure is not optimized for this purpose;; // we must iterate through it and update each of the bit vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:108,Deployability,update,update,108,// Update RegUses. The data structure is not optimized for this purpose;; // we must iterate through it and update each of the bit vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:45,Performance,optimiz,optimized,45,// Update RegUses. The data structure is not optimized for this purpose;; // we must iterate through it and update each of the bit vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:4,Testability,Test,Test,4,/// Test if this formula references the given register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:4,Testability,Test,Test,4,/// Test whether this formula uses registers which are used by uses other than; /// the use with the given index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:48,Modifiability,extend,extended,48,/// Return true if the given addrec can be sign-extended without changing its; /// value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:45,Modifiability,extend,extended,45,/// Return true if the given add can be sign-extended without changing its; /// value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:45,Modifiability,extend,extended,45,/// Return true if the given mul can be sign-extended without changing its; /// value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:204,Usability,simpl,simplified,204,"/// Return an expression for LHS /s RHS, if it can be determined and if the; /// remainder is known to be zero, or null otherwise. If IgnoreSignificantBits; /// is true, expressions like (X * Y) /s Y are simplified to X, ignoring that; /// the multiplication may overflow, which is useful when the result will be; /// used in a context where the most significant bits are ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:40,Security,access,accessed,40,/// Return the type of the memory being accessed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:38,Security,access,accessed,38,// First get the type of memory being accessed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:108,Energy Efficiency,reduce,reduced,108,"/// An operand value in an instruction which is to be replaced with some; /// equivalent, possibly strength-reduced, replacement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:34,Deployability,update,updated,34,/// The instruction which will be updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:75,Modifiability,variab,variable,75,"/// If this user is to use the post-incremented value of an induction; /// variable, this set is non-empty and holds the loops associated with the; /// induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:162,Modifiability,variab,variable,162,"/// If this user is to use the post-incremented value of an induction; /// variable, this set is non-empty and holds the loops associated with the; /// induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:60,Modifiability,variab,variables,60,// It is bad to allow LSR for current loop to add induction variables; // for its sibling loops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:4,Testability,Test,Test,4,/// Test whether this fixup always uses its value outside of the given loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:4,Testability,Test,Test,4,/// Test whether this use as a formula which has the same registers as the given; /// formula.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:34,Deployability,update,update,34,"/// Recompute the Regs field, and update RegUses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:3,Deployability,Update,Update,3,// Update the RegTracker.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:4,Testability,Test,Test,4,/// Test whether we know how to expand the current formula.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:64,Testability,log,logic,64,/// This class holds state for the main loop strength reduction logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:66,Modifiability,variab,variable,66,"/// This is the insert position that the current loop's induction variable; /// increment should be placed. In simple loops, this is the latch block's; /// terminator. But in more complicated cases, this is a position which will; /// dominate all the in-loop post-increment users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:111,Usability,simpl,simple,111,"/// This is the insert position that the current loop's induction variable; /// increment should be placed. In simple loops, this is the latch block's; /// terminator. But in more complicated cases, this is a position which will; /// dominate all the in-loop post-increment users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:33,Safety,avoid,avoid,33,// Limit the number of chains to avoid quadratic behavior. We don't expect to; // have more than a few IV increment chains in a loop. Missing a Chain falls; // back to normal LSR behavior for those uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:14,Modifiability,variab,variables,14,/// Induction variables that were generated and inserted by the SCEV Expander.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:109,Usability,simpl,simple,109,"// NOTE: we could handle setcc instructions with multiple uses here, but; // InstCombine does it as well for simple uses, it's not clear that it; // occurs enough in real life to handle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:131,Usability,clear,clear,131,"// NOTE: we could handle setcc instructions with multiple uses here, but; // InstCombine does it as well for simple uses, it's not clear that it; // occurs enough in real life to handle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:4,Modifiability,Rewrite,Rewrite,4,"/// Rewrite the loop's terminating condition if it uses a max computation.; ///; /// This is a narrow solution to a specific, but acute, problem. For loops; /// like this:; ///; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; ///; /// the trip count isn't just 'n', because 'n' might not be positive. And; /// unfortunately this can come up even for loops where the user didn't use; /// a C do-while loop. For example, seemingly well-behaved top-test loops; /// will commonly be lowered like this:; ///; /// if (n > 0) {; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; /// }; ///; /// and then it's possible for subsequent optimization to obscure the if; /// test in such a way that indvars can't find it.; ///; /// When indvars can't find the if test in loops like this, it creates a; /// max expression, which allows it to give the loop a canonical; /// induction variable:; ///; /// i = 0;; /// max = n < 1 ? 1 : n;; /// do {; /// p[i] = 0.0;; /// } while (++i != max);; ///; /// Canonical induction variables are necessary because the loop passes; /// are designed around them. The most obvious example of this is the; /// LoopInfo analysis, which doesn't remember trip count values. It; /// expects to be able to rediscover the trip count each time it is; /// needed, and it does this using a simple analysis that only succeeds if; /// the loop has a canonical induction variable.; ///; /// However, when it comes time to generate code, the maximum operation; /// can be quite costly, especially if it's inside of an outer loop.; ///; /// This function solves this problem by detecting this type of loop and; /// rewriting their conditions from ICMP_NE back to ICMP_SLT, and deleting; /// the instructions for the maximum computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:897,Modifiability,variab,variable,897,"/// Rewrite the loop's terminating condition if it uses a max computation.; ///; /// This is a narrow solution to a specific, but acute, problem. For loops; /// like this:; ///; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; ///; /// the trip count isn't just 'n', because 'n' might not be positive. And; /// unfortunately this can come up even for loops where the user didn't use; /// a C do-while loop. For example, seemingly well-behaved top-test loops; /// will commonly be lowered like this:; ///; /// if (n > 0) {; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; /// }; ///; /// and then it's possible for subsequent optimization to obscure the if; /// test in such a way that indvars can't find it.; ///; /// When indvars can't find the if test in loops like this, it creates a; /// max expression, which allows it to give the loop a canonical; /// induction variable:; ///; /// i = 0;; /// max = n < 1 ? 1 : n;; /// do {; /// p[i] = 0.0;; /// } while (++i != max);; ///; /// Canonical induction variables are necessary because the loop passes; /// are designed around them. The most obvious example of this is the; /// LoopInfo analysis, which doesn't remember trip count values. It; /// expects to be able to rediscover the trip count each time it is; /// needed, and it does this using a simple analysis that only succeeds if; /// the loop has a canonical induction variable.; ///; /// However, when it comes time to generate code, the maximum operation; /// can be quite costly, especially if it's inside of an outer loop.; ///; /// This function solves this problem by detecting this type of loop and; /// rewriting their conditions from ICMP_NE back to ICMP_SLT, and deleting; /// the instructions for the maximum computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:1034,Modifiability,variab,variables,1034,"/// Rewrite the loop's terminating condition if it uses a max computation.; ///; /// This is a narrow solution to a specific, but acute, problem. For loops; /// like this:; ///; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; ///; /// the trip count isn't just 'n', because 'n' might not be positive. And; /// unfortunately this can come up even for loops where the user didn't use; /// a C do-while loop. For example, seemingly well-behaved top-test loops; /// will commonly be lowered like this:; ///; /// if (n > 0) {; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; /// }; ///; /// and then it's possible for subsequent optimization to obscure the if; /// test in such a way that indvars can't find it.; ///; /// When indvars can't find the if test in loops like this, it creates a; /// max expression, which allows it to give the loop a canonical; /// induction variable:; ///; /// i = 0;; /// max = n < 1 ? 1 : n;; /// do {; /// p[i] = 0.0;; /// } while (++i != max);; ///; /// Canonical induction variables are necessary because the loop passes; /// are designed around them. The most obvious example of this is the; /// LoopInfo analysis, which doesn't remember trip count values. It; /// expects to be able to rediscover the trip count each time it is; /// needed, and it does this using a simple analysis that only succeeds if; /// the loop has a canonical induction variable.; ///; /// However, when it comes time to generate code, the maximum operation; /// can be quite costly, especially if it's inside of an outer loop.; ///; /// This function solves this problem by detecting this type of loop and; /// rewriting their conditions from ICMP_NE back to ICMP_SLT, and deleting; /// the instructions for the maximum computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:1407,Modifiability,variab,variable,1407,"/// Rewrite the loop's terminating condition if it uses a max computation.; ///; /// This is a narrow solution to a specific, but acute, problem. For loops; /// like this:; ///; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; ///; /// the trip count isn't just 'n', because 'n' might not be positive. And; /// unfortunately this can come up even for loops where the user didn't use; /// a C do-while loop. For example, seemingly well-behaved top-test loops; /// will commonly be lowered like this:; ///; /// if (n > 0) {; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; /// }; ///; /// and then it's possible for subsequent optimization to obscure the if; /// test in such a way that indvars can't find it.; ///; /// When indvars can't find the if test in loops like this, it creates a; /// max expression, which allows it to give the loop a canonical; /// induction variable:; ///; /// i = 0;; /// max = n < 1 ? 1 : n;; /// do {; /// p[i] = 0.0;; /// } while (++i != max);; ///; /// Canonical induction variables are necessary because the loop passes; /// are designed around them. The most obvious example of this is the; /// LoopInfo analysis, which doesn't remember trip count values. It; /// expects to be able to rediscover the trip count each time it is; /// needed, and it does this using a simple analysis that only succeeds if; /// the loop has a canonical induction variable.; ///; /// However, when it comes time to generate code, the maximum operation; /// can be quite costly, especially if it's inside of an outer loop.; ///; /// This function solves this problem by detecting this type of loop and; /// rewriting their conditions from ICMP_NE back to ICMP_SLT, and deleting; /// the instructions for the maximum computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:654,Performance,optimiz,optimization,654,"/// Rewrite the loop's terminating condition if it uses a max computation.; ///; /// This is a narrow solution to a specific, but acute, problem. For loops; /// like this:; ///; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; ///; /// the trip count isn't just 'n', because 'n' might not be positive. And; /// unfortunately this can come up even for loops where the user didn't use; /// a C do-while loop. For example, seemingly well-behaved top-test loops; /// will commonly be lowered like this:; ///; /// if (n > 0) {; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; /// }; ///; /// and then it's possible for subsequent optimization to obscure the if; /// test in such a way that indvars can't find it.; ///; /// When indvars can't find the if test in loops like this, it creates a; /// max expression, which allows it to give the loop a canonical; /// induction variable:; ///; /// i = 0;; /// max = n < 1 ? 1 : n;; /// do {; /// p[i] = 0.0;; /// } while (++i != max);; ///; /// Canonical induction variables are necessary because the loop passes; /// are designed around them. The most obvious example of this is the; /// LoopInfo analysis, which doesn't remember trip count values. It; /// expects to be able to rediscover the trip count each time it is; /// needed, and it does this using a simple analysis that only succeeds if; /// the loop has a canonical induction variable.; ///; /// However, when it comes time to generate code, the maximum operation; /// can be quite costly, especially if it's inside of an outer loop.; ///; /// This function solves this problem by detecting this type of loop and; /// rewriting their conditions from ICMP_NE back to ICMP_SLT, and deleting; /// the instructions for the maximum computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:1612,Safety,detect,detecting,1612,"/// Rewrite the loop's terminating condition if it uses a max computation.; ///; /// This is a narrow solution to a specific, but acute, problem. For loops; /// like this:; ///; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; ///; /// the trip count isn't just 'n', because 'n' might not be positive. And; /// unfortunately this can come up even for loops where the user didn't use; /// a C do-while loop. For example, seemingly well-behaved top-test loops; /// will commonly be lowered like this:; ///; /// if (n > 0) {; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; /// }; ///; /// and then it's possible for subsequent optimization to obscure the if; /// test in such a way that indvars can't find it.; ///; /// When indvars can't find the if test in loops like this, it creates a; /// max expression, which allows it to give the loop a canonical; /// induction variable:; ///; /// i = 0;; /// max = n < 1 ? 1 : n;; /// do {; /// p[i] = 0.0;; /// } while (++i != max);; ///; /// Canonical induction variables are necessary because the loop passes; /// are designed around them. The most obvious example of this is the; /// LoopInfo analysis, which doesn't remember trip count values. It; /// expects to be able to rediscover the trip count each time it is; /// needed, and it does this using a simple analysis that only succeeds if; /// the loop has a canonical induction variable.; ///; /// However, when it comes time to generate code, the maximum operation; /// can be quite costly, especially if it's inside of an outer loop.; ///; /// This function solves this problem by detecting this type of loop and; /// rewriting their conditions from ICMP_NE back to ICMP_SLT, and deleting; /// the instructions for the maximum computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:461,Testability,test,test,461,"/// Rewrite the loop's terminating condition if it uses a max computation.; ///; /// This is a narrow solution to a specific, but acute, problem. For loops; /// like this:; ///; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; ///; /// the trip count isn't just 'n', because 'n' might not be positive. And; /// unfortunately this can come up even for loops where the user didn't use; /// a C do-while loop. For example, seemingly well-behaved top-test loops; /// will commonly be lowered like this:; ///; /// if (n > 0) {; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; /// }; ///; /// and then it's possible for subsequent optimization to obscure the if; /// test in such a way that indvars can't find it.; ///; /// When indvars can't find the if test in loops like this, it creates a; /// max expression, which allows it to give the loop a canonical; /// induction variable:; ///; /// i = 0;; /// max = n < 1 ? 1 : n;; /// do {; /// p[i] = 0.0;; /// } while (++i != max);; ///; /// Canonical induction variables are necessary because the loop passes; /// are designed around them. The most obvious example of this is the; /// LoopInfo analysis, which doesn't remember trip count values. It; /// expects to be able to rediscover the trip count each time it is; /// needed, and it does this using a simple analysis that only succeeds if; /// the loop has a canonical induction variable.; ///; /// However, when it comes time to generate code, the maximum operation; /// can be quite costly, especially if it's inside of an outer loop.; ///; /// This function solves this problem by detecting this type of loop and; /// rewriting their conditions from ICMP_NE back to ICMP_SLT, and deleting; /// the instructions for the maximum computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:690,Testability,test,test,690,"/// Rewrite the loop's terminating condition if it uses a max computation.; ///; /// This is a narrow solution to a specific, but acute, problem. For loops; /// like this:; ///; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; ///; /// the trip count isn't just 'n', because 'n' might not be positive. And; /// unfortunately this can come up even for loops where the user didn't use; /// a C do-while loop. For example, seemingly well-behaved top-test loops; /// will commonly be lowered like this:; ///; /// if (n > 0) {; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; /// }; ///; /// and then it's possible for subsequent optimization to obscure the if; /// test in such a way that indvars can't find it.; ///; /// When indvars can't find the if test in loops like this, it creates a; /// max expression, which allows it to give the loop a canonical; /// induction variable:; ///; /// i = 0;; /// max = n < 1 ? 1 : n;; /// do {; /// p[i] = 0.0;; /// } while (++i != max);; ///; /// Canonical induction variables are necessary because the loop passes; /// are designed around them. The most obvious example of this is the; /// LoopInfo analysis, which doesn't remember trip count values. It; /// expects to be able to rediscover the trip count each time it is; /// needed, and it does this using a simple analysis that only succeeds if; /// the loop has a canonical induction variable.; ///; /// However, when it comes time to generate code, the maximum operation; /// can be quite costly, especially if it's inside of an outer loop.; ///; /// This function solves this problem by detecting this type of loop and; /// rewriting their conditions from ICMP_NE back to ICMP_SLT, and deleting; /// the instructions for the maximum computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:778,Testability,test,test,778,"/// Rewrite the loop's terminating condition if it uses a max computation.; ///; /// This is a narrow solution to a specific, but acute, problem. For loops; /// like this:; ///; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; ///; /// the trip count isn't just 'n', because 'n' might not be positive. And; /// unfortunately this can come up even for loops where the user didn't use; /// a C do-while loop. For example, seemingly well-behaved top-test loops; /// will commonly be lowered like this:; ///; /// if (n > 0) {; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; /// }; ///; /// and then it's possible for subsequent optimization to obscure the if; /// test in such a way that indvars can't find it.; ///; /// When indvars can't find the if test in loops like this, it creates a; /// max expression, which allows it to give the loop a canonical; /// induction variable:; ///; /// i = 0;; /// max = n < 1 ? 1 : n;; /// do {; /// p[i] = 0.0;; /// } while (++i != max);; ///; /// Canonical induction variables are necessary because the loop passes; /// are designed around them. The most obvious example of this is the; /// LoopInfo analysis, which doesn't remember trip count values. It; /// expects to be able to rediscover the trip count each time it is; /// needed, and it does this using a simple analysis that only succeeds if; /// the loop has a canonical induction variable.; ///; /// However, when it comes time to generate code, the maximum operation; /// can be quite costly, especially if it's inside of an outer loop.; ///; /// This function solves this problem by detecting this type of loop and; /// rewriting their conditions from ICMP_NE back to ICMP_SLT, and deleting; /// the instructions for the maximum computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:1329,Usability,simpl,simple,1329,"/// Rewrite the loop's terminating condition if it uses a max computation.; ///; /// This is a narrow solution to a specific, but acute, problem. For loops; /// like this:; ///; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; ///; /// the trip count isn't just 'n', because 'n' might not be positive. And; /// unfortunately this can come up even for loops where the user didn't use; /// a C do-while loop. For example, seemingly well-behaved top-test loops; /// will commonly be lowered like this:; ///; /// if (n > 0) {; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; /// }; ///; /// and then it's possible for subsequent optimization to obscure the if; /// test in such a way that indvars can't find it.; ///; /// When indvars can't find the if test in loops like this, it creates a; /// max expression, which allows it to give the loop a canonical; /// induction variable:; ///; /// i = 0;; /// max = n < 1 ? 1 : n;; /// do {; /// p[i] = 0.0;; /// } while (++i != max);; ///; /// Canonical induction variables are necessary because the loop passes; /// are designed around them. The most obvious example of this is the; /// LoopInfo analysis, which doesn't remember trip count values. It; /// expects to be able to rediscover the trip count each time it is; /// needed, and it does this using a simple analysis that only succeeds if; /// the loop has a canonical induction variable.; ///; /// However, when it comes time to generate code, the maximum operation; /// can be quite costly, especially if it's inside of an outer loop.; ///; /// This function solves this problem by detecting this type of loop and; /// rewriting their conditions from ICMP_NE back to ICMP_SLT, and deleting; /// the instructions for the maximum computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:53,Performance,optimiz,optimization,53,"// To handle a max with more than two operands, this optimization would; // require additional checking and setup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:32,Modifiability,variab,variable,32,// Check the relevant induction variable for conformance to; // the pattern.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:211,Energy Efficiency,reduce,reduce,211,"// We need a different set of heuristics for rotated and non-rotated loops.; // If a loop is rotated then the latch is also the backedge, so inserting; // post-inc expressions just before the latch is ideal. To reduce live ranges; // it also makes sense to rewrite terminating conditions to use post-inc; // expressions.; //; // If the loop is not rotated then the latch is not a backedge; the latch; // check is done in the loop head. Adding post-inc expressions before the; // latch will cause overlapping live-ranges of pre-inc and post-inc expressions; // in the loop body. In this case we do *not* want to use post-inc expressions; // in the latch check, and we want to insert post-inc expressions before; // the backedge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:257,Modifiability,rewrite,rewrite,257,"// We need a different set of heuristics for rotated and non-rotated loops.; // If a loop is rotated then the latch is also the backedge, so inserting; // post-inc expressions just before the latch is ideal. To reduce live ranges; // it also makes sense to rewrite terminating conditions to use post-inc; // expressions.; //; // If the loop is not rotated then the latch is not a backedge; the latch; // check is done in the loop head. Adding post-inc expressions before the; // latch will cause overlapping live-ranges of pre-inc and post-inc expressions; // in the loop body. In this case we do *not* want to use post-inc expressions; // in the latch check, and we want to insert post-inc expressions before; // the backedge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:60,Testability,test,tested,60,// The backedge doesn't exit the loop; treat this as a head-tested loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:150,Modifiability,variab,variable,150,"// Get the terminating condition for the loop if possible. If we; // can, we want to change it to use a post-incremented version of its; // induction variable, to allow coalescing the live ranges for the IV into; // one register value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:266,Availability,down,down,266,"// If the trip count is computed in terms of a max (due to ScalarEvolution; // being unable to find a sufficient guard, for example), change the loop; // comparison to use SLT or ULT instead of NE.; // One consequence of doing this now is that it disrupts the count-down; // optimization. That's not always a bad thing though, because in such; // cases it may still be worthwhile to avoid a max.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:275,Performance,optimiz,optimization,275,"// If the trip count is computed in terms of a max (due to ScalarEvolution; // being unable to find a sufficient guard, for example), change the loop; // comparison to use SLT or ULT instead of NE.; // One consequence of doing this now is that it disrupts the count-down; // optimization. That's not always a bad thing though, because in such; // cases it may still be worthwhile to avoid a max.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:383,Safety,avoid,avoid,383,"// If the trip count is computed in terms of a max (due to ScalarEvolution; // being unable to find a sufficient guard, for example), change the loop; // comparison to use SLT or ULT instead of NE.; // One consequence of doing this now is that it disrupts the count-down; // optimization. That's not always a bad thing though, because in such; // cases it may still be worthwhile to avoid a max.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:18,Safety,avoid,avoid,18,// Conservatively avoid trying to use the post-inc value in non-latch; // exits if there may be pre-inc users in intervening blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:3,Testability,Test,Test,3,// Test if the use is reachable from the exiting block. This dominator; // query is a conservative approximation of reachability.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:3,Safety,Avoid,Avoid,3,// Avoid weird situations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:55,Modifiability,variab,variable,55,"// Determine an insertion point for the loop induction variable increment. It; // must dominate all the post-inc comparisons we just set up, and it must; // dominate the loop latch edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:106,Deployability,update,update,106,"/// Determine if the given use can accommodate a fixup at the given offset and; /// other details. If so, update the use and return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:26,Security,access,access,26,"// Check for a mismatched access type, and fall back conservatively as needed.; // TODO: Be less conservative when the type is similar and can use the same; // addressing modes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:3,Deployability,Update,Update,3,// Update the use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:131,Security,access,access,131,"/// Return an LSRUse index and an offset value for a fixup which needs the given; /// expression, with the given kind and optional access type. Either reuse an; /// existing use or create a new one, as needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:3,Deployability,Update,Update,3,// Update RegUses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:69,Integrability,wrap,wrap,69,"/// IVChain logic must consistently peek base TruncInst operands, so wrap it in; /// a convenient helper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:12,Testability,log,logic,12,"/// IVChain logic must consistently peek base TruncInst operands, so wrap it in; /// a convenient helper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:382,Safety,avoid,avoids,382,"/// Return an approximation of this SCEV expression's ""base"", or NULL for any; /// constant. Returning the expression itself is conservative. Returning a; /// deeper subexpression is more precise and valid as long as it isn't less; /// complex than another subexpression. For expressions involving multiple; /// unscaled values, we need to return the pointer-type SCEVUnknown. This avoids; /// forming chains across objects, such as: PrevOper==a[i], IVOper==b[i],; /// IVInc==b-a.; ///; /// Since SCEVUnknown is the rightmost type, and pointers are the rightmost; /// SCEVUnknown, we simply return the rightmost SCEV operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:584,Usability,simpl,simply,584,"/// Return an approximation of this SCEV expression's ""base"", or NULL for any; /// constant. Returning the expression itself is conservative. Returning a; /// deeper subexpression is more precise and valid as long as it isn't less; /// complex than another subexpression. For expressions involving multiple; /// unscaled values, we need to return the pointer-type SCEVUnknown. This avoids; /// forming chains across objects, such as: PrevOper==a[i], IVOper==b[i],; /// IVInc==b-a.; ///; /// Since SCEVUnknown is the rightmost type, and pointers are the rightmost; /// SCEVUnknown, we simply return the rightmost SCEV operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:138,Modifiability,extend,extended,138,"// Materializing increment expressions in the preheader that didn't exist in; // the original code may cost a register. For example, sign-extended array; // indices can produce ridiculous increments like this:; // IV + ((sext i32 (2 * %s) to i64) + (-1 * (sext i32 %s to i64)))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:11,Modifiability,variab,variable,11,// Reusing variable increments likely saves a register to hold the multiple of; // the stride.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:231,Safety,avoid,avoids,231,"// Prune the solution space aggressively by checking that both IV operands; // are expressions that operate on the same unscaled SCEVUnknown. This; // ""base"" will be canceled by the subsequent getMinusSCEV call. Checking; // first avoids creating extra SCEV expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:666,Availability,redundant,redundant,666,"/// Populate the vector of Chains.; ///; /// This decreases ILP at the architecture level. Targets with ample registers,; /// multiple memory ports, and no register renaming probably don't want; /// this. However, such targets should probably disable LSR altogether.; ///; /// The job of LSR is to make a reasonable choice of induction variables across; /// the loop. Subsequent passes can easily ""unchain"" computation exposing more; /// ILP *within the loop* if the target wants it.; ///; /// Finding the best IV chain is potentially a scheduling problem. Since LSR; /// will not reorder memory operations, it will recognize this as a chain, but; /// will generate redundant IV increments. Ideally this would be corrected later; /// by a smart scheduler:; /// = A[i]; /// = A[i+x]; /// A[i] =; /// A[i+x] =; ///; /// TODO: Walk the entire domtree within this loop, not just the path to the; /// loop latch. This will discover chains on side paths, but requires; /// maintaining multiple copies of the Chains state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:537,Energy Efficiency,schedul,scheduling,537,"/// Populate the vector of Chains.; ///; /// This decreases ILP at the architecture level. Targets with ample registers,; /// multiple memory ports, and no register renaming probably don't want; /// this. However, such targets should probably disable LSR altogether.; ///; /// The job of LSR is to make a reasonable choice of induction variables across; /// the loop. Subsequent passes can easily ""unchain"" computation exposing more; /// ILP *within the loop* if the target wants it.; ///; /// Finding the best IV chain is potentially a scheduling problem. Since LSR; /// will not reorder memory operations, it will recognize this as a chain, but; /// will generate redundant IV increments. Ideally this would be corrected later; /// by a smart scheduler:; /// = A[i]; /// = A[i+x]; /// A[i] =; /// A[i+x] =; ///; /// TODO: Walk the entire domtree within this loop, not just the path to the; /// loop latch. This will discover chains on side paths, but requires; /// maintaining multiple copies of the Chains state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:745,Energy Efficiency,schedul,scheduler,745,"/// Populate the vector of Chains.; ///; /// This decreases ILP at the architecture level. Targets with ample registers,; /// multiple memory ports, and no register renaming probably don't want; /// this. However, such targets should probably disable LSR altogether.; ///; /// The job of LSR is to make a reasonable choice of induction variables across; /// the loop. Subsequent passes can easily ""unchain"" computation exposing more; /// ILP *within the loop* if the target wants it.; ///; /// Finding the best IV chain is potentially a scheduling problem. Since LSR; /// will not reorder memory operations, it will recognize this as a chain, but; /// will generate redundant IV increments. Ideally this would be corrected later; /// by a smart scheduler:; /// = A[i]; /// = A[i+x]; /// A[i] =; /// A[i+x] =; ///; /// TODO: Walk the entire domtree within this loop, not just the path to the; /// loop latch. This will discover chains on side paths, but requires; /// maintaining multiple copies of the Chains state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:336,Modifiability,variab,variables,336,"/// Populate the vector of Chains.; ///; /// This decreases ILP at the architecture level. Targets with ample registers,; /// multiple memory ports, and no register renaming probably don't want; /// this. However, such targets should probably disable LSR altogether.; ///; /// The job of LSR is to make a reasonable choice of induction variables across; /// the loop. Subsequent passes can easily ""unchain"" computation exposing more; /// ILP *within the loop* if the target wants it.; ///; /// Finding the best IV chain is potentially a scheduling problem. Since LSR; /// will not reorder memory operations, it will recognize this as a chain, but; /// will generate redundant IV increments. Ideally this would be corrected later; /// by a smart scheduler:; /// = A[i]; /// = A[i+x]; /// A[i] =; /// A[i+x] =; ///; /// TODO: Walk the entire domtree within this loop, not just the path to the; /// loop latch. This will discover chains on side paths, but requires; /// maintaining multiple copies of the Chains state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:666,Safety,redund,redundant,666,"/// Populate the vector of Chains.; ///; /// This decreases ILP at the architecture level. Targets with ample registers,; /// multiple memory ports, and no register renaming probably don't want; /// this. However, such targets should probably disable LSR altogether.; ///; /// The job of LSR is to make a reasonable choice of induction variables across; /// the loop. Subsequent passes can easily ""unchain"" computation exposing more; /// ILP *within the loop* if the target wants it.; ///; /// Finding the best IV chain is potentially a scheduling problem. Since LSR; /// will not reorder memory operations, it will recognize this as a chain, but; /// will generate redundant IV increments. Ideally this would be corrected later; /// by a smart scheduler:; /// = A[i]; /// = A[i+x]; /// A[i] =; /// A[i+x] =; ///; /// TODO: Walk the entire domtree within this loop, not just the path to the; /// loop latch. This will discover chains on side paths, but requires; /// maintaining multiple copies of the Chains state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:20,Availability,down,down,20,// Continue walking down the instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:20,Availability,down,down,20,// Continue walking down the domtree.; // Visit phi backedges to determine if the chain can generate the IV postinc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:50,Modifiability,rewrite,rewrite,50,"// Equality (== and !=) ICmps are special. We can rewrite (i == N) as; // (N - i == 0), and this allows (N - i) to be the expression that we work; // with rather than just N or i, so we can consider the register; // requirements for both N and i at the same time. Limiting this code to; // equality icmps is not a problem because all interesting loops use; // equality icmps, thanks to IndVarSimplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:80,Energy Efficiency,Power,PowerPC,80,"// If CI can be saved in some target, like replaced inside hardware loop; // in PowerPC, no need to generate initial formulae for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:145,Integrability,wrap,wrap,145,"// If we can't generally expand the expression (e.g. it contains; // a divide), but it is already at a loop invariant point before the; // loop, wrap it in an unknown (to prevent the expander from trying; // to re-expand in a potentially unsafe way.) The restriction to; // integer types is required because the unknown hides the base, and; // SCEV can't compute the difference of two unknown pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:238,Safety,unsafe,unsafe,238,"// If we can't generally expand the expression (e.g. it contains; // a divide), but it is already at a loop invariant point before the; // loop, wrap it in an unknown (to prevent the expander from trying; // to re-expand in a potentially unsafe way.) The restriction to; // integer types is required because the unknown hides the base, and; // SCEV can't compute the difference of two unknown pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:13,Usability,simpl,simple,13,/// Insert a simple single-register formula for the given expression into the; /// given use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:330,Modifiability,rewrite,rewrite,330,"// Ignore cases in which the currently-examined value could come from; // a basic block terminated with an EHPad. This checks all incoming; // blocks of the phi node since it is possible that the same incoming; // value comes from multiple basic blocks, only some of which may end; // in an EHPad. If any of them do, a subsequent rewrite attempt by this; // pass would try to insert instructions into an EHPad, hitting an; // assertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:426,Testability,assert,assertion,426,"// Ignore cases in which the currently-examined value could come from; // a basic block terminated with an EHPad. This checks all incoming; // blocks of the phi node since it is possible that the same incoming; // value comes from multiple basic blocks, only some of which may end; // in an EHPad. If any of them do, a subsequent rewrite attempt by this; // pass would try to insert instructions into an EHPad, hitting an; // assertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:60,Safety,avoid,avoid,60,"// Ignore uses which are part of other SCEV expressions, to avoid; // analyzing them multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:27,Performance,load,load,27,// Check if a post-indexed load/store can be used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:262,Energy Efficiency,efficient,efficient,262,"// Don't generate reassociations for the base register of a value that; // may generate a post-increment operator. The reason is that the; // reassociations cause extra base+register formula to be created,; // and possibly chosen, but the post-increment is more efficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:58,Deployability,update,update,58,"// If it cancelled out, drop the base register, otherwise update it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:278,Deployability,update,updates,278,"// With constant offsets and constant steps, we can generate pre-inc; // accesses by having the offset equal the step. So, for access #0 with a; // step of 8, we generate a G - 8 base which would require the first access; // to be ((G - 8) + 8),+,8. The pre-indexed access then updates the pointer; // for itself and hopefully becomes the base for other accesses. This means; // means that a single pre-indexed access can be generated to become the new; // base pointer for each iteration of the loop, resulting in no extra add/sub; // instructions for pointer updating.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:73,Security,access,accesses,73,"// With constant offsets and constant steps, we can generate pre-inc; // accesses by having the offset equal the step. So, for access #0 with a; // step of 8, we generate a G - 8 base which would require the first access; // to be ((G - 8) + 8),+,8. The pre-indexed access then updates the pointer; // for itself and hopefully becomes the base for other accesses. This means; // means that a single pre-indexed access can be generated to become the new; // base pointer for each iteration of the loop, resulting in no extra add/sub; // instructions for pointer updating.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:127,Security,access,access,127,"// With constant offsets and constant steps, we can generate pre-inc; // accesses by having the offset equal the step. So, for access #0 with a; // step of 8, we generate a G - 8 base which would require the first access; // to be ((G - 8) + 8),+,8. The pre-indexed access then updates the pointer; // for itself and hopefully becomes the base for other accesses. This means; // means that a single pre-indexed access can be generated to become the new; // base pointer for each iteration of the loop, resulting in no extra add/sub; // instructions for pointer updating.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:214,Security,access,access,214,"// With constant offsets and constant steps, we can generate pre-inc; // accesses by having the offset equal the step. So, for access #0 with a; // step of 8, we generate a G - 8 base which would require the first access; // to be ((G - 8) + 8),+,8. The pre-indexed access then updates the pointer; // for itself and hopefully becomes the base for other accesses. This means; // means that a single pre-indexed access can be generated to become the new; // base pointer for each iteration of the loop, resulting in no extra add/sub; // instructions for pointer updating.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:266,Security,access,access,266,"// With constant offsets and constant steps, we can generate pre-inc; // accesses by having the offset equal the step. So, for access #0 with a; // step of 8, we generate a G - 8 base which would require the first access; // to be ((G - 8) + 8),+,8. The pre-indexed access then updates the pointer; // for itself and hopefully becomes the base for other accesses. This means; // means that a single pre-indexed access can be generated to become the new; // base pointer for each iteration of the loop, resulting in no extra add/sub; // instructions for pointer updating.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:354,Security,access,accesses,354,"// With constant offsets and constant steps, we can generate pre-inc; // accesses by having the offset equal the step. So, for access #0 with a; // step of 8, we generate a G - 8 base which would require the first access; // to be ((G - 8) + 8),+,8. The pre-indexed access then updates the pointer; // for itself and hopefully becomes the base for other accesses. This means; // means that a single pre-indexed access can be generated to become the new; // base pointer for each iteration of the loop, resulting in no extra add/sub; // instructions for pointer updating.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:411,Security,access,access,411,"// With constant offsets and constant steps, we can generate pre-inc; // accesses by having the offset equal the step. So, for access #0 with a; // step of 8, we generate a G - 8 base which would require the first access; // to be ((G - 8) + 8),+,8. The pre-indexed access then updates the pointer; // for itself and hopefully becomes the base for other accesses. This means; // means that a single pre-indexed access can be generated to become the new; // base pointer for each iteration of the loop, resulting in no extra add/sub; // instructions for pointer updating.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:23,Performance,optimiz,optimized,23,// TODO: This could be optimized to avoid all the copying.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:36,Safety,avoid,avoid,36,// TODO: This could be optimized to avoid all the copying.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:4,Modifiability,Extend,Extend,4,"/// Extend/Truncate \p Expr to \p ToTy considering post-inc uses in \p Loops.; /// For all PostIncLoopSets in \p Loops, first de-normalize \p Expr, then; /// perform the extension/truncate and normalize again, as the normalized form; /// can result in folds that are not valid in the post-inc use contexts. The; /// expressions for all PostIncLoopSets must match, otherwise return nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:158,Performance,perform,perform,158,"/// Extend/Truncate \p Expr to \p ToTy considering post-inc uses in \p Loops.; /// For all PostIncLoopSets in \p Loops, first de-normalize \p Expr, then; /// perform the extension/truncate and normalize again, as the normalized form; /// can result in folds that are not valid in the post-inc use contexts. The; /// expressions for all PostIncLoopSets must match, otherwise return nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:20,Modifiability,extend,extend,20,// It is invalid to extend a pointer type so exit early if ScaledReg or; // any of the BaseRegs are pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:59,Integrability,depend,depend,59,"// Some formulas are instant losers. For example, they may depend on; // nonexistent AddRecs from other loops. These need to be filtered; // immediately, otherwise heuristics could choose them over others leading; // to an unsatisfactory solution. Passing LoserRegs into RateFormula here; // avoids the need to recompute this information across formulae using the; // same bad AddRec. Passing LoserRegs is also essential unless we remove; // the corresponding bad register from the Regs set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:292,Safety,avoid,avoids,292,"// Some formulas are instant losers. For example, they may depend on; // nonexistent AddRecs from other loops. These need to be filtered; // immediately, otherwise heuristics could choose them over others leading; // to an unsatisfactory solution. Passing LoserRegs into RateFormula here; // avoids the need to recompute this information across formulae using the; // same bad AddRec. Passing LoserRegs is also essential unless we remove; // the corresponding bad register from the Regs set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:93,Energy Efficiency,reduce,reduce,93,"/// When one formula uses a superset of the registers of another formula, it; /// won't help reduce register pressure (though it may not necessarily hurt; /// register pressure); remove it to simplify the system.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:192,Usability,simpl,simplify,192,"/// When one formula uses a superset of the registers of another formula, it; /// won't help reduce register pressure (though it may not necessarily hurt; /// register pressure); remove it to simplify the system.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:46,Integrability,wrap,wrapping,46,//FIXME: Formulas should store bitwidth to do wrapping properly.; // See PR41034.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:79,Energy Efficiency,allocate,allocate,79,"/// When there are many registers for expressions like A, A+1, A+2, etc.,; /// allocate a single register for them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:607,Safety,avoid,avoid,607,"/// If a LSRUse has multiple formulae with the same ScaledReg and Scale.; /// Pick the best one and delete the others.; /// This narrowing heuristic is to keep as many formulae with different; /// Scale and ScaledReg pair as possible while narrowing the search space.; /// The benefit is that it is more likely to find out a better solution; /// from a formulae set with more Scale and ScaledReg variations than; /// a formulae set with the same Scale and ScaledReg. The picking winner; /// reg heuristic will often keep the formulae with the same Scale and; /// ScaledReg and filter others, and we want to avoid that if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:80,Modifiability,variab,variables,80,"/// If we are over the complexity limit, filter out any post-inc prefering; /// variables to only post-inc values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:38,Performance,perform,performance,38,// This is temporary solution to test performance. Float should be; // replaced with round independent type (based on integers) to avoid; // different results for different target builds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:131,Safety,avoid,avoid,131,// This is temporary solution to test performance. Float should be; // replaced with round independent type (based on integers) to avoid; // different results for different target builds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:33,Testability,test,test,33,// This is temporary solution to test performance. Float should be; // replaced with round independent type (based on integers) to avoid; // different results for different target builds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:62,Usability,simpl,simple,62,"// With all other options exhausted, loop until the system is simple; // enough to handle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:46,Usability,simpl,simpler,46,"// If the scores are the same, but the Reg is simpler for the target; // (for example {x,+,1} as opposed to {x+C,+,1}, where the target can; // handle +C but not -C), opt for the simpler formula.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:179,Usability,simpl,simpler,179,"// If the scores are the same, but the Reg is simpler for the target; // (for example {x,+,1} as opposed to {x+C,+,1}, where the target can; // handle +C but not -C), opt for the simpler formula.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:109,Availability,down,down,109,"/// If there are an extraordinary number of formulae to choose from, use some; /// rough heuristics to prune down the number of formulae. This keeps the main; /// solver from taking an extraordinary amount of time in some worst-case; /// scenarios.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:79,Usability,clear,clear,79,"// If none of the formulae satisfied the required registers, then we could; // clear ReqRegs and try again. Currently, we simply give up in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:122,Usability,simpl,simply,122,"// If none of the formulae satisfied the required registers, then we could; // clear ReqRegs and try again. Currently, we simply give up in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:14,Modifiability,Rewrite,Rewriter,14,"// Inform the Rewriter if we have a post-increment use, so that it can; // perform an advantageous expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:75,Performance,perform,perform,75,"// Inform the Rewriter if we have a post-increment use, so that it can; // perform an advantageous expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:42,Modifiability,rewrite,rewriter,42,"// We're done expanding now, so reset the rewriter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:154,Deployability,update,update,154,"// An ICmpZero Formula represents an ICmp which we're handling as a; // comparison against zero. Now that we've expanded an expression for that; // form, update the ICmp's other operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:15,Modifiability,Rewrite,Rewrite,15,"/// Helper for Rewrite. PHI nodes are special because the use of their operands; /// effectively happens in their predecessor blocks, so the expression may need; /// to be expanded in multiple places.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:111,Usability,simpl,simple,111,"// If NewBB==NULL, then SplitCriticalEdge refused to split because all; // phi predecessors are identical. The simple thing to do is skip; // splitting in this case rather than complicate the API.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:26,Energy Efficiency,reduce,reduce,26,// Splitting the edge can reduce the number of PHI entries we have.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:93,Deployability,update,update,93,"// If LSR splits critical edge and phi node has other pending; // fixup operands, we need to update those pending fixups. Otherwise; // formulae will not be implemented completely and some instructions; // will not be eliminated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:77,Deployability,update,updated,77,"// If fixup is supposed to rewrite some operand in the phi; // that was just updated, it may be already moved to; // another phi node. Such fixup requires update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:155,Deployability,update,update,155,"// If fixup is supposed to rewrite some operand in the phi; // that was just updated, it may be already moved to; // another phi node. Such fixup requires update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:27,Modifiability,rewrite,rewrite,27,"// If fixup is supposed to rewrite some operand in the phi; // that was just updated, it may be already moved to; // another phi node. Such fixup requires update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:59,Deployability,update,update,59,// Otherwise it might be moved to another PHI and requires update.; // If fixup operand not found in any of the incoming blocks that; // means we have already rewritten it - nothing to do.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:114,Deployability,update,update,114,"/// Emit instructions for the leading candidate expression for this LSRUse (this; /// is called ""expanding""), and update the UserInst to reference the newly; /// expanded value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:3,Deployability,Update,Update,3,"// Update the user. ICmpZero is handled specially here (for now) because; // Expand may have updated one of the operands of the icmp already, and; // its new value may happen to be equal to LF.OperandValToReplace, in; // which case doing replaceUsesOfWith leads to replacing both operands; // with the same value. TODO: Reorganize this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:93,Deployability,update,updated,93,"// Update the user. ICmpZero is handled specially here (for now) because; // Expand may have updated one of the operands of the icmp already, and; // its new value may happen to be equal to LF.OperandValToReplace, in; // which case doing replaceUsesOfWith leads to replacing both operands; // with the same value. TODO: Reorganize this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:135,Performance,load,load,135,// Trying to hoist the IVInc to loop header if all IVInc users are in; // the loop header. It will help backend to generate post index load/store; // when the latch block is different from loop header block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:41,Performance,optimiz,optimization,41,"// For now this code do the conservative optimization, only work for; // the header block. Later we can hoist the IVInc to the block post; // dominate all users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:4,Modifiability,Rewrite,Rewrite,4,"/// Rewrite all the fixup locations with new values, following the chosen; /// solution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:40,Deployability,update,update,40,// Expand the new value definitions and update the users.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:403,Energy Efficiency,schedul,schedule,403,"// In our cost analysis above, we assume that each addrec consumes exactly; // one register, and arrange to have increments inserted just before the; // latch to maximimize the chance this is true. However, if we reused; // existing IVs, we now need to move the increments to match our; // expectations. Otherwise, our cost modeling results in us having a; // chosen a non-optimal result for the actual schedule. (And yes, this; // scheduling decision does impact later codegen.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:432,Energy Efficiency,schedul,scheduling,432,"// In our cost analysis above, we assume that each addrec consumes exactly; // one register, and arrange to have increments inserted just before the; // latch to maximimize the chance this is true. However, if we reused; // existing IVs, we now need to move the increments to match our; // expectations. Otherwise, our cost modeling results in us having a; // chosen a non-optimal result for the actual schedule. (And yes, this; // scheduling decision does impact later codegen.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:18,Energy Efficiency,schedul,schedule,18,// Can we legally schedule inc at the desired point?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:31,Availability,avail,available,31,"// If LoopSimplify form is not available, stay out of trouble.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:3,Modifiability,Config,Configure,3,"// Configure SCEVExpander already now, so the correct mode is used for; // isSafeToExpand() checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:10,Performance,perform,perform,10,"// First, perform some low-level loop optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:38,Performance,optimiz,optimizations,38,"// First, perform some low-level loop optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:161,Performance,optimiz,optimization,161,"// Start collecting data and preparing for the solver.; // If number of registers is not the major cost, we cannot benefit from the; // current profitable chain optimization which is based on number of; // registers.; // FIXME: add profitable chain optimization for other kinds major cost, for; // example number of instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:249,Performance,optimiz,optimization,249,"// Start collecting data and preparing for the solver.; // If number of registers is not the major cost, we cannot benefit from the; // current profitable chain optimization which is based on number of; // registers.; // FIXME: add profitable chain optimization for other kinds major cost, for; // example number of instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:3,Deployability,Release,Release,3,// Release memory that is no longer needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:65,Deployability,update,update,65,"// We split critical edges, so we change the CFG. However, we do update; // many analyses if they are around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:118,Modifiability,extend,extended,118,/// Several SCEV types are sequences of the same arithmetic operator applied; /// to constants and values that may be extended or truncated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:65,Testability,test,test,65,// TODO: MinMax - although these haven't been encountered in the test suite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:3,Testability,Assert,Assert,3,// Assert if a new and unknown SCEVCastEXpr type is encountered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:83,Availability,recover,recovers,83,/// Combine a translation of the SCEV and the IV to create an expression that; /// recovers a location's value.; /// returns true if an expression was created.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:83,Safety,recover,recovers,83,/// Combine a translation of the SCEV and the IV to create an expression that; /// recovers a location's value.; /// returns true if an expression was created.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:119,Availability,recover,recovery,119,// Initialise a new builder with the iteration count expression. In; // combination with the value's SCEV this enables recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:119,Safety,recover,recovery,119,// Initialise a new builder with the iteration count expression. In; // combination with the value's SCEV this enables recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:86,Energy Efficiency,reduce,reduce,86,"/// Write the new expression and new location ops for the dbg.value. If possible; /// reduce the szie of the dbg.value intrinsic by omitting DIArglist. This; /// can be omitted if:; /// 1. There is only a single location, refenced by a single DW_OP_llvm_arg.; /// 2. The DW_OP_LLVM_arg is the first operand in the expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:165,Availability,avail,available,165,"/// Cached location ops may be erased during LSR, in which case a poison is; /// required when restoring from the cache. The type of that location is no; /// longer available, so just use int8. The poison will be replaced by one or; /// more locations later when a SCEVDbgValueBuilder selects alternative; /// locations to use for the salvage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:4,Performance,Cache,Cached,4,"/// Cached location ops may be erased during LSR, in which case a poison is; /// required when restoring from the cache. The type of that location is no; /// longer available, so just use int8. The poison will be replaced by one or; /// more locations later when a SCEVDbgValueBuilder selects alternative; /// locations to use for the salvage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:114,Performance,cache,cache,114,"/// Cached location ops may be erased during LSR, in which case a poison is; /// required when restoring from the cache. The type of that location is no; /// longer available, so just use int8. The poison will be replaced by one or; /// more locations later when a SCEVDbgValueBuilder selects alternative; /// locations to use for the salvage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:107,Deployability,update,update,107,"// Place the locations not optimised out in the list first, avoiding; // inserts later. The map is used to update the DIExpression's; // DW_OP_LLVM_arg arguments as the expression is updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:183,Deployability,update,updated,183,"// Place the locations not optimised out in the list first, avoiding; // inserts later. The map is used to update the DIExpression's; // DW_OP_LLVM_arg arguments as the expression is updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:60,Safety,avoid,avoiding,60,"// Place the locations not optimised out in the list first, avoiding; // inserts later. The map is used to update the DIExpression's; // DW_OP_LLVM_arg arguments as the expression is updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:23,Deployability,update,updated,23,// Most Ops needn't be updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:127,Deployability,update,updated,127,"// The location doesn't have s SCEVDbgValueBuilder, so LSR did not; // optimise it away. So just translate the argument to the updated; // location index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:22,Availability,recover,recovery,22,// The location has a recovery expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:22,Safety,recover,recovery,22,// The location has a recovery expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:38,Availability,recover,recover,38,// The iteration count is required to recover location values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:38,Safety,recover,recover,38,// The iteration count is required to recover location values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:17,Performance,cache,cache,17,/// Identify and cache salvageable DVI locations and expressions along with the; /// corresponding SCEV(s). Also ensure that the DVI is not deleted between; /// cacheing and salvaging.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:161,Performance,cache,cacheing,161,/// Identify and cache salvageable DVI locations and expressions along with the; /// corresponding SCEV(s). Also ensure that the DVI is not deleted between; /// cacheing and salvaging.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:72,Performance,cache,cached,72,// Ensure that if any location op is undef that the dbg.vlue is not; // cached.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:63,Availability,recover,recover,63,// Each location Op may need a SCEVDbgValueBuilder in order to recover; // it. Pre-allocating a vector will enable quick lookups of the builder; // later during the salvage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:63,Safety,recover,recover,63,// Each location Op may need a SCEVDbgValueBuilder in order to recover; // it. Pre-allocating a vector will enable quick lookups of the builder; // later during the salvage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:116,Usability,usab,usable,116,"/// Ideally pick the PHI IV inserted by ScalarEvolutionExpander. As a fallback; /// any PHi from the loop header is usable, but may have less chance of; /// surviving subsequent transforms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:19,Usability,simpl,simple,19,// Only inspect on simple loop structure,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:131,Deployability,pipeline,pipeline,131,"// We could pattern match the inverse form of the icmp, but that is; // non-canonical, and this pass is running *very* late in the pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:34,Modifiability,rewrite,rewrite,34,"// If that IV isn't dead after we rewrite the exit condition in terms of; // another IV, there's no point in doing the transform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:206,Integrability,wrap,wrap,206,"// Check that we can compute the value of AddRec on the exiting iteration; // without soundness problems. evaluateAtIteration internally needs; // to multiply the stride of the iteration number - which may wrap around.; // The issue here is subtle because computing the result accounting for; // wrap is insufficient. In order to use the result in an exit test, we; // must also know that AddRec doesn't take the same value on any previous; // iteration. The simplest case to consider is a candidate IV which is; // narrower than the trip count (and thus original IV), but this can; // also happen due to non-unit strides on the candidate IVs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:296,Integrability,wrap,wrap,296,"// Check that we can compute the value of AddRec on the exiting iteration; // without soundness problems. evaluateAtIteration internally needs; // to multiply the stride of the iteration number - which may wrap around.; // The issue here is subtle because computing the result accounting for; // wrap is insufficient. In order to use the result in an exit test, we; // must also know that AddRec doesn't take the same value on any previous; // iteration. The simplest case to consider is a candidate IV which is; // narrower than the trip count (and thus original IV), but this can; // also happen due to non-unit strides on the candidate IVs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:356,Testability,test,test,356,"// Check that we can compute the value of AddRec on the exiting iteration; // without soundness problems. evaluateAtIteration internally needs; // to multiply the stride of the iteration number - which may wrap around.; // The issue here is subtle because computing the result accounting for; // wrap is insufficient. In order to use the result in an exit test, we; // must also know that AddRec doesn't take the same value on any previous; // iteration. The simplest case to consider is a candidate IV which is; // narrower than the trip count (and thus original IV), but this can; // also happen due to non-unit strides on the candidate IVs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:459,Usability,simpl,simplest,459,"// Check that we can compute the value of AddRec on the exiting iteration; // without soundness problems. evaluateAtIteration internally needs; // to multiply the stride of the iteration number - which may wrap around.; // The issue here is subtle because computing the result accounting for; // wrap is insufficient. In order to use the result in an exit test, we; // must also know that AddRec doesn't take the same value on any previous; // iteration. The simplest case to consider is a candidate IV which is; // narrower than the trip count (and thus original IV), but this can; // also happen due to non-unit strides on the candidate IVs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:15,Performance,perform,perform,15,"// In order to perform the transform, we need to drop the poison generating; // flags on this instruction (if any).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:302,Deployability,update,updates,302,"// LSR may at times remove all uses of an induction variable from a loop.; // The only remaining use is the PHI in the exit block.; // When this is the case, if the exit value of the IV can be calculated using; // SCEV, we can replace the exit block PHI with the final value of the IV and; // skip the updates in each loop iteration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:52,Modifiability,variab,variable,52,"// LSR may at times remove all uses of an induction variable from a loop.; // The only remaining use is the PHI in the exit block.; // When this is the case, if the exit value of the IV can be calculated using; // SCEV, we can replace the exit block PHI with the final value of the IV and; // skip the updates in each loop iteration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:38,Modifiability,rewrite,rewrite,38,// Obtain relevant IVs and attempt to rewrite the salvageable DVIs with; // expressions composed using the derived iteration count.; // TODO: Allow for multiple IV references for nested AddRecSCEVs,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollAndJamPass.cpp:99,Performance,perform,performance,99,"// If we are explicitly unroll and jamming, we are done. Otherwise there are a; // number of extra performance heuristics to check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollAndJamPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollAndJamPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollAndJamPass.cpp:115,Performance,load,loads,115,"// Limit to loops where there is something to gain from unrolling and; // jamming the loop. In this case, look for loads that are invariant in the; // outer loop and can become shared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollAndJamPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollAndJamPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:406,Usability,simpl,simple,406,"//===- LoopUnroll.cpp - Loop unroller pass --------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements a simple loop unroller. It works best when loops have; // been canonicalized by the -indvars pass, allowing it to determine the trip; // counts of loops easily.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:103,Performance,perform,performed,103,/// A magic value for use with the Threshold parameter to indicate; /// that the loop unroll should be performed regardless of how much; /// code expansion would result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:195,Security,hash,hashing,195,"/// A struct to densely store the state of an instruction after unrolling at; /// each iteration.; ///; /// This is designed to work like a tuple of <Instruction *, int> for the; /// purposes of hashing and lookup, but to be able to associate two boolean; /// states with each key.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:4,Security,Hash,Hashing,4,/// Hashing and equality testing for a set of the instruction states.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:25,Testability,test,testing,25,/// Hashing and equality testing for a set of the instruction states.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:235,Integrability,rout,routine,235,"// end anonymous namespace; /// Figure out if the loop is worth full unrolling.; ///; /// Complete loop unrolling can make some loads constant, and we need to know; /// if that would expose any further optimization opportunities. This routine; /// estimates this optimization. It computes cost of unrolled loop; /// (UnrolledCost) and dynamic cost of the original loop (RolledDynamicCost). By; /// dynamic cost we mean that we won't count costs of blocks that are known not; /// to be executed (i.e. if we have a branch in the loop and we know that at the; /// given iteration its condition would be resolved to true, we won't add up the; /// cost of the 'false'-block).; /// \returns Optional value, holding the RolledDynamicCost and UnrolledCost. If; /// the analysis failed (no benefits expected from the unrolling, or the loop is; /// too big to analyze), the returned value is std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:128,Performance,load,loads,128,"// end anonymous namespace; /// Figure out if the loop is worth full unrolling.; ///; /// Complete loop unrolling can make some loads constant, and we need to know; /// if that would expose any further optimization opportunities. This routine; /// estimates this optimization. It computes cost of unrolled loop; /// (UnrolledCost) and dynamic cost of the original loop (RolledDynamicCost). By; /// dynamic cost we mean that we won't count costs of blocks that are known not; /// to be executed (i.e. if we have a branch in the loop and we know that at the; /// given iteration its condition would be resolved to true, we won't add up the; /// cost of the 'false'-block).; /// \returns Optional value, holding the RolledDynamicCost and UnrolledCost. If; /// the analysis failed (no benefits expected from the unrolling, or the loop is; /// too big to analyze), the returned value is std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:202,Performance,optimiz,optimization,202,"// end anonymous namespace; /// Figure out if the loop is worth full unrolling.; ///; /// Complete loop unrolling can make some loads constant, and we need to know; /// if that would expose any further optimization opportunities. This routine; /// estimates this optimization. It computes cost of unrolled loop; /// (UnrolledCost) and dynamic cost of the original loop (RolledDynamicCost). By; /// dynamic cost we mean that we won't count costs of blocks that are known not; /// to be executed (i.e. if we have a branch in the loop and we know that at the; /// given iteration its condition would be resolved to true, we won't add up the; /// cost of the 'false'-block).; /// \returns Optional value, holding the RolledDynamicCost and UnrolledCost. If; /// the analysis failed (no benefits expected from the unrolling, or the loop is; /// too big to analyze), the returned value is std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:263,Performance,optimiz,optimization,263,"// end anonymous namespace; /// Figure out if the loop is worth full unrolling.; ///; /// Complete loop unrolling can make some loads constant, and we need to know; /// if that would expose any further optimization opportunities. This routine; /// estimates this optimization. It computes cost of unrolled loop; /// (UnrolledCost) and dynamic cost of the original loop (RolledDynamicCost). By; /// dynamic cost we mean that we won't count costs of blocks that are known not; /// to be executed (i.e. if we have a branch in the loop and we know that at the; /// given iteration its condition would be resolved to true, we won't add up the; /// cost of the 'false'-block).; /// \returns Optional value, holding the RolledDynamicCost and UnrolledCost. If; /// the analysis failed (no benefits expected from the unrolling, or the loop is; /// too big to analyze), the returned value is std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:183,Security,expose,expose,183,"// end anonymous namespace; /// Figure out if the loop is worth full unrolling.; ///; /// Complete loop unrolling can make some loads constant, and we need to know; /// if that would expose any further optimization opportunities. This routine; /// estimates this optimization. It computes cost of unrolled loop; /// (UnrolledCost) and dynamic cost of the original loop (RolledDynamicCost). By; /// dynamic cost we mean that we won't count costs of blocks that are known not; /// to be executed (i.e. if we have a branch in the loop and we know that at the; /// given iteration its condition would be resolved to true, we won't add up the; /// cost of the 'false'-block).; /// \returns Optional value, holding the RolledDynamicCost and UnrolledCost. If; /// the analysis failed (no benefits expected from the unrolling, or the loop is; /// too big to analyze), the returned value is std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:87,Usability,simpl,simplifying,87,// The estimated cost of the unrolled form of the loop. We try to estimate; // this by simplifying as much as we can while computing the estimate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:211,Energy Efficiency,reduce,reduced,211,"// We also track the estimated dynamic (that is, actually executed) cost in; // the rolled form. This helps identify cases when the savings from unrolling; // aren't just exposing dead control flows, but actual reduced dynamic; // instructions due to the simplifications which we expect to occur after; // unrolling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:255,Usability,simpl,simplifications,255,"// We also track the estimated dynamic (that is, actually executed) cost in; // the rolled form. This helps identify cases when the savings from unrolling; // aren't just exposing dead control flows, but actual reduced dynamic; // instructions due to the simplifications which we expect to occur after; // unrolling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:16,Usability,simpl,simplification,16,"// We track the simplification of each instruction in each iteration. We use; // this to recursively merge costs into the unrolled cost on-demand so that; // we don't count the cost of any dead code. This is essentially a map from; // <instruction, int> to <bool, bool>, but stored as a densely packed struct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:108,Usability,simpl,simply,108,"// We must count the cost of every operand which is not free,; // recursively. If we reach a loop PHI node, simply add it to the set; // to be considered on the next iteration (backwards!).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:125,Performance,load,load,125,"// Simulate execution of each iteration of the loop counting instructions,; // which would be simplified.; // Since the same load will take different values on different iterations,; // we literally have to go through all loop's iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:94,Usability,simpl,simplified,94,"// Simulate execution of each iteration of the loop counting instructions,; // which would be simplified.; // Since the same load will take different values on different iterations,; // we literally have to go through all loop's iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:47,Usability,simpl,simplified,47,// Prepare for the iteration by collecting any simplified entry or backedge; // inputs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:7,Usability,clear,clear,7,// Now clear and re-populate the map for the next iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:27,Performance,cache,cache,27,"// Note that we *must not* cache the size, this loop grows the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:121,Performance,optimiz,optimization,121,"// Visit all instructions in the given basic block and try to simplify; // it. We don't change the actual IR, just count optimization; // opportunities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:62,Usability,simpl,simplify,62,"// Visit all instructions in the given basic block and try to simplify; // it. We don't change the actual IR, just count optimization; // opportunities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:91,Usability,simpl,simplified,91,// Add in the live successors by first checking whether we have terminator; // that may be simplified based on the values simplified by this call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:122,Usability,simpl,simplified,122,// Add in the live successors by first checking whether we have terminator; // that may be simplified based on the values simplified by this call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:18,Performance,optimiz,optimization,18,"// If we found no optimization opportunities on the first iteration, we; // won't find them on later ones too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce unroll count to be modulo of TripCount for partial unrolling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:78,Energy Efficiency,power,power-of-two,78,"// If there is no Count that is modulo of TripCount, set Count to; // largest power-of-two factor that satisfies the threshold limit.; // As we'll create fixup loop, do the type of unrolling only if; // remainder loop is allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:466,Modifiability,refactor,refactored,466,"// Returns true if unroll count was set explicitly.; // Calculates unroll count and writes it to UP.Count.; // Unless IgnoreUser is true, will also use metadata and command-line options; // that are specific to to the LoopUnroll pass (which, for instance, are; // irrelevant for the LoopUnrollAndJam pass).; // FIXME: This function is used by LoopUnroll and LoopUnrollAndJam, but consumes; // many LoopUnroll-specific options. The shared functionality should be; // refactored into it own function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:58,Testability,test,testing,58,// Use an explicit peel count that has been specified for testing. In this; // case it's not permitted to also specify an explicit unroll count.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:89,Testability,test,test,89,// 3rd priority is exact full unrolling. This will eliminate all copies; // of some exit test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:521,Safety,predict,predictor,521,"// 4th priority is bounded unrolling.; // We can unroll by the upper bound amount if it's generally allowed or if; // we know that the loop is executed either the upper bound or zero times.; // (MaxOrZero unrolling keeps only the first loop test, so the number of; // loop tests remains the same compared to the non-unrolled version, whereas; // the generic upper bound unrolling keeps all but the last loop test so the; // number of loop tests goes up which may end up being worse on targets with; // constrained branch predictor resources so is controlled by an option.); // In addition we only unroll small upper bounds.; // Note that the cost of bounded unrolling is always strictly greater than; // cost of exact full unrolling. As such, if we have an exact count and; // found it unprofitable, we'll never chose to bounded unroll.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:241,Testability,test,test,241,"// 4th priority is bounded unrolling.; // We can unroll by the upper bound amount if it's generally allowed or if; // we know that the loop is executed either the upper bound or zero times.; // (MaxOrZero unrolling keeps only the first loop test, so the number of; // loop tests remains the same compared to the non-unrolled version, whereas; // the generic upper bound unrolling keeps all but the last loop test so the; // number of loop tests goes up which may end up being worse on targets with; // constrained branch predictor resources so is controlled by an option.); // In addition we only unroll small upper bounds.; // Note that the cost of bounded unrolling is always strictly greater than; // cost of exact full unrolling. As such, if we have an exact count and; // found it unprofitable, we'll never chose to bounded unroll.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:273,Testability,test,tests,273,"// 4th priority is bounded unrolling.; // We can unroll by the upper bound amount if it's generally allowed or if; // we know that the loop is executed either the upper bound or zero times.; // (MaxOrZero unrolling keeps only the first loop test, so the number of; // loop tests remains the same compared to the non-unrolled version, whereas; // the generic upper bound unrolling keeps all but the last loop test so the; // number of loop tests goes up which may end up being worse on targets with; // constrained branch predictor resources so is controlled by an option.); // In addition we only unroll small upper bounds.; // Note that the cost of bounded unrolling is always strictly greater than; // cost of exact full unrolling. As such, if we have an exact count and; // found it unprofitable, we'll never chose to bounded unroll.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:408,Testability,test,test,408,"// 4th priority is bounded unrolling.; // We can unroll by the upper bound amount if it's generally allowed or if; // we know that the loop is executed either the upper bound or zero times.; // (MaxOrZero unrolling keeps only the first loop test, so the number of; // loop tests remains the same compared to the non-unrolled version, whereas; // the generic upper bound unrolling keeps all but the last loop test so the; // number of loop tests goes up which may end up being worse on targets with; // constrained branch predictor resources so is controlled by an option.); // In addition we only unroll small upper bounds.; // Note that the cost of bounded unrolling is always strictly greater than; // cost of exact full unrolling. As such, if we have an exact count and; // found it unprofitable, we'll never chose to bounded unroll.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:439,Testability,test,tests,439,"// 4th priority is bounded unrolling.; // We can unroll by the upper bound amount if it's generally allowed or if; // we know that the loop is executed either the upper bound or zero times.; // (MaxOrZero unrolling keeps only the first loop test, so the number of; // loop tests remains the same compared to the non-unrolled version, whereas; // the generic upper bound unrolling keeps all but the last loop test so the; // number of loop tests goes up which may end up being worse on targets with; // constrained branch predictor resources so is controlled by an option.); // In addition we only unroll small upper bounds.; // Note that the cost of bounded unrolling is always strictly greater than; // cost of exact full unrolling. As such, if we have an exact count and; // found it unprofitable, we'll never chose to bounded unroll.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:64,Availability,avail,available,64,// Check if the runtime trip count is too small when profile is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce unroll count to be the largest power-of-two factor of; // the original count which satisfies the threshold limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:41,Energy Efficiency,power,power-of-two,41,// Reduce unroll count to be the largest power-of-two factor of; // the original count which satisfies the threshold limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:45,Safety,avoid,avoid,45,"// If this loop isn't forced to be unrolled, avoid unrolling it when the; // parent loop has an explicit unroll-and-jam pragma. This is to prevent; // automatic unrolling from interfering with the user requested; // transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:45,Safety,avoid,avoid,45,"// If this loop isn't forced to be unrolled, avoid unrolling it when the; // loop has an explicit unroll-and-jam pragma. This is to prevent automatic; // unrolling from interfering with the user requested transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:8,Performance,optimiz,optimizing,8,"// When optimizing for size, use LoopSize + 1 as threshold (we use < Threshold; // later), to (fully) unroll loops, if it does not increase code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:670,Energy Efficiency,power,powerful,670,"// If the loop contains a convergent operation, the prelude we'd add; // to do the first few instructions before we hit the unrolled loop; // is unsafe -- it adds a control-flow dependency to the convergent; // operation. Therefore restrict remainder loop (try unrolling without).; //; // TODO: This is quite conservative. In practice, convergent_op(); // is likely to be called unconditionally in the loop. In this; // case, the program would be ill-formed (on most architectures); // unless n were the same on all threads in a thread group.; // Assuming n is the same on all threads, any kind of unrolling is; // safe. But currently llvm's notion of convergence isn't powerful; // enough to express this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:178,Integrability,depend,dependency,178,"// If the loop contains a convergent operation, the prelude we'd add; // to do the first few instructions before we hit the unrolled loop; // is unsafe -- it adds a control-flow dependency to the convergent; // operation. Therefore restrict remainder loop (try unrolling without).; //; // TODO: This is quite conservative. In practice, convergent_op(); // is likely to be called unconditionally in the loop. In this; // case, the program would be ill-formed (on most architectures); // unless n were the same on all threads in a thread group.; // Assuming n is the same on all threads, any kind of unrolling is; // safe. But currently llvm's notion of convergence isn't powerful; // enough to express this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:145,Safety,unsafe,unsafe,145,"// If the loop contains a convergent operation, the prelude we'd add; // to do the first few instructions before we hit the unrolled loop; // is unsafe -- it adds a control-flow dependency to the convergent; // operation. Therefore restrict remainder loop (try unrolling without).; //; // TODO: This is quite conservative. In practice, convergent_op(); // is likely to be called unconditionally in the loop. In this; // case, the program would be ill-formed (on most architectures); // unless n were the same on all threads in a thread group.; // Assuming n is the same on all threads, any kind of unrolling is; // safe. But currently llvm's notion of convergence isn't powerful; // enough to express this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:615,Safety,safe,safe,615,"// If the loop contains a convergent operation, the prelude we'd add; // to do the first few instructions before we hit the unrolled loop; // is unsafe -- it adds a control-flow dependency to the convergent; // operation. Therefore restrict remainder loop (try unrolling without).; //; // TODO: This is quite conservative. In practice, convergent_op(); // is likely to be called unconditionally in the loop. In this; // case, the program would be ill-formed (on most architectures); // unless n were the same on all threads in a thread group.; // Assuming n is the same on all threads, any kind of unrolling is; // safe. But currently llvm's notion of convergence isn't powerful; // enough to express this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:113,Performance,perform,perform,113,"// At this point, UP.Runtime indicates that run-time unrolling is allowed.; // However, we only want to actually perform it if we don't know the trip; // count and the unroll count doesn't divide the known trip multiple.; // TODO: This decision should probably be pushed up into; // computeUnrollCount().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:32,Performance,Optimiz,OptimizationRemarkEmitter,32,"// For the old PM, we can't use OptimizationRemarkEmitter as an analysis; // pass. Function analyses need to be preserved across loop transformations; // but ORE cannot be preserved (see comment before the pass definition).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:32,Performance,Optimiz,OptimizationRemarkEmitter,32,"// For the new PM, we can't use OptimizationRemarkEmitter as an analysis; // pass. Function analyses need to be preserved across loop transformations; // but ORE cannot be preserved (see comment before the pass definition).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:659,Performance,optimiz,optimizations,659,"// Unrolling can do several things to introduce new loops into a loop nest:; // - Full unrolling clones child loops within the current loop but then; // removes the current loop making all of the children appear to be new; // sibling loops.; //; // When a new loop appears as a sibling loop after fully unrolling,; // its nesting structure has fundamentally changed and we want to revisit; // it to reflect that.; //; // When unrolling has removed the current loop, we need to tell the; // infrastructure that it is gone.; //; // Finally, we support a debugging/testing mode where we revisit child loops; // as well. These are not expected to require further optimizations as either; // they or the loop they were cloned from have been directly visited already.; // But the debugging mode allows us to check this assumption.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:562,Testability,test,testing,562,"// Unrolling can do several things to introduce new loops into a loop nest:; // - Full unrolling clones child loops within the current loop but then; // removes the current loop making all of the children appear to be new; // sibling loops.; //; // When a new loop appears as a sibling loop after fully unrolling,; // its nesting structure has fundamentally changed and we want to revisit; // it to reflect that.; //; // When unrolling has removed the current loop, we need to tell the; // infrastructure that it is gone.; //; // Finally, we support a debugging/testing mode where we revisit child loops; // as well. These are not expected to require further optimizations as either; // they or the loop they were cloned from have been directly visited already.; // But the debugging mode allows us to check this assumption.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:40,Usability,simpl,simplified,40,"// The unroller requires loops to be in simplified form, and also needs LCSSA.; // Since simplification may add new inner loops, it has to run before the; // legality and profitability checks. This means running the loop unroller; // will simplify all loops, regardless of whether anything end up being; // unrolled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:89,Usability,simpl,simplification,89,"// The unroller requires loops to be in simplified form, and also needs LCSSA.; // Since simplification may add new inner loops, it has to run before the; // legality and profitability checks. This means running the loop unroller; // will simplify all loops, regardless of whether anything end up being; // unrolled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:239,Usability,simpl,simplify,239,"// The unroller requires loops to be in simplified form, and also needs LCSSA.; // Since simplification may add new inner loops, it has to run before the; // legality and profitability checks. This means running the loop unroller; // will simplify all loops, regardless of whether anything end up being; // unrolled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:179,Performance,optimiz,optimization,179,"// Because the LoopInfo stores the loops in RPO, we walk the worklist; // from back to front so that we work forward across the CFG, which; // for unrolling is only needed to get optimization remarks emitted in; // a forward order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:141,Safety,avoid,avoid,141,"// Check if the profile summary indicates that the profiled application; // has a huge working set size, in which case we disable peeling to avoid; // bloating it further.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:13,Performance,cache,cached,13,// Clear any cached analysis results for L if we removed it completely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:3,Usability,Clear,Clear,3,// Clear any cached analysis results for L if we removed it completely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:1483,Performance,Perform,Perform,1483," MayAlias. This uncertainty from alias analysis restricts LICM; // from proceeding further. In cases where alias analysis is uncertain we might; // use loop versioning as an alternative.; //; // Loop Versioning will create a version of the loop with aggressive aliasing; // assumptions in addition to the original with conservative (default) aliasing; // assumptions. The version of the loop making aggressive aliasing assumptions; // will have all the memory accesses marked as no-alias. These two versions of; // loop will be preceded by a memory runtime check. This runtime check consists; // of bound checks for all unique memory accessed in loop, and it ensures the; // lack of memory aliasing. The result of the runtime check determines which of; // the loop versions is executed: If the runtime check detects any memory; // aliasing, then the original loop is executed. Otherwise, the version with; // aggressive aliasing assumptions is used.; //; // Following are the top level steps:; //; // a) Perform LoopVersioningLICM's feasibility check.; // b) If loop is a candidate for versioning then create a memory bound check,; // by considering all the memory accesses in loop body.; // c) Clone original loop and set all memory accesses as no-alias in new loop.; // d) Set original loop & versioned loop as a branch target of the runtime check; // result.; //; // It transforms loop as shown below:; //; // +----------------+; // |Runtime Memcheck|; // +----------------+; // |; // +----------+----------------+----------+; // | |; // +---------+----------+ +-----------+----------+; // |Orig Loop Preheader | |Cloned Loop Preheader |; // +--------------------+ +----------------------+; // | |; // +--------------------+ +----------------------+; // |Orig Loop Body | |Cloned Loop Body |; // +--------------------+ +----------------------+; // | |; // +--------------------+ +----------------------+; // |Orig Loop Exit Block| |Cloned Loop Exit Block|; // +--------------------+ +-----------+-",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:1287,Safety,detect,detects,1287,".0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // When alias analysis is uncertain about the aliasing between any two accesses,; // it will return MayAlias. This uncertainty from alias analysis restricts LICM; // from proceeding further. In cases where alias analysis is uncertain we might; // use loop versioning as an alternative.; //; // Loop Versioning will create a version of the loop with aggressive aliasing; // assumptions in addition to the original with conservative (default) aliasing; // assumptions. The version of the loop making aggressive aliasing assumptions; // will have all the memory accesses marked as no-alias. These two versions of; // loop will be preceded by a memory runtime check. This runtime check consists; // of bound checks for all unique memory accessed in loop, and it ensures the; // lack of memory aliasing. The result of the runtime check determines which of; // the loop versions is executed: If the runtime check detects any memory; // aliasing, then the original loop is executed. Otherwise, the version with; // aggressive aliasing assumptions is used.; //; // Following are the top level steps:; //; // a) Perform LoopVersioningLICM's feasibility check.; // b) If loop is a candidate for versioning then create a memory bound check,; // by considering all the memory accesses in loop body.; // c) Clone original loop and set all memory accesses as no-alias in new loop.; // d) Set original loop & versioned loop as a branch target of the runtime check; // result.; //; // It transforms loop as shown below:; //; // +----------------+; // |Runtime Memcheck|; // +----------------+; // |; // +----------+----------------+----------+; // | |; // +---------+----------+ +-----------+----------+; // |Orig Loop Preheader | |Cloned Loop Preheader |; // +--------------------+ +----------------------+; // | |; // +--------------------+ +----------------------+; // |Orig Loop Body | |Cloned Loop ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:451,Security,access,accesses,451,"//===- LoopVersioningLICM.cpp - LICM Loop Versioning ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // When alias analysis is uncertain about the aliasing between any two accesses,; // it will return MayAlias. This uncertainty from alias analysis restricts LICM; // from proceeding further. In cases where alias analysis is uncertain we might; // use loop versioning as an alternative.; //; // Loop Versioning will create a version of the loop with aggressive aliasing; // assumptions in addition to the original with conservative (default) aliasing; // assumptions. The version of the loop making aggressive aliasing assumptions; // will have all the memory accesses marked as no-alias. These two versions of; // loop will be preceded by a memory runtime check. This runtime check consists; // of bound checks for all unique memory accessed in loop, and it ensures the; // lack of memory aliasing. The result of the runtime check determines which of; // the loop versions is executed: If the runtime check detects any memory; // aliasing, then the original loop is executed. Otherwise, the version with; // aggressive aliasing assumptions is used.; //; // Following are the top level steps:; //; // a) Perform LoopVersioningLICM's feasibility check.; // b) If loop is a candidate for versioning then create a memory bound check,; // by considering all the memory accesses in loop body.; // c) Clone original loop and set all memory accesses as no-alias in new loop.; // d) Set original loop & versioned loop as a branch target of the runtime check; // result.; //; // It transforms loop as shown below:; //; // +----------------+; // |Runtime Memcheck|; // +----------------+; // |; // +----------+----------------+-----",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:939,Security,access,accesses,939,"//===- LoopVersioningLICM.cpp - LICM Loop Versioning ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // When alias analysis is uncertain about the aliasing between any two accesses,; // it will return MayAlias. This uncertainty from alias analysis restricts LICM; // from proceeding further. In cases where alias analysis is uncertain we might; // use loop versioning as an alternative.; //; // Loop Versioning will create a version of the loop with aggressive aliasing; // assumptions in addition to the original with conservative (default) aliasing; // assumptions. The version of the loop making aggressive aliasing assumptions; // will have all the memory accesses marked as no-alias. These two versions of; // loop will be preceded by a memory runtime check. This runtime check consists; // of bound checks for all unique memory accessed in loop, and it ensures the; // lack of memory aliasing. The result of the runtime check determines which of; // the loop versions is executed: If the runtime check detects any memory; // aliasing, then the original loop is executed. Otherwise, the version with; // aggressive aliasing assumptions is used.; //; // Following are the top level steps:; //; // a) Perform LoopVersioningLICM's feasibility check.; // b) If loop is a candidate for versioning then create a memory bound check,; // by considering all the memory accesses in loop body.; // c) Clone original loop and set all memory accesses as no-alias in new loop.; // d) Set original loop & versioned loop as a branch target of the runtime check; // result.; //; // It transforms loop as shown below:; //; // +----------------+; // |Runtime Memcheck|; // +----------------+; // |; // +----------+----------------+-----",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:1113,Security,access,accessed,1113,"ect, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // When alias analysis is uncertain about the aliasing between any two accesses,; // it will return MayAlias. This uncertainty from alias analysis restricts LICM; // from proceeding further. In cases where alias analysis is uncertain we might; // use loop versioning as an alternative.; //; // Loop Versioning will create a version of the loop with aggressive aliasing; // assumptions in addition to the original with conservative (default) aliasing; // assumptions. The version of the loop making aggressive aliasing assumptions; // will have all the memory accesses marked as no-alias. These two versions of; // loop will be preceded by a memory runtime check. This runtime check consists; // of bound checks for all unique memory accessed in loop, and it ensures the; // lack of memory aliasing. The result of the runtime check determines which of; // the loop versions is executed: If the runtime check detects any memory; // aliasing, then the original loop is executed. Otherwise, the version with; // aggressive aliasing assumptions is used.; //; // Following are the top level steps:; //; // a) Perform LoopVersioningLICM's feasibility check.; // b) If loop is a candidate for versioning then create a memory bound check,; // by considering all the memory accesses in loop body.; // c) Clone original loop and set all memory accesses as no-alias in new loop.; // d) Set original loop & versioned loop as a branch target of the runtime check; // result.; //; // It transforms loop as shown below:; //; // +----------------+; // |Runtime Memcheck|; // +----------------+; // |; // +----------+----------------+----------+; // | |; // +---------+----------+ +-----------+----------+; // |Orig Loop Preheader | |Cloned Loop Pr",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:1644,Security,access,accesses,1644,"is is uncertain we might; // use loop versioning as an alternative.; //; // Loop Versioning will create a version of the loop with aggressive aliasing; // assumptions in addition to the original with conservative (default) aliasing; // assumptions. The version of the loop making aggressive aliasing assumptions; // will have all the memory accesses marked as no-alias. These two versions of; // loop will be preceded by a memory runtime check. This runtime check consists; // of bound checks for all unique memory accessed in loop, and it ensures the; // lack of memory aliasing. The result of the runtime check determines which of; // the loop versions is executed: If the runtime check detects any memory; // aliasing, then the original loop is executed. Otherwise, the version with; // aggressive aliasing assumptions is used.; //; // Following are the top level steps:; //; // a) Perform LoopVersioningLICM's feasibility check.; // b) If loop is a candidate for versioning then create a memory bound check,; // by considering all the memory accesses in loop body.; // c) Clone original loop and set all memory accesses as no-alias in new loop.; // d) Set original loop & versioned loop as a branch target of the runtime check; // result.; //; // It transforms loop as shown below:; //; // +----------------+; // |Runtime Memcheck|; // +----------------+; // |; // +----------+----------------+----------+; // | |; // +---------+----------+ +-----------+----------+; // |Orig Loop Preheader | |Cloned Loop Preheader |; // +--------------------+ +----------------------+; // | |; // +--------------------+ +----------------------+; // |Orig Loop Body | |Cloned Loop Body |; // +--------------------+ +----------------------+; // | |; // +--------------------+ +----------------------+; // |Orig Loop Exit Block| |Cloned Loop Exit Block|; // +--------------------+ +-----------+----------+; // | |; // +----------+--------------+-----------+; // |; // +-----+----+; // |Join Block|; // +----------+",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:1713,Security,access,accesses,1713,"oning will create a version of the loop with aggressive aliasing; // assumptions in addition to the original with conservative (default) aliasing; // assumptions. The version of the loop making aggressive aliasing assumptions; // will have all the memory accesses marked as no-alias. These two versions of; // loop will be preceded by a memory runtime check. This runtime check consists; // of bound checks for all unique memory accessed in loop, and it ensures the; // lack of memory aliasing. The result of the runtime check determines which of; // the loop versions is executed: If the runtime check detects any memory; // aliasing, then the original loop is executed. Otherwise, the version with; // aggressive aliasing assumptions is used.; //; // Following are the top level steps:; //; // a) Perform LoopVersioningLICM's feasibility check.; // b) If loop is a candidate for versioning then create a memory bound check,; // by considering all the memory accesses in loop body.; // c) Clone original loop and set all memory accesses as no-alias in new loop.; // d) Set original loop & versioned loop as a branch target of the runtime check; // result.; //; // It transforms loop as shown below:; //; // +----------------+; // |Runtime Memcheck|; // +----------------+; // |; // +----------+----------------+----------+; // | |; // +---------+----------+ +-----------+----------+; // |Orig Loop Preheader | |Cloned Loop Preheader |; // +--------------------+ +----------------------+; // | |; // +--------------------+ +----------------------+; // |Orig Loop Body | |Cloned Loop Body |; // +--------------------+ +----------------------+; // | |; // +--------------------+ +----------------------+; // |Orig Loop Exit Block| |Cloned Loop Exit Block|; // +--------------------+ +-----------+----------+; // | |; // +----------+--------------+-----------+; // |; // +-----+----+; // |Join Block|; // +----------+; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:147,Safety,safe,safe,147,// We don't explicitly pass in LoopAccessInfo to the constructor since the; // loop versioning might return early due to instructions that are not safe; // for versioning. By passing the proxy instead the construction of; // LoopAccessInfo will take place only when it's necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:27,Performance,load,load,27,// Counter to track num of load & store,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:3,Performance,Optimiz,OptimizationRemarkEmitter,3,// OptimizationRemarkEmitter,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:24,Usability,simpl,simplify,24,// Loop must be in loop simplify form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:25,Testability,test,tested,25,"// We only handle bottom-tested loop, i.e. loop in which the condition is; // checked at the end of each iteration. With that we can assume that all; // instructions in the loop are executed the same number of times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:63,Security,access,accesses,63,// Parallel loops must not have aliasing loop-invariant memory accesses.; // Hence we don't need to version anything in this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:17,Security,access,accesses,17,/// Check memory accesses in loop and confirms it's good for; /// LoopVersioningLICM.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:306,Safety,avoid,avoided,306,"// Memory check:; // Transform phase will generate a versioned loop and also a runtime check to; // ensure the pointers are independent and they dont alias.; // In version variant of loop, alias meta data asserts that all access are; // mutually independent.; //; // Pointers aliasing in alias domain are avoided because with multiple; // aliasing domains we may not be able to hoist potential loop invariant; // access out of the loop.; //; // Iterate over alias tracker sets, and confirm AliasSets doesn't have any; // must alias set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:223,Security,access,access,223,"// Memory check:; // Transform phase will generate a versioned loop and also a runtime check to; // ensure the pointers are independent and they dont alias.; // In version variant of loop, alias meta data asserts that all access are; // mutually independent.; //; // Pointers aliasing in alias domain are avoided because with multiple; // aliasing domains we may not be able to hoist potential loop invariant; // access out of the loop.; //; // Iterate over alias tracker sets, and confirm AliasSets doesn't have any; // must alias set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:414,Security,access,access,414,"// Memory check:; // Transform phase will generate a versioned loop and also a runtime check to; // ensure the pointers are independent and they dont alias.; // In version variant of loop, alias meta data asserts that all access are; // mutually independent.; //; // Pointers aliasing in alias domain are avoided because with multiple; // aliasing domains we may not be able to hoist potential loop invariant; // access out of the loop.; //; // Iterate over alias tracker sets, and confirm AliasSets doesn't have any; // must alias set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:206,Testability,assert,asserts,206,"// Memory check:; // Transform phase will generate a versioned loop and also a runtime check to; // ensure the pointers are independent and they dont alias.; // In version variant of loop, alias meta data asserts that all access are; // mutually independent.; //; // Pointers aliasing in alias domain are avoided because with multiple; // aliasing domains we may not be able to hoist potential loop invariant; // access out of the loop.; //; // Iterate over alias tracker sets, and confirm AliasSets doesn't have any; // must alias set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:167,Security,access,accesses,167,"// Alias tracker should have pointers of same data type.; //; // FIXME: check no longer effective since opaque pointers?; // If the intent is to check that the memory accesses use the; // same data type (such that LICM can promote them), then we; // can no longer see this from the pointer value types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:151,Performance,load,load,151,"/// Check loop instructions safe for Loop versioning.; /// It returns true if it's safe else returns false.; /// Consider following:; /// 1) Check all load store in loop body are non atomic & non volatile.; /// 2) Check function call safety, by ensuring its not accessing memory.; /// 3) Loop body shouldn't have any may throw instruction.; /// 4) Loop body shouldn't have any convergent or noduplicate instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:28,Safety,safe,safe,28,"/// Check loop instructions safe for Loop versioning.; /// It returns true if it's safe else returns false.; /// Consider following:; /// 1) Check all load store in loop body are non atomic & non volatile.; /// 2) Check function call safety, by ensuring its not accessing memory.; /// 3) Loop body shouldn't have any may throw instruction.; /// 4) Loop body shouldn't have any convergent or noduplicate instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:83,Safety,safe,safe,83,"/// Check loop instructions safe for Loop versioning.; /// It returns true if it's safe else returns false.; /// Consider following:; /// 1) Check all load store in loop body are non atomic & non volatile.; /// 2) Check function call safety, by ensuring its not accessing memory.; /// 3) Loop body shouldn't have any may throw instruction.; /// 4) Loop body shouldn't have any convergent or noduplicate instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:234,Safety,safe,safety,234,"/// Check loop instructions safe for Loop versioning.; /// It returns true if it's safe else returns false.; /// Consider following:; /// 1) Check all load store in loop body are non atomic & non volatile.; /// 2) Check function call safety, by ensuring its not accessing memory.; /// 3) Loop body shouldn't have any may throw instruction.; /// 4) Loop body shouldn't have any convergent or noduplicate instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:262,Security,access,accessing,262,"/// Check loop instructions safe for Loop versioning.; /// It returns true if it's safe else returns false.; /// Consider following:; /// 1) Check all load store in loop body are non atomic & non volatile.; /// 2) Check function call safety, by ensuring its not accessing memory.; /// 3) Loop body shouldn't have any may throw instruction.; /// 4) Loop body shouldn't have any convergent or noduplicate instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:23,Safety,safe,safety,23,// Check function call safety,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:3,Safety,Avoid,Avoid,3,// Avoid loops with possiblity of throw,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:29,Performance,load,load,29,// If current instruction is load instructions; // make sure it's a simple load (non atomic & non volatile),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:75,Performance,load,load,75,// If current instruction is load instructions; // make sure it's a simple load (non atomic & non volatile),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:68,Usability,simpl,simple,68,// If current instruction is load instructions; // make sure it's a simple load (non atomic & non volatile),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:68,Usability,simpl,simple,68,// If current instruction is store instruction; // make sure it's a simple store (non atomic & non volatile),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:85,Safety,safe,safety,85,// Iterate over loop blocks and instructions of each block and check; // instruction safety.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:21,Safety,unsafe,unsafe,21,// If instruction is unsafe just return false.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:43,Performance,load,load,43,// Loop should have at least one invariant load or store instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:150,Security,access,access,150,/// Checks legality for LoopVersioningLICM by considering following:; /// a) loop structure legality b) loop instruction legality; /// c) loop memory access legality.; /// Return true if legal else returns false.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:21,Security,access,access,21,// Check loop memory access leagality.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:4,Deployability,Update,Update,4,/// Update loop with aggressive aliasing assumptions.; /// It marks no-alias to any pairs of memory operations by assuming; /// loop should not have any must-alias memory accesses pairs.; /// During LoopVersioningLICM legality we ignore loops having must; /// aliasing memory accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:171,Security,access,accesses,171,/// Update loop with aggressive aliasing assumptions.; /// It marks no-alias to any pairs of memory operations by assuming; /// loop should not have any must-alias memory accesses pairs.; /// During LoopVersioningLICM legality we ignore loops having must; /// aliasing memory accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:276,Security,access,accesses,276,/// Update loop with aggressive aliasing assumptions.; /// It marks no-alias to any pairs of memory operations by assuming; /// loop should not have any must-alias memory accesses pairs.; /// During LoopVersioningLICM legality we ignore loops having must; /// aliasing memory accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:67,Performance,load,load,67,// Iterate over each instruction of loop.; // set no-alias for all load & store instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:119,Usability,simpl,simply,119,"// Check feasiblity of LoopVersioningLICM.; // If versioning found to be feasible and beneficial then proceed; // else simply return, by cleaning up memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:54,Security,access,accessed,54,"// Do loop versioning.; // Create memcheck for memory accessed inside loop.; // Clone original loop, and set blocks properly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:127,Security,access,access,127,"// Set ""llvm.mem.parallel_loop_access"" metaData to versioned loop.; // FIXME: ""llvm.mem.parallel_loop_access"" annotates memory access; // instructions, not loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:3,Deployability,Update,Update,3,// Update version loop with aggressive aliasing assumption.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerConstantIntrinsics.cpp:262,Usability,Simpl,Simplify,262,/// Legacy pass for lowering is.constant intrinsics out of the IR.; ///; /// When this pass is run over a function it converts is.constant intrinsics; /// into 'true' or 'false'. This complements the normal constant folding; /// to 'true' as part of Instruction Simplify passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerConstantIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerConstantIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerExpectIntrinsic.cpp:549,Security,expose,exposed,549,"// These default values are chosen to represent an extremely skewed outcome for; // a condition, but they leave some room for interpretation by later passes.; //; // If the documentation for __builtin_expect() was made explicit that it should; // only be used in extreme cases, we could make this ratio higher. As it stands,; // programmers may be using __builtin_expect() / llvm.expect to annotate that a; // branch is likely or unlikely to be taken.; // WARNING: these values are internal implementation detail of the pass.; // They should not be exposed to the outside of the pass, front-end codegen; // should emit @llvm.expect intrinsics instead of using these weights directly.; // Transforms should use TargetTransformInfo's getPredictableBranchThreshold().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerExpectIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerExpectIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerExpectIntrinsic.cpp:14,Performance,optimiz,optimized,14,"// Handle non-optimized IR code like:; // %expval = call i64 @llvm.expect.i64(i64 %conv1, i64 1); // %tobool = icmp ne i64 %expval, 0; // br i1 %tobool, label %if.then, label %if.end; //; // Or the following simpler case:; // %expval = call i1 @llvm.expect.i1(i1 %cmp, i1 1); // br i1 %expval, label %if.then, label %if.end",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerExpectIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerExpectIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerExpectIntrinsic.cpp:208,Usability,simpl,simpler,208,"// Handle non-optimized IR code like:; // %expval = call i64 @llvm.expect.i64(i64 %conv1, i64 1); // %tobool = icmp ne i64 %expval, 0; // br i1 %tobool, label %if.then, label %if.end; //; // Or the following simpler case:; // %expval = call i1 @llvm.expect.i1(i1 %cmp, i1 1); // br i1 %expval, label %if.then, label %if.end",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerExpectIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerExpectIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:50,Safety,avoid,avoid,50,/// Erase \p V from \p BB and move \II forward to avoid invalidating; /// iterators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:919,Deployability,Update,Update,919,"/// LowerMatrixIntrinsics contains the methods used to lower matrix intrinsics.; ///; /// Currently, the lowering for each matrix intrinsic is done as follows:; /// 1. Propagate the shape information from intrinsics to connected; /// instructions.; /// 2. Lower instructions with shape information (assuming column-major layout).; /// The lowering works similarly using row-major layout.; /// 2.1. Get column vectors for each argument. If we already lowered the; /// definition of an argument, use the produced column vectors directly.; /// If not, split the operand vector containing an embedded matrix into; /// a set of column vectors,; /// 2.2. Lower the instruction in terms of column major operations, which; /// yields a set of column vectors containing result matrix. Note that we; /// lower all instructions that have shape information. Besides the; /// intrinsics, this includes stores for example.; /// 2.3. Update uses of the lowered instruction. If we have shape information; /// for a user, there is nothing to do, as we will look up the result; /// column matrix when lowering the user. For other uses, we embed the; /// result matrix in a flat vector and update the use.; /// 2.4. Cache the result column matrix for the instruction we lowered; /// 3. After we lowered all instructions in a function, remove the now; /// obsolete instructions.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:1171,Deployability,update,update,1171,"/// LowerMatrixIntrinsics contains the methods used to lower matrix intrinsics.; ///; /// Currently, the lowering for each matrix intrinsic is done as follows:; /// 1. Propagate the shape information from intrinsics to connected; /// instructions.; /// 2. Lower instructions with shape information (assuming column-major layout).; /// The lowering works similarly using row-major layout.; /// 2.1. Get column vectors for each argument. If we already lowered the; /// definition of an argument, use the produced column vectors directly.; /// If not, split the operand vector containing an embedded matrix into; /// a set of column vectors,; /// 2.2. Lower the instruction in terms of column major operations, which; /// yields a set of column vectors containing result matrix. Note that we; /// lower all instructions that have shape information. Besides the; /// intrinsics, this includes stores for example.; /// 2.3. Update uses of the lowered instruction. If we have shape information; /// for a user, there is nothing to do, as we will look up the result; /// column matrix when lowering the user. For other uses, we embed the; /// result matrix in a flat vector and update the use.; /// 2.4. Cache the result column matrix for the instruction we lowered; /// 3. After we lowered all instructions in a function, remove the now; /// obsolete instructions.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:1197,Performance,Cache,Cache,1197,"/// LowerMatrixIntrinsics contains the methods used to lower matrix intrinsics.; ///; /// Currently, the lowering for each matrix intrinsic is done as follows:; /// 1. Propagate the shape information from intrinsics to connected; /// instructions.; /// 2. Lower instructions with shape information (assuming column-major layout).; /// The lowering works similarly using row-major layout.; /// 2.1. Get column vectors for each argument. If we already lowered the; /// definition of an argument, use the produced column vectors directly.; /// If not, split the operand vector containing an embedded matrix into; /// a set of column vectors,; /// 2.2. Lower the instruction in terms of column major operations, which; /// yields a set of column vectors containing result matrix. Note that we; /// lower all instructions that have shape information. Besides the; /// intrinsics, this includes stores for example.; /// 2.3. Update uses of the lowered instruction. If we have shape information; /// for a user, there is nothing to do, as we will look up the result; /// column matrix when lowering the user. For other uses, we embed the; /// result matrix in a flat vector and update the use.; /// 2.4. Cache the result column matrix for the instruction we lowered; /// 3. After we lowered all instructions in a function, remove the now; /// obsolete instructions.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:52,Performance,load,loads,52,"/// Contains estimates of the number of operations (loads, stores, compute) required to lower a matrix operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:14,Performance,load,loads,14,/// Number of loads emitted to generate this matrix.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:203,Performance,optimiz,optimizations,203,"/// Most of the time transposes can be fused with matrix multiplies or can; /// be folded away via algebraic simplifications. This is the number of; /// transposes that we failed to make ""free"" via such optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:109,Usability,simpl,simplifications,109,"/// Most of the time transposes can be fused with matrix multiplies or can; /// be folded away via algebraic simplifications. This is the number of; /// transposes that we failed to make ""free"" via such optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:4,Integrability,Wrap,Wrapper,4,"/// Wrapper class representing a matrix as a set of vectors, either in row or; /// column major layout. All vectors must have the same vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:474,Performance,optimiz,optimizeTransposes,474,"/// Maps instructions to their shape information. The shape information; /// describes the shape to be used while lowering. This matches the shape of; /// the result value of the instruction, with the only exceptions being store; /// instructions and the matrix_column_major_store intrinsics. For those, the; /// shape information indicates that those instructions should be lowered; /// using shape information as well. A ValueMap is used so that when; /// sub-passes like optimizeTransposes performs RAUW the map stays; /// up-to-date.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:493,Performance,perform,performs,493,"/// Maps instructions to their shape information. The shape information; /// describes the shape to be used while lowering. This matches the shape of; /// the result value of the instruction, with the only exceptions being store; /// instructions and the matrix_column_major_store intrinsics. For those, the; /// shape information indicates that those instructions should be lowered; /// using shape information as well. A ValueMap is used so that when; /// sub-passes like optimizeTransposes performs RAUW the map stays; /// up-to-date.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:138,Availability,avail,available,138,"/// List of instructions to remove. While lowering, we are not replacing all; /// users of a lowered instruction, if shape information is available and; /// those need to be removed after we finished lowering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:56,Deployability,pipeline,pipelines,56,/// Is this the minimal version executed in the backend pipelines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:119,Performance,cache,cache,119,"/// Return the set of vectors that a matrix value is lowered to.; ///; /// If we lowered \p MatrixVal, just return the cache result matrix. Otherwise; /// split the flat vector \p MatrixVal containing a matrix with shape \p SI; /// into vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:187,Safety,avoid,avoid,187,"/// Sink a top-level transpose inside matmuls and adds.; /// This creates and erases instructions as needed, and returns the newly; /// created instruction while updating the iterator to avoid invalidation. If; /// this returns nullptr, no new instruction was created.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:3,Safety,Avoid,Avoid,3,// Avoid unnecessary work if there are no matrix intrinsics in the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:86,Deployability,update,update,86,"// Delete the instructions backwards, as it has a reduced likelihood of; // having to update as many def-use and use-def chains.; //; // Because we add to ToRemove during fusion we can't guarantee that defs; // are before uses. Change uses to poison temporarily as these should get; // removed as well.; //; // For verification, we keep track of where we changed uses to poison in; // PoisonedInsts and then check that we in fact remove them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:50,Energy Efficiency,reduce,reduced,50,"// Delete the instructions backwards, as it has a reduced likelihood of; // having to update as many def-use and use-def chains.; //; // Because we add to ToRemove during fusion we can't guarantee that defs; // are before uses. Change uses to poison temporarily as these should get; // removed as well.; //; // For verification, we keep track of where we changed uses to poison in; // PoisonedInsts and then check that we in fact remove them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:62,Availability,error,error,62,"// If we didn't remove all poisoned instructions, it's a hard error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:167,Energy Efficiency,reduce,reduce,167,"/// Compute the alignment for a column/row \p Idx with \p Stride between them.; /// The address at \p Idx == 0 has alignment \p A. If \p Stride is a; /// ConstantInt, reduce the initial alignment based on the byte offset. For; /// non-ConstantInt strides, return the common alignment of the initial; /// alignment and the element size in bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:4,Performance,Load,Load,4,/// Load a matrix with \p Shape starting at \p Ptr and using \p Stride between; /// vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:4,Performance,Load,Loads,4,"/// Loads a sub-matrix with shape \p ResultShape from a \p R x \p C matrix,; /// starting at \p MatrixPtr[I][J].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:12,Performance,load,load,12,/// Lower a load instruction with shape information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:36,Performance,load,load,36,/// Lowers llvm.matrix.column.major.load.; ///; /// The intrinsic loads a matrix from memory using a stride between columns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:66,Performance,load,loads,66,/// Lowers llvm.matrix.column.major.load.; ///; /// The intrinsic loads a matrix from memory using a stride between columns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:57,Availability,mask,mask,57,"// If Col is 7 long and I is 2 and BlockNumElts is 2 the mask is: 0, 1, 7,; // 8, 4, 5, 6",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:45,Deployability,update,update,45,"/// Cache \p Matrix as result of \p Inst and update the uses of \p Inst. For; /// users with shape information, there's nothing to do: they will use the; /// cached value when they are lowered. For other users, \p Matrix is; /// flattened and the uses are updated to use it. Also marks \p Inst for; /// deletion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:256,Deployability,update,updated,256,"/// Cache \p Matrix as result of \p Inst and update the uses of \p Inst. For; /// users with shape information, there's nothing to do: they will use the; /// cached value when they are lowered. For other users, \p Matrix is; /// flattened and the uses are updated to use it. Also marks \p Inst for; /// deletion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:4,Performance,Cache,Cache,4,"/// Cache \p Matrix as result of \p Inst and update the uses of \p Inst. For; /// users with shape information, there's nothing to do: they will use the; /// cached value when they are lowered. For other users, \p Matrix is; /// flattened and the uses are updated to use it. Also marks \p Inst for; /// deletion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:158,Performance,cache,cached,158,"/// Cache \p Matrix as result of \p Inst and update the uses of \p Inst. For; /// users with shape information, there's nothing to do: they will use the; /// cached value when they are lowered. For other users, \p Matrix is; /// flattened and the uses are updated to use it. Also marks \p Inst for; /// deletion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:54,Performance,load,loads,54,/// Special case for MatMul lowering. Prevents scalar loads of row-major; /// vectors Lowers to vector reduction add instead of sequential add if; /// reassocation is enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:13,Performance,load,loads,13,// Costs for loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:36,Energy Efficiency,reduce,reduce,36,// We compare the costs of a vector.reduce.add to sequential add.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:35,Performance,load,loads,35,// Matmul must be the only user of loads because we don't use LowerLoad; // for row vectors (LowerLoad results in scalar loads and shufflevectors; // instead of single vector load).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:121,Performance,load,loads,121,// Matmul must be the only user of loads because we don't use LowerLoad; // for row vectors (LowerLoad results in scalar loads and shufflevectors; // instead of single vector load).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:175,Performance,load,load,175,// Matmul must be the only user of loads because we don't use LowerLoad; // for row vectors (LowerLoad results in scalar loads and shufflevectors; // instead of single vector load).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:30,Performance,load,load,30,"// If vector uses the builtin load, lower to a LoadInst",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:47,Performance,Load,LoadInst,47,"// If vector uses the builtin load, lower to a LoadInst",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:35,Energy Efficiency,reduce,reduce,35,// Insert mul/fmul and llvm.vector.reduce.fadd,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:33,Performance,Load,Load,33,/// Ensure that the memory in \p Load does not alias \p Store by potentially; /// copying it to a new location. This new or otherwise the original location; /// is returned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:55,Performance,Load,Load,55,"// Create code to check if the memory locations of the Load and Store; // overlap and if they do, copy Load's operand to a new buffer.; // First, create new blocks for 2n part of the check and the copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:103,Performance,Load,Load,103,"// Create code to check if the memory locations of the Load and Store; // overlap and if they do, copy Load's operand to a new buffer.; // First, create new blocks for 2n part of the check and the copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:27,Deployability,update,update,27,"// FIXME: Use lazy DTU and update SplitBlock to accept a DTU instead of a; // DT. Manually collect dominator tree updates, to avoid unnecessary work,; // as we adjust Check0 and Check1's branches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:114,Deployability,update,updates,114,"// FIXME: Use lazy DTU and update SplitBlock to accept a DTU instead of a; // DT. Manually collect dominator tree updates, to avoid unnecessary work,; // as we adjust Check0 and Check1's branches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:126,Safety,avoid,avoid,126,"// FIXME: Use lazy DTU and update SplitBlock to accept a DTU instead of a; // DT. Manually collect dominator tree updates, to avoid unnecessary work,; // as we adjust Check0 and Check1's branches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:16,Performance,load,loaded,16,"// Check if the loaded memory location begins before the end of the store; // location. If the condition holds, they might overlap, otherwise they are; // guaranteed to not overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:51,Performance,load,load,51,"// Check if the store begins before the end of the load location. If the; // condition holds, they alias, otherwise they are guaranteed to not; // overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:8,Performance,load,load,8,// Copy load operand to new alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:40,Safety,avoid,avoid,40,"// Use an array type for the alloca, to avoid potentially huge alignment; // requirements for large vector types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:165,Performance,load,loads,165,// Then we need enough elements to exceed the number of vector; // registers we have. Note that this is an oversimplification since; // fusing also takes some extra loads which may exceed the number of; // reloads necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:60,Performance,Load,Load,60,"// Insert in the inner loop body, which computes; // Res += Load(CurrentRow, K) * Load(K, CurrentColumn)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:82,Performance,Load,Load,82,"// Insert in the inner loop body, which computes; // Res += Load(CurrentRow, K) * Load(K, CurrentColumn)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:3,Performance,Load,Load,3,// Load tiles of the operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:171,Usability,simpl,simplifications,171,"// TODO: Improve estimate of operations needed for transposes. Currently we; // just count the insertelement/extractelement instructions, but do not; // account for later simplifications/combines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:53,Availability,avail,available,53,"/// Lower load instructions, if shape information is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:10,Performance,load,load,10,"/// Lower load instructions, if shape information is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:52,Availability,avail,available,52,"/// Lower binary operators, if shape information is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:13,Performance,perform,perform,13,// Helper to perform binary op on vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:51,Availability,avail,available,51,"/// Lower unary operators, if shape information is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:13,Performance,perform,perform,13,// Helper to perform unary op on vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:29,Performance,Optimiz,Optimize,29,"//===- MemCpyOptimizer.cpp - Optimize use of memcpy and friends -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs various transformations related to eliminating memcpy; // calls, or transforming sets of stores into memset's.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:393,Performance,perform,performs,393,"//===- MemCpyOptimizer.cpp - Optimize use of memcpy and friends -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs various transformations related to eliminating memcpy; // calls, or transforming sets of stores into memset's.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:331,Modifiability,extend,extends,331,"/// Represents a range of memset'd bytes with the ByteVal value.; /// This allows us to analyze stores like:; /// store 0 -> P+1; /// store 0 -> P+0; /// store 0 -> P+3; /// store 0 -> P+2; /// which sometimes happens with stores to arrays of structs etc. When we see; /// the first store, we make a range [1, 2). The second store extends the range; /// to [0, 2). The third makes a new range [2, 3). The fourth store joins the; /// two ranges into [0, 3) which is memset'able.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:64,Modifiability,extend,extend,64,"// If any of the stores are a memset, then it is always good to extend the; // memset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:328,Performance,optimiz,optimizer,328,"// If we have fewer than 8 stores, it can still be worthwhile to do this.; // For example, merging 4 i8 stores into an i32 store is useful almost always.; // However, merging 2 32-bit stores isn't useful on a 32-bit architecture (the; // memset will be split into 2 32-bit stores anyway) and doing so can; // pessimize the llvm optimizer.; //; // Since we don't have perfect knowledge here, make some assumptions: assume; // the maximum GPR width is the same size as the largest legal integer; // size. If so, check to see whether we will end up actually reducing the; // number of stores used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:14,Energy Efficiency,reduce,reduce,14,"// If we will reduce the # stores (according to this heuristic), do the; // transformation. This encourages merging 4 x i8 -> i32 and 2 x i16 -> i32; // etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:151,Modifiability,extend,extends,151,"// Now we know that Start <= I->End and End >= I->Start so the range overlaps; // but is not entirely contained within the range.; // See if the range extends the start of the range. In this case, it couldn't; // possibly cause it to join the prior range, because otherwise we would have; // stopped on *it*.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:140,Modifiability,Extend,Extend,140,"// Now we know that Start <= I->End and Start >= I->Start (so the startpoint; // is in or right at the end of I), and that End >= I->Start. Extend I out to; // End.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:223,Security,access,accessible,223,"//===----------------------------------------------------------------------===//; // MemCpyOptLegacyPass Pass; //===----------------------------------------------------------------------===//; // Check that V is either not accessible by the caller, or unwinding cannot; // occur between Start and End.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:101,Security,access,accesses,101,"// For MemoryUses, getClobberingMemoryAccess may skip non-clobbering writes.; // Manually check read accesses between Start and End, if they are in the; // same block, for clobbers. Otherwise assume Loc is clobbered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:3,Deployability,Update,Update,3,// Update AA metadata,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:18,Performance,scalab,scalable,18,// We can't track scalable types,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:19,Security,access,access,19,// Calls that only access inaccessible memory do not block merging; // accessible stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:71,Security,access,accessible,71,// Calls that only access inaccessible memory do not block merging; // accessible stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:35,Performance,scalab,scalable,35,// We can't track ranges involving scalable types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:189,Performance,optimiz,optimization,189,"// If we had at least one store that could be merged in, add the starting; // store as well. We try to avoid this unless there is at least something; // interesting as a small compile-time optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:103,Safety,avoid,avoid,103,"// If we had at least one store that could be merged in, add the starting; // store as well. We try to avoid this unless there is at least something; // interesting as a small compile-time optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:31,Performance,perform,perform,31,// Make sure hoisting does not perform a store that was not guaranteed to; // happen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:32,Availability,down,downwards,32,"// Since LI is implicitly moved downwards past the lifted instructions,; // none of them may modify its source.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:154,Deployability,pipeline,pipelines,154,"// Find MSSA insertion point. Normally P will always have a corresponding; // memory access before which we can insert. However, with non-standard AA; // pipelines, there may be a mismatch between AA and MSSA, in which case we; // will scan for a memory access before P. In either case, we know for sure; // that at least the load will have a memory access.; // TODO: Simplify this once P will be determined by MSSA, in which case the; // discrepancy can no longer occur.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:326,Performance,load,load,326,"// Find MSSA insertion point. Normally P will always have a corresponding; // memory access before which we can insert. However, with non-standard AA; // pipelines, there may be a mismatch between AA and MSSA, in which case we; // will scan for a memory access before P. In either case, we know for sure; // that at least the load will have a memory access.; // TODO: Simplify this once P will be determined by MSSA, in which case the; // discrepancy can no longer occur.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:85,Security,access,access,85,"// Find MSSA insertion point. Normally P will always have a corresponding; // memory access before which we can insert. However, with non-standard AA; // pipelines, there may be a mismatch between AA and MSSA, in which case we; // will scan for a memory access before P. In either case, we know for sure; // that at least the load will have a memory access.; // TODO: Simplify this once P will be determined by MSSA, in which case the; // discrepancy can no longer occur.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:254,Security,access,access,254,"// Find MSSA insertion point. Normally P will always have a corresponding; // memory access before which we can insert. However, with non-standard AA; // pipelines, there may be a mismatch between AA and MSSA, in which case we; // will scan for a memory access before P. In either case, we know for sure; // that at least the load will have a memory access.; // TODO: Simplify this once P will be determined by MSSA, in which case the; // discrepancy can no longer occur.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:350,Security,access,access,350,"// Find MSSA insertion point. Normally P will always have a corresponding; // memory access before which we can insert. However, with non-standard AA; // pipelines, there may be a mismatch between AA and MSSA, in which case we; // will scan for a memory access before P. In either case, we know for sure; // that at least the load will have a memory access.; // TODO: Simplify this once P will be determined by MSSA, in which case the; // discrepancy can no longer occur.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:368,Usability,Simpl,Simplify,368,"// Find MSSA insertion point. Normally P will always have a corresponding; // memory access before which we can insert. However, with non-standard AA; // pipelines, there may be a mismatch between AA and MSSA, in which case we; // will scan for a memory access before P. In either case, we know for sure; // that at least the load will have a memory access.; // TODO: Simplify this once P will be determined by MSSA, in which case the; // discrepancy can no longer occur.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:112,Availability,avail,available,112,// Don't introduce calls to memcpy/memmove intrinsics out of thin air if; // the corresponding libcalls are not available.; // TODO: We should really distinguish between libcall availability and; // our ability to introduce intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:178,Availability,avail,availability,178,// Don't introduce calls to memcpy/memmove intrinsics out of thin air if; // the corresponding libcalls are not available.; // TODO: We should really distinguish between libcall availability and; // our ability to introduce intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:83,Performance,load,load,83,"// We use alias analysis to check if an instruction may store to; // the memory we load from in between the load and the store. If; // such an instruction is found, we try to promote there instead; // of at the store position.; // TODO: Can use MSSA for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:108,Performance,load,load,108,"// We use alias analysis to check if an instruction may store to; // the memory we load from in between the load and the store. If; // such an instruction is found, we try to promote there instead; // of at the store position.; // TODO: Can use MSSA for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:49,Performance,load,loaded,49,// We found an instruction that may write to the loaded memory.; // We can try to promote at this position instead of the store; // position if nothing aliases the store memory after this and the store; // destination is not in the range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:71,Performance,load,load,71,"// If a valid insertion position is found, then we can promote; // the load/store pair to a memcpy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:9,Performance,load,load,9,"// If we load from memory that may alias the memory we store to,; // memmove must be used to preserve semantic. If not, memcpy can; // be used. Also, if we load from constant memory, memcpy can be used; // as the constant memory won't be modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:156,Performance,load,load,156,"// If we load from memory that may alias the memory we store to,; // memmove must be used to preserve semantic. If not, memcpy can; // be used. Also, if we load from constant memory, memcpy can be used; // as the constant memory won't be modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:28,Performance,perform,performing,28,"// Detect cases where we're performing call slot forwarding, but; // happen to be using a load-store pair to implement it, rather than; // a memcpy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:90,Performance,load,load-store,90,"// Detect cases where we're performing call slot forwarding, but; // happen to be using a load-store pair to implement it, rather than; // a memcpy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:3,Safety,Detect,Detect,3,"// Detect cases where we're performing call slot forwarding, but; // happen to be using a load-store pair to implement it, rather than; // a memcpy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:103,Performance,perform,performCallSlotOptzn,103,// We defer this expensive clobber walk until the cheap checks; // have been done on the source inside performCallSlotOptzn.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:16,Performance,load,load-store,16,"// If this is a load-store pair from a stack slot to a stack slot, we; // might be able to perform the stack-move optimization just as we do for; // memcpys from an alloca to an alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:91,Performance,perform,perform,91,"// If this is a load-store pair from a stack slot to a stack slot, we; // might be able to perform the stack-move optimization just as we do for; // memcpys from an alloca to an alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:114,Performance,optimiz,optimization,114,"// If this is a load-store pair from a stack slot to a stack slot, we; // might be able to perform the stack-move optimization just as we do for; // memcpys from an alloca to an alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:3,Safety,Avoid,Avoid,3,// Avoid invalidating the iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:3,Safety,Avoid,Avoid,3,"// Avoid merging nontemporal stores since the resulting; // memcpy/memset would not be able to preserve the nontemporal hint.; // In theory we could teach how to propagate the !nontemporal metadata to; // memset calls. However, that change would force the backend to; // conservatively expand !nontemporal memset calls back to sequences of; // store instructions (effectively undoing the merging).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:376,Usability,undo,undoing,376,"// Avoid merging nontemporal stores since the resulting; // memcpy/memset would not be able to preserve the nontemporal hint.; // In theory we could teach how to propagate the !nontemporal metadata to; // memset calls. However, that change would force the backend to; // conservatively expand !nontemporal memset calls back to sequences of; // store instructions (effectively undoing the merging).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:92,Security,audit,audited,92,"// Not all the transforms below are correct for non-integral pointers, bail; // until we've audited the individual pieces.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:3,Performance,Load,Load,3,// Load to store forwarding can be interpreted as memcpy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:119,Availability,avail,available,119,// The following code creates memset intrinsics out of thin air. Don't do; // this if the corresponding libfunc is not available.; // TODO: We should really distinguish between libcall availability and; // our ability to introduce intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:185,Availability,avail,availability,185,// The following code creates memset intrinsics out of thin air. Don't do; // this if the corresponding libfunc is not available.; // TODO: We should really distinguish between libcall availability and; // our ability to introduce intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:118,Performance,optimiz,optimization,118,"// If we have an aggregate, we try to promote it to memset regardless; // of opportunity for merging as it can expose optimization opportunities; // in subsequent passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:111,Security,expose,expose,111,"// If we have an aggregate, we try to promote it to memset regardless; // of opportunity for merging as it can expose optimization opportunities; // in subsequent passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:38,Integrability,depend,depends,38,"/// Takes a memcpy and a call that it depends on,; /// and checks for the possibility of a call slot optimization by having; /// the call write its result directly into the destination of the memcpy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:101,Performance,optimiz,optimization,101,"/// Takes a memcpy and a call that it depends on,; /// and checks for the possibility of a call slot optimization by having; /// the call write its result directly into the destination of the memcpy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:410,Performance,optimiz,optimize,410,"// The general transformation to keep in mind is; //; // call @func(..., src, ...); // memcpy(dest, src, ...); //; // ->; //; // memcpy(dest, src, ...); // call @func(..., dest, ...); //; // Since moving the memcpy is technically awkward, we additionally check that; // src only holds uninitialized values at the moment of the call, meaning that; // the memcpy can be discarded rather than moved.; // We can't optimize scalable types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:419,Performance,scalab,scalable,419,"// The general transformation to keep in mind is; //; // call @func(..., src, ...); // memcpy(dest, src, ...); //; // ->; //; // memcpy(dest, src, ...); // call @func(..., dest, ...); //; // Since moving the memcpy is technically awkward, we additionally check that; // src only holds uninitialized values at the moment of the call, meaning that; // the memcpy can be discarded rather than moved.; // We can't optimize scalable types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:39,Usability,simpl,simplifies,39,// Require that src be an alloca. This simplifies the reasoning considerably.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:12,Performance,optimiz,optimize,12,// We can't optimize scalable types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:21,Performance,scalab,scalable,21,// We can't optimize scalable types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:137,Security,access,accessed,137,"// Make sure that nothing can observe cpyDest being written early. There are; // a number of cases to consider:; // 1. cpyDest cannot be accessed between C and cpyStore as a precondition of; // the transform.; // 2. C itself may not access cpyDest (prior to the transform). This is; // checked further below.; // 3. If cpyDest is accessible to the caller of this function (potentially; // captured and not based on an alloca), we need to ensure that we cannot; // unwind between C and cpyStore. This is checked here.; // 4. If cpyDest is potentially captured, there may be accesses to it from; // another thread. In this case, we need to check that cpyStore is; // guaranteed to be executed if C is. As it is a non-atomic access, it; // renders accesses from other threads undefined.; // TODO: This is currently not checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:233,Security,access,access,233,"// Make sure that nothing can observe cpyDest being written early. There are; // a number of cases to consider:; // 1. cpyDest cannot be accessed between C and cpyStore as a precondition of; // the transform.; // 2. C itself may not access cpyDest (prior to the transform). This is; // checked further below.; // 3. If cpyDest is accessible to the caller of this function (potentially; // captured and not based on an alloca), we need to ensure that we cannot; // unwind between C and cpyStore. This is checked here.; // 4. If cpyDest is potentially captured, there may be accesses to it from; // another thread. In this case, we need to check that cpyStore is; // guaranteed to be executed if C is. As it is a non-atomic access, it; // renders accesses from other threads undefined.; // TODO: This is currently not checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:330,Security,access,accessible,330,"// Make sure that nothing can observe cpyDest being written early. There are; // a number of cases to consider:; // 1. cpyDest cannot be accessed between C and cpyStore as a precondition of; // the transform.; // 2. C itself may not access cpyDest (prior to the transform). This is; // checked further below.; // 3. If cpyDest is accessible to the caller of this function (potentially; // captured and not based on an alloca), we need to ensure that we cannot; // unwind between C and cpyStore. This is checked here.; // 4. If cpyDest is potentially captured, there may be accesses to it from; // another thread. In this case, we need to check that cpyStore is; // guaranteed to be executed if C is. As it is a non-atomic access, it; // renders accesses from other threads undefined.; // TODO: This is currently not checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:573,Security,access,accesses,573,"// Make sure that nothing can observe cpyDest being written early. There are; // a number of cases to consider:; // 1. cpyDest cannot be accessed between C and cpyStore as a precondition of; // the transform.; // 2. C itself may not access cpyDest (prior to the transform). This is; // checked further below.; // 3. If cpyDest is accessible to the caller of this function (potentially; // captured and not based on an alloca), we need to ensure that we cannot; // unwind between C and cpyStore. This is checked here.; // 4. If cpyDest is potentially captured, there may be accesses to it from; // another thread. In this case, we need to check that cpyStore is; // guaranteed to be executed if C is. As it is a non-atomic access, it; // renders accesses from other threads undefined.; // TODO: This is currently not checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:722,Security,access,access,722,"// Make sure that nothing can observe cpyDest being written early. There are; // a number of cases to consider:; // 1. cpyDest cannot be accessed between C and cpyStore as a precondition of; // the transform.; // 2. C itself may not access cpyDest (prior to the transform). This is; // checked further below.; // 3. If cpyDest is accessible to the caller of this function (potentially; // captured and not based on an alloca), we need to ensure that we cannot; // unwind between C and cpyStore. This is checked here.; // 4. If cpyDest is potentially captured, there may be accesses to it from; // another thread. In this case, we need to check that cpyStore is; // guaranteed to be executed if C is. As it is a non-atomic access, it; // renders accesses from other threads undefined.; // TODO: This is currently not checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:745,Security,access,accesses,745,"// Make sure that nothing can observe cpyDest being written early. There are; // a number of cases to consider:; // 1. cpyDest cannot be accessed between C and cpyStore as a precondition of; // the transform.; // 2. C itself may not access cpyDest (prior to the transform). This is; // checked further below.; // 3. If cpyDest is accessible to the caller of this function (potentially; // captured and not based on an alloca), we need to ensure that we cannot; // unwind between C and cpyStore. This is checked here.; // 4. If cpyDest is potentially captured, there may be accesses to it from; // another thread. In this case, we need to check that cpyStore is; // guaranteed to be executed if C is. As it is a non-atomic access, it; // renders accesses from other threads undefined.; // TODO: This is currently not checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:25,Security,access,accessed,25,"// Check that src is not accessed except via the call and the memcpy. This; // guarantees that it holds only undefined values when passed in (so the final; // memcpy can be dropped), that it is not read or written between the call and; // the memcpy, and that writing beyond the end of it is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:40,Performance,load,load,40,// Ignore the direct read of src in the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:49,Security,access,access,49,"// In addition to knowing that the call does not access src in some; // unexpected manner, for example via a global, which we deduce from; // the use analysis, we also need to know that it does not sneakily; // access dest. We rely on AA to figure this out for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:211,Security,access,access,211,"// In addition to knowing that the call does not access src in some; // unexpected manner, for example via a global, which we deduce from; // the use analysis, we also need to know that it does not sneakily; // access dest. We rely on AA to figure this out for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:17,Performance,perform,perform,17,"// If necessary, perform additional analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:81,Safety,safe,safe,81,// We can't create address space casts here because we don't know if they're; // safe for the target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:50,Integrability,depend,dependence,50,/// We've found that the (upward scanning) memory dependence of memcpy 'M' is; /// the memcpy 'MDep'. Try to simplify M to copy from MDep's input if we can.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:109,Usability,simpl,simplify,109,/// We've found that the (upward scanning) memory dependence of memcpy 'M' is; /// the memcpy 'MDep'. Try to simplify M to copy from MDep's input if we can.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:339,Performance,perform,perform,339,"// Verify that the copied-from memory doesn't change in between the two; // transfers. For example, in:; // memcpy(a <- b); // *b = 42;; // memcpy(c <- a); // It would be invalid to transform the second memcpy into memcpy(c <- b).; //; // TODO: If the code between M and MDep is transparent to the destination ""c"",; // then we could still perform the xform by moving M up to the first memcpy.; // TODO: It would be sufficient to check the MDep source up to the memcpy; // size of M, rather than MDep.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:50,Integrability,depend,dependence,50,"/// We've found that the (upward scanning) memory dependence of \p MemCpy is; /// \p MemSet. Try to simplify \p MemSet to only set the trailing bytes that; /// weren't copied over by \p MemCpy.; ///; /// In other words, transform:; /// \code; /// memset(dst, c, dst_size);; /// ...; /// memcpy(dst, src, src_size);; /// \endcode; /// into:; /// \code; /// ...; /// memset(dst + src_size, c, dst_size <= src_size ? 0 : dst_size - src_size);; /// memcpy(dst, src, src_size);; /// \endcode; ///; /// The memset is sunk to just before the memcpy to ensure that src_size is; /// present when emitting the simplified memset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:100,Usability,simpl,simplify,100,"/// We've found that the (upward scanning) memory dependence of \p MemCpy is; /// \p MemSet. Try to simplify \p MemSet to only set the trailing bytes that; /// weren't copied over by \p MemCpy.; ///; /// In other words, transform:; /// \code; /// memset(dst, c, dst_size);; /// ...; /// memcpy(dst, src, src_size);; /// \endcode; /// into:; /// \code; /// ...; /// memset(dst + src_size, c, dst_size <= src_size ? 0 : dst_size - src_size);; /// memcpy(dst, src, src_size);; /// \endcode; ///; /// The memset is sunk to just before the memcpy to ensure that src_size is; /// present when emitting the simplified memset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:600,Usability,simpl,simplified,600,"/// We've found that the (upward scanning) memory dependence of \p MemCpy is; /// \p MemSet. Try to simplify \p MemSet to only set the trailing bytes that; /// weren't copied over by \p MemCpy.; ///; /// In other words, transform:; /// \code; /// memset(dst, c, dst_size);; /// ...; /// memcpy(dst, src, src_size);; /// \endcode; /// into:; /// \code; /// ...; /// memset(dst + src_size, c, dst_size <= src_size ? 0 : dst_size - src_size);; /// memcpy(dst, src, src_size);; /// \endcode; ///; /// The memset is sunk to just before the memcpy to ensure that src_size is; /// present when emitting the simplified memset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:111,Security,access,accessed,111,"// We know that dst up to src_size is not written. We now need to make sure; // that dst up to dst_size is not accessed. (If we did not move the memset,; // checking for reads would be sufficient.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:30,Usability,simpl,simply,30,"// If the sizes are the same, simply drop the memset instead of generating; // a replacement with zero size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:96,Security,access,access,96,"// The new memset is inserted before the memcpy, and it is known that the; // memcpy's defining access is the memset about to be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:268,Security,access,access,268,"// If the lifetime.start covers a whole alloca (as it almost always; // does) and we're querying a pointer based on that alloca, then we know; // the memory is definitely undef, regardless of how exactly we alias.; // The size also doesn't matter, as an out-of-bounds access would be UB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:513,Integrability,wrap,wrap,513,"// Attempts to optimize the pattern whereby memory is copied from an alloca to; // another alloca, where the two allocas don't have conflicting mod/ref. If; // successful, the two allocas can be merged into one and the transfer can be; // deleted. This pattern is generated frequently in Rust, due to the ubiquity of; // move operations in that language.; //; // Once we determine that the optimization is safe to perform, we replace all; // uses of the destination alloca with the source alloca. We also ""shrink wrap""; // the lifetime markers of the single merged alloca to before the first use; // and after the last use. Note that the ""shrink wrapping"" procedure is a safe; // transformation only because we restrict the scope of this optimization to; // allocas that aren't captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:646,Integrability,wrap,wrapping,646,"// Attempts to optimize the pattern whereby memory is copied from an alloca to; // another alloca, where the two allocas don't have conflicting mod/ref. If; // successful, the two allocas can be merged into one and the transfer can be; // deleted. This pattern is generated frequently in Rust, due to the ubiquity of; // move operations in that language.; //; // Once we determine that the optimization is safe to perform, we replace all; // uses of the destination alloca with the source alloca. We also ""shrink wrap""; // the lifetime markers of the single merged alloca to before the first use; // and after the last use. Note that the ""shrink wrapping"" procedure is a safe; // transformation only because we restrict the scope of this optimization to; // allocas that aren't captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:15,Performance,optimiz,optimize,15,"// Attempts to optimize the pattern whereby memory is copied from an alloca to; // another alloca, where the two allocas don't have conflicting mod/ref. If; // successful, the two allocas can be merged into one and the transfer can be; // deleted. This pattern is generated frequently in Rust, due to the ubiquity of; // move operations in that language.; //; // Once we determine that the optimization is safe to perform, we replace all; // uses of the destination alloca with the source alloca. We also ""shrink wrap""; // the lifetime markers of the single merged alloca to before the first use; // and after the last use. Note that the ""shrink wrapping"" procedure is a safe; // transformation only because we restrict the scope of this optimization to; // allocas that aren't captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:390,Performance,optimiz,optimization,390,"// Attempts to optimize the pattern whereby memory is copied from an alloca to; // another alloca, where the two allocas don't have conflicting mod/ref. If; // successful, the two allocas can be merged into one and the transfer can be; // deleted. This pattern is generated frequently in Rust, due to the ubiquity of; // move operations in that language.; //; // Once we determine that the optimization is safe to perform, we replace all; // uses of the destination alloca with the source alloca. We also ""shrink wrap""; // the lifetime markers of the single merged alloca to before the first use; // and after the last use. Note that the ""shrink wrapping"" procedure is a safe; // transformation only because we restrict the scope of this optimization to; // allocas that aren't captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:414,Performance,perform,perform,414,"// Attempts to optimize the pattern whereby memory is copied from an alloca to; // another alloca, where the two allocas don't have conflicting mod/ref. If; // successful, the two allocas can be merged into one and the transfer can be; // deleted. This pattern is generated frequently in Rust, due to the ubiquity of; // move operations in that language.; //; // Once we determine that the optimization is safe to perform, we replace all; // uses of the destination alloca with the source alloca. We also ""shrink wrap""; // the lifetime markers of the single merged alloca to before the first use; // and after the last use. Note that the ""shrink wrapping"" procedure is a safe; // transformation only because we restrict the scope of this optimization to; // allocas that aren't captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:738,Performance,optimiz,optimization,738,"// Attempts to optimize the pattern whereby memory is copied from an alloca to; // another alloca, where the two allocas don't have conflicting mod/ref. If; // successful, the two allocas can be merged into one and the transfer can be; // deleted. This pattern is generated frequently in Rust, due to the ubiquity of; // move operations in that language.; //; // Once we determine that the optimization is safe to perform, we replace all; // uses of the destination alloca with the source alloca. We also ""shrink wrap""; // the lifetime markers of the single merged alloca to before the first use; // and after the last use. Note that the ""shrink wrapping"" procedure is a safe; // transformation only because we restrict the scope of this optimization to; // allocas that aren't captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:406,Safety,safe,safe,406,"// Attempts to optimize the pattern whereby memory is copied from an alloca to; // another alloca, where the two allocas don't have conflicting mod/ref. If; // successful, the two allocas can be merged into one and the transfer can be; // deleted. This pattern is generated frequently in Rust, due to the ubiquity of; // move operations in that language.; //; // Once we determine that the optimization is safe to perform, we replace all; // uses of the destination alloca with the source alloca. We also ""shrink wrap""; // the lifetime markers of the single merged alloca to before the first use; // and after the last use. Note that the ""shrink wrapping"" procedure is a safe; // transformation only because we restrict the scope of this optimization to; // allocas that aren't captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:671,Safety,safe,safe,671,"// Attempts to optimize the pattern whereby memory is copied from an alloca to; // another alloca, where the two allocas don't have conflicting mod/ref. If; // successful, the two allocas can be merged into one and the transfer can be; // deleted. This pattern is generated frequently in Rust, due to the ubiquity of; // move operations in that language.; //; // Once we determine that the optimization is safe to perform, we replace all; // uses of the destination alloca with the source alloca. We also ""shrink wrap""; // the lifetime markers of the single merged alloca to before the first use; // and after the last use. Note that the ""shrink wrapping"" procedure is a safe; // transformation only because we restrict the scope of this optimization to; // allocas that aren't captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:164,Integrability,wrap,wrap,164,"// Check that src and dest are never captured, unescaped allocas. Also; // find the nearest common dominator and postdominator for all users in; // order to shrink wrap the lifetimes, and instructions with noalias metadata; // to remove them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:308,Availability,alive,alive,308,"// We note the locations of these intrinsic calls so that we can; // delete them later if the optimization succeeds, this is safe; // since both llvm.lifetime.start and llvm.lifetime.end intrinsics; // practically fill all the bytes of the alloca with an undefined; // value, although conceptually marked as alive/dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:94,Performance,optimiz,optimization,94,"// We note the locations of these intrinsic calls so that we can; // delete them later if the optimization succeeds, this is safe; // since both llvm.lifetime.start and llvm.lifetime.end intrinsics; // practically fill all the bytes of the alloca with an undefined; // value, although conceptually marked as alive/dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:125,Safety,safe,safe,125,"// We note the locations of these intrinsic calls so that we can; // delete them later if the optimization succeeds, this is safe; // since both llvm.lifetime.start and llvm.lifetime.end intrinsics; // practically fill all the bytes of the alloca with an undefined; // value, although conceptually marked as alive/dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:30,Performance,Load,Load,30,"// Check that, from after the Load to the end of the BB,; // - if the dest has any Mod, src has no Ref, and; // - if the dest has any Ref, src has no Mod except full-sized lifetimes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:32,Performance,Load,Load,32,"// Any ModRef post-dominated by Load doesn't matter, also Load and Store; // themselves can be ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:58,Performance,Load,Load,58,"// Any ModRef post-dominated by Load doesn't matter, also Load and Store; // themselves can be ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:43,Security,access,accesses,43,"// As this transformation can cause memory accesses that didn't previously; // alias to begin to alias one another, we remove !noalias metadata from any; // uses of either alloca. This is conservative, but more precision doesn't; // seem worthwhile right now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:201,Integrability,depend,depending,201,"/// Perform simplification of memcpy's. If we have memcpy A; /// which copies X to Y, and memcpy B which copies Y to Z, then we can rewrite; /// B to be a memcpy from X to Z (or potentially a memmove, depending on; /// circumstances). This allows later passes to remove the first memcpy; /// altogether.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:132,Modifiability,rewrite,rewrite,132,"/// Perform simplification of memcpy's. If we have memcpy A; /// which copies X to Y, and memcpy B which copies Y to Z, then we can rewrite; /// B to be a memcpy from X to Z (or potentially a memmove, depending on; /// circumstances). This allows later passes to remove the first memcpy; /// altogether.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:4,Performance,Perform,Perform,4,"/// Perform simplification of memcpy's. If we have memcpy A; /// which copies X to Y, and memcpy B which copies Y to Z, then we can rewrite; /// B to be a memcpy from X to Z (or potentially a memmove, depending on; /// circumstances). This allows later passes to remove the first memcpy; /// altogether.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:12,Usability,simpl,simplification,12,"/// Perform simplification of memcpy's. If we have memcpy A; /// which copies X to Y, and memcpy B which copies Y to Z, then we can rewrite; /// B to be a memcpy from X to Z (or potentially a memmove, depending on; /// circumstances). This allows later passes to remove the first memcpy; /// altogether.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:15,Performance,optimiz,optimize,15,// We can only optimize non-volatile memcpy's.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:41,Security,access,accessing,41,// Degenerate case: memcpy marked as not accessing memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:27,Availability,redundant,redundant,27,"// Try to turn a partially redundant memset + memcpy into; // smaller memset + memcpy. We don't need the memcpy size for this.; // The memcpy must post-dom the memset, so limit this to the same basic; // block. A non-local generalization is likely not worthwhile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:27,Safety,redund,redundant,27,"// Try to turn a partially redundant memset + memcpy into; // smaller memset + memcpy. We don't need the memcpy size for this.; // The memcpy must post-dom the memset, so limit this to the same basic; // block. A non-local generalization is likely not worthwhile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:27,Performance,optimiz,optimizations,27,"// There are five possible optimizations we can do for memcpy:; // a) memcpy-memcpy xform which exposes redundance for DSE.; // b) call-memcpy xform for return slot optimization.; // c) memcpy from freshly alloca'd space or space that has just started; // its lifetime copies undefined data, and we can therefore eliminate; // the memcpy in favor of the data that was already at the destination.; // d) memcpy from a just-memset'd source can be turned into memset.; // e) elimination of memcpy via stack-move optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:165,Performance,optimiz,optimization,165,"// There are five possible optimizations we can do for memcpy:; // a) memcpy-memcpy xform which exposes redundance for DSE.; // b) call-memcpy xform for return slot optimization.; // c) memcpy from freshly alloca'd space or space that has just started; // its lifetime copies undefined data, and we can therefore eliminate; // the memcpy in favor of the data that was already at the destination.; // d) memcpy from a just-memset'd source can be turned into memset.; // e) elimination of memcpy via stack-move optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:509,Performance,optimiz,optimization,509,"// There are five possible optimizations we can do for memcpy:; // a) memcpy-memcpy xform which exposes redundance for DSE.; // b) call-memcpy xform for return slot optimization.; // c) memcpy from freshly alloca'd space or space that has just started; // its lifetime copies undefined data, and we can therefore eliminate; // the memcpy in favor of the data that was already at the destination.; // d) memcpy from a just-memset'd source can be turned into memset.; // e) elimination of memcpy via stack-move optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:104,Safety,redund,redundance,104,"// There are five possible optimizations we can do for memcpy:; // a) memcpy-memcpy xform which exposes redundance for DSE.; // b) call-memcpy xform for return slot optimization.; // c) memcpy from freshly alloca'd space or space that has just started; // its lifetime copies undefined data, and we can therefore eliminate; // the memcpy in favor of the data that was already at the destination.; // d) memcpy from a just-memset'd source can be turned into memset.; // e) elimination of memcpy via stack-move optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:96,Security,expose,exposes,96,"// There are five possible optimizations we can do for memcpy:; // a) memcpy-memcpy xform which exposes redundance for DSE.; // b) call-memcpy xform for return slot optimization.; // c) memcpy from freshly alloca'd space or space that has just started; // its lifetime copies undefined data, and we can therefore eliminate; // the memcpy in favor of the data that was already at the destination.; // d) memcpy from a just-memset'd source can be turned into memset.; // e) elimination of memcpy via stack-move optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:84,Performance,perform,perform,84,"// If the transfer is from a stack slot to a stack slot, then we may be able; // to perform the stack-move optimization. See the comments in; // performStackMoveOptzn() for more details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:107,Performance,optimiz,optimization,107,"// If the transfer is from a stack slot to a stack slot, then we may be able; // to perform the stack-move optimization. See the comments in; // performStackMoveOptzn() for more details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:145,Performance,perform,performStackMoveOptzn,145,"// If the transfer is from a stack slot to a stack slot, then we may be able; // to perform the stack-move optimization. See the comments in; // performStackMoveOptzn() for more details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:3,Safety,Avoid,Avoid,3,// Avoid invalidating the iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:25,Deployability,Update,Update,25,// Otherwise we're good! Update the byval argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:729,Safety,safe,safe,729,"/// This is called on memcpy dest pointer arguments attributed as immutable; /// during call. Try to use memcpy source directly if all of the following; /// conditions are satisfied.; /// 1. The memcpy dst is neither modified during the call nor captured by the; /// call. (if readonly, noalias, nocapture attributes on call-site.); /// 2. The memcpy dst is an alloca with known alignment & size.; /// 2-1. The memcpy length == the alloca size which ensures that the new; /// pointer is dereferenceable for the required range; /// 2-2. The src pointer has alignment >= the alloca alignment or can be; /// enforced so.; /// 3. The memcpy dst and src is not modified between the memcpy and the call.; /// (if MSSA clobber check is safe.); /// 4. The memcpy src is not modified during the call. (ModRef check shows no; /// Mod.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:47,Modifiability,Variab,Variable,47,"// Can't handle unknown size alloca.; // (e.g. Variable Length Array, Scalable Vector)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:70,Performance,Scalab,Scalable,70,"// Can't handle unknown size alloca.; // (e.g. Variable Length Array, Scalable Vector)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:25,Deployability,Update,Update,25,// Otherwise we're good! Update the immut argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:3,Safety,Avoid,Avoid,3,// Avoid invalidating the iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:56,Performance,load,load,56,"//===- MergedLoadStoreMotion.cpp - merge and hoist/sink load/stores -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.e",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:405,Performance,perform,performs,405,"//===- MergedLoadStoreMotion.cpp - merge and hoist/sink load/stores -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.e",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:424,Performance,load,loads,424,"//===- MergedLoadStoreMotion.cpp - merge and hoist/sink load/stores -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.e",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:497,Performance,load,loads,497,"//===- MergedLoadStoreMotion.cpp - merge and hoist/sink load/stores -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.e",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:570,Performance,load,loads,570,"//===- MergedLoadStoreMotion.cpp - merge and hoist/sink load/stores -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.e",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:657,Performance,load,load,657,"//===- MergedLoadStoreMotion.cpp - merge and hoist/sink load/stores -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.e",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:860,Performance,load,load,860,"//===- MergedLoadStoreMotion.cpp - merge and hoist/sink load/stores -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.e",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:1106,Performance,optimiz,optimization,1106,"nder the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // %s.sink = phi [%st, if.then], [%se, if.else];",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:1141,Performance,load,load,1141,"https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // %s.sink = phi [%st, if.then], [%se, if.else]; // <...>; // store %s.sink, %addr_s; // <...>; //; //; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:1252,Performance,perform,performs,1252,"ache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // %s.sink = phi [%st, if.then], [%se, if.else]; // <...>; // store %s.sink, %addr_s; // <...>; //; //; //===----------------------- TODO -----------------------------------------===//; //; /",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:1261,Performance,load,load,1261,"ache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // %s.sink = phi [%st, if.then], [%se, if.else]; // <...>; // store %s.sink, %addr_s; // <...>; //; //; //===----------------------- TODO -----------------------------------------===//; //; /",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:1566,Performance,load,load,1566,"d sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // %s.sink = phi [%st, if.then], [%se, if.else]; // <...>; // store %s.sink, %addr_s; // <...>; //; //; //===----------------------- TODO -----------------------------------------===//; //; // 1) Generalize to regions other than diamonds; // 2) Be more aggressive merging memory operations; // Note that both changes require register pressure control; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:1585,Performance,load,load,1585,"d sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // %s.sink = phi [%st, if.then], [%se, if.else]; // <...>; // store %s.sink, %addr_s; // <...>; //; //; //===----------------------- TODO -----------------------------------------===//; //; // 1) Generalize to regions other than diamonds; // 2) Be more aggressive merging memory operations; // Note that both changes require register pressure control; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:1841,Performance,load,load,1841,"d sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // %s.sink = phi [%st, if.then], [%se, if.else]; // <...>; // store %s.sink, %addr_s; // <...>; //; //; //===----------------------- TODO -----------------------------------------===//; //; // 1) Generalize to regions other than diamonds; // 2) Be more aggressive merging memory operations; // Note that both changes require register pressure control; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:1086,Safety,safe,safe,1086,"---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // %",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:3,Integrability,Rout,Routines,3,// Routines for sinking stores,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:115,Safety,safe,safe,115,///; /// Check if \p BB contains a store to the same address as \p SI; ///; /// \return The store in \p when it is safe to sink. Otherwise return Null.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:18,Usability,simpl,simple,18,"// Don't sink non-simple (atomic, volatile) stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:64,Performance,optimiz,optimization,64,"// Merge unconditional branches, allowing PRE to catch more; // optimization opportunities.; // This loop doesn't care about newly inserted/split blocks ; // since they never will be diamond heads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:20,Performance,load,loads,20,// Hoist equivalent loads and sink stores; // outside diamonds when possible,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:498,Energy Efficiency,efficient,efficient,498,"//===- MergeICmps.cpp - Optimize chains of integer comparisons ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass turns chains of integer comparisons into memcmp (the memcmp is; // later typically inlined as a chain of efficient hardware comparisons). This; // typically benefits c++ member or nonmember operator==().; //; // The basic idea is to replace a longer chain of integer comparisons loaded; // from contiguous memory locations into a shorter chain of larger integer; // comparisons. Benefits are double:; // - There are less jumps, and therefore less opportunities for mispredictions; // and I-cache misses.; // - Code size is smaller, both because jumps are removed and because the; // encoding of a 2*n byte compare is smaller than that of two n-byte; // compares.; //; // Example:; //; // struct S {; // int a;; // char b;; // char c;; // uint16_t d;; // bool operator==(const S& o) const {; // return a == o.a && b == o.b && c == o.c && d == o.d;; // }; // };; //; // Is optimized as :; //; // bool S::operator==(const S& o) const {; // return memcmp(this, &o, 8) == 0;; // }; //; // Which will later be expanded (ExpandMemCmp) as a single 8-bytes icmp.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:24,Performance,Optimiz,Optimize,24,"//===- MergeICmps.cpp - Optimize chains of integer comparisons ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass turns chains of integer comparisons into memcmp (the memcmp is; // later typically inlined as a chain of efficient hardware comparisons). This; // typically benefits c++ member or nonmember operator==().; //; // The basic idea is to replace a longer chain of integer comparisons loaded; // from contiguous memory locations into a shorter chain of larger integer; // comparisons. Benefits are double:; // - There are less jumps, and therefore less opportunities for mispredictions; // and I-cache misses.; // - Code size is smaller, both because jumps are removed and because the; // encoding of a 2*n byte compare is smaller than that of two n-byte; // compares.; //; // Example:; //; // struct S {; // int a;; // char b;; // char c;; // uint16_t d;; // bool operator==(const S& o) const {; // return a == o.a && b == o.b && c == o.c && d == o.d;; // }; // };; //; // Is optimized as :; //; // bool S::operator==(const S& o) const {; // return memcmp(this, &o, 8) == 0;; // }; //; // Which will later be expanded (ExpandMemCmp) as a single 8-bytes icmp.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:672,Performance,load,loaded,672,"//===- MergeICmps.cpp - Optimize chains of integer comparisons ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass turns chains of integer comparisons into memcmp (the memcmp is; // later typically inlined as a chain of efficient hardware comparisons). This; // typically benefits c++ member or nonmember operator==().; //; // The basic idea is to replace a longer chain of integer comparisons loaded; // from contiguous memory locations into a shorter chain of larger integer; // comparisons. Benefits are double:; // - There are less jumps, and therefore less opportunities for mispredictions; // and I-cache misses.; // - Code size is smaller, both because jumps are removed and because the; // encoding of a 2*n byte compare is smaller than that of two n-byte; // compares.; //; // Example:; //; // struct S {; // int a;; // char b;; // char c;; // uint16_t d;; // bool operator==(const S& o) const {; // return a == o.a && b == o.b && c == o.c && d == o.d;; // }; // };; //; // Is optimized as :; //; // bool S::operator==(const S& o) const {; // return memcmp(this, &o, 8) == 0;; // }; //; // Which will later be expanded (ExpandMemCmp) as a single 8-bytes icmp.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:883,Performance,cache,cache,883,"//===- MergeICmps.cpp - Optimize chains of integer comparisons ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass turns chains of integer comparisons into memcmp (the memcmp is; // later typically inlined as a chain of efficient hardware comparisons). This; // typically benefits c++ member or nonmember operator==().; //; // The basic idea is to replace a longer chain of integer comparisons loaded; // from contiguous memory locations into a shorter chain of larger integer; // comparisons. Benefits are double:; // - There are less jumps, and therefore less opportunities for mispredictions; // and I-cache misses.; // - Code size is smaller, both because jumps are removed and because the; // encoding of a 2*n byte compare is smaller than that of two n-byte; // compares.; //; // Example:; //; // struct S {; // int a;; // char b;; // char c;; // uint16_t d;; // bool operator==(const S& o) const {; // return a == o.a && b == o.b && c == o.c && d == o.d;; // }; // };; //; // Is optimized as :; //; // bool S::operator==(const S& o) const {; // return memcmp(this, &o, 8) == 0;; // }; //; // Which will later be expanded (ExpandMemCmp) as a single 8-bytes icmp.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:1264,Performance,optimiz,optimized,1264,"//===- MergeICmps.cpp - Optimize chains of integer comparisons ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass turns chains of integer comparisons into memcmp (the memcmp is; // later typically inlined as a chain of efficient hardware comparisons). This; // typically benefits c++ member or nonmember operator==().; //; // The basic idea is to replace a longer chain of integer comparisons loaded; // from contiguous memory locations into a shorter chain of larger integer; // comparisons. Benefits are double:; // - There are less jumps, and therefore less opportunities for mispredictions; // and I-cache misses.; // - Code size is smaller, both because jumps are removed and because the; // encoding of a 2*n byte compare is smaller than that of two n-byte; // compares.; //; // Example:; //; // struct S {; // int a;; // char b;; // char c;; // uint16_t d;; // bool operator==(const S& o) const {; // return a == o.a && b == o.b && c == o.c && d == o.d;; // }; // };; //; // Is optimized as :; //; // bool S::operator==(const S& o) const {; // return memcmp(this, &o, 8) == 0;; // }; //; // Which will later be expanded (ExpandMemCmp) as a single 8-bytes icmp.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:69,Performance,load,load,69,"// A BCE atom ""Binary Compare Expression Atom"" represents an integer load; // that is a constant offset from a base value, e.g. `a` or `o.c` in the example; // at the top.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:22,Performance,load,load,22,"// If this value is a load from a constant offset w.r.t. a base address, and; // there are no other users of the load or address, returns the base address and; // the offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:113,Performance,load,load,113,"// If this value is a load from a constant offset w.r.t. a base address, and; // there are no other users of the load or address, returns the base address and; // the offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:10,Performance,optimiz,optimize,10,// Do not optimize atomic loads to non-atomic memcmp,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:26,Performance,load,loads,26,// Do not optimize atomic loads to non-atomic memcmp,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:299,Performance,load,loads,299,"// A comparison between two BCE atoms, e.g. `a == o.a` in the example at the; // top.; // Note: the terminology is misleading: the comparison is symmetric, so there; // is no real {l/r}hs. What we want though is to have the same base on the; // left (resp. right), so that we can detect consecutive loads. To ensure this; // we put the smallest atom on the left.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:280,Safety,detect,detect,280,"// A comparison between two BCE atoms, e.g. `a == o.a` in the example at the; // top.; // Note: the terminology is misleading: the comparison is symmetric, so there; // is no real {l/r}hs. What we want though is to have the same base on the; // left (resp. right), so that we can detect consecutive loads. To ensure this; // we put the smallest atom on the left.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:39,Performance,load,loads,39,"// If this instruction may clobber the loads and is in middle of the BCE cmp; // block instructions, then bail for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:60,Performance,load,load,60,"// If a potentially clobbering instruction comes before the load,; // we can still safely sink the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:99,Performance,load,load,99,"// If a potentially clobbering instruction comes before the load,; // we can still safely sink the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:83,Safety,safe,safely,83,"// If a potentially clobbering instruction comes before the load,; // we can still safely sink the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:214,Performance,load,loads,214,// TODO(courbet): Can we allow some other things ? This is very conservative.; // We might be able to get away with anything does not have any side; // effects outside of the basic block.; // Note: The GEPs and/or loads are not necessarily in the same block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:18,Deployability,continuous,continuous,18,// Sort to detect continuous offsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:11,Safety,detect,detect,11,// Sort to detect continuous offsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:442,Safety,abort,abort,442,"// This is the initial block in the chain, in case this block does other; // work, we can try to split the block and move the irrelevant; // instructions to the predecessor.; //; // If this is not the initial block in the chain, splitting it wont; // work.; //; // As once split, there will still be instructions before the BCE cmp; // instructions that do other work in program order, i.e. within the; // chain before sorting. Unless we can abort the chain at this point; // and start anew.; //; // NOTE: we only handle blocks a with single predecessor for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:31,Safety,abort,abort,31,"// TODO(courbet): Right now we abort the whole chain. We could be; // merging only the blocks that don't do other work and resume the; // chain from there. For example:; // if (a[0] == b[0]) { // bb1; // if (a[1] == b[1]) { // bb2; // some_value = 3; //bb3; // if (a[2] == b[2]) { //bb3; // do a ton of stuff //bb4; // }; // }; // }; //; // This is:; //; // bb1 --eq--> bb2 --eq--> bb3* -eq--> bb4 --+; // \ \ \ \; // ne ne ne \; // \ \ \ v; // +------------+-----------+----------> bb_phi; //; // We can only merge the first two comparisons, because bb3* does; // ""other work"" (setting some_value to 3).; // We could still merge bb1 and bb2 though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:123,Usability,resume,resume,123,"// TODO(courbet): Right now we abort the whole chain. We could be; // merging only the blocks that don't do other work and resume the; // chain from there. For example:; // if (a[0] == b[0]) { // bb1; // if (a[1] == b[1]) { // bb2; // some_value = 3; //bb3; // if (a[2] == b[2]) { //bb3; // do a ton of stuff //bb4; // }; // }; // }; //; // This is:; //; // bb1 --eq--> bb2 --eq--> bb3* -eq--> bb4 --+; // \ \ \ \; // ne ne ne \; // \ \ \ v; // +------------+-----------+----------> bb_phi; //; // We can only merge the first two comparisons, because bb3* does; // ""other work"" (setting some_value to 3).; // We could still merge bb1 and bb2 though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:76,Performance,optimiz,optimized,76,// A class to compute the name of a set of merged basic blocks.; // This is optimized for the common case of no block names.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:116,Availability,avail,available,116,// Effectively merge blocks. We go in the reverse direction from the phi block; // so that the next block is always available to branch to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:59,Deployability,update,update,59,"// If the old cmp chain was the function entry, we need to update the function; // entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:103,Safety,avoid,avoid,103,// We only try merging comparisons if the target wants to expand memcmp later.; // The rationale is to avoid turning small chains into memcmp calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:84,Availability,avail,available,84,"// MergeICmps does not need the DominatorTree, but we update it if it's; // already available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:54,Deployability,update,update,54,"// MergeICmps does not need the DominatorTree, but we update it if it's; // already available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp:1523,Energy Efficiency,efficient,efficiently,1523,"// }; //; // An ideal compiler should reassociate (a + 2) + b to (a + b) + 2 and simplify; // the above code to; //; // int t = a + b;; // bar(t);; // bar(t + 2);; //; // However, the Reassociate pass is unable to do that because it processes each; // instruction individually and believes (a + 2) + b is the best form according; // to its rank system.; //; // To address this limitation, NaryReassociate reassociates an expression in a; // form that reuses existing instructions. As a result, NaryReassociate can; // reassociate (a + 2) + b in the example to (a + b) + 2 because it detects that; // (a + b) is computed before.; //; // NaryReassociate works as follows. For every instruction in the form of (a +; // b) + c, it checks whether a + c or b + c is already computed by a dominating; // instruction. If so, it then reassociates (a + b) + c into (a + c) + b or (b +; // c) + a and removes the redundancy accordingly. To efficiently look up whether; // an expression is computed before, we store each instruction seen and its SCEV; // into an SCEV-to-instruction map.; //; // Although the algorithm pattern-matches only ternary additions, it; // automatically handles many >3-ary expressions by walking through the function; // in the depth-first order. For example, given; //; // (a + c) + d; // ((a + b) + c) + d; //; // NaryReassociate first rewrites (a + b) + c to (a + c) + b, and then rewrites; // ((a + c) + b) + d into ((a + c) + d) + b.; //; // Finally, the above dominator-based algorithm may need to be run multiple; // iterations before emitting optimal code. One source of this need is that we; // only split an operand when it is used only once. The above algorithm can; // eliminate an instruction and decrease the usage count of its operands. As a; // result, an instruction that previously had multiple uses may become a; // single-use instruction and thus eligible for split consideration. For; // example,; //; // ac = a + c; // ab = a + b; // abc = ab + c; // ab2 = ab + b",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp:1947,Modifiability,rewrite,rewrites,1947," // To address this limitation, NaryReassociate reassociates an expression in a; // form that reuses existing instructions. As a result, NaryReassociate can; // reassociate (a + 2) + b in the example to (a + b) + 2 because it detects that; // (a + b) is computed before.; //; // NaryReassociate works as follows. For every instruction in the form of (a +; // b) + c, it checks whether a + c or b + c is already computed by a dominating; // instruction. If so, it then reassociates (a + b) + c into (a + c) + b or (b +; // c) + a and removes the redundancy accordingly. To efficiently look up whether; // an expression is computed before, we store each instruction seen and its SCEV; // into an SCEV-to-instruction map.; //; // Although the algorithm pattern-matches only ternary additions, it; // automatically handles many >3-ary expressions by walking through the function; // in the depth-first order. For example, given; //; // (a + c) + d; // ((a + b) + c) + d; //; // NaryReassociate first rewrites (a + b) + c to (a + c) + b, and then rewrites; // ((a + c) + b) + d into ((a + c) + d) + b.; //; // Finally, the above dominator-based algorithm may need to be run multiple; // iterations before emitting optimal code. One source of this need is that we; // only split an operand when it is used only once. The above algorithm can; // eliminate an instruction and decrease the usage count of its operands. As a; // result, an instruction that previously had multiple uses may become a; // single-use instruction and thus eligible for split consideration. For; // example,; //; // ac = a + c; // ab = a + b; // abc = ab + c; // ab2 = ab + b; // ab2c = ab2 + c; //; // In the first iteration, we cannot reassociate abc to ac+b because ab is used; // twice. However, we can reassociate ab2c to abc+b in the first iteration. As a; // result, ab2 becomes dead and ab will be used only once in the second; // iteration.; //; // Limitations and TODO items:; //; // 1) We only considers n-ary adds and mu",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp:1993,Modifiability,rewrite,rewrites,1993," // To address this limitation, NaryReassociate reassociates an expression in a; // form that reuses existing instructions. As a result, NaryReassociate can; // reassociate (a + 2) + b in the example to (a + b) + 2 because it detects that; // (a + b) is computed before.; //; // NaryReassociate works as follows. For every instruction in the form of (a +; // b) + c, it checks whether a + c or b + c is already computed by a dominating; // instruction. If so, it then reassociates (a + b) + c into (a + c) + b or (b +; // c) + a and removes the redundancy accordingly. To efficiently look up whether; // an expression is computed before, we store each instruction seen and its SCEV; // into an SCEV-to-instruction map.; //; // Although the algorithm pattern-matches only ternary additions, it; // automatically handles many >3-ary expressions by walking through the function; // in the depth-first order. For example, given; //; // (a + c) + d; // ((a + b) + c) + d; //; // NaryReassociate first rewrites (a + b) + c to (a + c) + b, and then rewrites; // ((a + c) + b) + d into ((a + c) + d) + b.; //; // Finally, the above dominator-based algorithm may need to be run multiple; // iterations before emitting optimal code. One source of this need is that we; // only split an operand when it is used only once. The above algorithm can; // eliminate an instruction and decrease the usage count of its operands. As a; // result, an instruction that previously had multiple uses may become a; // single-use instruction and thus eligible for split consideration. For; // example,; //; // ac = a + c; // ab = a + b; // abc = ab + c; // ab2 = ab + b; // ab2c = ab2 + c; //; // In the first iteration, we cannot reassociate abc to ac+b because ab is used; // twice. However, we can reassociate ab2c to abc+b in the first iteration. As a; // result, ab2 becomes dead and ab will be used only once in the second; // iteration.; //; // Limitations and TODO items:; //; // 1) We only considers n-ary adds and mu",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp:2978,Modifiability,extend,extended,2978,"eassociate can; // reassociate (a + 2) + b in the example to (a + b) + 2 because it detects that; // (a + b) is computed before.; //; // NaryReassociate works as follows. For every instruction in the form of (a +; // b) + c, it checks whether a + c or b + c is already computed by a dominating; // instruction. If so, it then reassociates (a + b) + c into (a + c) + b or (b +; // c) + a and removes the redundancy accordingly. To efficiently look up whether; // an expression is computed before, we store each instruction seen and its SCEV; // into an SCEV-to-instruction map.; //; // Although the algorithm pattern-matches only ternary additions, it; // automatically handles many >3-ary expressions by walking through the function; // in the depth-first order. For example, given; //; // (a + c) + d; // ((a + b) + c) + d; //; // NaryReassociate first rewrites (a + b) + c to (a + c) + b, and then rewrites; // ((a + c) + b) + d into ((a + c) + d) + b.; //; // Finally, the above dominator-based algorithm may need to be run multiple; // iterations before emitting optimal code. One source of this need is that we; // only split an operand when it is used only once. The above algorithm can; // eliminate an instruction and decrease the usage count of its operands. As a; // result, an instruction that previously had multiple uses may become a; // single-use instruction and thus eligible for split consideration. For; // example,; //; // ac = a + c; // ab = a + b; // abc = ab + c; // ab2 = ab + b; // ab2c = ab2 + c; //; // In the first iteration, we cannot reassociate abc to ac+b because ab is used; // twice. However, we can reassociate ab2c to abc+b in the first iteration. As a; // result, ab2 becomes dead and ab will be used only once in the second; // iteration.; //; // Limitations and TODO items:; //; // 1) We only considers n-ary adds and muls for now. This should be extended; // and generalized.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp:447,Safety,redund,redundancy,447,"//===- NaryReassociate.cpp - Reassociate n-ary expressions ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass reassociates n-ary add expressions and eliminates the redundancy; // exposed by the reassociation.; //; // A motivating example:; //; // void foo(int a, int b) {; // bar(a + b);; // bar((a + 2) + b);; // }; //; // An ideal compiler should reassociate (a + 2) + b to (a + b) + 2 and simplify; // the above code to; //; // int t = a + b;; // bar(t);; // bar(t + 2);; //; // However, the Reassociate pass is unable to do that because it processes each; // instruction individually and believes (a + 2) + b is the best form according; // to its rank system.; //; // To address this limitation, NaryReassociate reassociates an expression in a; // form that reuses existing instructions. As a result, NaryReassociate can; // reassociate (a + 2) + b in the example to (a + b) + 2 because it detects that; // (a + b) is computed before.; //; // NaryReassociate works as follows. For every instruction in the form of (a +; // b) + c, it checks whether a + c or b + c is already computed by a dominating; // instruction. If so, it then reassociates (a + b) + c into (a + c) + b or (b +; // c) + a and removes the redundancy accordingly. To efficiently look up whether; // an expression is computed before, we store each instruction seen and its SCEV; // into an SCEV-to-instruction map.; //; // Although the algorithm pattern-matches only ternary additions, it; // automatically handles many >3-ary expressions by walking through the function; // in the depth-first order. For example, given; //; // (a + c) + d; // ((a + b) + c) + d; //; // NaryReassociate first rewrites (a + b) + c to (a + c) + b, and then rewrites",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp:1177,Safety,detect,detects,1177,"th LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass reassociates n-ary add expressions and eliminates the redundancy; // exposed by the reassociation.; //; // A motivating example:; //; // void foo(int a, int b) {; // bar(a + b);; // bar((a + 2) + b);; // }; //; // An ideal compiler should reassociate (a + 2) + b to (a + b) + 2 and simplify; // the above code to; //; // int t = a + b;; // bar(t);; // bar(t + 2);; //; // However, the Reassociate pass is unable to do that because it processes each; // instruction individually and believes (a + 2) + b is the best form according; // to its rank system.; //; // To address this limitation, NaryReassociate reassociates an expression in a; // form that reuses existing instructions. As a result, NaryReassociate can; // reassociate (a + 2) + b in the example to (a + b) + 2 because it detects that; // (a + b) is computed before.; //; // NaryReassociate works as follows. For every instruction in the form of (a +; // b) + c, it checks whether a + c or b + c is already computed by a dominating; // instruction. If so, it then reassociates (a + b) + c into (a + c) + b or (b +; // c) + a and removes the redundancy accordingly. To efficiently look up whether; // an expression is computed before, we store each instruction seen and its SCEV; // into an SCEV-to-instruction map.; //; // Although the algorithm pattern-matches only ternary additions, it; // automatically handles many >3-ary expressions by walking through the function; // in the depth-first order. For example, given; //; // (a + c) + d; // ((a + b) + c) + d; //; // NaryReassociate first rewrites (a + b) + c to (a + c) + b, and then rewrites; // ((a + c) + b) + d into ((a + c) + d) + b.; //; // Finally, the above dominator-based algorithm may need to be run multiple; // iterations befo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp:1496,Safety,redund,redundancy,1496," exposed by the reassociation.; //; // A motivating example:; //; // void foo(int a, int b) {; // bar(a + b);; // bar((a + 2) + b);; // }; //; // An ideal compiler should reassociate (a + 2) + b to (a + b) + 2 and simplify; // the above code to; //; // int t = a + b;; // bar(t);; // bar(t + 2);; //; // However, the Reassociate pass is unable to do that because it processes each; // instruction individually and believes (a + 2) + b is the best form according; // to its rank system.; //; // To address this limitation, NaryReassociate reassociates an expression in a; // form that reuses existing instructions. As a result, NaryReassociate can; // reassociate (a + 2) + b in the example to (a + b) + 2 because it detects that; // (a + b) is computed before.; //; // NaryReassociate works as follows. For every instruction in the form of (a +; // b) + c, it checks whether a + c or b + c is already computed by a dominating; // instruction. If so, it then reassociates (a + b) + c into (a + c) + b or (b +; // c) + a and removes the redundancy accordingly. To efficiently look up whether; // an expression is computed before, we store each instruction seen and its SCEV; // into an SCEV-to-instruction map.; //; // Although the algorithm pattern-matches only ternary additions, it; // automatically handles many >3-ary expressions by walking through the function; // in the depth-first order. For example, given; //; // (a + c) + d; // ((a + b) + c) + d; //; // NaryReassociate first rewrites (a + b) + c to (a + c) + b, and then rewrites; // ((a + c) + b) + d into ((a + c) + d) + b.; //; // Finally, the above dominator-based algorithm may need to be run multiple; // iterations before emitting optimal code. One source of this need is that we; // only split an operand when it is used only once. The above algorithm can; // eliminate an instruction and decrease the usage count of its operands. As a; // result, an instruction that previously had multiple uses may become a; // single-use instru",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp:462,Security,expose,exposed,462,"//===- NaryReassociate.cpp - Reassociate n-ary expressions ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass reassociates n-ary add expressions and eliminates the redundancy; // exposed by the reassociation.; //; // A motivating example:; //; // void foo(int a, int b) {; // bar(a + b);; // bar((a + 2) + b);; // }; //; // An ideal compiler should reassociate (a + 2) + b to (a + b) + 2 and simplify; // the above code to; //; // int t = a + b;; // bar(t);; // bar(t + 2);; //; // However, the Reassociate pass is unable to do that because it processes each; // instruction individually and believes (a + 2) + b is the best form according; // to its rank system.; //; // To address this limitation, NaryReassociate reassociates an expression in a; // form that reuses existing instructions. As a result, NaryReassociate can; // reassociate (a + 2) + b in the example to (a + b) + 2 because it detects that; // (a + b) is computed before.; //; // NaryReassociate works as follows. For every instruction in the form of (a +; // b) + c, it checks whether a + c or b + c is already computed by a dominating; // instruction. If so, it then reassociates (a + b) + c into (a + c) + b or (b +; // c) + a and removes the redundancy accordingly. To efficiently look up whether; // an expression is computed before, we store each instruction seen and its SCEV; // into an SCEV-to-instruction map.; //; // Although the algorithm pattern-matches only ternary additions, it; // automatically handles many >3-ary expressions by walking through the function; // in the depth-first order. For example, given; //; // (a + c) + d; // ((a + b) + c) + d; //; // NaryReassociate first rewrites (a + b) + c to (a + c) + b, and then rewrites",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp:675,Usability,simpl,simplify,675,"//===- NaryReassociate.cpp - Reassociate n-ary expressions ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass reassociates n-ary add expressions and eliminates the redundancy; // exposed by the reassociation.; //; // A motivating example:; //; // void foo(int a, int b) {; // bar(a + b);; // bar((a + 2) + b);; // }; //; // An ideal compiler should reassociate (a + 2) + b to (a + b) + 2 and simplify; // the above code to; //; // int t = a + b;; // bar(t);; // bar(t + 2);; //; // However, the Reassociate pass is unable to do that because it processes each; // instruction individually and believes (a + 2) + b is the best form according; // to its rank system.; //; // To address this limitation, NaryReassociate reassociates an expression in a; // form that reuses existing instructions. As a result, NaryReassociate can; // reassociate (a + 2) + b in the example to (a + b) + 2 because it detects that; // (a + b) is computed before.; //; // NaryReassociate works as follows. For every instruction in the form of (a +; // b) + c, it checks whether a + c or b + c is already computed by a dominating; // instruction. If so, it then reassociates (a + b) + c into (a + c) + b or (b +; // c) + a and removes the redundancy accordingly. To efficiently look up whether; // an expression is computed before, we store each instruction seen and its SCEV; // into an SCEV-to-instruction map.; //; // Although the algorithm pattern-matches only ternary additions, it; // automatically handles many >3-ary expressions by walking through the function; // in the depth-first order. For example, given; //; // (a + c) + d; // ((a + b) + c) + d; //; // NaryReassociate first rewrites (a + b) + c to (a + c) + b, and then rewrites",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp:85,Deployability,update,updated,85,// Delete all dead instructions from 'DeadInsts'.; // Please note ScalarEvolution is updated along the way.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp:8,Modifiability,extend,extend,8,// Zero-extend LHS if it is non-negative. InstCombine canonicalizes sext to; // zext if the source operand is proved non-negative. We should do that; // consistently so that CandidateExpr more likely appears before. See; // @reassociate_gep_assume for an example of this canonicalization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp:235,Performance,optimiz,optimization,235,"// Because we process the basic blocks in pre-order of the dominator tree, a; // candidate that doesn't dominate the current instruction won't dominate any; // future instruction either. Therefore, we pop it out of the stack. This; // optimization makes the algorithm O(n).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp:7,Performance,optimiz,optimization,7,// The optimization is profitable only if LHS can be removed in the end.; // In other words LHS should be used (directly or indirectly) by I only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:2482,Availability,Redundant,Redundant,2482,"n in that block. This is because the standard RPO; /// algorithm does not track what things have the same value number, it only; /// tracks what the value number of a given operation is (the mapping is; /// operation -> value number). Thus, when a value number of an operation; /// changes, it must reprocess everything to ensure all uses of a value number; /// get updated properly. In constrast, the sparse algorithm we use *also*; /// tracks what operations have a given value number (IE it also tracks the; /// reverse mapping from value number -> operations with that value number), so; /// that it only needs to reprocess the instructions that are affected when; /// something's value number changes. The vast majority of complexity and code; /// in this file is devoted to tracking what value numbers could change for what; /// instructions when various things happen. The rest of the algorithm is; /// devoted to performing symbolic evaluation, forward propagation, and; /// simplification of operations based on the value numbers deduced so far; ///; /// In order to make the GVN mostly-complete, we use a technique derived from; /// ""Detection of Redundant Expressions: A Complete and Polynomial-time; /// Algorithm in SSA"" by R.R. Pai. The source of incompleteness in most SSA; /// based GVN algorithms is related to their inability to detect equivalence; /// between phi of ops (IE phi(a+b, c+d)) and op of phis (phi(a,c) + phi(b, d)).; /// We resolve this issue by generating the equivalent ""phi of ops"" form for; /// each op of phis we see, in a way that only takes polynomial time to resolve.; ///; /// We also do not perform elimination by using any published algorithm. All; /// published algorithms are O(Instructions). Instead, we use a technique that; /// is O(number of operations with the same value number), enabling us to skip; /// trying to eliminate things that have unique value numbers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:1691,Deployability,update,updated,1691,"ecution of the program. In that respect, congruency is a; /// compile-time approximation of equivalence of values at runtime.; /// The algorithm implemented here uses a sparse formulation and it's based; /// on the ideas described in the paper:; /// ""A Sparse Algorithm for Predicated Global Value Numbering"" from; /// Karthik Gargi.; ///; /// A brief overview of the algorithm: The algorithm is essentially the same as; /// the standard RPO value numbering algorithm (a good reference is the paper; /// ""SCC based value numbering"" by L. Taylor Simpson) with one major difference:; /// The RPO algorithm proceeds, on every iteration, to process every reachable; /// block and every instruction in that block. This is because the standard RPO; /// algorithm does not track what things have the same value number, it only; /// tracks what the value number of a given operation is (the mapping is; /// operation -> value number). Thus, when a value number of an operation; /// changes, it must reprocess everything to ensure all uses of a value number; /// get updated properly. In constrast, the sparse algorithm we use *also*; /// tracks what operations have a given value number (IE it also tracks the; /// reverse mapping from value number -> operations with that value number), so; /// that it only needs to reprocess the instructions that are affected when; /// something's value number changes. The vast majority of complexity and code; /// in this file is devoted to tracking what value numbers could change for what; /// instructions when various things happen. The rest of the algorithm is; /// devoted to performing symbolic evaluation, forward propagation, and; /// simplification of operations based on the value numbers deduced so far; ///; /// In order to make the GVN mostly-complete, we use a technique derived from; /// ""Detection of Redundant Expressions: A Complete and Polynomial-time; /// Algorithm in SSA"" by R.R. Pai. The source of incompleteness in most SSA; /// based GVN algori",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:2246,Performance,perform,performing,2246,"n in that block. This is because the standard RPO; /// algorithm does not track what things have the same value number, it only; /// tracks what the value number of a given operation is (the mapping is; /// operation -> value number). Thus, when a value number of an operation; /// changes, it must reprocess everything to ensure all uses of a value number; /// get updated properly. In constrast, the sparse algorithm we use *also*; /// tracks what operations have a given value number (IE it also tracks the; /// reverse mapping from value number -> operations with that value number), so; /// that it only needs to reprocess the instructions that are affected when; /// something's value number changes. The vast majority of complexity and code; /// in this file is devoted to tracking what value numbers could change for what; /// instructions when various things happen. The rest of the algorithm is; /// devoted to performing symbolic evaluation, forward propagation, and; /// simplification of operations based on the value numbers deduced so far; ///; /// In order to make the GVN mostly-complete, we use a technique derived from; /// ""Detection of Redundant Expressions: A Complete and Polynomial-time; /// Algorithm in SSA"" by R.R. Pai. The source of incompleteness in most SSA; /// based GVN algorithms is related to their inability to detect equivalence; /// between phi of ops (IE phi(a+b, c+d)) and op of phis (phi(a,c) + phi(b, d)).; /// We resolve this issue by generating the equivalent ""phi of ops"" form for; /// each op of phis we see, in a way that only takes polynomial time to resolve.; ///; /// We also do not perform elimination by using any published algorithm. All; /// published algorithms are O(Instructions). Instead, we use a technique that; /// is O(number of operations with the same value number), enabling us to skip; /// trying to eliminate things that have unique value numbers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:2958,Performance,perform,perform,2958,"n in that block. This is because the standard RPO; /// algorithm does not track what things have the same value number, it only; /// tracks what the value number of a given operation is (the mapping is; /// operation -> value number). Thus, when a value number of an operation; /// changes, it must reprocess everything to ensure all uses of a value number; /// get updated properly. In constrast, the sparse algorithm we use *also*; /// tracks what operations have a given value number (IE it also tracks the; /// reverse mapping from value number -> operations with that value number), so; /// that it only needs to reprocess the instructions that are affected when; /// something's value number changes. The vast majority of complexity and code; /// in this file is devoted to tracking what value numbers could change for what; /// instructions when various things happen. The rest of the algorithm is; /// devoted to performing symbolic evaluation, forward propagation, and; /// simplification of operations based on the value numbers deduced so far; ///; /// In order to make the GVN mostly-complete, we use a technique derived from; /// ""Detection of Redundant Expressions: A Complete and Polynomial-time; /// Algorithm in SSA"" by R.R. Pai. The source of incompleteness in most SSA; /// based GVN algorithms is related to their inability to detect equivalence; /// between phi of ops (IE phi(a+b, c+d)) and op of phis (phi(a,c) + phi(b, d)).; /// We resolve this issue by generating the equivalent ""phi of ops"" form for; /// each op of phis we see, in a way that only takes polynomial time to resolve.; ///; /// We also do not perform elimination by using any published algorithm. All; /// published algorithms are O(Instructions). Instead, we use a technique that; /// is O(number of operations with the same value number), enabling us to skip; /// trying to eliminate things that have unique value numbers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:2469,Safety,Detect,Detection,2469,"n in that block. This is because the standard RPO; /// algorithm does not track what things have the same value number, it only; /// tracks what the value number of a given operation is (the mapping is; /// operation -> value number). Thus, when a value number of an operation; /// changes, it must reprocess everything to ensure all uses of a value number; /// get updated properly. In constrast, the sparse algorithm we use *also*; /// tracks what operations have a given value number (IE it also tracks the; /// reverse mapping from value number -> operations with that value number), so; /// that it only needs to reprocess the instructions that are affected when; /// something's value number changes. The vast majority of complexity and code; /// in this file is devoted to tracking what value numbers could change for what; /// instructions when various things happen. The rest of the algorithm is; /// devoted to performing symbolic evaluation, forward propagation, and; /// simplification of operations based on the value numbers deduced so far; ///; /// In order to make the GVN mostly-complete, we use a technique derived from; /// ""Detection of Redundant Expressions: A Complete and Polynomial-time; /// Algorithm in SSA"" by R.R. Pai. The source of incompleteness in most SSA; /// based GVN algorithms is related to their inability to detect equivalence; /// between phi of ops (IE phi(a+b, c+d)) and op of phis (phi(a,c) + phi(b, d)).; /// We resolve this issue by generating the equivalent ""phi of ops"" form for; /// each op of phis we see, in a way that only takes polynomial time to resolve.; ///; /// We also do not perform elimination by using any published algorithm. All; /// published algorithms are O(Instructions). Instead, we use a technique that; /// is O(number of operations with the same value number), enabling us to skip; /// trying to eliminate things that have unique value numbers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:2482,Safety,Redund,Redundant,2482,"n in that block. This is because the standard RPO; /// algorithm does not track what things have the same value number, it only; /// tracks what the value number of a given operation is (the mapping is; /// operation -> value number). Thus, when a value number of an operation; /// changes, it must reprocess everything to ensure all uses of a value number; /// get updated properly. In constrast, the sparse algorithm we use *also*; /// tracks what operations have a given value number (IE it also tracks the; /// reverse mapping from value number -> operations with that value number), so; /// that it only needs to reprocess the instructions that are affected when; /// something's value number changes. The vast majority of complexity and code; /// in this file is devoted to tracking what value numbers could change for what; /// instructions when various things happen. The rest of the algorithm is; /// devoted to performing symbolic evaluation, forward propagation, and; /// simplification of operations based on the value numbers deduced so far; ///; /// In order to make the GVN mostly-complete, we use a technique derived from; /// ""Detection of Redundant Expressions: A Complete and Polynomial-time; /// Algorithm in SSA"" by R.R. Pai. The source of incompleteness in most SSA; /// based GVN algorithms is related to their inability to detect equivalence; /// between phi of ops (IE phi(a+b, c+d)) and op of phis (phi(a,c) + phi(b, d)).; /// We resolve this issue by generating the equivalent ""phi of ops"" form for; /// each op of phis we see, in a way that only takes polynomial time to resolve.; ///; /// We also do not perform elimination by using any published algorithm. All; /// published algorithms are O(Instructions). Instead, we use a technique that; /// is O(number of operations with the same value number), enabling us to skip; /// trying to eliminate things that have unique value numbers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:2672,Safety,detect,detect,2672,"n in that block. This is because the standard RPO; /// algorithm does not track what things have the same value number, it only; /// tracks what the value number of a given operation is (the mapping is; /// operation -> value number). Thus, when a value number of an operation; /// changes, it must reprocess everything to ensure all uses of a value number; /// get updated properly. In constrast, the sparse algorithm we use *also*; /// tracks what operations have a given value number (IE it also tracks the; /// reverse mapping from value number -> operations with that value number), so; /// that it only needs to reprocess the instructions that are affected when; /// something's value number changes. The vast majority of complexity and code; /// in this file is devoted to tracking what value numbers could change for what; /// instructions when various things happen. The rest of the algorithm is; /// devoted to performing symbolic evaluation, forward propagation, and; /// simplification of operations based on the value numbers deduced so far; ///; /// In order to make the GVN mostly-complete, we use a technique derived from; /// ""Detection of Redundant Expressions: A Complete and Polynomial-time; /// Algorithm in SSA"" by R.R. Pai. The source of incompleteness in most SSA; /// based GVN algorithms is related to their inability to detect equivalence; /// between phi of ops (IE phi(a+b, c+d)) and op of phis (phi(a,c) + phi(b, d)).; /// We resolve this issue by generating the equivalent ""phi of ops"" form for; /// each op of phis we see, in a way that only takes polynomial time to resolve.; ///; /// We also do not perform elimination by using any published algorithm. All; /// published algorithms are O(Instructions). Instead, we use a technique that; /// is O(number of operations with the same value number), enabling us to skip; /// trying to eliminate things that have unique value numbers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:2308,Usability,simpl,simplification,2308,"n in that block. This is because the standard RPO; /// algorithm does not track what things have the same value number, it only; /// tracks what the value number of a given operation is (the mapping is; /// operation -> value number). Thus, when a value number of an operation; /// changes, it must reprocess everything to ensure all uses of a value number; /// get updated properly. In constrast, the sparse algorithm we use *also*; /// tracks what operations have a given value number (IE it also tracks the; /// reverse mapping from value number -> operations with that value number), so; /// that it only needs to reprocess the instructions that are affected when; /// something's value number changes. The vast majority of complexity and code; /// in this file is devoted to tracking what value numbers could change for what; /// instructions when various things happen. The rest of the algorithm is; /// devoted to performing symbolic evaluation, forward propagation, and; /// simplification of operations based on the value numbers deduced so far; ///; /// In order to make the GVN mostly-complete, we use a technique derived from; /// ""Detection of Redundant Expressions: A Complete and Polynomial-time; /// Algorithm in SSA"" by R.R. Pai. The source of incompleteness in most SSA; /// based GVN algorithms is related to their inability to detect equivalence; /// between phi of ops (IE phi(a+b, c+d)) and op of phis (phi(a,c) + phi(b, d)).; /// We resolve this issue by generating the equivalent ""phi of ops"" form for; /// each op of phis we see, in a way that only takes polynomial time to resolve.; ///; /// We also do not perform elimination by using any published algorithm. All; /// published algorithms are O(Instructions). Instead, we use a technique that; /// is O(number of operations with the same value number), enabling us to skip; /// trying to eliminate things that have unique value numbers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:28,Security,access,access,28,// Currently store defining access refinement is too slow due to basicaa being; // egregiously slow. This flag lets us keep it working while we work on this; // issue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:257,Safety,risk,risk,257,"// Tarjan's SCC finding algorithm with Nuutila's improvements; // SCCIterator is actually fairly complex for the simple thing we want.; // It also wants to hand us SCC's that are unrelated to the phi node we ask; // about, and have us process them there or risk redoing work.; // Graph traits over a filter iterator also doesn't work that well here.; // This SCC finder is specialized to walk use-def chains, and only follows; // instructions,; // not generic values (arguments, etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:113,Usability,simpl,simple,113,"// Tarjan's SCC finding algorithm with Nuutila's improvements; // SCCIterator is actually fairly complex for the simple thing we want.; // It also wants to hand us SCC's that are unrelated to the phi node we ask; // about, and have us process them there or risk redoing work.; // Graph traits over a filter iterator also doesn't work that well here.; // This SCC finder is specialized to walk use-def chains, and only follows; // instructions,; // not generic values (arguments, etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:1476,Integrability,depend,depends,1476,"gruence class has a leader, and the leader is used to symbolize; // instructions in a canonical way (IE every operand of an instruction that is a; // member of the same congruence class will always be replaced with leader; // during symbolization). To simplify symbolization, we keep the leader as a; // constant if class can be proved to be a constant value. Otherwise, the; // leader is the member of the value set with the smallest DFS number. Each; // congruence class also has a defining expression, though the expression may be; // null. If it exists, it can be used for forward propagation and reassociation; // of values.; // For memory, we also track a representative MemoryAccess, and a set of memory; // members for MemoryPhis (which have no real instructions). Note that for; // memory, it seems tempting to try to split the memory members into a; // MemoryCongruenceClass or something. Unfortunately, this does not work; // easily. The value numbering of a given memory expression depends on the; // leader of the memory congruence class, and the leader of memory congruence; // class depends on the value numbering of a given memory expression. This; // leads to wasted propagation, and in some cases, missed optimization. For; // example: If we had value numbered two stores together before, but now do not,; // we move them to a new value congruence class. This in turn will move at one; // of the memorydefs to a new memory congruence class. Which in turn, affects; // the value numbering of the stores we just value numbered (because the memory; // congruence class is part of the value number). So while theoretically; // possible to split them up, it turns out to be *incredibly* complicated to get; // it to work right, because of the interdependency. While structurally; // slightly messier, it is algorithmically much simpler and faster to do what we; // do here, and track them both at once in the same class.; // Note: The default iterators for this class iterate over values",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:1580,Integrability,depend,depends,1580,"gruence class has a leader, and the leader is used to symbolize; // instructions in a canonical way (IE every operand of an instruction that is a; // member of the same congruence class will always be replaced with leader; // during symbolization). To simplify symbolization, we keep the leader as a; // constant if class can be proved to be a constant value. Otherwise, the; // leader is the member of the value set with the smallest DFS number. Each; // congruence class also has a defining expression, though the expression may be; // null. If it exists, it can be used for forward propagation and reassociation; // of values.; // For memory, we also track a representative MemoryAccess, and a set of memory; // members for MemoryPhis (which have no real instructions). Note that for; // memory, it seems tempting to try to split the memory members into a; // MemoryCongruenceClass or something. Unfortunately, this does not work; // easily. The value numbering of a given memory expression depends on the; // leader of the memory congruence class, and the leader of memory congruence; // class depends on the value numbering of a given memory expression. This; // leads to wasted propagation, and in some cases, missed optimization. For; // example: If we had value numbered two stores together before, but now do not,; // we move them to a new value congruence class. This in turn will move at one; // of the memorydefs to a new memory congruence class. Which in turn, affects; // the value numbering of the stores we just value numbered (because the memory; // congruence class is part of the value number). So while theoretically; // possible to split them up, it turns out to be *incredibly* complicated to get; // it to work right, because of the interdependency. While structurally; // slightly messier, it is algorithmically much simpler and faster to do what we; // do here, and track them both at once in the same class.; // Note: The default iterators for this class iterate over values",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:166,Performance,perform,perform,166,"// Congruence classes represent the set of expressions/instructions; // that are all the same *during some scope in the function*.; // That is, because of the way we perform equality propagation, and; // because of memory value numbering, it is not correct to assume; // you can willy-nilly replace any member with any other at any; // point in the function.; //; // For any Value in the Member set, it is valid to replace any dominated member; // with that Value.; //; // Every congruence class has a leader, and the leader is used to symbolize; // instructions in a canonical way (IE every operand of an instruction that is a; // member of the same congruence class will always be replaced with leader; // during symbolization). To simplify symbolization, we keep the leader as a; // constant if class can be proved to be a constant value. Otherwise, the; // leader is the member of the value set with the smallest DFS number. Each; // congruence class also has a defining expression, though the expression may be; // null. If it exists, it can be used for forward propagation and reassociation; // of values.; // For memory, we also track a representative MemoryAccess, and a set of memory; // members for MemoryPhis (which have no real instructions). Note that for; // memory, it seems tempting to try to split the memory members into a; // MemoryCongruenceClass or something. Unfortunately, this does not work; // easily. The value numbering of a given memory expression depends on the; // leader of the memory congruence class, and the leader of memory congruence; // class depends on the value numbering of a given memory expression. This; // leads to wasted propagation, and in some cases, missed optimization. For; // example: If we had value numbered two stores together before, but now do not,; // we move them to a new value congruence class. This in turn will move at one; // of the memorydefs to a new memory congruence class. Which in turn, affects; // the value numbering of the stores",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:1705,Performance,optimiz,optimization,1705,"gruence class has a leader, and the leader is used to symbolize; // instructions in a canonical way (IE every operand of an instruction that is a; // member of the same congruence class will always be replaced with leader; // during symbolization). To simplify symbolization, we keep the leader as a; // constant if class can be proved to be a constant value. Otherwise, the; // leader is the member of the value set with the smallest DFS number. Each; // congruence class also has a defining expression, though the expression may be; // null. If it exists, it can be used for forward propagation and reassociation; // of values.; // For memory, we also track a representative MemoryAccess, and a set of memory; // members for MemoryPhis (which have no real instructions). Note that for; // memory, it seems tempting to try to split the memory members into a; // MemoryCongruenceClass or something. Unfortunately, this does not work; // easily. The value numbering of a given memory expression depends on the; // leader of the memory congruence class, and the leader of memory congruence; // class depends on the value numbering of a given memory expression. This; // leads to wasted propagation, and in some cases, missed optimization. For; // example: If we had value numbered two stores together before, but now do not,; // we move them to a new value congruence class. This in turn will move at one; // of the memorydefs to a new memory congruence class. Which in turn, affects; // the value numbering of the stores we just value numbered (because the memory; // congruence class is part of the value number). So while theoretically; // possible to split them up, it turns out to be *incredibly* complicated to get; // it to work right, because of the interdependency. While structurally; // slightly messier, it is algorithmically much simpler and faster to do what we; // do here, and track them both at once in the same class.; // Note: The default iterators for this class iterate over values",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:734,Usability,simpl,simplify,734,"// Congruence classes represent the set of expressions/instructions; // that are all the same *during some scope in the function*.; // That is, because of the way we perform equality propagation, and; // because of memory value numbering, it is not correct to assume; // you can willy-nilly replace any member with any other at any; // point in the function.; //; // For any Value in the Member set, it is valid to replace any dominated member; // with that Value.; //; // Every congruence class has a leader, and the leader is used to symbolize; // instructions in a canonical way (IE every operand of an instruction that is a; // member of the same congruence class will always be replaced with leader; // during symbolization). To simplify symbolization, we keep the leader as a; // constant if class can be proved to be a constant value. Otherwise, the; // leader is the member of the value set with the smallest DFS number. Each; // congruence class also has a defining expression, though the expression may be; // null. If it exists, it can be used for forward propagation and reassociation; // of values.; // For memory, we also track a representative MemoryAccess, and a set of memory; // members for MemoryPhis (which have no real instructions). Note that for; // memory, it seems tempting to try to split the memory members into a; // MemoryCongruenceClass or something. Unfortunately, this does not work; // easily. The value numbering of a given memory expression depends on the; // leader of the memory congruence class, and the leader of memory congruence; // class depends on the value numbering of a given memory expression. This; // leads to wasted propagation, and in some cases, missed optimization. For; // example: If we had value numbered two stores together before, but now do not,; // we move them to a new value congruence class. This in turn will move at one; // of the memorydefs to a new memory congruence class. Which in turn, affects; // the value numbering of the stores",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:2323,Usability,simpl,simpler,2323,"gruence class has a leader, and the leader is used to symbolize; // instructions in a canonical way (IE every operand of an instruction that is a; // member of the same congruence class will always be replaced with leader; // during symbolization). To simplify symbolization, we keep the leader as a; // constant if class can be proved to be a constant value. Otherwise, the; // leader is the member of the value set with the smallest DFS number. Each; // congruence class also has a defining expression, though the expression may be; // null. If it exists, it can be used for forward propagation and reassociation; // of values.; // For memory, we also track a representative MemoryAccess, and a set of memory; // members for MemoryPhis (which have no real instructions). Note that for; // memory, it seems tempting to try to split the memory members into a; // MemoryCongruenceClass or something. Unfortunately, this does not work; // easily. The value numbering of a given memory expression depends on the; // leader of the memory congruence class, and the leader of memory congruence; // class depends on the value numbering of a given memory expression. This; // leads to wasted propagation, and in some cases, missed optimization. For; // example: If we had value numbered two stores together before, but now do not,; // we move them to a new value congruence class. This in turn will move at one; // of the memorydefs to a new memory congruence class. Which in turn, affects; // the value numbering of the stores we just value numbered (because the memory; // congruence class is part of the value number). So while theoretically; // possible to split them up, it turns out to be *incredibly* complicated to get; // it to work right, because of the interdependency. While structurally; // slightly messier, it is algorithmically much simpler and faster to do what we; // do here, and track them both at once in the same class.; // Note: The default iterators for this class iterate over values",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:67,Testability,assert,assertion,67,"// True if this class has no members left. This is mainly used for assertion; // purposes, and for skipping empty classes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:83,Security,access,access,83,"// If this class contains MemoryDefs or MemoryPhis, this is the leading memory; // access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:73,Safety,detect,detect,73,// Number of stores in this congruence class.; // This is used so we can detect store equivalence changes properly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:11,Security,hash,hashes,11,"// Compare hashes before equality. This is *not* what the hashtable does,; // since it is computing it modulo the number of buckets, whereas we are; // using the full hash keyspace. Since the hashes are precomputed, this; // check is *much* faster than equality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:58,Security,hash,hashtable,58,"// Compare hashes before equality. This is *not* what the hashtable does,; // since it is computing it modulo the number of buckets, whereas we are; // using the full hash keyspace. Since the hashes are precomputed, this; // check is *much* faster than equality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:167,Security,hash,hash,167,"// Compare hashes before equality. This is *not* what the hashtable does,; // since it is computing it modulo the number of buckets, whereas we are; // using the full hash keyspace. Since the hashes are precomputed, this; // check is *much* faster than equality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:192,Security,hash,hashes,192,"// Compare hashes before equality. This is *not* what the hashtable does,; // since it is computing it modulo the number of buckets, whereas we are; // using the full hash keyspace. Since the hashes are precomputed, this; // check is *much* faster than equality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:561,Performance,perform,perform,561,"// In order to know when we should re-process instructions that have; // phi-of-ops, we track the set of expressions that they needed as; // leaders. When we discover new leaders for those expressions, we process the; // associated phi-of-op instructions again in case they have changed. The; // other way they may change is if they had leaders, and those leaders; // disappear. However, at the point they have leaders, there are uses of the; // relevant operands in the created phi node, and so they will get reprocessed; // through the normal user marking we perform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:152,Testability,test,test,152,// Set of all temporary instructions we created.; // Note: This will include instructions that were just created during value; // numbering. The way to test if something is using them is to check; // RealToTemp.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:468,Integrability,depend,depended,468,"// This is the set of instructions to revisit on a reachability change. At; // the end of the main iteration loop it will contain at least all the phi of; // ops instructions that will be changed to phis, as well as regular phis.; // During the iteration loop, it may contain other things, such as phi of ops; // instructions that used edge reachability to reach a result, and so need to; // be revisited when the edge changes, independent of whether the phi they; // depended on changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:539,Safety,avoid,avoid,539,"// We could, if we wanted, build MemoryPhiExpressions and; // MemoryVariableExpressions, etc, and value number them the same way we value; // number phi expressions. For the moment, this seems like overkill. They; // can only exist in one of three states: they can be TOP (equal to; // everything), Equivalent to something else, or unique. Because we do not; // create expressions for them, we need to simulate leader change not just; // when they change class, but when they change state. Note: We can do the; // same thing for phis, and avoid having phi expressions if we wanted, We; // should eventually unify in one direction or the other, so this is a little; // bit of an experiment in which turns out easier to maintain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:411,Energy Efficiency,efficient,efficiently,411,"// This is a bitvector because, on larger functions, we may have; // thousands of touched instructions at once (entire blocks,; // instructions with hundreds of uses, etc). Even with optimization; // for when we mark whole blocks as touched, when this was a; // SmallPtrSet or DenseSet, for some functions, we spent >20% of all; // the time in GVN just managing this list. The bitvector, on the; // other hand, efficiently supports test/set/clear of both; // individual and ranges, as well as ""find next element"" This; // enables us to use it as a worklist with essentially 0 cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:183,Performance,optimiz,optimization,183,"// This is a bitvector because, on larger functions, we may have; // thousands of touched instructions at once (entire blocks,; // instructions with hundreds of uses, etc). Even with optimization; // for when we mark whole blocks as touched, when this was a; // SmallPtrSet or DenseSet, for some functions, we spent >20% of all; // the time in GVN just managing this list. The bitvector, on the; // other hand, efficiently supports test/set/clear of both; // individual and ranges, as well as ""find next element"" This; // enables us to use it as a worklist with essentially 0 cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:432,Testability,test,test,432,"// This is a bitvector because, on larger functions, we may have; // thousands of touched instructions at once (entire blocks,; // instructions with hundreds of uses, etc). Even with optimization; // for when we mark whole blocks as touched, when this was a; // SmallPtrSet or DenseSet, for some functions, we spent >20% of all; // the time in GVN just managing this list. The bitvector, on the; // other hand, efficiently supports test/set/clear of both; // individual and ranges, as well as ""find next element"" This; // enables us to use it as a worklist with essentially 0 cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:441,Usability,clear,clear,441,"// This is a bitvector because, on larger functions, we may have; // thousands of touched instructions at once (entire blocks,; // instructions with hundreds of uses, etc). Even with optimization; // for when we mark whole blocks as touched, when this was a; // SmallPtrSet or DenseSet, for some functions, we spent >20% of all; // the time in GVN just managing this list. The bitvector, on the; // other hand, efficiently supports test/set/clear of both; // individual and ranges, as well as ""find next element"" This; // enables us to use it as a worklist with essentially 0 cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:61,Integrability,depend,dependency,61,/// Helper struct return a Expression with an optional extra dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:51,Availability,avail,available,51,// Return true if V is a value that will always be available (IE can; // be placed anywhere) in the function. We don't do globals here; // because they are often worse to put in place.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:232,Energy Efficiency,efficient,efficient,232,"// Ensure that commutative instructions that only differ by a permutation; // of their operands get the same value number by sorting the operand value; // numbers. Since all commutative instructions have two operands it is more; // efficient to sort by hand rather than using, say, std::sort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:28,Usability,simpl,simplification,28,"// Take a Value returned by simplification of Expression E/Instruction; // I, and see if it resulted in a simpler expression. If so, return; // that expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:106,Usability,simpl,simpler,106,"// Take a Value returned by simplification of Expression E/Instruction; // I, and see if it resulted in a simpler expression. If so, return; // that expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:232,Energy Efficiency,efficient,efficient,232,"// Ensure that commutative instructions that only differ by a permutation; // of their operands get the same value number by sorting the operand value; // numbers. Since all commutative instructions have two operands it is more; // efficient to sort by hand rather than using, say, std::sort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:3,Performance,Perform,Perform,3,// Perform simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:11,Usability,simpl,simplification,11,// Perform simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:37,Usability,simpl,simplifyCmpInst,37,// TODO: 25% of our time is spent in simplifyCmpInst with pointer operands,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:263,Integrability,interface,interface,263,"// We don't bother trying to simplify unless all of the operands; // were constant.; // TODO: There are a lot of Simplify*'s we could call here, if we; // wanted to. The original motivating case for this code was a; // zext i1 false to i8, which we don't have an interface to; // simplify (IE there is no SimplifyZExt).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:29,Usability,simpl,simplify,29,"// We don't bother trying to simplify unless all of the operands; // were constant.; // TODO: There are a lot of Simplify*'s we could call here, if we; // wanted to. The original motivating case for this code was a; // zext i1 false to i8, which we don't have an interface to; // simplify (IE there is no SimplifyZExt).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:113,Usability,Simpl,Simplify,113,"// We don't bother trying to simplify unless all of the operands; // were constant.; // TODO: There are a lot of Simplify*'s we could call here, if we; // wanted to. The original motivating case for this code was a; // zext i1 false to i8, which we don't have an interface to; // simplify (IE there is no SimplifyZExt).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:280,Usability,simpl,simplify,280,"// We don't bother trying to simplify unless all of the operands; // were constant.; // TODO: There are a lot of Simplify*'s we could call here, if we; // wanted to. The original motivating case for this code was a; // zext i1 false to i8, which we don't have an interface to; // simplify (IE there is no SimplifyZExt).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:305,Usability,Simpl,SimplifyZExt,305,"// We don't bother trying to simplify unless all of the operands; // were constant.; // TODO: There are a lot of Simplify*'s we could call here, if we; // wanted to. The original motivating case for this code was a; // zext i1 false to i8, which we don't have an interface to; // simplify (IE there is no SimplifyZExt).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:657,Integrability,Depend,Depending,657,"// This must be an instruction because we are only called from phi nodes; // in the case that the value it needs to check against is an instruction.; // The most likely candidates for dominance are the leader and the next leader.; // The leader or nextleader will dominate in all cases where there is an; // equivalent that is higher up in the dom tree.; // We can't *only* check them, however, because the; // dominator tree could have an infinite number of non-dominating siblings; // with instructions that are in the right congruence class.; // A; // B C D E F G; // |; // H; // Instruction U could be in H, with equivalents in every other sibling.; // Depending on the rpo order picked, the leader could be the equivalent in; // any of these siblings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:18,Performance,load,loads,18,// Give store and loads same opcode so they value number together.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:135,Performance,load,load,135,"// TODO: Value number heap versions. We may be able to discover; // things alias analysis can't on it's own (IE that a store and a; // load have the same value, and thus, it isn't clobbering the load).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:195,Performance,load,load,195,"// TODO: Value number heap versions. We may be able to discover; // things alias analysis can't on it's own (IE that a store and a; // load have the same value, and thus, it isn't clobbering the load).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:18,Performance,load,loads,18,// Give store and loads same opcode so they value number together.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:135,Performance,load,load,135,"// TODO: Value number heap versions. We may be able to discover; // things alias analysis can't on it's own (IE that a store and a; // load have the same value, and thus, it isn't clobbering the load).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:195,Performance,load,load,195,"// TODO: Value number heap versions. We may be able to discover; // things alias analysis can't on it's own (IE that a store and a; // load have the same value, and thus, it isn't clobbering the load).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:10,Performance,load,loads,10,"// Unlike loads, we never try to eliminate stores, so we do not check if they; // are simple and avoid value numbering them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:97,Safety,avoid,avoid,97,"// Unlike loads, we never try to eliminate stores, so we do not check if they; // are simple and avoid value numbering them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:86,Usability,simpl,simple,86,"// Unlike loads, we never try to eliminate stores, so we do not check if they; // are simple and avoid value numbering them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:173,Usability,simpl,simple,173,"// See if we are defined by a previous store expression, it already has a; // value, and it's the same value as our current store. FIXME: Right now, we; // only do this for simple stores, we should expand to cover memcpys, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:346,Performance,load,load,346,"// We really want to check whether the expression we matched was a store. No; // easy way to do that. However, we can check that the class we found has a; // store, which, assuming the value numbering state is not corrupt, is; // sufficient, because we must also be equivalent to that store's expression; // for it to be in the same class as the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:51,Performance,load,load,51,"// Also check if our value operand is defined by a load of the same memory; // location, and the memory state is the same as it was then (otherwise, it; // could have been overwritten later. See test32 in; // transforms/DeadStoreElimination/simple.ll).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:241,Usability,simpl,simple,241,"// Also check if our value operand is defined by a load of the same memory; // location, and the memory state is the same as it was then (otherwise, it; // could have been overwritten later. See test32 in; // transforms/DeadStoreElimination/simple.ll).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:40,Performance,load,loaded,40,"// See if we can extract the value of a loaded pointer from a load, a store, or; // a memory instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:62,Performance,load,load,62,"// See if we can extract the value of a loaded pointer from a load, a store, or; // a memory instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:28,Performance,load,load,28,// We can coerce a constant load into a load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:40,Performance,load,load,40,// We can coerce a constant load into a load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:79,Integrability,depend,dependent,79,// All of the below are only true if the loaded pointer is produced; // by the dependent instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:41,Performance,load,loaded,41,// All of the below are only true if the loaded pointer is produced; // by the dependent instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:31,Integrability,depend,depend,31,"// If this load really doesn't depend on anything, then we must be loading an; // undef value. This can happen when loading for a fresh allocation with no; // intervening stores, for example. Note that this is only true in the case; // that the result of the allocation is pointer equal to the load ptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:11,Performance,load,load,11,"// If this load really doesn't depend on anything, then we must be loading an; // undef value. This can happen when loading for a fresh allocation with no; // intervening stores, for example. Note that this is only true in the case; // that the result of the allocation is pointer equal to the load ptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:67,Performance,load,loading,67,"// If this load really doesn't depend on anything, then we must be loading an; // undef value. This can happen when loading for a fresh allocation with no; // intervening stores, for example. Note that this is only true in the case; // that the result of the allocation is pointer equal to the load ptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:116,Performance,load,loading,116,"// If this load really doesn't depend on anything, then we must be loading an; // undef value. This can happen when loading for a fresh allocation with no; // intervening stores, for example. Note that this is only true in the case; // that the result of the allocation is pointer equal to the load ptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:294,Performance,load,load,294,"// If this load really doesn't depend on anything, then we must be loading an; // undef value. This can happen when loading for a fresh allocation with no; // intervening stores, for example. Note that this is only true in the case; // that the result of the allocation is pointer equal to the load ptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:11,Performance,load,load,11,"// If this load occurs either right after a lifetime begin,; // then the loaded value is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:73,Performance,load,loaded,73,"// If this load occurs either right after a lifetime begin,; // then the loaded value is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:43,Performance,load,loads,43,"// We can eliminate in favor of non-simple loads, but we won't be able to; // eliminate the loads themselves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:92,Performance,load,loads,92,"// We can eliminate in favor of non-simple loads, but we won't be able to; // eliminate the loads themselves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:36,Usability,simpl,simple,36,"// We can eliminate in favor of non-simple loads, but we won't be able to; // eliminate the loads themselves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:3,Performance,Load,Load,3,// Load of undef is UB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:79,Security,access,access,79,"// This will handle stores and memory insts. We only do if it the; // defining access has a different type, or it is a pointer produced by; // certain memory operations that cause the memory to have a fixed value; // (IE things like calloc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:43,Security,access,access,43,"// If our MemoryLeader is not our defining access, add a use to the; // MemoryLeader, so that we get reprocessed when it changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:229,Performance,optimiz,optimization,229,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:317,Performance,optimiz,optimizations,317,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:356,Safety,detect,detect,356,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:40,Security,access,access,40,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:90,Security,access,accessing,90,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:378,Security,access,accessing,378,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:177,Usability,resume,resume,177,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:57,Integrability,depend,depend,57,"// Do not combine convergent calls since they implicitly depend on the set of; // threads that is currently executing, and they might be in different basic; // blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
