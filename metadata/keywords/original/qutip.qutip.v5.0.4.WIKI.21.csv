id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:30629,Modifiability,config,config,30629,"algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. bounds = self._build_bounds_list(); result = self._create_result(). if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if 'accuracy_factor' in self.method_options:; factr = self.method_options['accuracy_factor']; elif 'ftol' in self.method_options:; factr = self.method_options['ftol']; elif hasattr(term_conds, 'accuracy_factor'):; factr = term_conds.accuracy_factor; else:; factr = 1e7. if 'max_metric_corr' in self.method_options:; m = self.method_options['max_metric_corr']; elif 'maxcor' in self.method_options:; m = self.method_options['maxcor']; elif hasattr(self, 'max_metric_corr'):; m = self.max_metric_corr; else:; m = 10. if self.log_level <= logging.INFO:; msg = (""Op",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:33483,Modifiability,config,configuration,33483,"elity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerCrab(Optimizer):; """"""; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients. AJGP ToDo: Add citation here; """""". def reset(self):; Optimizer.reset(self); self.id_text = 'CRAB'; self.num_optim_vars = 0. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_vars = 0; pulse_gen_valid = True; # check the pulse generators match the ctrls; # (in terms of number); # and count the number of parameters; if self.pulse_generator is None:; pulse_gen_valid = False; err_msg = ""pulse_generator attribute is None""; elif not isinstance(self.pulse_generator, collections.abc.Iterable):; pulse_gen_valid = False; err_msg = ""pulse_generator is not iterable"". elif len(self.pulse_generator) != dyn.num_ctrls:; pulse_gen_valid = False; err_msg = (""the number of pulse generators {} does not equal ""; ""the number of controls {}"".format(; len(self.pulse_generator), dyn.num_ctrls)). if pulse_gen_valid:; for p_gen in self.pulse_generator:; if not isinstance(p_gen, pulsegen.PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:34953,Modifiability,variab,variable,34953,") != dyn.num_ctrls:; pulse_gen_valid = False; err_msg = (""the number of pulse generators {} does not equal ""; ""the number of controls {}"".format(; len(self.pulse_generator), dyn.num_ctrls)). if pulse_gen_valid:; for p_gen in self.pulse_generator:; if not isinstance(p_gen, pulsegen.PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p_gen.num_optim_vars. if not pulse_gen_valid:; raise errors.UsageError(; ""The pulse_generator attribute must be set to a list of ""; ""PulseGenCrab - one for each control. Here "" + err_msg). def _build_bounds_list(self):; """"""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:35149,Modifiability,extend,extend,35149,"lse_generator), dyn.num_ctrls)). if pulse_gen_valid:; for p_gen in self.pulse_generator:; if not isinstance(p_gen, pulsegen.PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p_gen.num_optim_vars. if not pulse_gen_valid:; raise errors.UsageError(; ""The pulse_generator attribute must be set to a list of ""; ""PulseGenCrab - one for each control. Here "" + err_msg). def _build_bounds_list(self):; """"""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:35300,Modifiability,variab,variable,35300,".PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p_gen.num_optim_vars. if not pulse_gen_valid:; raise errors.UsageError(; ""The pulse_generator attribute must be set to a list of ""; ""PulseGenCrab - one for each control. Here "" + err_msg). def _build_bounds_list(self):; """"""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Op",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:37894,Modifiability,config,config,37894,"None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). #print(""Initial values:\n{}"".format(self.optim_var_vals)); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. result = self._create_result(). if self.log_level <= logging.INFO:; logger.info(""Optimising pulse(s) using {} with ""; ""'fmin' (Nelder-Mead) method"".format(self.alg)). try:; ret = spopt.fmin(; self.fid_err_func_wrapper, self.optim_var_vals,; xtol=self.xtol, ftol=self.ftol,; maxiter=term_conds.max_iterations,; maxfun=term_conds.max_fid_func_calls,; full_output=True, disp=self.disp_conv_msg,; retall=self.record_iteration_steps,; callback=self.iter_step_callback_func). final_param_vals = ret[0]; num_iter = ret[2]; warn_flag = ret[4]; if self.record_iteration_steps:; self.iteration_steps = ret[5]; amps = self._get_ctrl_amps(final_param_vals); dyn.",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:18,Performance,optimiz,optimizer,18,". . qutip.control.optimizer — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Module code »; qutip.control.optimizer. Source code for qutip.control.optimizer; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:279,Performance,optimiz,optimizer,279,". . qutip.control.optimizer — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Module code »; qutip.control.optimizer. Source code for qutip.control.optimizer; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:320,Performance,optimiz,optimizer,320,". . qutip.control.optimizer — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Module code »; qutip.control.optimizer. Source code for qutip.control.optimizer; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:3212,Performance,optimiz,optimize,3212,"s here are expected to implement a run_optimization function; that will use some method for optimising the control pulse, as defined; by the control amplitudes. The system that the pulse acts upon are defined; by the Dynamics object that must be passed in the instantiation. The methods are typically N dimensional function optimisers that; find the minima of a fidelity error function. Note the number of variables; for the fidelity function is the number of control timeslots,; i.e. n_ctrls x Ntimeslots; The methods will call functions on the Dynamics.fid_computer object,; one or many times per interation,; to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are cal",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:3800,Performance,perform,performs,3800,"t the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.contr",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:4079,Performance,optimiz,optimize,4079,"al minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; exc",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:4479,Performance,optimiz,optimize,4479," implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; ",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:6495,Performance,optimiz,optimize,6495,"uantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params : Dictionary; Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad : bool; If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value appl",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:6561,Performance,optimiz,optimize,6561,"og_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params : Dictionary; Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad : bool; If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds ",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:8425,Performance,perform,performance,8425,"the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics : Dynamics (subclass instance); describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Not",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:12827,Performance,optimiz,optimizer,12827,"lf.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.OptimDump):; self.dump = qtrldump.OptimDump(self, level=lvl); else:; self.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.evo_full_initial = self.dynamics.full_evo.copy(); result.time = self.dynamics.time.copy(); result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_c",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:14488,Performance,optimiz,optimize,14488,"check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_options(self):; """"""; Creates the method_options dictionary for the scipy.optimize.minimize; function based on the attributes of this object and the; termination_conditions; It assumes that apply_method_params has already been run and; hence the method_options attribute may already contain items.; These values will NOT be overridden; """"""; tc = self.termination_conditions; if self.method_options is None:; self.method_options = {}; mo = self.method_options. if 'max_metric_corr' in mo and not 'maxcor' in mo:; mo['maxcor'] = mo['max_metric_corr']; elif hasattr(self, 'max_metric_corr') and not 'maxcor' in mo:; mo['maxcor'] = self.max_metric_corr; if 'accuracy_factor' in mo and not 'ftol' in mo:; mo['ftol'] = mo['accuracy_factor']; elif hasattr(tc, 'accuracy_factor') and not 'ftol' in mo:; mo['ftol'] = tc.accuracy_factor; if tc.max_iterations > 0 and not 'maxiter' in mo:; mo['maxiter'] = tc.max_iterations; if tc.max_fid_func_calls > 0 and not 'maxfev' in mo:; mo['maxfev'] = tc.max_fid_func_calls; if tc.min_gradient_norm > 0 and not 'gtol' in mo:; mo['gtol'] = tc.min_gr",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:15906,Performance,optimiz,optimize,15906,"maxcor' in mo:; mo['maxcor'] = mo['max_metric_corr']; elif hasattr(self, 'max_metric_corr') and not 'maxcor' in mo:; mo['maxcor'] = self.max_metric_corr; if 'accuracy_factor' in mo and not 'ftol' in mo:; mo['ftol'] = mo['accuracy_factor']; elif hasattr(tc, 'accuracy_factor') and not 'ftol' in mo:; mo['ftol'] = tc.accuracy_factor; if tc.max_iterations > 0 and not 'maxiter' in mo:; mo['maxiter'] = tc.max_iterations; if tc.max_fid_func_calls > 0 and not 'maxfev' in mo:; mo['maxfev'] = tc.max_fid_func_calls; if tc.min_gradient_norm > 0 and not 'gtol' in mo:; mo['gtol'] = tc.min_gradient_norm; if not 'disp' in mo:; mo['disp'] = self.disp_conv_msg. return mo. [docs] def apply_method_params(self, params=None):; """"""; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function; """"""; if not params:; params = self.method_params. if isinstance(params, dict):; self.method_params = params; unused_params = {}; for key in params:; val = params[key]; if hasattr(self, key):; setattr(self, key, val); if hasattr(self.termination_conditions, key):; setattr(self.termination_conditions, key, val); else:; unused_params[key] = val. if len(unused_params) > 0:; if not isinstance(self.method_options, dict):; self.method_options = unused_params; else:; self.method_options.update(unused_params). def _build_bounds_list(self):; cfg = self.config; dyn = self.dynamics; n_ctrls = dyn.num_ctrls; self.bounds = []; for t in range(dyn.num_tslots):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.app",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:17053,Performance,optimiz,optimize,17053,"= {}; for key in params:; val = params[key]; if hasattr(self, key):; setattr(self, key, val); if hasattr(self.termination_conditions, key):; setattr(self.termination_conditions, key, val); else:; unused_params[key] = val. if len(unused_params) > 0:; if not isinstance(self.method_options, dict):; self.method_options = unused_params; else:; self.method_options.update(unused_params). def _build_bounds_list(self):; cfg = self.config; dyn = self.dynamics; n_ctrls = dyn.num_ctrls; self.bounds = []; for t in range(dyn.num_tslots):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.append((lb, ub)). [docs] def run_optimization(self, term_conds=None):; """"""; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient. The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for t",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:26213,Performance,optimiz,optimize,26213,"result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.stats.calculate(); result.stats = copy.copy(self.stats). [docs]class OptimizerBFGS(Optimizer):; """"""; Implements the run_optimization method using the BFGS algorithm; """"""; def reset(self):; Optimizer.reset(self); self.id_text = 'BFGS'. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_bfgs' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). result = self._create_result(); try:; opt",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:28414,Performance,optimiz,optimize,28414,"_callback_func,; gtol=term_conds.min_gradient_norm,; maxiter=term_conds.max_iterations,; full_output=True, disp=True). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); if warn == 1:; result.max_iter_exceeded = True; result.termination_reason = ""Iteration count limit reached""; elif warn == 2:; result.grad_norm_min_reached = True; result.termination_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_lev",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:29999,Performance,optimiz,optimize,29999,"ttr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. bounds = self._build_bounds_list(); result = self._create_result(). if self.a",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:32916,Performance,optimiz,optimize,32916,"f.approx_grad,; callback=self.iter_step_callback_func,; bounds=self.bounds, m=m, factr=factr,; pgtol=term_conds.min_gradient_norm,; disp=self.msg_level,; maxfun=term_conds.max_fid_func_calls,; maxiter=term_conds.max_iterations). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); warn = res_dict['warnflag']; if warn == 0:; result.grad_norm_min_reached = True; result.termination_reason = ""function converged""; elif warn == 1:; result.max_iter_exceeded = True; result.termination_reason = (""Iteration or fidelity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerCrab(Optimizer):; """"""; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients. AJGP ToDo: Add citation here; """""". def reset(self):; Optimizer.reset(self); self.id_text = 'CRAB'; self.num_optim_vars = 0. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_vars = 0; pulse_gen_valid = True; # check the pulse generators match the ctrls; # (in terms of number); # and count the number of parameters; if self.pulse_generator is None:; pulse_gen_valid = False; err_msg = ""pulse_generator attribute is None""; elif not isinstance(self.pulse_generator, collections.abc.Iterable):; pulse_gen_valid = False",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:36348,Performance,optimiz,optimize,36348,"hat is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes; -----; [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011).; [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Spec",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:36974,Performance,optimiz,optimize,36974,"_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes; -----; [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011).; [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:4599,Testability,log,logging,4599,"OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging ",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:4608,Testability,log,logger,4608,"OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging ",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:4617,Testability,log,logging,4617,"OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging ",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:5620,Testability,log,logger,5620,"ogging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize meth",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:10669,Testability,log,logger,10669,"elf):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised l",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:10787,Testability,log,logger,10787,"one; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to ",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:10808,Testability,log,logger,10808,"one; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to ",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:10835,Testability,log,logger,10835,"on_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped; """"""; if self.dump is None:; lvl = 'NONE'; e",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:11589,Testability,log,logs,11589,"config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.OptimDump):; self.dump = qtrldump.OptimDump(self, level=lvl); else:; self.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the curren",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:11769,Testability,log,logs,11769," and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.OptimDump):; self.dump = qtrldump.OptimDump(self, level=lvl); else:; self.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.evo_full_initial = self.dynamics.",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:14118,Testability,log,logger,14118," is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_options(self):; """"""; Creates the method_options dictionary for the scipy.optimize.minimize; function based on the attributes of this object and the; termination_conditions; It assumes that apply_method_params has already been run and; hence the method_options attribute may already contain items.; These values will NOT be overridden; """"""; tc = self.termination_conditions; if self.method_options is None:; self.method_options = {}; mo = self.method_options. if 'max_metric_corr' in mo and not 'maxcor' in mo:; mo['maxcor'] = mo['max_metric_corr']; elif hasattr(self, 'max_metric_corr') and not 'maxcor' in mo:; mo['maxcor'] = self.max_metric_corr; if 'accuracy_factor' in mo and not 'ftol' in mo:",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:17603,Testability,test,tested,17603,"s):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.append((lb, ub)). [docs] def run_optimization(self, term_conds=None):; """"""; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient. The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 0. if self.bounds is None:; self._build_bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_gra",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:18657,Testability,log,logging,18657," some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 0. if self.bounds is None:; self._build_bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_grad:; jac=None; else:; jac=self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""minimise '{}' method"").format(self.alg, self.method); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:18819,Testability,log,logger,18819,"ameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 0. if self.bounds is None:; self._build_bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_grad:; jac=None; else:; jac=self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""minimise '{}' method"").format(self.alg, self.method); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of th",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:19298,Testability,log,logger,19298,"e_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 0. if self.bounds is None:; self._build_bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_grad:; jac=None; else:; jac=self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""minimise '{}' method"").format(self.alg, self.method); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamic",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:21137,Testability,log,logging,21137,"s passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed a",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:21153,Testability,log,logger,21153,"optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. H",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:22711,Testability,log,logging,22711,"unc_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; se",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:22727,Testability,log,logger,22727,"errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. ",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:23748,Testability,log,logging,23748,"ient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_re",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:23764,Testability,log,logger,23764,"at(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:27012,Testability,log,logging,27012,"d when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_bfgs' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). result = self._create_result(); try:; optim_var_vals, cost, grad, invHess, nFCalls, nGCalls, warn = \; spopt.fmin_bfgs(self.fid_err_func_wrapper,; self.optim_var_vals,; fprime=fprime,; # approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; gtol=term_conds.min_gradient_norm,; maxiter=term_conds.max_iterations,; full_output=True, disp=True). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); if warn == 1:; result.max_iter_exceeded = True; result.termination_reason = ""Iteration count limit reached""; elif warn == 2:; result.grad_norm_min_reached = True; result.termination_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(re",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:27159,Testability,log,logger,27159," iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_bfgs' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). result = self._create_result(); try:; optim_var_vals, cost, grad, invHess, nFCalls, nGCalls, warn = \; spopt.fmin_bfgs(self.fid_err_func_wrapper,; self.optim_var_vals,; fprime=fprime,; # approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; gtol=term_conds.min_gradient_norm,; maxiter=term_conds.max_iterations,; full_output=True, disp=True). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); if warn == 1:; result.max_iter_exceeded = True; result.termination_reason = ""Iteration count limit reached""; elif warn == 2:; result.grad_norm_min_reached = True; result.termination_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using t",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:29366,Testability,log,logging,29366,"re used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if th",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:29425,Testability,log,logging,29425,".fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an Opti",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:31611,Testability,log,logging,31611,"dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. bounds = self._build_bounds_list(); result = self._create_result(). if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if 'accuracy_factor' in self.method_options:; factr = self.method_options['accuracy_factor']; elif 'ftol' in self.method_options:; factr = self.method_options['ftol']; elif hasattr(term_conds, 'accuracy_factor'):; factr = term_conds.accuracy_factor; else:; factr = 1e7. if 'max_metric_corr' in self.method_options:; m = self.method_options['max_metric_corr']; elif 'maxcor' in self.method_options:; m = self.method_options['maxcor']; elif hasattr(self, 'max_metric_corr'):; m = self.max_metric_corr; else:; m = 10. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_l_bfgs_b' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg); try:; optim_var_vals, fid, res_dict = spopt.fmin_l_bfgs_b(; self.fid_err_func_wrapper, self.optim_var_vals,; fprime=fprime,; approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; bounds=self.bounds, m=m, factr=factr,; pgtol=term_conds.min_gradient_norm,; disp=self.msg_level,; maxfun=term_conds.max_fid_func_calls,; maxiter=term_conds.max_iterations). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); warn = res_dict['warnflag']; if warn == 0:; result.grad_norm_min_reached = True; result.termination_reason = ""function converged""; elif warn == 1:; result.max_iter_exceeded = True; result.termination_reason = (""Iteration or fidelity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.Optimiza",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:31762,Testability,log,logger,31762,"r(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. bounds = self._build_bounds_list(); result = self._create_result(). if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if 'accuracy_factor' in self.method_options:; factr = self.method_options['accuracy_factor']; elif 'ftol' in self.method_options:; factr = self.method_options['ftol']; elif hasattr(term_conds, 'accuracy_factor'):; factr = term_conds.accuracy_factor; else:; factr = 1e7. if 'max_metric_corr' in self.method_options:; m = self.method_options['max_metric_corr']; elif 'maxcor' in self.method_options:; m = self.method_options['maxcor']; elif hasattr(self, 'max_metric_corr'):; m = self.max_metric_corr; else:; m = 10. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_l_bfgs_b' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg); try:; optim_var_vals, fid, res_dict = spopt.fmin_l_bfgs_b(; self.fid_err_func_wrapper, self.optim_var_vals,; fprime=fprime,; approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; bounds=self.bounds, m=m, factr=factr,; pgtol=term_conds.min_gradient_norm,; disp=self.msg_level,; maxfun=term_conds.max_fid_func_calls,; maxiter=term_conds.max_iterations). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); warn = res_dict['warnflag']; if warn == 0:; result.grad_norm_min_reached = True; result.termination_reason = ""function converged""; elif warn == 1:; result.max_iter_exceeded = True; result.termination_reason = (""Iteration or fidelity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_r",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:35610,Testability,log,logging,35610,"h control. Here "" + err_msg). def _build_bounds_list(self):; """"""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes; -----; [1] P. Doria, T. Calarco ",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:35682,Testability,log,logger,35682,"""""""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes; -----; [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011).; [2] T",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:38304,Testability,log,logging,38304," or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). #print(""Initial values:\n{}"".format(self.optim_var_vals)); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. result = self._create_result(). if self.log_level <= logging.INFO:; logger.info(""Optimising pulse(s) using {} with ""; ""'fmin' (Nelder-Mead) method"".format(self.alg)). try:; ret = spopt.fmin(; self.fid_err_func_wrapper, self.optim_var_vals,; xtol=self.xtol, ftol=self.ftol,; maxiter=term_conds.max_iterations,; maxfun=term_conds.max_fid_func_calls,; full_output=True, disp=self.disp_conv_msg,; retall=self.record_iteration_steps,; callback=self.iter_step_callback_func). final_param_vals = ret[0]; num_iter = ret[2]; warn_flag = ret[4]; if self.record_iteration_steps:; self.iteration_steps = ret[5]; amps = self._get_ctrl_amps(final_param_vals); dyn.update_ctrl_amps(amps). # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != num_iter:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, num_iter,; self.method)); result.num_iter = num_iter; if warn_flag == 0:; result.termination_reason = \; ""Func",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:38319,Testability,log,logger,38319," or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). #print(""Initial values:\n{}"".format(self.optim_var_vals)); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. result = self._create_result(). if self.log_level <= logging.INFO:; logger.info(""Optimising pulse(s) using {} with ""; ""'fmin' (Nelder-Mead) method"".format(self.alg)). try:; ret = spopt.fmin(; self.fid_err_func_wrapper, self.optim_var_vals,; xtol=self.xtol, ftol=self.ftol,; maxiter=term_conds.max_iterations,; maxfun=term_conds.max_fid_func_calls,; full_output=True, disp=self.disp_conv_msg,; retall=self.record_iteration_steps,; callback=self.iter_step_callback_func). final_param_vals = ret[0]; num_iter = ret[2]; warn_flag = ret[4]; if self.record_iteration_steps:; self.iteration_steps = ret[5]; amps = self._get_ctrl_amps(final_param_vals); dyn.update_ctrl_amps(amps). # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != num_iter:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, num_iter,; self.method)); result.num_iter = num_iter; if warn_flag == 0:; result.termination_reason = \; ""Function converged (w",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:39067,Testability,log,logger,39067,"efault_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. result = self._create_result(). if self.log_level <= logging.INFO:; logger.info(""Optimising pulse(s) using {} with ""; ""'fmin' (Nelder-Mead) method"".format(self.alg)). try:; ret = spopt.fmin(; self.fid_err_func_wrapper, self.optim_var_vals,; xtol=self.xtol, ftol=self.ftol,; maxiter=term_conds.max_iterations,; maxfun=term_conds.max_fid_func_calls,; full_output=True, disp=self.disp_conv_msg,; retall=self.record_iteration_steps,; callback=self.iter_step_callback_func). final_param_vals = ret[0]; num_iter = ret[2]; warn_flag = ret[4]; if self.record_iteration_steps:; self.iteration_steps = ret[5]; amps = self._get_ctrl_amps(final_param_vals); dyn.update_ctrl_amps(amps). # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != num_iter:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, num_iter,; self.method)); result.num_iter = num_iter; if warn_flag == 0:; result.termination_reason = \; ""Function converged (within tolerance)""; elif warn_flag == 1:; result.termination_reason = \; ""Maximum number of function evaluations reached""; result.max_fid_func_exceeded = True; elif warn_flag == 2:; result.termination_reason = \; ""Maximum number of iterations reached""; result.max_iter_exceeded = True; else:; result.termination_reason = \; ""Unknown (warn_flag={})"".format(warn_flag). except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimIterSummary(qtrldump.DumpSummaryItem):; """"""A summary of the most recent iteration of the pulse optimisation. Attributes; ----------; iter_nu",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:13976,Usability,clear,clear,13976,"e optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_options(self):; """"""; Creates the method_options dictionary for the scipy.optimize.minimize; function based on the attributes of this object and the; termination_conditions; It assumes that apply_method_params has already been run and; hence the method_options attribute may already contain items.; These values will NOT be overridden; """"""; tc = self.termination_conditions; if self.method_options is None:; self.method_options = {}; mo = self.method_options. if 'max_metric_corr' in mo and not 'maxcor' in mo:; mo['maxcor'] = mo['max_metric_corr']; elif hasattr(sel",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.5/modules/qutip/control/optimresult.html:2675,Availability,error,error,2675,"OODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Class containing the results of the pulse optimisation; """""". import numpy as np. [docs]class OptimResult(object):; """"""; Attributes give the result of the pulse optimisation attempt. Attributes; ----------; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting; ; fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tsl",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.5/modules/qutip/control/optimresult.html:2745,Availability,error,error,2745,"OODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Class containing the results of the pulse optimisation; """""". import numpy as np. [docs]class OptimResult(object):; """"""; Attributes give the result of the pulse optimisation attempt. Attributes; ----------; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting; ; fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tsl",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.5/modules/qutip/control/optimresult.html:2814,Availability,error,error,2814,"# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Class containing the results of the pulse optimisation; """""". import numpy as np. [docs]class OptimResult(object):; """"""; Attributes give the result of the pulse optimisation attempt. Attributes; ----------; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting; ; fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operat",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.5/modules/qutip/control/optimresult.html:2944,Availability,error,error,2944,"R OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Class containing the results of the pulse optimisation; """""". import numpy as np. [docs]class OptimResult(object):; """"""; Attributes give the result of the pulse optimisation attempt. Attributes; ----------; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting; ; fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. evo_full_initial : Qobj; The evolution operator fro",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.5/modules/qutip/control/optimresult.html:4874,Deployability,update,updated,4874,"ad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. evo_full_initial : Qobj; The evolution operator from t=0 to t=T based on the initial amps; ; stats : Stats; Object contaning the stats for the run (if any collected); ; optimizer : Optimizer; Instance of the Optimizer used to generate the result; """"""; def __init__(self):; self.reset(). def reset(self):; self.fidelity = 0.0; self.initial_fid_err = np.Inf; self.fid_err = np.Inf; self.goal_achieved = False; self.grad_norm_final = 0.0; self.grad_norm_min_reached = False; self.num_iter = 0; self.max_iter_exceeded = False; self.num_fid_func_calls = 0; self.max_fid_func_exceeded = False; self.wall_time = 0.0; self.wall_time_limit_exceeded = False; self.termination_reason = ""not started yet""; self.time = None; self.initial_amps = None; self.final_amps = None; self.evo_full_final = None; self.evo_full_initial = None; self.stats = None; self.optimizer = None. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.5/modules/qutip/control/optimresult.html:4023,Performance,optimiz,optimizer,4023,"ad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. evo_full_initial : Qobj; The evolution operator from t=0 to t=T based on the initial amps; ; stats : Stats; Object contaning the stats for the run (if any collected); ; optimizer : Optimizer; Instance of the Optimizer used to generate the result; """"""; def __init__(self):; self.reset(). def reset(self):; self.fidelity = 0.0; self.initial_fid_err = np.Inf; self.fid_err = np.Inf; self.goal_achieved = False; self.grad_norm_final = 0.0; self.grad_norm_min_reached = False; self.num_iter = 0; self.max_iter_exceeded = False; self.num_fid_func_calls = 0; self.max_fid_func_exceeded = False; self.wall_time = 0.0; self.wall_time_limit_exceeded = False; self.termination_reason = ""not started yet""; self.time = None; self.initial_amps = None; self.final_amps = None; self.evo_full_final = None; self.evo_full_initial = None; self.stats = None; self.optimizer = None. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.5/modules/qutip/control/optimresult.html:4698,Performance,optimiz,optimizer,4698,"ad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. evo_full_initial : Qobj; The evolution operator from t=0 to t=T based on the initial amps; ; stats : Stats; Object contaning the stats for the run (if any collected); ; optimizer : Optimizer; Instance of the Optimizer used to generate the result; """"""; def __init__(self):; self.reset(). def reset(self):; self.fidelity = 0.0; self.initial_fid_err = np.Inf; self.fid_err = np.Inf; self.goal_achieved = False; self.grad_norm_final = 0.0; self.grad_norm_min_reached = False; self.num_iter = 0; self.max_iter_exceeded = False; self.num_fid_func_calls = 0; self.max_fid_func_exceeded = False; self.wall_time = 0.0; self.wall_time_limit_exceeded = False; self.termination_reason = ""not started yet""; self.time = None; self.initial_amps = None; self.final_amps = None; self.evo_full_final = None; self.evo_full_initial = None; self.stats = None; self.optimizer = None. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:2840,Availability,error,errors,2840,"NTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' ",MatchSource.WIKI,docs/4.5/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:6249,Availability,error,errors,6249,"he logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been replaced ""; ""by '_compute_propagator'""); return self._compute_propagator(k); ; def _compute_propagator(self, k):; """"""; calculate the progator between X(k) and X(k+1); Uses matrix expm of the dyn_gen at that point (in time); Assumes that the dyn_gen have been been calculated,; i.e. drift and ctrls combined; Return the propagator; """"""; dyn = self.parent; dgt = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX';",MatchSource.WIKI,docs/4.5/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:6695,Availability,error,errors,6695," dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(k, j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """""";",MatchSource.WIKI,docs/4.5/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:4337,Deployability,configurat,configuration,4337,"ted with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been ",MatchSource.WIKI,docs/4.5/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:7047,Deployability,configurat,configuration,7047,"""""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(k, j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """"""; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator; """"""; [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'DIAG'; self.grad_exact = True; self.apply_params(). def _compute_propagator(self, k):; """"""; Calculates the exponentiation of the dynamics generat",MatchSource.WIKI,docs/4.5/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:7831,Deployability,configurat,configuration,7831,"e a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(k, j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """"""; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator; """"""; [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'DIAG'; self.grad_exact = True; self.apply_params(). def _compute_propagator(self, k):; """"""; Calculates the exponentiation of the dynamics generator (H); As part of the calc the the eigen decomposition is required, which; is reused in the propagator gradient calculation; """"""; dyn = self.parent; dyn._ensure_decomp_curr(k). if dyn.oper_dtype == Qobj:. prop = (dyn._dyn_gen_eigenvectors[k]*dyn._prop_eigen[k]*; dyn._get_dyn_gen_eigenvectors_adj(k)); else:; prop = dyn._dyn_gen_eigenvectors[k].dot(; dyn._prop_eigen[k]).dot(; dyn._get_dyn_gen_eigenvectors_adj(k)). return prop. def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot. Returns:; [prop], prop_grad; """"""; dyn = self.parent; dyn._ensure_decomp_curr(k). if compute_prop:; prop = self._compute_propagator(k). if",MatchSource.WIKI,docs/4.5/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:14202,Deployability,update,updated,14202," e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient; """"""; [docs] def reset(self):; PropagatorComputer.reset(self); self.id_text = 'FRECHET'; self.grad_exact = True; self.apply_params(). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot using the expm_frechet method; The propagtor is calculated (almost) for 'free' in this method; and hence it is returned if compute_prop==True; Returns:; [prop], prop_grad; """"""; dyn = self.parent. if dyn.oper_dtype == Qobj:; A = dyn._get_phased_dyn_gen(k).full()*dyn.tau[k]; E = dyn._get_phased_ctrl_dyn_gen(k, j).full()*dyn.tau[k]; if compute_prop:; prop_dense, prop_grad_dense = la.expm_frechet(A, E); prop = Qobj(prop_dense, dims=dyn.dyn_dims); prop_grad = Qobj(prop_grad_dense,; dims=dyn.dyn_dims); else:; prop_grad_dense = la.expm_frechet(A, E, compute_expm=False); prop_grad = Qobj(prop_grad_dense,; dims=dyn.dyn_dims); elif dyn.oper_dtype == np.ndarray:; A = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; E = dyn._get_phased_ctrl_dyn_gen(k, j)*dyn.tau[k]; if compute_prop:; prop, prop_grad = la.expm_frechet(A, E); else:; prop_grad = la.expm_frechet(A, E,; compute_expm=False); else:; # Assuming some sparse matrix; spcls = dyn._dyn_gen[k].__class__; A = (dyn._get_phased_dyn_gen(k)*dyn.tau[k]).toarray(); E = (dyn._get_phased_ctrl_dyn_gen(k, j)*dyn.tau[k]).toarray(); if compute_prop:; prop_dense, prop_grad_dense = la.expm_frechet(A, E); prop = spcls(prop_dense); prop_grad = spcls(prop_grad_dense); else:; prop_grad_dense = la.expm_frechet(A, E, compute_expm=False); prop_grad = spcls(prop_grad_dense). if compute_prop:; return prop, prop_grad; else:; return prop_grad. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:9930,Energy Efficiency,efficient,efficient,9930,"genvectors[k]); # multiply (elementwise) by timeslice and factor matrix; cdg = Qobj(np.multiply(cdg.full()*dyn.tau[k],; dyn._dyn_gen_factormatrix[k]), dims=dyn.dyn_dims); # Return to canonical basis; prop_grad = (dyn._dyn_gen_eigenvectors[k]*cdg*; dyn._get_dyn_gen_eigenvectors_adj(k)); else:; # put control dyn_gen in combined dg diagonal basis; cdg = dyn._get_dyn_gen_eigenvectors_adj(k).dot(; dyn._get_phased_ctrl_dyn_gen(k, j)).dot(; dyn._dyn_gen_eigenvectors[k]); # multiply (elementwise) by timeslice and factor matrix; cdg = np.multiply(cdg*dyn.tau[k], dyn._dyn_gen_factormatrix[k]); # Return to canonical basis; prop_grad = dyn._dyn_gen_eigenvectors[k].dot(cdg).dot(; dyn._get_dyn_gen_eigenvectors_adj(k)). if compute_prop:; return prop, prop_grad; else:; return prop_grad. class PropCompAugMat(PropagatorComputer):; """"""; Augmented Matrix (deprecated - see _Frechet). It should work for all systems, e.g. open, symplectic; There will be other PropagatorComputer subclasses that are more efficient; The _Frechet class should provide exactly the same functionality; more efficiently. Note the propagator gradient calculation using the augmented matrix; is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer; """"""; def reset(self):; PropagatorComputer.reset(self); self.id_text = 'AUG_MAT'; self.grad_exact = True; self.apply_params(). def _get_aug_mat(self, k, j):; """"""; Generate the matrix [[A, E], [0, A]] where; A is the overall dynamics generator; E is the control dynamics generator; for a given timeslot and control; returns this augmented matrix; """"""; dyn = self.parent; dg = dyn._get_phased_dyn_gen(k). if dyn.oper_dtype == Qobj:; A = dg.data*dyn.tau[k]; E = dyn._get_phased_ctrl_dyn_gen(k, j).data*dyn.tau[k]; Z = sp.csr_matrix(dg.data.shape); aug = Qobj(sp.vstack([sp.hstack([A, E]), sp.hstack([Z, A])])); elif dyn.oper_dtype == np.ndarray:; A = dg*dyn.tau",MatchSource.WIKI,docs/4.5/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:10012,Energy Efficiency,efficient,efficiently,10012,"genvectors[k]); # multiply (elementwise) by timeslice and factor matrix; cdg = Qobj(np.multiply(cdg.full()*dyn.tau[k],; dyn._dyn_gen_factormatrix[k]), dims=dyn.dyn_dims); # Return to canonical basis; prop_grad = (dyn._dyn_gen_eigenvectors[k]*cdg*; dyn._get_dyn_gen_eigenvectors_adj(k)); else:; # put control dyn_gen in combined dg diagonal basis; cdg = dyn._get_dyn_gen_eigenvectors_adj(k).dot(; dyn._get_phased_ctrl_dyn_gen(k, j)).dot(; dyn._dyn_gen_eigenvectors[k]); # multiply (elementwise) by timeslice and factor matrix; cdg = np.multiply(cdg*dyn.tau[k], dyn._dyn_gen_factormatrix[k]); # Return to canonical basis; prop_grad = dyn._dyn_gen_eigenvectors[k].dot(cdg).dot(; dyn._get_dyn_gen_eigenvectors_adj(k)). if compute_prop:; return prop, prop_grad; else:; return prop_grad. class PropCompAugMat(PropagatorComputer):; """"""; Augmented Matrix (deprecated - see _Frechet). It should work for all systems, e.g. open, symplectic; There will be other PropagatorComputer subclasses that are more efficient; The _Frechet class should provide exactly the same functionality; more efficiently. Note the propagator gradient calculation using the augmented matrix; is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer; """"""; def reset(self):; PropagatorComputer.reset(self); self.id_text = 'AUG_MAT'; self.grad_exact = True; self.apply_params(). def _get_aug_mat(self, k, j):; """"""; Generate the matrix [[A, E], [0, A]] where; A is the overall dynamics generator; E is the control dynamics generator; for a given timeslot and control; returns this augmented matrix; """"""; dyn = self.parent; dg = dyn._get_phased_dyn_gen(k). if dyn.oper_dtype == Qobj:; A = dg.data*dyn.tau[k]; E = dyn._get_phased_ctrl_dyn_gen(k, j).data*dyn.tau[k]; Z = sp.csr_matrix(dg.data.shape); aug = Qobj(sp.vstack([sp.hstack([A, E]), sp.hstack([Z, A])])); elif dyn.oper_dtype == np.ndarray:; A = dg*dyn.tau",MatchSource.WIKI,docs/4.5/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:12387,Energy Efficiency,efficient,efficient,12387," using the exponentiation of the the augmented; matrix.; The propagtor is calculated for 'free' in this method; and hence it is returned if compute_prop==True; Returns:; [prop], prop_grad; """"""; dyn = self.parent; dg = dyn._get_phased_dyn_gen(k); aug = self._get_aug_mat(k, j). if dyn.oper_dtype == Qobj:; aug_exp = aug.expm(); prop_grad = Qobj(aug_exp.data[:dg.shape[0], dg.shape[1]:],; dims=dyn.dyn_dims); if compute_prop:; prop = Qobj(aug_exp.data[:dg.shape[0], :dg.shape[1]],; dims=dyn.dyn_dims); else:; aug_exp = la.expm(aug); prop_grad = aug_exp[:dg.shape[0], dg.shape[1]:]; if compute_prop:; prop = aug_exp[:dg.shape[0], :dg.shape[1]]. if compute_prop:; return prop, prop_grad; else:; return prop_grad. [docs]class PropCompFrechet(PropagatorComputer):; """"""; Frechet method for calculating the propagator:; exponentiating the combined dynamics generator; and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient; """"""; [docs] def reset(self):; PropagatorComputer.reset(self); self.id_text = 'FRECHET'; self.grad_exact = True; self.apply_params(). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot using the expm_frechet method; The propagtor is calculated (almost) for 'free' in this method; and hence it is returned if compute_prop==True; Returns:; [prop], prop_grad; """"""; dyn = self.parent. if dyn.oper_dtype == Qobj:; A = dyn._get_phased_dyn_gen(k).full()*dyn.tau[k]; E = dyn._get_phased_ctrl_dyn_gen(k, j).full()*dyn.tau[k]; if compute_prop:; prop_dense, prop_grad_dense = la.expm_frechet(A, E); prop = Qobj(prop_dense, dims=dyn.dyn_dims); prop_grad = Qobj(prop_grad_dense,; dims=dyn.dyn_dims); else:; prop_grad_dense = la.expm_frechet(A, E, compute_expm=False); prop_grad = Qobj(prop_grad_dense,; dims=dyn.dyn_dims); elif dyn.oper_dtype == np.ndarray:; A = dyn._get_phased_dyn_gen(k)*dyn.tau[",MatchSource.WIKI,docs/4.5/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:2870,Integrability,message,message,2870,"# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken f",MatchSource.WIKI,docs/4.5/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:2958,Integrability,message,message,2958,"# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken f",MatchSource.WIKI,docs/4.5/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:3046,Integrability,message,message,3046,"##########################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is",MatchSource.WIKI,docs/4.5/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:4337,Modifiability,config,configuration,4337,"ted with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been ",MatchSource.WIKI,docs/4.5/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:7047,Modifiability,config,configuration,7047,"""""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(k, j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """"""; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator; """"""; [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'DIAG'; self.grad_exact = True; self.apply_params(). def _compute_propagator(self, k):; """"""; Calculates the exponentiation of the dynamics generat",MatchSource.WIKI,docs/4.5/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:7831,Modifiability,config,configuration,7831,"e a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(k, j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """"""; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator; """"""; [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'DIAG'; self.grad_exact = True; self.apply_params(). def _compute_propagator(self, k):; """"""; Calculates the exponentiation of the dynamics generator (H); As part of the calc the the eigen decomposition is required, which; is reused in the propagator gradient calculation; """"""; dyn = self.parent; dyn._ensure_decomp_curr(k). if dyn.oper_dtype == Qobj:. prop = (dyn._dyn_gen_eigenvectors[k]*dyn._prop_eigen[k]*; dyn._get_dyn_gen_eigenvectors_adj(k)); else:; prop = dyn._dyn_gen_eigenvectors[k].dot(; dyn._prop_eigen[k]).dot(; dyn._get_dyn_gen_eigenvectors_adj(k)). return prop. def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot. Returns:; [prop], prop_grad; """"""; dyn = self.parent; dyn._ensure_decomp_curr(k). if compute_prop:; prop = self._compute_propagator(k). if",MatchSource.WIKI,docs/4.5/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:2710,Testability,log,logging,2710,"CES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of m",MatchSource.WIKI,docs/4.5/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:2749,Testability,log,logging,2749,"INESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, ",MatchSource.WIKI,docs/4.5/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:2758,Testability,log,logger,2758,"INESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, ",MatchSource.WIKI,docs/4.5/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:2767,Testability,log,logging,2767,"INESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, ",MatchSource.WIKI,docs/4.5/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:3626,Testability,log,logger,3626," import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instanti",MatchSource.WIKI,docs/4.5/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:3673,Testability,log,logging,3673,"logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exi",MatchSource.WIKI,docs/4.5/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:5013,Testability,log,logger,5013,"RN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been replaced ""; ""by '_compute_propagator'""); return self._compute_propagator(k); ; def _compute_propagator(self, k):; """"""; calculate the progator between X(k) and X(k+1); Uses matrix expm of the dyn_gen at that point (in time); Assumes that the dyn_gen have been been calculated,; i.e. drift and ctrls combined; Return the propagator; """"""; dyn = self.parent; dgt = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsil",MatchSource.WIKI,docs/4.5/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:5131,Testability,log,logger,5131,"gator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been replaced ""; ""by '_compute_propagator'""); return self._compute_propagator(k); ; def _compute_propagator(self, k):; """"""; calculate the progator between X(k) and X(k+1); Uses matrix expm of the dyn_gen at that point (in time); Assumes that the dyn_gen have been been calculated,; i.e. drift and ctrls combined; Return the propagator; """"""; dyn = self.parent; dgt = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point",MatchSource.WIKI,docs/4.5/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:5152,Testability,log,logger,5152,"gator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been replaced ""; ""by '_compute_propagator'""); return self._compute_propagator(k); ; def _compute_propagator(self, k):; """"""; calculate the progator between X(k) and X(k+1); Uses matrix expm of the dyn_gen at that point (in time); Assumes that the dyn_gen have been been calculated,; i.e. drift and ctrls combined; Return the propagator; """"""; dyn = self.parent; dgt = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point",MatchSource.WIKI,docs/4.5/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:5179,Testability,log,logger,5179,"rop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been replaced ""; ""by '_compute_propagator'""); return self._compute_propagator(k); ; def _compute_propagator(self, k):; """"""; calculate the progator between X(k) and X(k+1); Uses matrix expm of the dyn_gen at that point (in time); Assumes that the dyn_gen have been been calculated,; i.e. drift and ctrls combined; Return the propagator; """"""; dyn = self.parent; dgt = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the dire",MatchSource.WIKI,docs/4.5/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:6891,Usability,simpl,simply,6891,"epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(k, j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """"""; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator; """"""; [docs] def reset(self):; """"""; reset any configuration data; """"""",MatchSource.WIKI,docs/4.5/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html:2681,Availability,error,errors,2681,"TUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np. import qutip.logging_utils as logging; logger = logging.get_logger(). import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:; ; RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot; ; These are the other non-periodic options:; ; LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0; ; These are the periodic options; ; SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave; ; If a Dynamics object is passed in then this is used in instantiate; the PulseGen, meaning that some timeslot and amplitude properties; are copied ov",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html:2691,Availability,error,errors,2691,"TUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np. import qutip.logging_utils as logging; logger = logging.get_logger(). import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:; ; RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot; ; These are the other non-periodic options:; ; LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0; ; These are the periodic options; ; SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave; ; If a Dynamics object is passed in then this is used in instantiate; the PulseGen, meaning that some timeslot and amplitude properties; are copied ov",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html:8524,Availability,error,errors,8524,".scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pulse_initialised = False; self.periodic = False; self.random = False; self.lbound = None; self.ubound = None; self.ramping_pulse = None; ; self.apply_params(); ; [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the ; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; """""" ; if not params:; params = self.params; ; if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def gen_pulse(self):; """"""; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for generating a pulse. ""; "" Suspect base class was used where sub class should have been""). [docs] def init_pulse(self):; """"""; Initialise the pulse parameters; """"""; if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.pulse_time/self.num_tslots; ; if self._uses_time:; self.time = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; self.time[k+1] = self.time[k] + self.tau[k]; ; self._pulse_initialised = True. if not self.lbound is None:; if np.isinf(self.lbound):; self.lbound = None; if not self.ubound is None:; if np.isinf(self.ubound):; self.ubound = None; ; if not self.ubound is None and not self.lbound is None:; if self.ubound < self.lbound:; raise ValueError(""ubound cannot be less the lbound""). def _apply_bounds_and_offset(self, pulse):; """"""; Ensure that the randomly generated pulse fits within the bounds",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html:36540,Deployability,update,updated,36540,"es; ----------; freqs : float array[num_coeffs]; Frequencies for the basis functions; randomize_freqs : bool; If True (default) the some random offset is applied to the frequencies; """""". [docs] def reset(self):; """"""; reset attributes to default values; """"""; PulseGenCrab.reset(self); self.freqs = None; self.randomize_freqs = True. [docs] def init_pulse(self, num_coeffs=None):; """"""; Set the initial freq and coefficient values; """"""; PulseGenCrab.init_pulse(self); ; self.init_freqs(); ; [docs] def init_freqs(self):; """"""; Generate the frequencies; These are the Fourier harmonics with a uniformly distributed; random offset; """"""; self.freqs = np.empty(self.num_coeffs); ff = 2*np.pi / self.pulse_time; for i in range(self.num_coeffs):; self.freqs[i] = ff*(i + 1); ; if self.randomize_freqs:; self.freqs += np.random.random(self.num_coeffs) - 0.5; ; [docs] def gen_pulse(self, coeffs=None):; """"""; Generate a pulse using the Fourier basis with the freqs and; coeffs attributes.; ; Parameters; ----------; coeffs : float array[num_coeffs, num_basis_funcs]; The basis coefficient values; If given this overides the default and sets the attribute; of the same name.; """"""; if coeffs:; self.coeffs = coeffs; ; if not self._pulse_initialised:; self.init_pulse(); ; pulse = np.zeros(self.num_tslots). for i in range(self.num_coeffs):; phase = self.freqs[i]*self.time; # basis1comp = self.coeffs[i, 0]*np.sin(phase); # basis2comp = self.coeffs[i, 1]*np.cos(phase); # pulse += basis1comp + basis2comp; pulse += self.coeffs[i, 0]*np.sin(phase) + \; self.coeffs[i, 1]*np.cos(phase) . if self.guess_pulse_func:; pulse = self.guess_pulse_func(pulse); if self.ramping_pulse is not None:; pulse = self._apply_ramping_pulse(pulse); ; return self._apply_bounds(pulse); . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html:30747,Energy Efficiency,efficient,efficient,30747,"If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs; ; [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(); ; [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; T",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html:30830,Integrability,message,message,30830,"effs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs; ; [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(); ; [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically this will be the basis coefficients; """"""; # Type and size checking avoided here as",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html:29276,Modifiability,variab,variables,29276,".parent = dyn; self.num_coeffs = num_coeffs; self.params = params; self.reset(); ; [docs] def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.reset(self); self.NUM_COEFFS_WARN_LVL = 20; self.DEF_NUM_COEFFS = 4; self._BSC_ALL = 1; self._BSC_GT_MEAN = 2; self._BSC_LT_MEAN = 3; ; self._uses_time = True; self.time = None; self.num_basis_funcs = 2; self.num_optim_vars = 0; self.coeffs = None; self.randomize_coeffs = True; self._num_coeffs_estimated = False; self.guess_pulse_action = 'MODULATE'; self.guess_pulse = None; self.guess_pulse_func = None; self.apply_params(); ; [docs] def init_pulse(self, num_coeffs=None):; """"""; Set the initial freq and coefficient values; """"""; PulseGen.init_pulse(self); self.init_coeffs(num_coeffs=num_coeffs); ; if self.guess_pulse is not None:; self.init_guess_pulse(); self._init_bounds(); ; if self.log_level <= logging.DEBUG and not self._num_coeffs_estimated:; logger.debug(; ""CRAB pulse initialised with {} coefficients per basis ""; ""function, which means a total of {} ""; ""optimisation variables for this pulse"".format(; self.num_coeffs, self.num_optim_vars)); ; # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse; ; [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_leve",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html:30388,Modifiability,variab,variables,30388,"um_optim_vars)); ; # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse; ; [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html:12675,Safety,avoid,avoid,12675,"scaling : float; The pulses should fit approximately within -/+scaling; (before the offset is applied); as it is used to set a maximum for each component wave; Use bounds to be sure; (copied from Dynamics.initial_ctrl_scaling if given). min_wavelen : float; Minimum wavelength of any component wave; Set by default to 1/10th of the pulse time; """""". def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.reset(self); self.random = True; self._uses_time = True; try:; self.min_wavelen = self.pulse_time / 10.0; except:; self.min_wavelen = 0.1; self.apply_params(). def gen_pulse(self, min_wavelen=None):; """"""; Generate a random pulse based on a Fourier series with a minimum; wavelength; """""". if min_wavelen is not None:; self.min_wavelen = min_wavelen; min_wavelen = self.min_wavelen. if min_wavelen > self.pulse_time:; raise ValueError(""Minimum wavelength cannot be greater than ""; ""the pulse time""); if not self._pulse_initialised:; self.init_pulse(). # use some phase to avoid the first pulse being always 0. sum_wave = np.zeros(self.tau.shape); wavelen = 2.0*self.pulse_time. t = self.time; wl = []; while wavelen > min_wavelen:; wl.append(wavelen); wavelen = wavelen/2.0. num_comp_waves = len(wl); amp_scale = np.sqrt(8)*self.scaling / float(num_comp_waves). for wavelen in wl:; amp = amp_scale*(np.random.rand()*2 - 1); phase_off = np.random.rand()*np.pi/2.0; curr_wave = amp*np.sin(2*np.pi*t/wavelen + phase_off); sum_wave += curr_wave. return self._apply_bounds_and_offset(sum_wave). class PulseGenRndWaves(PulseGen):; """"""; Generates pulses by summing sine waves with random frequencies; amplitudes and phase offset. Attributes; ----------; scaling : float; The pulses should fit approximately within -/+scaling; (before the offset is applied); as it is used to set a maximum for each component wave; Use bounds to be sure; (copied from Dynamics.initial_ctrl_scaling if given). num_comp_waves : integer; Number of component waves. That is the number of waves that; are summe",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html:15071,Safety,avoid,avoid,15071,"elf.num_comp_waves = 20; try:; self.min_wavelen = self.pulse_time / 10.0; except:; self.min_wavelen = 0.1; try:; self.max_wavelen = 2*self.pulse_time; except:; self.max_wavelen = 10.0; self.apply_params(). def gen_pulse(self, num_comp_waves=None,; min_wavelen=None, max_wavelen=None):; """"""; Generate a random pulse by summing sine waves with random freq,; amplitude and phase offset; """""". if num_comp_waves is not None:; self.num_comp_waves = num_comp_waves; if min_wavelen is not None:; self.min_wavelen = min_wavelen; if max_wavelen is not None:; self.max_wavelen = max_wavelen. num_comp_waves = self.num_comp_waves; min_wavelen = self.min_wavelen; max_wavelen = self.max_wavelen. if min_wavelen > self.pulse_time:; raise ValueError(""Minimum wavelength cannot be greater than ""; ""the pulse time""); if max_wavelen <= min_wavelen:; raise ValueError(""Maximum wavelength must be greater than ""; ""the minimum wavelength""). if not self._pulse_initialised:; self.init_pulse(). # use some phase to avoid the first pulse being always 0. sum_wave = np.zeros(self.tau.shape). t = self.time; wl_range = max_wavelen - min_wavelen; amp_scale = np.sqrt(8)*self.scaling / float(num_comp_waves); for n in range(num_comp_waves):; amp = amp_scale*(np.random.rand()*2 - 1); phase_off = np.random.rand()*np.pi/2.0; wavelen = min_wavelen + np.random.rand()*wl_range; curr_wave = amp*np.sin(2*np.pi*t/wavelen + phase_off); sum_wave += curr_wave. return self._apply_bounds_and_offset(sum_wave). class PulseGenRndWalk1(PulseGen):; """"""; Generates pulses by using a random walk algorithm. Attributes; ----------; scaling : float; Used as the range for the starting amplitude; Note must used bounds if values must be restricted.; Also scales the max_d_amp value; (copied from Dynamics.initial_ctrl_scaling if given). max_d_amp : float; Maximum amount amplitude will change between timeslots; Note this is also factored by the scaling attribute; """"""; def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.res",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html:31791,Safety,avoid,avoided,31791," {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs; ; [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(); ; [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically this will be the basis coefficients; """"""; # Type and size checking avoided here as this is in the ; # main optmisation call sequence; self.set_coeffs(param_vals); ; def set_coeffs(self, param_vals):; self.coeffs = param_vals.reshape(; [self.num_coeffs, self.num_basis_funcs]); ; def init_guess_pulse(self):; ; self.guess_pulse_func = None; if not self.guess_pulse_action:; logger.WARN(""No guess pulse action given, hence ignored.""); elif self.guess_pulse_action.upper() == 'MODULATE':; self.guess_pulse_func = self.guess_pulse_modulate; elif self.guess_pulse_action.upper() == 'ADD':; self.guess_pulse_func = self.guess_pulse_add; else:; logger.WARN(""No option for guess pulse action '{}' ""; "", hence ignored."".format(self.guess_pulse_action)); ; def guess_pulse_add(self, pulse):; pulse = pulse + self.guess_pulse; return pulse; ; def guess_pulse_modulate(self, pulse):; pulse = (1.0 + pulse)*self.guess_pulse; return pulse; ; def _init_bounds(self):; add_guess_pulse_scale ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html:2577,Testability,log,logging,2577,"AL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np. import qutip.logging_utils as logging; logger = logging.get_logger(). import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:; ; RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot; ; These are the other non-periodic options:; ; LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0; ; These are the periodic options; ; SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave; ; If a Dynamics object is passed in then t",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html:2586,Testability,log,logger,2586,"AL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np. import qutip.logging_utils as logging; logger = logging.get_logger(). import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:; ; RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot; ; These are the other non-periodic options:; ; LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0; ; These are the periodic options; ; SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave; ; If a Dynamics object is passed in then t",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html:2595,Testability,log,logging,2595,"AL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np. import qutip.logging_utils as logging; logger = logging.get_logger(). import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:; ; RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot; ; These are the other non-periodic options:; ; LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0; ; These are the periodic options; ; SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave; ; If a Dynamics object is passed in then t",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html:6562,Testability,log,logger,6562,"caling applied to the pulse; (copied from Dynamics.initial_ctrl_scaling if given). offset : float; linear offset applied to the pulse; (copied from Dynamics.initial_ctrl_offset if given). tau : array[num_tslots] of float; Duration of each timeslot; (copied from Dynamics if given). lbound : float; Lower boundary for the pulse amplitudes; Note that the scaling and offset attributes can be used to fully; bound the pulse for all generators except some of the random ones; This bound (if set) may result in additional shifting / scaling; Default is -Inf. ubound : float; Upper boundary for the pulse amplitudes; Note that the scaling and offset attributes can be used to fully; bound the pulse for all generators except some of the random ones; This bound (if set) may result in additional shifting / scaling; Default is Inf. periodic : boolean; True if the pulse generator produces periodic pulses. random : boolean; True if the pulse generator produces random pulses. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; """"""; def __init__(self, dyn=None, params=None):; self.parent = dyn; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset attributes to default values; """"""; if isinstance(self.parent, dynamics.Dynamics):; dyn = self.parent; self.num_tslots = dyn.num_tslots; self.pulse_time = dyn.evo_time; self.scaling = dyn.initial_ctrl_scaling; self.offset = dyn.initial_ctrl_offset; self.tau = dyn.tau; self.log_level = dyn.log_level; else:; self.num_tslots = 100; self.pulse_time = 1.0; self.scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pul",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html:8160,Testability,log,logger,8160,"ics.Dynamics):; dyn = self.parent; self.num_tslots = dyn.num_tslots; self.pulse_time = dyn.evo_time; self.scaling = dyn.initial_ctrl_scaling; self.offset = dyn.initial_ctrl_offset; self.tau = dyn.tau; self.log_level = dyn.log_level; else:; self.num_tslots = 100; self.pulse_time = 1.0; self.scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pulse_initialised = False; self.periodic = False; self.random = False; self.lbound = None; self.ubound = None; self.ramping_pulse = None; ; self.apply_params(); ; [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the ; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; """""" ; if not params:; params = self.params; ; if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def gen_pulse(self):; """"""; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for generating a pulse. ""; "" Suspect base class was used where sub class should have been""). [docs] def init_pulse(self):; """"""; Initialise the pulse parameters; """"""; if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.pulse_time/self.num_tslots; ; if self._uses_time:; self.time = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; self.time[k+1] = self.time[k] + self.tau[k]; ; self._pulse_initialised = True. if not self.lbound is None:; if np.isinf(self.lbound):; self.lbound = None; if not self.ubound is None:; if np.isinf(",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html:8281,Testability,log,logger,8281,".scaling = dyn.initial_ctrl_scaling; self.offset = dyn.initial_ctrl_offset; self.tau = dyn.tau; self.log_level = dyn.log_level; else:; self.num_tslots = 100; self.pulse_time = 1.0; self.scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pulse_initialised = False; self.periodic = False; self.random = False; self.lbound = None; self.ubound = None; self.ramping_pulse = None; ; self.apply_params(); ; [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the ; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; """""" ; if not params:; params = self.params; ; if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def gen_pulse(self):; """"""; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for generating a pulse. ""; "" Suspect base class was used where sub class should have been""). [docs] def init_pulse(self):; """"""; Initialise the pulse parameters; """"""; if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.pulse_time/self.num_tslots; ; if self._uses_time:; self.time = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; self.time[k+1] = self.time[k] + self.tau[k]; ; self._pulse_initialised = True. if not self.lbound is None:; if np.isinf(self.lbound):; self.lbound = None; if not self.ubound is None:; if np.isinf(self.ubound):; self.ubound = None; ; if not self.ubound is None and not self.lbound is None:; if self.ubou",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html:8302,Testability,log,logger,8302,".scaling = dyn.initial_ctrl_scaling; self.offset = dyn.initial_ctrl_offset; self.tau = dyn.tau; self.log_level = dyn.log_level; else:; self.num_tslots = 100; self.pulse_time = 1.0; self.scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pulse_initialised = False; self.periodic = False; self.random = False; self.lbound = None; self.ubound = None; self.ramping_pulse = None; ; self.apply_params(); ; [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the ; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; """""" ; if not params:; params = self.params; ; if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def gen_pulse(self):; """"""; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for generating a pulse. ""; "" Suspect base class was used where sub class should have been""). [docs] def init_pulse(self):; """"""; Initialise the pulse parameters; """"""; if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.pulse_time/self.num_tslots; ; if self._uses_time:; self.time = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; self.time[k+1] = self.time[k] + self.tau[k]; ; self._pulse_initialised = True. if not self.lbound is None:; if np.isinf(self.lbound):; self.lbound = None; if not self.ubound is None:; if np.isinf(self.ubound):; self.ubound = None; ; if not self.ubound is None and not self.lbound is None:; if self.ubou",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html:8329,Testability,log,logger,8329,"; self.tau = dyn.tau; self.log_level = dyn.log_level; else:; self.num_tslots = 100; self.pulse_time = 1.0; self.scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pulse_initialised = False; self.periodic = False; self.random = False; self.lbound = None; self.ubound = None; self.ramping_pulse = None; ; self.apply_params(); ; [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the ; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; """""" ; if not params:; params = self.params; ; if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def gen_pulse(self):; """"""; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for generating a pulse. ""; "" Suspect base class was used where sub class should have been""). [docs] def init_pulse(self):; """"""; Initialise the pulse parameters; """"""; if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.pulse_time/self.num_tslots; ; if self._uses_time:; self.time = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; self.time[k+1] = self.time[k] + self.tau[k]; ; self._pulse_initialised = True. if not self.lbound is None:; if np.isinf(self.lbound):; self.lbound = None; if not self.ubound is None:; if np.isinf(self.ubound):; self.ubound = None; ; if not self.ubound is None and not self.lbound is None:; if self.ubound < self.lbound:; raise ValueError(""ubound cannot be less the lbound""). d",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html:29098,Testability,log,logging,29098," initialised, otherwise they will all be equal to self.scaling; """"""; def __init__(self, dyn=None, num_coeffs=None, params=None):; self.parent = dyn; self.num_coeffs = num_coeffs; self.params = params; self.reset(); ; [docs] def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.reset(self); self.NUM_COEFFS_WARN_LVL = 20; self.DEF_NUM_COEFFS = 4; self._BSC_ALL = 1; self._BSC_GT_MEAN = 2; self._BSC_LT_MEAN = 3; ; self._uses_time = True; self.time = None; self.num_basis_funcs = 2; self.num_optim_vars = 0; self.coeffs = None; self.randomize_coeffs = True; self._num_coeffs_estimated = False; self.guess_pulse_action = 'MODULATE'; self.guess_pulse = None; self.guess_pulse_func = None; self.apply_params(); ; [docs] def init_pulse(self, num_coeffs=None):; """"""; Set the initial freq and coefficient values; """"""; PulseGen.init_pulse(self); self.init_coeffs(num_coeffs=num_coeffs); ; if self.guess_pulse is not None:; self.init_guess_pulse(); self._init_bounds(); ; if self.log_level <= logging.DEBUG and not self._num_coeffs_estimated:; logger.debug(; ""CRAB pulse initialised with {} coefficients per basis ""; ""function, which means a total of {} ""; ""optimisation variables for this pulse"".format(; self.num_coeffs, self.num_optim_vars)); ; # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse; ; [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html:29149,Testability,log,logger,29149,"l to self.scaling; """"""; def __init__(self, dyn=None, num_coeffs=None, params=None):; self.parent = dyn; self.num_coeffs = num_coeffs; self.params = params; self.reset(); ; [docs] def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.reset(self); self.NUM_COEFFS_WARN_LVL = 20; self.DEF_NUM_COEFFS = 4; self._BSC_ALL = 1; self._BSC_GT_MEAN = 2; self._BSC_LT_MEAN = 3; ; self._uses_time = True; self.time = None; self.num_basis_funcs = 2; self.num_optim_vars = 0; self.coeffs = None; self.randomize_coeffs = True; self._num_coeffs_estimated = False; self.guess_pulse_action = 'MODULATE'; self.guess_pulse = None; self.guess_pulse_func = None; self.apply_params(); ; [docs] def init_pulse(self, num_coeffs=None):; """"""; Set the initial freq and coefficient values; """"""; PulseGen.init_pulse(self); self.init_coeffs(num_coeffs=num_coeffs); ; if self.guess_pulse is not None:; self.init_guess_pulse(); self._init_bounds(); ; if self.log_level <= logging.DEBUG and not self._num_coeffs_estimated:; logger.debug(; ""CRAB pulse initialised with {} coefficients per basis ""; ""function, which means a total of {} ""; ""optimisation variables for this pulse"".format(; self.num_coeffs, self.num_optim_vars)); ; # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse; ; [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html:30234,Testability,log,logging,30234,", which means a total of {} ""; ""optimisation variables for this pulse"".format(; self.num_coeffs, self.num_optim_vars)); ; # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse; ; [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html:30249,Testability,log,logger,30249,"tal of {} ""; ""optimisation variables for this pulse"".format(; self.num_coeffs, self.num_optim_vars)); ; # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse; ; [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Return",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html:30585,Testability,log,logging,30585,"he initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs; ; [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(); ; [docs] def set_optim_var_vals(self, ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html:30648,Testability,log,logger,30648,"um_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs; ; [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(); ; [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html:32097,Testability,log,logger,32097,"s_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs; ; [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(); ; [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically this will be the basis coefficients; """"""; # Type and size checking avoided here as this is in the ; # main optmisation call sequence; self.set_coeffs(param_vals); ; def set_coeffs(self, param_vals):; self.coeffs = param_vals.reshape(; [self.num_coeffs, self.num_basis_funcs]); ; def init_guess_pulse(self):; ; self.guess_pulse_func = None; if not self.guess_pulse_action:; logger.WARN(""No guess pulse action given, hence ignored.""); elif self.guess_pulse_action.upper() == 'MODULATE':; self.guess_pulse_func = self.guess_pulse_modulate; elif self.guess_pulse_action.upper() == 'ADD':; self.guess_pulse_func = self.guess_pulse_add; else:; logger.WARN(""No option for guess pulse action '{}' ""; "", hence ignored."".format(self.guess_pulse_action)); ; def guess_pulse_add(self, pulse):; pulse = pulse + self.guess_pulse; return pulse; ; def guess_pulse_modulate(self, pulse):; pulse = (1.0 + pulse)*self.guess_pulse; return pulse; ; def _init_bounds(self):; add_guess_pulse_scale = False; if self.lbound is None and self.ubound is None:; # no bounds to apply; self._bound_scale_cond = None; elif self.lbound is None:; # only upper bound; if self.ubound > 0:; self._bound_mean = 0.0; self._bound_scale = self.ubound; else:; add_guess_pulse_scale = True; self._bound_scale = self.scaling*self.num_coeffs + \; self.get_guess_pulse_scale(); self._bound_mean = -abs(self._boun",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html:32362,Testability,log,logger,32362,"n num_coeffs; ; [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(); ; [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically this will be the basis coefficients; """"""; # Type and size checking avoided here as this is in the ; # main optmisation call sequence; self.set_coeffs(param_vals); ; def set_coeffs(self, param_vals):; self.coeffs = param_vals.reshape(; [self.num_coeffs, self.num_basis_funcs]); ; def init_guess_pulse(self):; ; self.guess_pulse_func = None; if not self.guess_pulse_action:; logger.WARN(""No guess pulse action given, hence ignored.""); elif self.guess_pulse_action.upper() == 'MODULATE':; self.guess_pulse_func = self.guess_pulse_modulate; elif self.guess_pulse_action.upper() == 'ADD':; self.guess_pulse_func = self.guess_pulse_add; else:; logger.WARN(""No option for guess pulse action '{}' ""; "", hence ignored."".format(self.guess_pulse_action)); ; def guess_pulse_add(self, pulse):; pulse = pulse + self.guess_pulse; return pulse; ; def guess_pulse_modulate(self, pulse):; pulse = (1.0 + pulse)*self.guess_pulse; return pulse; ; def _init_bounds(self):; add_guess_pulse_scale = False; if self.lbound is None and self.ubound is None:; # no bounds to apply; self._bound_scale_cond = None; elif self.lbound is None:; # only upper bound; if self.ubound > 0:; self._bound_mean = 0.0; self._bound_scale = self.ubound; else:; add_guess_pulse_scale = True; self._bound_scale = self.scaling*self.num_coeffs + \; self.get_guess_pulse_scale(); self._bound_mean = -abs(self._bound_scale) + self.ubound; self._bound_scale_cond = self._BSC_GT_MEAN. elif self.ubound is None:; # only lower bound; if self.lbound < 0:; self._bound_mean = 0.0; self._bound_scale = abs(self.lbound); else:; self._bound_scale = self.scaling*self.num_coeffs + \; self.",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html:11053,Usability,simpl,simply,11053," - max_amp; else:; # min_amp + offset must exceed the lbound; return pulse + self.lbound - min_amp; else:; bound_range = self.ubound - self.lbound; amp_range = max_amp - min_amp; if max_amp - min_amp > bound_range:; # pulse range is too high, it must be scaled; pulse = pulse * bound_range / amp_range. # otherwise the pulse should fit anyway; return pulse + self.lbound - min(pulse). def _apply_ramping_pulse(self, pulse, ramping_pulse=None):; if ramping_pulse is None:; ramping_pulse = self.ramping_pulse; if ramping_pulse is not None:; pulse = pulse*ramping_pulse; ; return pulse; ; [docs]class PulseGenZero(PulseGen):; """"""; Generates a flat pulse; """"""; [docs] def gen_pulse(self):; """"""; Generate a pulse with the same value in every timeslot.; The value will be zero, unless the offset is not zero,; in which case it will be the offset; """"""; pulse = np.zeros(self.num_tslots); return self._apply_bounds_and_offset(pulse). [docs]class PulseGenRandom(PulseGen):; """"""; Generates random pulses as simply random values for each timeslot; """"""; [docs] def reset(self):; PulseGen.reset(self); self.random = True; self.apply_params(). [docs] def gen_pulse(self):; """"""; Generate a pulse of random values between 1 and -1; Values are scaled using the scaling property; and shifted using the offset property; Returns the pulse as an array of vales for each timeslot; """"""; pulse = (2*np.random.random(self.num_tslots) - 1) * self.scaling. return self._apply_bounds_and_offset(pulse). class PulseGenRndFourier(PulseGen):; """"""; Generates pulses by summing sine waves as a Fourier series; with random coefficients. Attributes; ----------; scaling : float; The pulses should fit approximately within -/+scaling; (before the offset is applied); as it is used to set a maximum for each component wave; Use bounds to be sure; (copied from Dynamics.initial_ctrl_scaling if given). min_wavelen : float; Minimum wavelength of any component wave; Set by default to 1/10th of the pulse time; """""". def reset(self):; """"""; re",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:2481,Availability,error,error,2481,"TORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number o",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:2649,Availability,error,error,2649,"# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:2946,Availability,error,error,2946,"F THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Opt",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:3199,Availability,error,error,3199,"email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Co",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:3882,Availability,error,error,3882,"odule. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; imp",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:4881,Availability,error,errors,4881,"tion. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_param",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:4891,Availability,error,errors,4891,"tion. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_param",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:6306,Availability,error,error,6306,"e message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:6715,Availability,error,error,6715,"10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be gi",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:6735,Availability,error,error,6735,"10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be gi",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:8263,Availability,error,error,8263,"ntrol generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; ; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a sc",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:8330,Availability,error,error,8330,"on.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; ; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:9345,Availability,error,error,9345,"lue. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; ; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameter",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:10969,Availability,error,error,10969,"minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; phase_option : string; Deprecated. Pass in fid_params instead. fid_err_scale_factor : float; Deprecated. Use scale_factor key in fid_params instead. tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ; tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; amp_update_mode : string; Deprecated. Use tslot_type inste",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:10989,Availability,error,error,10989,"minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; phase_option : string; Deprecated. Pass in fid_params instead. fid_err_scale_factor : float; Deprecated. Use scale_factor key in fid_params instead. tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ; tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; amp_update_mode : string; Deprecated. Use tslot_type inste",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:14185,Availability,error,error,14185,"name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level); ; # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:19534,Availability,error,error,19534,"not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:20201,Availability,error,error,20201,"im_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; ; H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:20368,Availability,error,error,20368,"mping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; ; H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot duration",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:21788,Availability,error,error,21788,"t control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scip",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:21855,Availability,error,error,21855,"on.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pu",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:22868,Availability,error,error,22868,"value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; ; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; ; PSU - global phase ignored; SU - global phase included. dyn_para",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:27080,Availability,error,error,27080,"be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # parameters are checked in create pulse optimiser; ; # The deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params:; method_params['accuracy_factor'] = accuracy_factor; else:; method_params = {'accuracy_factor':accuracy_factor}; _param_deprecation(; ""The 'a",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:30234,Availability,error,error,30234,"nit_pulse_type=init_pulse_type, init_pulse_params=init_pulse_params,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, out_file_ext=out_file_ext,; gen_stats=gen_stats); ; [docs]def opt_pulse_crab(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:30713,Availability,error,error,30713," optim_params=None, optim_method='fmin', method_params=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:30733,Availability,error,error,30733," optim_params=None, optim_method='fmin', method_params=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:32261,Availability,error,error,32261,"ntrol generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:32328,Availability,error,error,32328,"on.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while sti",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:34023,Availability,error,error,34023,"his is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:34859,Availability,error,error,34859," be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ; tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; guess_pulse_type : string; type / shape of pulse(s) used modulate the control amplitudes. ; Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN; Default is None; ; guess_pulse_params : di",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:34879,Availability,error,error,34879," be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ; tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; guess_pulse_type : string; type / shape of pulse(s) used modulate the control amplitudes. ; Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN; Default is None; ; guess_pulse_params : di",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:37922,Availability,error,error,37922,"e attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_param",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:40727,Availability,error,error,40727,"t_type=tslot_type, tslot_params=tslot_params,; init_pulse_type=guess_pulse_type, ; init_pulse_params=guess_pulse_params,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, out_file_ext=out_file_ext, gen_stats=gen_stats); ; [docs]def opt_pulse_crab_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of th",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:41466,Availability,error,error,41466,"ss_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the tim",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:41486,Availability,error,error,41486,"ss_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the tim",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:43011,Availability,error,error,43011,"t control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:43078,Availability,error,error,43078,"on.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while sti",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:44773,Availability,error,error,44773," -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:48184,Availability,error,error,48184,"e attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_param",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:52789,Availability,error,error,52789,"ntrol generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm; ; alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a sc",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:52856,Availability,error,error,52856,"on.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm; ; alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:53871,Availability,error,error,53871,"lue. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm; ; alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:55506,Availability,error,error,55506,"minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; phase_option : string; Deprecated. Pass in fid_params instead. fid_err_scale_factor : float; Deprecated. Use scale_factor key in fid_params instead. tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ; tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; amp_update_mode : string; Deprecated. Use tslot_type inste",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:55526,Availability,error,error,55526,"minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; phase_option : string; Deprecated. Pass in fid_params instead. fid_err_scale_factor : float; Deprecated. Use scale_factor key in fid_params instead. tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ; tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; amp_update_mode : string; Deprecated. Use tslot_type inste",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:60988,Availability,error,errors,60988,"tion is None:; if isinstance(fid_params, dict):; if not 'phase_option' in fid_params:; fid_params['phase_option'] = phase_option; else:; fid_params = {'phase_option':phase_option}; _param_deprecation(; ""The 'phase_option' parameter is deprecated. ""; ""Use 'phase_option' in fid_params instead""); ; # fid_err_scale_factor; if not fid_err_scale_factor is None:; if isinstance(fid_params, dict):; if not 'fid_err_scale_factor' in fid_params:; fid_params['scale_factor'] = fid_err_scale_factor; else:; fid_params = {'scale_factor':fid_err_scale_factor}; _param_deprecation(; ""The 'fid_err_scale_factor' parameter is deprecated. ""; ""Use 'scale_factor' in fid_params instead""); ; # amp_update_mode; if not amp_update_mode is None:; amp_update_mode_up = _upper_safe(amp_update_mode); if amp_update_mode_up == 'ALL':; tslot_type = 'UPDATE_ALL'; else:; tslot_type = amp_update_mode; _param_deprecation(; ""The 'amp_update_mode' parameter is deprecated. ""; ""Use 'tslot_type' instead""); ; # set algorithm defaults; alg_up = _upper_safe(alg); if alg is None:; raise errors.UsageError(; ""Optimisation algorithm must be specified through 'alg' parameter""); elif alg_up == 'GRAPE':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN_L_BFGS_B'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_le",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:61566,Availability,error,errors,61566,"er is deprecated. ""; ""Use 'scale_factor' in fid_params instead""); ; # amp_update_mode; if not amp_update_mode is None:; amp_update_mode_up = _upper_safe(amp_update_mode); if amp_update_mode_up == 'ALL':; tslot_type = 'UPDATE_ALL'; else:; tslot_type = amp_update_mode; _param_deprecation(; ""The 'amp_update_mode' parameter is deprecated. ""; ""Use 'tslot_type' instead""); ; # set algorithm defaults; alg_up = _upper_safe(alg); if alg is None:; raise errors.UsageError(; ""Optimisation algorithm must be specified through 'alg' parameter""); elif alg_up == 'GRAPE':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN_L_BFGS_B'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); dyn._drift_dyn_gen_checked = True; dyn._ctrl_dyn_gen_checked = True; ; # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None o",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:62245,Availability,error,errors,62245,"ulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); dyn._drift_dyn_gen_checked = True; dyn._ctrl_dyn_gen_checked = True; ; # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCompDiag):; dyn.prop_computer = propcomp.PropCompDiag(dyn); elif prop_type == 'AUG_MAT':; if not isinstance(dyn.prop_computer, propcomp.PropCompAugMat):; dyn.prop_computer = propcomp.PropCompAugMat(dyn); elif prop_type == 'FRECHET':; if not isinstance(dyn.prop_computer, propcomp.PropCompFrechet):; dyn.prop_computer = propcomp.PropCompFrechet(dyn); else:; raise errors.UsageError(""No op",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:63206,Availability,error,errors,63206,"dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); dyn._drift_dyn_gen_checked = True; dyn._ctrl_dyn_gen_checked = True; ; # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCompDiag):; dyn.prop_computer = propcomp.PropCompDiag(dyn); elif prop_type == 'AUG_MAT':; if not isinstance(dyn.prop_computer, propcomp.PropCompAugMat):; dyn.prop_computer = propcomp.PropCompAugMat(dyn); elif prop_type == 'FRECHET':; if not isinstance(dyn.prop_computer, propcomp.PropCompFrechet):; dyn.prop_computer = propcomp.PropCompFrechet(dyn); else:; raise errors.UsageError(""No option for prop_type: "" + prop_type); dyn.prop_computer.apply_params(prop_params). # Create the FidelityComputer instance; # The default will be typically be the best option; # Note: the FidCompTraceDiffApprox is a subclass of FidCompTraceDiff; # so need to check this type first; fid_type_up = _upper_safe(fid_type); if fid_type_up == 'DEF' or fid_type_up is None or fid_type_up == '':; # None given, use the default for the Dynamics; pass; elif fid_type_up == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.f",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:64129,Availability,error,errors,64129,"ropcomp.PropCompFrechet):; dyn.prop_computer = propcomp.PropCompFrechet(dyn); else:; raise errors.UsageError(""No option for prop_type: "" + prop_type); dyn.prop_computer.apply_params(prop_params). # Create the FidelityComputer instance; # The default will be typically be the best option; # Note: the FidCompTraceDiffApprox is a subclass of FidCompTraceDiff; # so need to check this type first; fid_type_up = _upper_safe(fid_type); if fid_type_up == 'DEF' or fid_type_up is None or fid_type_up == '':; # None given, use the default for the Dynamics; pass; elif fid_type_up == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method;",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:64530,Availability,error,errors,64530,"ceDiff; # so need to check this type first; fid_type_up = _upper_safe(fid_type); if fid_type_up == 'DEF' or fid_type_up is None or fid_type_up == '':; # None given, use the default for the Dynamics; pass; elif fid_type_up == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; t",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:64937,Availability,error,errors,64937,"Diff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:66314,Availability,error,errors,66314,"tim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to generate the; # timeslot durations; try:; evo_time / num_tslots; except:; raise errors.UsageError(; ""Either the timeslot durations should be supplied as an ""; ""array 'tau' or the number of timeslots 'num_tslots' ""; ""and the evolution time 'evo_time' must be given.""). dyn.num_tslots = num_tslots; dyn.evo_time = evo_time; else:; dyn.tau = tau. # this function is called, so that the num_ctrls attribute will be set; n_ctrls = dyn.num_ctrls. ramping_pgen = None; if ramping_pulse_type:; ramping_pgen = pulsegen.create_pulse_gen(; pulse_type=ramping_pulse_type, dyn=dyn, ; pulse_params=ramping_pulse_params); if alg_up == 'CRAB':; # Create a pulse generator for each ctrl; crab_pulse_params = None; num_coeffs = None; init_coeff_scaling = None; if isinstance(alg_params, dict):; num_coeffs = alg_params.get('num_coeffs'); init_coeff_scaling = alg_params.get('init_coeff_scaling'); if 'crab_pulse_params' in alg_params:; crab_pulse_params = alg_params.get('crab_pulse_params'); ; guess_pulse_type = init_pul",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:2353,Deployability,configurat,configuration,2353,"OT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:17682,Deployability,configurat,configuration,17682,"tim_method=optim_method, method_params=method_params,; dyn_type=dyn_type, dyn_params=dyn_params, ; prop_type=prop_type, prop_params=prop_params,; fid_type=fid_type, fid_params=fid_params,; init_pulse_type=init_pulse_type, init_pulse_params=init_pulse_params,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics. dyn.init_timeslots(); # Generate initial pulses for each control; init_amps = np.zeros([dyn.num_tslots, dyn.num_ctrls]); ; if alg == 'CRAB':; for j in range(dyn.num_ctrls):; pgen = optim.pulse_generator[j]; pgen.init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(); ; # Initialise the starting amplitudes; dyn.initialize_controls(init_amps); ; if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amp",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:51193,Deployability,configurat,configuration,51193,"_file_ext, gen_stats=gen_stats). [docs]def create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, gen_stats=False):. """"""; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. t",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:69474,Deployability,update,updated,69474,".get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:3518,Energy Efficiency,reduce,reduces,3518,"time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as l",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:5172,Integrability,message,message,5172," & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, ou",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:5260,Integrability,message,message,5260," & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, ou",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:5348,Integrability,message,message,5348,"m-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combin",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:7017,Integrability,depend,dependent,7017,"tion=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundarie",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:7241,Integrability,depend,dependent,7241,"ging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a li",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:9576,Integrability,depend,dependent,9576,"me : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; ; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPRO",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:19646,Integrability,wrap,wrapper,19646,"e). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; ; H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided f",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:20553,Integrability,depend,dependent,20553,"fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; ; H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:20770,Integrability,depend,dependent,20770," chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; ; H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list o",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:23099,Integrability,depend,dependent,23099,"ime : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; ; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; ; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs;",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:31015,Integrability,depend,dependent,31015,"=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundarie",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:31239,Integrability,depend,dependent,31239,"trol pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a li",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:40839,Integrability,wrap,wrapper,40839,"_ext=out_file_ext, gen_stats=gen_stats); ; [docs]def opt_pulse_crab_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Arra",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:41778,Integrability,depend,dependent,41778,"e fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control am",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:41993,Integrability,depend,dependent,41993,"es are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list o",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:51543,Integrability,depend,dependent,51543,"m_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, gen_stats=False):. """"""; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundarie",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:51767,Integrability,depend,dependent,51767,"scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, gen_stats=False):. """"""; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a li",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:54102,Integrability,depend,dependent,54102,"float; Maximum allowed elapsed time for the optimisation algorithm; ; alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:68541,Integrability,message,message,68541,"_pulse_action = init_pulse_params.get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a the",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:2353,Modifiability,config,configuration,2353,"OT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:2971,Modifiability,variab,variables,2971,"F THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Opt",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:3553,Modifiability,variab,variables,3553,"time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as l",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:3642,Modifiability,variab,variables,3642,"time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as l",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:3723,Modifiability,variab,variables,3723,"um control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; impor",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:17682,Modifiability,config,configuration,17682,"tim_method=optim_method, method_params=method_params,; dyn_type=dyn_type, dyn_params=dyn_params, ; prop_type=prop_type, prop_params=prop_params,; fid_type=fid_type, fid_params=fid_params,; init_pulse_type=init_pulse_type, init_pulse_params=init_pulse_params,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics. dyn.init_timeslots(); # Generate initial pulses for each control; init_amps = np.zeros([dyn.num_tslots, dyn.num_ctrls]); ; if alg == 'CRAB':; for j in range(dyn.num_ctrls):; pgen = optim.pulse_generator[j]; pgen.init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(); ; # Initialise the starting amplitudes; dyn.initialize_controls(init_amps); ; if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amp",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:30520,Modifiability,variab,variables,30520,"ft, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:33440,Modifiability,variab,variable,33440,"um allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:33965,Modifiability,variab,variable,33965,"his is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:41273,Modifiability,variab,variables,41273,"=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : in",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:44190,Modifiability,variab,variable,44190,"um allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The ke",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:44715,Modifiability,variab,variable,44715," -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:51193,Modifiability,config,configuration,51193,"_file_ext, gen_stats=gen_stats). [docs]def create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, gen_stats=False):. """"""; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. t",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:68951,Modifiability,config,config,68951,".get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:2903,Performance,optimiz,optimize,2903,"F THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Opt",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:4405,Performance,optimiz,optimization,4405,"was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklev",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:4799,Performance,optimiz,optimizer,4799,"adient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:4812,Performance,optimiz,optimizer,4812,"adient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:9258,Performance,optimiz,optimize,9258," error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; ; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:9443,Performance,optimiz,optimize,9443,"e, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; ; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:9955,Performance,optimiz,optimize,9955,"rams : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:22781,Performance,optimiz,optimize,22781,"ty error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; ; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_typ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:22966,Performance,optimiz,optimize,22966,"lue, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; ; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; ; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the obj",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:23480,Performance,optimiz,optimize,23480,"ms : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; ; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; ; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the tim",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:33242,Performance,perform,performane,33242,"misation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:33581,Performance,optimiz,optimize,33581,"ithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:33888,Performance,optimiz,optimize,33888," float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:43992,Performance,perform,performane,43992,"misation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:44331,Performance,optimiz,optimize,44331,"ithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict;",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:44638,Performance,optimiz,optimize,44638," float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPD",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:53784,Performance,optimiz,optimize,53784," error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm; ; alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamic",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:53969,Performance,optimiz,optimize,53969,"e, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm; ; alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is cr",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:54492,Performance,optimiz,optimize,54492,"ionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:58646,Performance,optimiz,optimizer,58646,"The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:58719,Performance,optimiz,optimizer,58719," name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params:; method_params['accuracy_facto",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:64669,Performance,optimiz,optimizer,64669,"== '':; # None given, use the default for the Dynamics; pass; elif fid_type_up == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wa",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:64785,Performance,optimiz,optimizer,64785,", fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; optim.apply_method_params(method_params). if gen_stats:; # Create a",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:64885,Performance,optimiz,optimizer,64885," == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:65091,Performance,optimiz,optimize,65091,"FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = dr",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:65193,Performance,optimiz,optimizer,65193,"option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dy",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:65243,Performance,optimiz,optimizer,65243,"; ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been suppli",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:65905,Performance,perform,performance,65905,"od_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to generate the; # timeslot durations; try:; evo_time / num_tslots; except:; raise errors.UsageError(; ""Either the timeslot durations should be supplied as an ""; ""array 'tau' or the number of timeslots 'num_tslots' ""; ""and the evolution time 'evo_time' must be given.""). dyn.num_tslots = num_tslots; dyn.evo_time = evo_time; else:; dyn.tau = tau. # this function is called, so that the num_ctrls attribute will be set; n_ctrls = dyn.num_ctrls. ramping_pgen = None; if ramping_pulse_type:; ramping_pgen = pulsegen.create_pulse_gen(; pulse_type=ramping_pulse_type, dyn=dyn, ; pulse_params=ramping_pulse_params",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:68997,Performance,optimiz,optimizer,68997,".get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:2821,Security,access,accessible,2821," CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default i",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:13990,Security,access,accessible,13990,"emented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level); ; # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:26886,Security,access,accessible,26886,"emented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # parameters are checked in create pulse optimiser; ; # The deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if no",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:37727,Security,access,accessible,37727,"emented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:47989,Security,access,accessible,47989,"emented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:58288,Security,access,accessible,58288,"any initial / guess pulses generated.; ; ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params,",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:58491,Security,access,accessed,58491,"n, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:58594,Security,access,accessed,58594,"pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:4578,Testability,log,logging,4578,"ontrol pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lboun",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:4587,Testability,log,logger,4587,"ontrol pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lboun",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:4596,Testability,log,logging,4596,"ontrol pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lboun",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:6197,Testability,log,logging,6197,"tion(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:13273,Testability,log,logger,13273,"_params : dict; Parameters for the initial / guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. pulse_scaling : float; Linear scale factor for generated initial / guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added; to any initial / guess pulses generated.; ; ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:14266,Testability,log,logging,14266,"name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level); ; # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:14295,Testability,log,logger,14295,"s are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level); ; # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params:; method_params['accuracy_factor'] = accuracy_factor; else:; method_params = {'accuracy_factor':accuracy_factor}; _param_deprecat",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:14330,Testability,log,logger,14330,"ng_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level); ; # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params:; method_params['accuracy_factor'] = accuracy_factor; else:; method_params = {'accuracy_factor':accuracy_factor}; _param_deprecation(; ""The 'accuracy_factor' par",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:17653,Testability,log,logging,17653," max_wall_time=max_wall_time,; alg=alg, alg_params=alg_params, optim_params=optim_params,; optim_method=optim_method, method_params=method_params,; dyn_type=dyn_type, dyn_params=dyn_params, ; prop_type=prop_type, prop_params=prop_params,; fid_type=fid_type, fid_params=fid_params,; init_pulse_type=init_pulse_type, init_pulse_params=init_pulse_params,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics. dyn.init_timeslots(); # Generate initial pulses for each control; init_amps = np.zeros([dyn.num_tslots, dyn.num_ctrls]); ; if alg == 'CRAB':; for j in range(dyn.num_ctrls):; pgen = optim.pulse_generator[j]; pgen.init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(); ; # Initialise the starting amplitudes; dyn.initialize_controls(init_amps); ; if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:18208,Testability,log,logger,18208,"ots(); # Generate initial pulses for each control; init_amps = np.zeros([dyn.num_tslots, dyn.num_ctrls]); ; if alg == 'CRAB':; for j in range(dyn.num_ctrls):; pgen = optim.pulse_generator[j]; pgen.init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(); ; # Initialise the starting amplitudes; dyn.initialize_controls(init_amps); ; if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:18389,Testability,log,logging,18389,"ptim.pulse_generator[j]; pgen.init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(); ; # Initialise the starting amplitudes; dyn.initialize_controls(init_amps); ; if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_puls",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:18404,Testability,log,logger,18404,"init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(); ; # Initialise the starting amplitudes; dyn.initialize_controls(init_amps); ; if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_par",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:18688,Testability,log,logging,18688," ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse,",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:18703,Testability,log,logger,18703,"_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate option",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:19425,Testability,log,logging,19425,"g.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Param",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:26169,Testability,log,logger,26169,"_params : dict; Parameters for the initial / guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. pulse_scaling : float; Linear scale factor for generated initial / guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added; to any initial / guess pulses generated.; ; ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""".",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:30125,Testability,log,logging,30125,"method_params,; dyn_type='UNIT', dyn_params=dyn_params,; prop_params=prop_params, fid_params=fid_params,; init_pulse_type=init_pulse_type, init_pulse_params=init_pulse_params,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, out_file_ext=out_file_ext,; gen_stats=gen_stats); ; [docs]def opt_pulse_crab(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots,",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:33479,Testability,test,tested,33479,"um allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:37010,Testability,log,logger,37010,"d after the object is created; ; guess_pulse_action : string; Determines how the guess pulse is applied to the pulse generated; by the basis expansion.; Options are: MODULATE, ADD ; Default is MODULATE. pulse_scaling : float; Linear scale factor for generated guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added; to any guess pulses generated.; ; ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:38087,Testability,log,logging,38087,"evels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and ; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pul",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:38116,Testability,log,logger,38116,"EBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and ; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_action is not None and ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:38151,Testability,log,logger,38151,"BUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and ; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_action is not None and ; not 'pulse_action' in guess_pu",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:40618,Testability,log,logging,40618,"arams,; dyn_type=dyn_type, dyn_params=dyn_params, ; prop_type=prop_type, prop_params=prop_params,; fid_type=fid_type, fid_params=fid_params,; tslot_type=tslot_type, tslot_params=tslot_params,; init_pulse_type=guess_pulse_type, ; init_pulse_params=guess_pulse_params,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, out_file_ext=out_file_ext, gen_stats=gen_stats); ; [docs]def opt_pulse_crab_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolu",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:44229,Testability,test,tested,44229,"um allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The ke",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:47272,Testability,log,logger,47272,"d after the object is created; ; guess_pulse_action : string; Determines how the guess pulse is applied to the pulse generated; by the basis expansion.; Options are: MODULATE, ADD ; Default is MODULATE. pulse_scaling : float; Linear scale factor for generated guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added; to any guess pulses generated.; ; ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:48349,Testability,log,logging,48349,"evels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and ; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pul",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:48378,Testability,log,logger,48378,"EBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and ; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_action is not None and ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:48413,Testability,log,logger,48413,"BUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and ; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_action is not None and ; not 'pulse_action' in guess_pu",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:50956,Testability,log,logging,50956,"ms=fid_params,; tslot_type=tslot_type, tslot_params=tslot_params,; init_pulse_type=guess_pulse_type, ; init_pulse_params=guess_pulse_params,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, out_file_ext=out_file_ext, gen_stats=gen_stats). [docs]def create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, gen_stats=False):. """"""; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:57816,Testability,log,logger,57816," ; (see PulseGen classes for details); For the CRAB the this the guess_pulse_type. . init_pulse_params : dict; Parameters for the initial / guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. pulse_scaling : float; Linear scale factor for generated initial / guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added; to any initial / guess pulses generated.; ; ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:61850,Testability,log,logging,61850,"e_mode' parameter is deprecated. ""; ""Use 'tslot_type' instead""); ; # set algorithm defaults; alg_up = _upper_safe(alg); if alg is None:; raise errors.UsageError(; ""Optimisation algorithm must be specified through 'alg' parameter""); elif alg_up == 'GRAPE':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN_L_BFGS_B'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); dyn._drift_dyn_gen_checked = True; dyn._ctrl_dyn_gen_checked = True; ; # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCom",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:61879,Testability,log,logger,61879,"ated. ""; ""Use 'tslot_type' instead""); ; # set algorithm defaults; alg_up = _upper_safe(alg); if alg is None:; raise errors.UsageError(; ""Optimisation algorithm must be specified through 'alg' parameter""); elif alg_up == 'GRAPE':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN_L_BFGS_B'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); dyn._drift_dyn_gen_checked = True; dyn._ctrl_dyn_gen_checked = True; ; # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCompDiag):; dyn.prop_computer",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:61914,Testability,log,logger,61914,"ead""); ; # set algorithm defaults; alg_up = _upper_safe(alg); if alg is None:; raise errors.UsageError(; ""Optimisation algorithm must be specified through 'alg' parameter""); elif alg_up == 'GRAPE':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN_L_BFGS_B'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); dyn._drift_dyn_gen_checked = True; dyn._ctrl_dyn_gen_checked = True; ; # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCompDiag):; dyn.prop_computer = propcomp.PropCompDiag(dyn); e",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:68906,Testability,log,logging,68906,".get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:68922,Testability,log,logger,68922,".get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:5087,Usability,simpl,simplefilter,5087," & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, ou",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:19637,Usability,simpl,simply,19637,"e). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; ; H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided f",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:40830,Usability,simpl,simply,40830,"_ext=out_file_ext, gen_stats=gen_stats); ; [docs]def opt_pulse_crab_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Arra",MatchSource.WIKI,docs/4.5/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.5/modules/qutip/control/stats.html:2333,Availability,redundant,redundant,2333," BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (el",MatchSource.WIKI,docs/4.5/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/stats.html
https://qutip.org/docs/4.5/modules/qutip/control/stats.html:4034,Availability,error,error,4034,"me for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_compute : float; Total wall (elasped) time computing combined forward propagation,; that is the time evolution from the start to a specific timeslot.; Excludes calculating the propagators themselves. wall_time_onwd_prop_compute : float; Total wall (elasped) time computing combined onward propagation,; that is the time evolution from a specific timeslot to the end time.; Excludes calculating the propagators themselves. wall_time_gradient_compute : float; Total wall (elasped) time computing the fidelity error gradient.; Excludes calculating the propagator gradients (in exact gradient; methods). num_fidelity_func_calls : integer; Number of calls to fidelity function by the optimisation algorithm. num_grad_func_calls : integer; Number of calls to gradient function by the optimisation algorithm. num_tslot_recompute : integer; Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the",MatchSource.WIKI,docs/4.5/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/stats.html
https://qutip.org/docs/4.5/modules/qutip/control/stats.html:2526,Deployability,configurat,configurations,2526,"CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_ti",MatchSource.WIKI,docs/4.5/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/stats.html
https://qutip.org/docs/4.5/modules/qutip/control/stats.html:2565,Deployability,update,updated,2565,"CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_ti",MatchSource.WIKI,docs/4.5/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/stats.html
https://qutip.org/docs/4.5/modules/qutip/control/stats.html:4839,Deployability,update,updated,4839,"ned onward propagation,; that is the time evolution from a specific timeslot to the end time.; Excludes calculating the propagators themselves. wall_time_gradient_compute : float; Total wall (elasped) time computing the fidelity error gradient.; Excludes calculating the propagator gradients (in exact gradient; methods). num_fidelity_func_calls : integer; Number of calls to fidelity function by the optimisation algorithm. num_grad_func_calls : integer; Number of calls to gradient function by the optimisation algorithm. num_tslot_recompute : integer; Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update; """"""; def __init__(self):; self.reset(). def reset(self):; self.dyn_gen_name = ""dynamics generator""; self.clear(). def clear(self):; self.num_iter = 0; # Duration attributes; self.wall_time_optim_start = 0.0; self.wall_time_optim_end = 0.0; self.wall_time_optim = 0.0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; sel",MatchSource.WIKI,docs/4.5/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/stats.html
https://qutip.org/docs/4.5/modules/qutip/control/stats.html:4925,Deployability,update,updates,4925,".; Excludes calculating the propagators themselves. wall_time_gradient_compute : float; Total wall (elasped) time computing the fidelity error gradient.; Excludes calculating the propagator gradients (in exact gradient; methods). num_fidelity_func_calls : integer; Number of calls to fidelity function by the optimisation algorithm. num_grad_func_calls : integer; Number of calls to gradient function by the optimisation algorithm. num_tslot_recompute : integer; Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update; """"""; def __init__(self):; self.reset(). def reset(self):; self.dyn_gen_name = ""dynamics generator""; self.clear(). def clear(self):; self.num_iter = 0; # Duration attributes; self.wall_time_optim_start = 0.0; self.wall_time_optim_end = 0.0; self.wall_time_optim = 0.0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; self.wall_time_gradient_compute = 0.0; # Fidelity and gradient function calls and computes; sel",MatchSource.WIKI,docs/4.5/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/stats.html
https://qutip.org/docs/4.5/modules/qutip/control/stats.html:5161,Deployability,update,update,5161,"adient; methods). num_fidelity_func_calls : integer; Number of calls to fidelity function by the optimisation algorithm. num_grad_func_calls : integer; Number of calls to gradient function by the optimisation algorithm. num_tslot_recompute : integer; Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update; """"""; def __init__(self):; self.reset(). def reset(self):; self.dyn_gen_name = ""dynamics generator""; self.clear(). def clear(self):; self.num_iter = 0; # Duration attributes; self.wall_time_optim_start = 0.0; self.wall_time_optim_end = 0.0; self.wall_time_optim = 0.0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; self.wall_time_gradient_compute = 0.0; # Fidelity and gradient function calls and computes; self.num_fidelity_func_calls = 0; self.num_grad_func_calls = 0; self.num_tslot_recompute = 0; self.num_fidelity_computes = 0; self.num_grad_computes = 0; # Control amplitudes; self.num_ctrl_amp_updates = 0; self.mea",MatchSource.WIKI,docs/4.5/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/stats.html
https://qutip.org/docs/4.5/modules/qutip/control/stats.html:5374,Deployability,update,update,5374,"_recompute : integer; Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update; """"""; def __init__(self):; self.reset(). def reset(self):; self.dyn_gen_name = ""dynamics generator""; self.clear(). def clear(self):; self.num_iter = 0; # Duration attributes; self.wall_time_optim_start = 0.0; self.wall_time_optim_end = 0.0; self.wall_time_optim = 0.0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; self.wall_time_gradient_compute = 0.0; # Fidelity and gradient function calls and computes; self.num_fidelity_func_calls = 0; self.num_grad_func_calls = 0; self.num_tslot_recompute = 0; self.num_fidelity_computes = 0; self.num_grad_computes = 0; # Control amplitudes; self.num_ctrl_amp_updates = 0; self.mean_num_ctrl_amp_updates_per_iter = 0.0; self.num_timeslot_changes = 0; self.mean_num_timeslot_changes_per_update = 0.0; self.num_ctrl_amp_changes = 0; self.mean_num_ctrl_amp_changes_per_update = 0.0. [docs] def calculate(self):; """"",MatchSource.WIKI,docs/4.5/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/stats.html
https://qutip.org/docs/4.5/modules/qutip/control/stats.html:9087,Deployability,update,updates,9087,"(""Wall time computing forward propagation: "" +; self._format_datetime(self.wall_time_fwd_prop_compute, tot)); print(""Wall time computing onward propagation: "" +; self._format_datetime(self.wall_time_onwd_prop_compute, tot)); print(""Wall time computing gradient: "" +; self._format_datetime(self.wall_time_gradient_compute, tot)); print(""""). def report_func_calls(self):; print(""**** Iterations and function calls ****""); print(""Number of iterations: {}"".format(self.num_iter)); print(""Number of fidelity function calls: ""; ""{}"".format(self.num_fidelity_func_calls)); print(""Number of times fidelity is computed: ""; ""{}"".format(self.num_fidelity_computes)); print(""Number of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift an",MatchSource.WIKI,docs/4.5/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/stats.html
https://qutip.org/docs/4.5/modules/qutip/control/stats.html:9162,Deployability,update,updates,9162,"int(""Wall time computing onward propagation: "" +; self._format_datetime(self.wall_time_onwd_prop_compute, tot)); print(""Wall time computing gradient: "" +; self._format_datetime(self.wall_time_gradient_compute, tot)); print(""""). def report_func_calls(self):; print(""**** Iterations and function calls ****""); print(""Number of iterations: {}"".format(self.num_iter)); print(""Number of fidelity function calls: ""; ""{}"".format(self.num_fidelity_func_calls)); print(""Number of times fidelity is computed: ""; ""{}"".format(self.num_fidelity_computes)); print(""Number of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per",MatchSource.WIKI,docs/4.5/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/stats.html
https://qutip.org/docs/4.5/modules/qutip/control/stats.html:9372,Deployability,update,update,9372,"gradient_compute, tot)); print(""""). def report_func_calls(self):; print(""**** Iterations and function calls ****""); print(""Number of iterations: {}"".format(self.num_iter)); print(""Number of fidelity function calls: ""; ""{}"".format(self.num_fidelity_func_calls)); print(""Number of times fidelity is computed: ""; ""{}"".format(self.num_fidelity_computes)); print(""Number of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_",MatchSource.WIKI,docs/4.5/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/stats.html
https://qutip.org/docs/4.5/modules/qutip/control/stats.html:9571,Deployability,update,update,9571,"function calls: ""; ""{}"".format(self.num_fidelity_func_calls)); print(""Number of times fidelity is computed: ""; ""{}"".format(self.num_fidelity_computes)); print(""Number of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator com",MatchSource.WIKI,docs/4.5/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/stats.html
https://qutip.org/docs/4.5/modules/qutip/control/stats.html:9705,Deployability,configurat,configurations,9705,"of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator computations per update. mean_wall_time_prop_compute : float; Mean average time to compute a propagator (and its gradient). num_fwd_prop_step_computes : integer; Total num",MatchSource.WIKI,docs/4.5/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/stats.html
https://qutip.org/docs/4.5/modules/qutip/control/stats.html:9761,Deployability,update,updated,9761,"of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator computations per update. mean_wall_time_prop_compute : float; Mean average time to compute a propagator (and its gradient). num_fwd_prop_step_computes : integer; Total num",MatchSource.WIKI,docs/4.5/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/stats.html
https://qutip.org/docs/4.5/modules/qutip/control/stats.html:9889,Deployability,update,update,9889,"mat(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator computations per update. mean_wall_time_prop_compute : float; Mean average time to compute a propagator (and its gradient). num_fwd_prop_step_computes : integer; Total number of steps (matrix product) computing forward propagation. mean_num_fwd_prop_step_computes_per_update : float; Mean average num",MatchSource.WIKI,docs/4.5/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/stats.html
https://qutip.org/docs/4.5/modules/qutip/control/stats.html:10233,Deployability,update,update,10233,"n: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator computations per update. mean_wall_time_prop_compute : float; Mean average time to compute a propagator (and its gradient). num_fwd_prop_step_computes : integer; Total number of steps (matrix product) computing forward propagation. mean_num_fwd_prop_step_computes_per_update : float; Mean average number of steps computing forward propagation. mean_wall_time_fwd_prop_compute : float; Mean average time to compute forward propagation. num_onwd_prop_step_computes : integer; Total number of steps (matrix product) computing onward propagation. mean_num_onwd_prop_step_computes_per_update : float; Mean average number of steps computing onward",MatchSource.WIKI,docs/4.5/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/stats.html
https://qutip.org/docs/4.5/modules/qutip/control/stats.html:10559,Deployability,update,update,10559,"_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator computations per update. mean_wall_time_prop_compute : float; Mean average time to compute a propagator (and its gradient). num_fwd_prop_step_computes : integer; Total number of steps (matrix product) computing forward propagation. mean_num_fwd_prop_step_computes_per_update : float; Mean average number of steps computing forward propagation. mean_wall_time_fwd_prop_compute : float; Mean average time to compute forward propagation. num_onwd_prop_step_computes : integer; Total number of steps (matrix product) computing onward propagation. mean_num_onwd_prop_step_computes_per_update : float; Mean average number of steps computing onward propagation. mean_wall_time_onwd_prop_compute; Mean average time to compute onward propagation; """""". def __init__(self):; self.reset(). def reset(self):; Stats.reset(self); # Dynamics generators (Hamiltonians); self.num_dyn_gen_computes = 0; self.mean_num_dyn_gen_computes_per_update = 0.0; self.mean_wall_time_dyn_gen_compute = 0.",MatchSource.WIKI,docs/4.5/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/stats.html
https://qutip.org/docs/4.5/modules/qutip/control/stats.html:13561,Deployability,update,update,13561,"_step_computes /; float(self.num_ctrl_amp_updates)). self.mean_wall_time_fwd_prop_compute = \; (self.wall_time_fwd_prop_compute /; float(self.num_fwd_prop_step_computes)). self.mean_num_onwd_prop_step_computes_per_update = \; (self.num_onwd_prop_step_computes /; float(self.num_ctrl_amp_updates)). self.mean_wall_time_onwd_prop_compute = \; (self.wall_time_onwd_prop_compute /; float(self.num_onwd_prop_step_computes)). def report(self):; """"""; Print a report of the stats to the console; """""". print(""\n------------------------------------""; ""\n---- Control optimisation stats ----""); self.report_timings(); self.report_func_calls(); self.report_amp_updates(); self.report_dyn_gen_comps(); self.report_fwd_prop(); self.report_onwd_prop(); print(""------------------------------------""). def report_dyn_gen_comps(self):; print(""**** {} Computations ****"".format(self.dyn_gen_name)); print(""Total number of {} computations: ""; ""{}"".format(self.dyn_gen_name, self.num_dyn_gen_computes)); print(""Mean number of {} computations per update: ""; ""{}"".format(self.dyn_gen_name,; self.mean_num_dyn_gen_computes_per_update)); print(""Mean wall time to compute {}s: ""; ""{} s"".format(self.dyn_gen_name,; self.mean_wall_time_dyn_gen_compute)); print(""**** Propagator Computations ****""); print(""Total number of propagator computations: ""; ""{}"".format(self.num_prop_computes)); print(""Mean number of propagator computations per update: ""; ""{}"".format(self.mean_num_prop_computes_per_update)); print(""Mean wall time to compute propagator ""; ""{} s"".format(self.mean_wall_time_prop_compute)). def report_fwd_prop(self):; print(""**** Forward Propagation ****""); print(""Total number of forward propagation step computations: ""; ""{}"".format(self.num_fwd_prop_step_computes)); print(""Mean number of forward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_fwd_prop_step_computes_per_update)); print(""Mean wall time to compute forward propagation ""; ""{} s"".format(self.mean_wall_time_fwd_prop_compute",MatchSource.WIKI,docs/4.5/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/stats.html
https://qutip.org/docs/4.5/modules/qutip/control/stats.html:13946,Deployability,update,update,13946,"t(self.num_onwd_prop_step_computes)). def report(self):; """"""; Print a report of the stats to the console; """""". print(""\n------------------------------------""; ""\n---- Control optimisation stats ----""); self.report_timings(); self.report_func_calls(); self.report_amp_updates(); self.report_dyn_gen_comps(); self.report_fwd_prop(); self.report_onwd_prop(); print(""------------------------------------""). def report_dyn_gen_comps(self):; print(""**** {} Computations ****"".format(self.dyn_gen_name)); print(""Total number of {} computations: ""; ""{}"".format(self.dyn_gen_name, self.num_dyn_gen_computes)); print(""Mean number of {} computations per update: ""; ""{}"".format(self.dyn_gen_name,; self.mean_num_dyn_gen_computes_per_update)); print(""Mean wall time to compute {}s: ""; ""{} s"".format(self.dyn_gen_name,; self.mean_wall_time_dyn_gen_compute)); print(""**** Propagator Computations ****""); print(""Total number of propagator computations: ""; ""{}"".format(self.num_prop_computes)); print(""Mean number of propagator computations per update: ""; ""{}"".format(self.mean_num_prop_computes_per_update)); print(""Mean wall time to compute propagator ""; ""{} s"".format(self.mean_wall_time_prop_compute)). def report_fwd_prop(self):; print(""**** Forward Propagation ****""); print(""Total number of forward propagation step computations: ""; ""{}"".format(self.num_fwd_prop_step_computes)); print(""Mean number of forward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_fwd_prop_step_computes_per_update)); print(""Mean wall time to compute forward propagation ""; ""{} s"".format(self.mean_wall_time_fwd_prop_compute)). def report_onwd_prop(self):; print(""**** Onward Propagation ****""); print(""Total number of onward propagation step computations: ""; ""{}"".format(self.num_onwd_prop_step_computes)); print(""Mean number of onward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_onwd_prop_step_computes_per_update)); print(""Mean wall time to compute onward propagation ""; ""{",MatchSource.WIKI,docs/4.5/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/stats.html
https://qutip.org/docs/4.5/modules/qutip/control/stats.html:14356,Deployability,update,update,14356,"ps(); self.report_fwd_prop(); self.report_onwd_prop(); print(""------------------------------------""). def report_dyn_gen_comps(self):; print(""**** {} Computations ****"".format(self.dyn_gen_name)); print(""Total number of {} computations: ""; ""{}"".format(self.dyn_gen_name, self.num_dyn_gen_computes)); print(""Mean number of {} computations per update: ""; ""{}"".format(self.dyn_gen_name,; self.mean_num_dyn_gen_computes_per_update)); print(""Mean wall time to compute {}s: ""; ""{} s"".format(self.dyn_gen_name,; self.mean_wall_time_dyn_gen_compute)); print(""**** Propagator Computations ****""); print(""Total number of propagator computations: ""; ""{}"".format(self.num_prop_computes)); print(""Mean number of propagator computations per update: ""; ""{}"".format(self.mean_num_prop_computes_per_update)); print(""Mean wall time to compute propagator ""; ""{} s"".format(self.mean_wall_time_prop_compute)). def report_fwd_prop(self):; print(""**** Forward Propagation ****""); print(""Total number of forward propagation step computations: ""; ""{}"".format(self.num_fwd_prop_step_computes)); print(""Mean number of forward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_fwd_prop_step_computes_per_update)); print(""Mean wall time to compute forward propagation ""; ""{} s"".format(self.mean_wall_time_fwd_prop_compute)). def report_onwd_prop(self):; print(""**** Onward Propagation ****""); print(""Total number of onward propagation step computations: ""; ""{}"".format(self.num_onwd_prop_step_computes)); print(""Mean number of onward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_onwd_prop_step_computes_per_update)); print(""Mean wall time to compute onward propagation ""; ""{} s"".format(self.mean_wall_time_onwd_prop_compute)). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/stats.html
https://qutip.org/docs/4.5/modules/qutip/control/stats.html:14787,Deployability,update,update,14787,"ps(); self.report_fwd_prop(); self.report_onwd_prop(); print(""------------------------------------""). def report_dyn_gen_comps(self):; print(""**** {} Computations ****"".format(self.dyn_gen_name)); print(""Total number of {} computations: ""; ""{}"".format(self.dyn_gen_name, self.num_dyn_gen_computes)); print(""Mean number of {} computations per update: ""; ""{}"".format(self.dyn_gen_name,; self.mean_num_dyn_gen_computes_per_update)); print(""Mean wall time to compute {}s: ""; ""{} s"".format(self.dyn_gen_name,; self.mean_wall_time_dyn_gen_compute)); print(""**** Propagator Computations ****""); print(""Total number of propagator computations: ""; ""{}"".format(self.num_prop_computes)); print(""Mean number of propagator computations per update: ""; ""{}"".format(self.mean_num_prop_computes_per_update)); print(""Mean wall time to compute propagator ""; ""{} s"".format(self.mean_wall_time_prop_compute)). def report_fwd_prop(self):; print(""**** Forward Propagation ****""); print(""Total number of forward propagation step computations: ""; ""{}"".format(self.num_fwd_prop_step_computes)); print(""Mean number of forward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_fwd_prop_step_computes_per_update)); print(""Mean wall time to compute forward propagation ""; ""{} s"".format(self.mean_wall_time_fwd_prop_compute)). def report_onwd_prop(self):; print(""**** Onward Propagation ****""); print(""Total number of onward propagation step computations: ""; ""{}"".format(self.num_onwd_prop_step_computes)); print(""Mean number of onward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_onwd_prop_step_computes_per_update)); print(""Mean wall time to compute onward propagation ""; ""{} s"".format(self.mean_wall_time_onwd_prop_compute)). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/stats.html
https://qutip.org/docs/4.5/modules/qutip/control/stats.html:15130,Deployability,update,updated,15130,"ps(); self.report_fwd_prop(); self.report_onwd_prop(); print(""------------------------------------""). def report_dyn_gen_comps(self):; print(""**** {} Computations ****"".format(self.dyn_gen_name)); print(""Total number of {} computations: ""; ""{}"".format(self.dyn_gen_name, self.num_dyn_gen_computes)); print(""Mean number of {} computations per update: ""; ""{}"".format(self.dyn_gen_name,; self.mean_num_dyn_gen_computes_per_update)); print(""Mean wall time to compute {}s: ""; ""{} s"".format(self.dyn_gen_name,; self.mean_wall_time_dyn_gen_compute)); print(""**** Propagator Computations ****""); print(""Total number of propagator computations: ""; ""{}"".format(self.num_prop_computes)); print(""Mean number of propagator computations per update: ""; ""{}"".format(self.mean_num_prop_computes_per_update)); print(""Mean wall time to compute propagator ""; ""{} s"".format(self.mean_wall_time_prop_compute)). def report_fwd_prop(self):; print(""**** Forward Propagation ****""); print(""Total number of forward propagation step computations: ""; ""{}"".format(self.num_fwd_prop_step_computes)); print(""Mean number of forward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_fwd_prop_step_computes_per_update)); print(""Mean wall time to compute forward propagation ""; ""{} s"".format(self.mean_wall_time_fwd_prop_compute)). def report_onwd_prop(self):; print(""**** Onward Propagation ****""); print(""Total number of onward propagation step computations: ""; ""{}"".format(self.num_onwd_prop_step_computes)); print(""Mean number of onward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_onwd_prop_step_computes_per_update)); print(""Mean wall time to compute onward propagation ""; ""{} s"".format(self.mean_wall_time_onwd_prop_compute)). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/stats.html
https://qutip.org/docs/4.5/modules/qutip/control/stats.html:2526,Modifiability,config,configurations,2526,"CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_ti",MatchSource.WIKI,docs/4.5/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/stats.html
https://qutip.org/docs/4.5/modules/qutip/control/stats.html:9705,Modifiability,config,configurations,9705,"of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator computations per update. mean_wall_time_prop_compute : float; Mean average time to compute a propagator (and its gradient). num_fwd_prop_step_computes : integer; Total num",MatchSource.WIKI,docs/4.5/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/stats.html
https://qutip.org/docs/4.5/modules/qutip/control/stats.html:2333,Safety,redund,redundant,2333," BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (el",MatchSource.WIKI,docs/4.5/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/stats.html
https://qutip.org/docs/4.5/modules/qutip/control/stats.html:2858,Usability,simpl,simply,2858,"CT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_compute : float; Total wall (elasped) time computing combined forward propagation,; that is the time evolution from the start to a specific timeslot.; Excludes calculating the propagators themselves. wall_time_onwd_prop_compute : float; Total wall (elasped) time computing combined onward propagation,; th",MatchSource.WIKI,docs/4.5/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/stats.html
https://qutip.org/docs/4.5/modules/qutip/control/stats.html:5487,Usability,clear,clear,5487,"ity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update; """"""; def __init__(self):; self.reset(). def reset(self):; self.dyn_gen_name = ""dynamics generator""; self.clear(). def clear(self):; self.num_iter = 0; # Duration attributes; self.wall_time_optim_start = 0.0; self.wall_time_optim_end = 0.0; self.wall_time_optim = 0.0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; self.wall_time_gradient_compute = 0.0; # Fidelity and gradient function calls and computes; self.num_fidelity_func_calls = 0; self.num_grad_func_calls = 0; self.num_tslot_recompute = 0; self.num_fidelity_computes = 0; self.num_grad_computes = 0; # Control amplitudes; self.num_ctrl_amp_updates = 0; self.mean_num_ctrl_amp_updates_per_iter = 0.0; self.num_timeslot_changes = 0; self.mean_num_timeslot_changes_per_update = 0.0; self.num_ctrl_amp_changes = 0; self.mean_num_ctrl_amp_changes_per_update = 0.0. [docs] def calculate(self):; """"""; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report; """"""; # If the optimation is still ru",MatchSource.WIKI,docs/4.5/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/stats.html
https://qutip.org/docs/4.5/modules/qutip/control/stats.html:5500,Usability,clear,clear,5500,"nteger; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update; """"""; def __init__(self):; self.reset(). def reset(self):; self.dyn_gen_name = ""dynamics generator""; self.clear(). def clear(self):; self.num_iter = 0; # Duration attributes; self.wall_time_optim_start = 0.0; self.wall_time_optim_end = 0.0; self.wall_time_optim = 0.0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; self.wall_time_gradient_compute = 0.0; # Fidelity and gradient function calls and computes; self.num_fidelity_func_calls = 0; self.num_grad_func_calls = 0; self.num_tslot_recompute = 0; self.num_fidelity_computes = 0; self.num_grad_computes = 0; # Control amplitudes; self.num_ctrl_amp_updates = 0; self.mean_num_ctrl_amp_updates_per_iter = 0.0; self.num_timeslot_changes = 0; self.mean_num_timeslot_changes_per_update = 0.0; self.num_ctrl_amp_changes = 0; self.mean_num_ctrl_amp_changes_per_update = 0.0. [docs] def calculate(self):; """"""; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report; """"""; # If the optimation is still running then the o",MatchSource.WIKI,docs/4.5/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/stats.html
https://qutip.org/docs/4.5/modules/qutip/control/termcond.html:2798,Availability,error,error,2798,"ON) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes containing termination conditions for the control pulse optimisation; i.e. attributes that will be checked during the optimisation, that; will determine if the algorithm has completed its task / exceeded limits; """""". [docs]class TerminationConditions(object):; """"""; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes; ----------; fid_err_targ : float; Target fidelity error. fid_goal : float; goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time : float; # maximum time for optimisation (seconds). min_gradient_norm : float; Minimum normalised gradient after which optimisation will terminate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm; ; accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user; """"""; def __init__(self):; self.reset(). def reset(se",MatchSource.WIKI,docs/4.5/modules/qutip/control/termcond.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/termcond.html
https://qutip.org/docs/4.5/modules/qutip/control/termcond.html:4103,Deployability,update,updated,4103,"; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes containing termination conditions for the control pulse optimisation; i.e. attributes that will be checked during the optimisation, that; will determine if the algorithm has completed its task / exceeded limits; """""". [docs]class TerminationConditions(object):; """"""; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes; ----------; fid_err_targ : float; Target fidelity error. fid_goal : float; goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time : float; # maximum time for optimisation (seconds). min_gradient_norm : float; Minimum normalised gradient after which optimisation will terminate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm; ; accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user; """"""; def __init__(self):; self.reset(). def reset(self):; self.fid_err_targ = 1e-5; self.fid_goal = None; self.max_wall_time = 60*60.0; self.min_gradient_norm = 1e-5; self.max_iterations = 1e10; self.max_fid_func_calls = 1e10. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/control/termcond.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/termcond.html
https://qutip.org/docs/4.5/modules/qutip/control/termcond.html:3465,Performance,optimiz,optimize,3465,"; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes containing termination conditions for the control pulse optimisation; i.e. attributes that will be checked during the optimisation, that; will determine if the algorithm has completed its task / exceeded limits; """""". [docs]class TerminationConditions(object):; """"""; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes; ----------; fid_err_targ : float; Target fidelity error. fid_goal : float; goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time : float; # maximum time for optimisation (seconds). min_gradient_norm : float; Minimum normalised gradient after which optimisation will terminate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm; ; accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user; """"""; def __init__(self):; self.reset(). def reset(self):; self.fid_err_targ = 1e-5; self.fid_goal = None; self.max_wall_time = 60*60.0; self.min_gradient_norm = 1e-5; self.max_iterations = 1e10; self.max_fid_func_calls = 1e10. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/control/termcond.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/termcond.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:3638,Availability,error,errors,3638,"n using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP sett",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:3648,Availability,error,errors,3648,"n using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP sett",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:14220,Availability,mask,masks,14220,"inal; # evolution operator vals (which never change) and hence all other; # values are set as requiring calculation.; n_ts = self.parent.num_tslots; self.dyn_gen_recalc = np.ones(n_ts, dtype=bool); # np.ones(n_ts, dtype=bool); self.prop_recalc = np.ones(n_ts, dtype=bool); self.evo_init2t_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_init2t_recalc[0] = False; self.evo_t2targ_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_t2targ_recalc[-1] = False. # The _calc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will have changed Hamiltonians; i.e. any where control amplitudes have changed for that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find firs",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:20402,Availability,error,errors,20402,"w.sum(); dyn.stats.wall_time_onwd_prop_compute += \; timeit.default_timer() - time_start. # Clear calc now flags; self.dyn_gen_calc_now[:] = False; self.prop_calc_now[:] = False; self.evo_init2t_calc_now[:] = False; self.evo_t2targ_calc_now[:] = False. def get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value. Attempts to find a timeslot where the least number of propagator; calculations will be required.; Flags the associated evolution operators for calculation now; """"""; dyn = self.parent; n_ts = dyn.num_tslots; kBothEvoCurrent = -1; kFwdEvoCurrent = -1; kUse = -1; # If no specific timeslot set in config, then determine dynamically; if kUse < 0:; for k in range(n_ts):; # find first timeslot where both evo_init2t and; # evo_t2targ are current; if not self.evo_init2t_recalc[k]:; kFwdEvoCurrent = k; if not self.evo_t2targ_recalc[k]:; kBothEvoCurrent = k; break. if kBothEvoCurrent >= 0:; kUse = kBothEvoCurrent; elif kFwdEvoCurrent >= 0:; kUse = kFwdEvoCurrent; else:; raise errors.FunctionalError(""No timeslot found matching ""; ""criteria""). self.evo_init2t_calc_now[kUse] = True; self.evo_t2targ_calc_now[kUse] = True; return kUse. class EvoCompSummary(qtrldump.DumpSummaryItem):; """"""; A summary of the most recent time evolution computation; Used in stats calculations and for data dumping; ; Attributes; ----------; evo_dump_idx : int; Index of the linked :class:`dump.EvoCompDumpItem`; None if no linked item; ; iter_num : int; Iteration number of the pulse optimisation; None if evolution compute outside of a pulse optimisation; ; fid_func_call_num : int; Fidelity function call number of the pulse optimisation; None if evolution compute outside of a pulse optimisation; ; grad_func_call_num : int; Gradient function call number of the pulse optimisation; None if evolution compute outside of a pulse optimisation; ; num_amps_changed : int; Number of control timeslot amplitudes changed since previous; evolution ca",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:2424,Deployability,update,update,2424,"INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Timeslot Computer; These classes determine which dynamics generators, propagators and evolutions; are recalculated when there is a control amplitude update.; The timeslot computer processes the lists held by the dynamics object. The default (UpdateAll) updates all of these each amp update, on the; assumption that all amplitudes are changed each iteration. This is typical; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods ",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:2528,Deployability,update,updates,2528,"NDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Timeslot Computer; These classes determine which dynamics generators, propagators and evolutions; are recalculated when there is a control amplitude update.; The timeslot computer processes the lists held by the dynamics object. The default (UpdateAll) updates all of these each amp update, on the; assumption that all amplitudes are changed each iteration. This is typical; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from ",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:2558,Deployability,update,update,2558,"NDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Timeslot Computer; These classes determine which dynamics generators, propagators and evolutions; are recalculated when there is a control amplitude update.; The timeslot computer processes the lists held by the dynamics object. The default (UpdateAll) updates all of these each amp update, on the; assumption that all amplitudes are changed each iteration. This is typical; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from ",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:2790,Deployability,update,updated,2790,"; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Timeslot Computer; These classes determine which dynamics generators, propagators and evolutions; are recalculated when there is a control amplitude update.; The timeslot computer processes the lists held by the dynamics object. The default (UpdateAll) updates all of these each amp update, on the; assumption that all amplitudes are changed each iteration. This is typical; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecatio",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:3189,Deployability,update,update,3189,"organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Timeslot Computer; These classes determine which dynamics generators, propagators and evolutions; are recalculated when there is a control amplitude update.; The timeslot computer processes the lists held by the dynamics object. The default (UpdateAll) updates all of these each amp update, on the; assumption that all amplitudes are changed each iteration. This is typical; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for t",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:6819,Deployability,update,updated,6819,"def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""); ; anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True; ; if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True; ; if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""); . [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # True where value in new_amps differs, otherwise false; changed_amps = dyn.ctrl_amps != new_amps; if np.any(changed_amps):; # Flag fidelity and gr",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:8113,Deployability,update,update,8113,"they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # True where value in new_amps differs, otherwise false; changed_amps = dyn.ctrl_amps != new_amps; if np.any(changed_amps):; # Flag fidelity and gradients as needing recalculation; changed = True; if self.log_level <= logging.DEBUG:; logger.debug(""{} amplitudes changed"".format(; changed_amps.sum())); ; if ecs:; ecs.num_amps_changed = changed_amps.sum(); ecs.num_timeslots_changed = np.any(changed_amps, 1).sum(). else:; if self.log_level <= logging.DEBUG:; logger.debug(""No amplitudes changed""). # *** update stats ***; if dyn.stats:; dyn.stats.num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_r",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:12627,Deployability,update,updated,12627,"itarity_check_level:; dyn.check_unitarity(); ; if dyn.dump:; self.dump_current(). [docs] def get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; _func_deprecation(""'get_timeslot_for_fidelity_calc' is deprecated. ""; ""Use '_get_timeslot_for_fidelity_calc'""); return self._get_timeslot_for_fidelity_calc. def _get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; return self.parent.num_tslots. class TSlotCompDynUpdate(TimeslotComputer):; """"""; Timeslot Computer - Dynamic Update; ********************************; ***** CURRENTLY HAS ISSUES *****; ***** AJGP 2014-10-02; ***** and is therefore not being maintained; ***** i.e. changes made to _UpdateAll are not being implemented here; ********************************; Updates only the dynamics generators, propagators and evolutions as; required when a subset of the ctrl amplitudes are updated.; Will update all if all amps have changed.; """""". def reset(self):; self.dyn_gen_recalc = None; self.prop_recalc = None; self.evo_init2t_recalc = None; self.evo_t2targ_recalc = None; self.dyn_gen_calc_now = None; self.prop_calc_now = None; self.evo_init2t_calc_now = None; self.evo_t2targ_calc_now = None; TimeslotComputer.reset(self); self.id_text = 'DYNAMIC'; self.apply_params(). def init_comp(self):; """"""; Initialise the flags; """"""; ####; # These maps are used to determine what needs to be updated; ####; # Note _recalc means the value needs updating at some point; # e.g. here no values have been set, except the initial and final; # evolution operator vals (which never change) and hence all other; # values are set as requiring calculation.; n_ts = self.parent.num_tslots; self.dyn_gen_recalc = np.ones(n_ts, dtype=bool); # np.ones(n_ts, dtype=bool); self.prop_recalc = np.ones(n_ts",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:12642,Deployability,update,update,12642,"""""""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; _func_deprecation(""'get_timeslot_for_fidelity_calc' is deprecated. ""; ""Use '_get_timeslot_for_fidelity_calc'""); return self._get_timeslot_for_fidelity_calc. def _get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; return self.parent.num_tslots. class TSlotCompDynUpdate(TimeslotComputer):; """"""; Timeslot Computer - Dynamic Update; ********************************; ***** CURRENTLY HAS ISSUES *****; ***** AJGP 2014-10-02; ***** and is therefore not being maintained; ***** i.e. changes made to _UpdateAll are not being implemented here; ********************************; Updates only the dynamics generators, propagators and evolutions as; required when a subset of the ctrl amplitudes are updated.; Will update all if all amps have changed.; """""". def reset(self):; self.dyn_gen_recalc = None; self.prop_recalc = None; self.evo_init2t_recalc = None; self.evo_t2targ_recalc = None; self.dyn_gen_calc_now = None; self.prop_calc_now = None; self.evo_init2t_calc_now = None; self.evo_t2targ_calc_now = None; TimeslotComputer.reset(self); self.id_text = 'DYNAMIC'; self.apply_params(). def init_comp(self):; """"""; Initialise the flags; """"""; ####; # These maps are used to determine what needs to be updated; ####; # Note _recalc means the value needs updating at some point; # e.g. here no values have been set, except the initial and final; # evolution operator vals (which never change) and hence all other; # values are set as requiring calculation.; n_ts = self.parent.num_tslots; self.dyn_gen_recalc = np.ones(n_ts, dtype=bool); # np.ones(n_ts, dtype=bool); self.prop_recalc = np.ones(n_ts, dtype=bool); self.evo_init2t_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_init2t_recalc[0] = False; self.evo_t2targ_recalc = n",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:13130,Deployability,update,updated,13130,"imply returns the last timeslot; """"""; return self.parent.num_tslots. class TSlotCompDynUpdate(TimeslotComputer):; """"""; Timeslot Computer - Dynamic Update; ********************************; ***** CURRENTLY HAS ISSUES *****; ***** AJGP 2014-10-02; ***** and is therefore not being maintained; ***** i.e. changes made to _UpdateAll are not being implemented here; ********************************; Updates only the dynamics generators, propagators and evolutions as; required when a subset of the ctrl amplitudes are updated.; Will update all if all amps have changed.; """""". def reset(self):; self.dyn_gen_recalc = None; self.prop_recalc = None; self.evo_init2t_recalc = None; self.evo_t2targ_recalc = None; self.dyn_gen_calc_now = None; self.prop_calc_now = None; self.evo_init2t_calc_now = None; self.evo_t2targ_calc_now = None; TimeslotComputer.reset(self); self.id_text = 'DYNAMIC'; self.apply_params(). def init_comp(self):; """"""; Initialise the flags; """"""; ####; # These maps are used to determine what needs to be updated; ####; # Note _recalc means the value needs updating at some point; # e.g. here no values have been set, except the initial and final; # evolution operator vals (which never change) and hence all other; # values are set as requiring calculation.; n_ts = self.parent.num_tslots; self.dyn_gen_recalc = np.ones(n_ts, dtype=bool); # np.ones(n_ts, dtype=bool); self.prop_recalc = np.ones(n_ts, dtype=bool); self.evo_init2t_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_init2t_recalc[0] = False; self.evo_t2targ_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_t2targ_recalc[-1] = False. # The _calc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:14294,Deployability,update,update,14294,"inal; # evolution operator vals (which never change) and hence all other; # values are set as requiring calculation.; n_ts = self.parent.num_tslots; self.dyn_gen_recalc = np.ones(n_ts, dtype=bool); # np.ones(n_ts, dtype=bool); self.prop_recalc = np.ones(n_ts, dtype=bool); self.evo_init2t_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_init2t_recalc[0] = False; self.evo_t2targ_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_t2targ_recalc[-1] = False. # The _calc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will have changed Hamiltonians; i.e. any where control amplitudes have changed for that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find firs",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:15245,Deployability,update,updated,15245," are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalcula",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:15772,Deployability,update,update,15772,"changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalculates the evo_init2t (forward) and evo_t2targ (onward) time; evolution operators; DynGen (Hamiltonians etc) and prop (propagator) are calculated; as necessary; """"""; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""recomputing evolution ""; ""(DynUpdate)""). dyn = self.parent; n_ts = dyn.num_tslots; # find the op slots that have been marked for update now; # and need recalculation; evo_init2t_recomp_now = self.evo_init2t_ca",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:16701,Deployability,update,update,16701,"adients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalculates the evo_init2t (forward) and evo_t2targ (onward) time; evolution operators; DynGen (Hamiltonians etc) and prop (propagator) are calculated; as necessary; """"""; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""recomputing evolution ""; ""(DynUpdate)""). dyn = self.parent; n_ts = dyn.num_tslots; # find the op slots that have been marked for update now; # and need recalculation; evo_init2t_recomp_now = self.evo_init2t_calc_now & \; self.evo_init2t_recalc; evo_t2targ_recomp_now = self.evo_t2targ_calc_now & \; self.evo_t2targ_recalc. # to recomupte evo_init2t, will need to start; # at a cell that has been computed; if np.any(evo_init2t_recomp_now):; for k in range(n_ts, 0, -1):; if evo_init2t_recomp_now[k] and self.evo_init2t_recalc[k-1]:; evo_init2t_recomp_now[k-1] = True. # for evo_t2targ, will also need to start; # at a cell that has been computed; if np.any(evo_t2targ_recomp_now):; for k in range(0, n_ts):; if evo_t2targ_recomp_now[k] and self.evo_t2targ_recalc[k+1]:; evo_t2targ_recomp_now[k+1] = True. # determine which dyn gen and prop need recalculating now in order to; # calculate the forwrd and onward evolutions; prop_recomp_now = (evo_init2t_recomp_now[1:]; | evo_t2targ_recomp_now[:-1]; | self.prop_calc_now[:]) & self.prop_recalc[:]; dyn_gen_recomp_now = (prop_recomp_now[:] | self.dyn_gen_calc_now[:]) \; & self.dyn_gen_r",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:23134,Deployability,update,updated,23134," of a pulse optimisation; ; num_amps_changed : int; Number of control timeslot amplitudes changed since previous; evolution calculation; ; num_timeslots_changed : int; Number of timeslots in which any amplitudes changed since previous; evolution calculation; ; wall_time_dyn_gen_compute : float; Time spent computing dynamics generators; (in seconds of elapsed time); ; wall_time_prop_compute : float; Time spent computing propagators (including and propagator gradients); (in seconds of elapsed time); ; wall_time_fwd_prop_compute : float; Time spent computing the forward evolution of the system; see :property:`dynamics.fwd_evo` ; (in seconds of elapsed time); ; wall_time_onwd_prop_compute : float; Time spent computing the 'backward' evolution of the system; see :property:`dynamics.onwd_evo` and :property:`dynamics.onto_evo`; (in seconds of elapsed time); """"""; ; min_col_width = 11; summary_property_names = (; ""idx"", ""evo_dump_idx"", ; ""iter_num"", ""fid_func_call_num"", ""grad_func_call_num"",; ""num_amps_changed"", ""num_timeslots_changed"",; ""wall_time_dyn_gen_compute"", ""wall_time_prop_compute"",; ""wall_time_fwd_prop_compute"", ""wall_time_onwd_prop_compute""); ; summary_property_fmt_type = (; 'd', 'd',; 'd', 'd', 'd',; 'd', 'd',; 'g', 'g', ; 'g', 'g'; ); ; summary_property_fmt_prec = (; 0, 0, ; 0, 0, 0,; 0, 0, ; 3, 3,; 3, 3; ); ; def __init__(self):; self.reset(); ; def reset(self):; qtrldump.DumpSummaryItem.reset(self); self.evo_dump_idx = None; self.iter_num = None; self.fid_func_call_num = None; self.grad_func_call_num = None; self.num_amps_changed = 0; self.num_timeslots_changed = 0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:3804,Integrability,message,message,3804,"cordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set; """"""; def __init_",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:3892,Integrability,message,message,3892,"cordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set; """"""; def __init_",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:3980,Integrability,message,message,3980,"or stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set; """"""; def __init__(self, dynamics, params=None):; from qutip.control.dynamics import Dynamics; if not isinstance(dynamics, Dynamics):; raise Ty",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:6633,Modifiability,config,config,6633,"if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""); ; anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True; ; if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True; ; if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""); . [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # Tru",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:20023,Modifiability,config,config,20023,"mer(); # compute the onward propagation; R = range(n_ts-1, -1, -1); for k in R:; if evo_t2targ_recomp_now[k]:; dyn.evo_t2targ[k] = dyn.evo_t2targ[k+1].dot(dyn.prop[k]); self.evo_t2targ_recalc[k] = False; if dyn.stats is not None:; dyn.stats.num_onwd_prop_step_computes += \; evo_t2targ_recomp_now.sum(); dyn.stats.wall_time_onwd_prop_compute += \; timeit.default_timer() - time_start. # Clear calc now flags; self.dyn_gen_calc_now[:] = False; self.prop_calc_now[:] = False; self.evo_init2t_calc_now[:] = False; self.evo_t2targ_calc_now[:] = False. def get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value. Attempts to find a timeslot where the least number of propagator; calculations will be required.; Flags the associated evolution operators for calculation now; """"""; dyn = self.parent; n_ts = dyn.num_tslots; kBothEvoCurrent = -1; kFwdEvoCurrent = -1; kUse = -1; # If no specific timeslot set in config, then determine dynamically; if kUse < 0:; for k in range(n_ts):; # find first timeslot where both evo_init2t and; # evo_t2targ are current; if not self.evo_init2t_recalc[k]:; kFwdEvoCurrent = k; if not self.evo_t2targ_recalc[k]:; kBothEvoCurrent = k; break. if kBothEvoCurrent >= 0:; kUse = kBothEvoCurrent; elif kFwdEvoCurrent >= 0:; kUse = kFwdEvoCurrent; else:; raise errors.FunctionalError(""No timeslot found matching ""; ""criteria""). self.evo_init2t_calc_now[kUse] = True; self.evo_t2targ_calc_now[kUse] = True; return kUse. class EvoCompSummary(qtrldump.DumpSummaryItem):; """"""; A summary of the most recent time evolution computation; Used in stats calculations and for data dumping; ; Attributes; ----------; evo_dump_idx : int; Index of the linked :class:`dump.EvoCompDumpItem`; None if no linked item; ; iter_num : int; Iteration number of the pulse optimisation; None if evolution compute outside of a pulse optimisation; ; fid_func_call_num : int; Fidelity function call number of the pulse optimisation; None if ",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:8772,Security,access,access,8772,"ity and gradients as needing recalculation; changed = True; if self.log_level <= logging.DEBUG:; logger.debug(""{} amplitudes changed"".format(; changed_amps.sum())); ; if ecs:; ecs.num_amps_changed = changed_amps.sum(); ecs.num_timeslots_changed = np.any(changed_amps, 1).sum(). else:; if self.log_level <= logging.DEBUG:; logger.debug(""No amplitudes changed""). # *** update stats ***; if dyn.stats:; dyn.stats.num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:3703,Testability,log,logging,3703,"APE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:3742,Testability,log,logging,3742,"sumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the mo",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:3751,Testability,log,logger,3751,"sumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the mo",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:3760,Testability,log,logging,3760,"sumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the mo",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:4317,Testability,log,logger,4317," and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set; """"""; def __init__(self, dynamics, params=None):; from qutip.control.dynamics import Dynamics; if not isinstance(dynamics, Dynamics):; raise TypeError(""Must instantiate with {} type"".format(; Dynamics)); self.parent = dynamics; self.params = params; self.reset(). def reset(self):; self.log_level = self.parent.log_level; self.id_text = 'TS_COMP_BASE'; self.evo_comp_summary = None. [docs] def apply_params(self, params",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:5860,Testability,log,logger,5860,"s or dump are set; """"""; def __init__(self, dynamics, params=None):; from qutip.control.dynamics import Dynamics; if not isinstance(dynamics, Dynamics):; raise TypeError(""Must instantiate with {} type"".format(; Dynamics)); self.parent = dynamics; self.params = params; self.reset(). def reset(self):; self.log_level = self.parent.log_level; self.id_text = 'TS_COMP_BASE'; self.evo_comp_summary = None. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""); ; anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True; ; if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True; ; if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""); . [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:5978,Testability,log,logger,5978," Dynamics; if not isinstance(dynamics, Dynamics):; raise TypeError(""Must instantiate with {} type"".format(; Dynamics)); self.parent = dynamics; self.params = params; self.reset(). def reset(self):; self.log_level = self.parent.log_level; self.id_text = 'TS_COMP_BASE'; self.evo_comp_summary = None. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""); ; anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True; ; if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True; ; if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""); . [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amp",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:5999,Testability,log,logger,5999," Dynamics; if not isinstance(dynamics, Dynamics):; raise TypeError(""Must instantiate with {} type"".format(; Dynamics)); self.parent = dynamics; self.params = params; self.reset(). def reset(self):; self.log_level = self.parent.log_level; self.id_text = 'TS_COMP_BASE'; self.evo_comp_summary = None. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""); ; anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True; ; if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True; ; if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""); . [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amp",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:6026,Testability,log,logger,6026,"nstantiate with {} type"".format(; Dynamics)); self.parent = dynamics; self.params = params; self.reset(). def reset(self):; self.log_level = self.parent.log_level; self.id_text = 'TS_COMP_BASE'; self.evo_comp_summary = None. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""); ; anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True; ; if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True; ; if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""); . [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, ",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:6576,Testability,log,logger,6576," are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""); ; anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True; ; if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True; ; if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""); . [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = n",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:7827,Testability,log,logging,7827,"ed; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # True where value in new_amps differs, otherwise false; changed_amps = dyn.ctrl_amps != new_amps; if np.any(changed_amps):; # Flag fidelity and gradients as needing recalculation; changed = True; if self.log_level <= logging.DEBUG:; logger.debug(""{} amplitudes changed"".format(; changed_amps.sum())); ; if ecs:; ecs.num_amps_changed = changed_amps.sum(); ecs.num_timeslots_changed = np.any(changed_amps, 1).sum(). else:; if self.log_level <= logging.DEBUG:; logger.debug(""No amplitudes changed""). # *** update stats ***; if dyn.stats:; dyn.stats.num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:7843,Testability,log,logger,7843,"(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # True where value in new_amps differs, otherwise false; changed_amps = dyn.ctrl_amps != new_amps; if np.any(changed_amps):; # Flag fidelity and gradients as needing recalculation; changed = True; if self.log_level <= logging.DEBUG:; logger.debug(""{} amplitudes changed"".format(; changed_amps.sum())); ; if ecs:; ecs.num_amps_changed = changed_amps.sum(); ecs.num_timeslots_changed = np.any(changed_amps, 1).sum(). else:; if self.log_level <= logging.DEBUG:; logger.debug(""No amplitudes changed""). # *** update stats ***; if dyn.stats:; dyn.stats.num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:8052,Testability,log,logging,8052,"eeding recalculation; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # True where value in new_amps differs, otherwise false; changed_amps = dyn.ctrl_amps != new_amps; if np.any(changed_amps):; # Flag fidelity and gradients as needing recalculation; changed = True; if self.log_level <= logging.DEBUG:; logger.debug(""{} amplitudes changed"".format(; changed_amps.sum())); ; if ecs:; ecs.num_amps_changed = changed_amps.sum(); ecs.num_timeslots_changed = np.any(changed_amps, 1).sum(). else:; if self.log_level <= logging.DEBUG:; logger.debug(""No amplitudes changed""). # *** update stats ***; if dyn.stats:; dyn.stats.num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs =",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:8068,Testability,log,logger,8068,"on; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # True where value in new_amps differs, otherwise false; changed_amps = dyn.ctrl_amps != new_amps; if np.any(changed_amps):; # Flag fidelity and gradients as needing recalculation; changed = True; if self.log_level <= logging.DEBUG:; logger.debug(""{} amplitudes changed"".format(; changed_amps.sum())); ; if ecs:; ecs.num_amps_changed = changed_amps.sum(); ecs.num_timeslots_changed = np.any(changed_amps, 1).sum(). else:; if self.log_level <= logging.DEBUG:; logger.debug(""No amplitudes changed""). # *** update stats ***; if dyn.stats:; dyn.stats.num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_sum",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:9158,Testability,log,logging,9158,".num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:9174,Testability,log,logger,9174,"tes += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop_compute = \; time",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:9181,Testability,log,log,9181,"s.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop_compute = \; timeit.default_ti",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:9185,Testability,log,logging,9185,"s.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop_compute = \; timeit.default_ti",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:9865,Testability,log,logging,9865,"dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop_compute = \; timeit.default_timer() - time_start. if ecs: time_start = timeit.default_timer(); # compute the forward propagation; R = range(n_ts); for k in R:; if dyn.oper_dtype == Qobj:; dyn._fwd_evo[k+1] = dyn._prop[k]*dyn._fwd_evo[k]; else:; dyn._fwd_evo[k+1] = dyn._prop[k].dot(dyn._fwd_evo[k]). if ecs:; ecs.wall_time_fwd_prop_compute = \; timeit.default_timer() - time_start; time_start = timeit.default_timer(); # compute the onward propagation; if dyn.fid_computer.uses_onwd_evo:; dyn._onwd_evo[n_ts-1] = dyn._prop[n_ts-1]; R = range(n_ts-2, -1, -1); for k in R:; if dyn.oper_dtype == Qobj:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1]*dyn._prop[k]; else:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1].dot(dyn._",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:9889,Testability,log,logger,9889,"ne; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop_compute = \; timeit.default_timer() - time_start. if ecs: time_start = timeit.default_timer(); # compute the forward propagation; R = range(n_ts); for k in R:; if dyn.oper_dtype == Qobj:; dyn._fwd_evo[k+1] = dyn._prop[k]*dyn._fwd_evo[k]; else:; dyn._fwd_evo[k+1] = dyn._prop[k].dot(dyn._fwd_evo[k]). if ecs:; ecs.wall_time_fwd_prop_compute = \; timeit.default_timer() - time_start; time_start = timeit.default_timer(); # compute the onward propagation; if dyn.fid_computer.uses_onwd_evo:; dyn._onwd_evo[n_ts-1] = dyn._prop[n_ts-1]; R = range(n_ts-2, -1, -1); for k in R:; if dyn.oper_dtype == Qobj:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1]*dyn._prop[k]; else:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1].dot(dyn._prop[k]). if dyn.fid_c",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:9896,Testability,log,log,9896,"qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop_compute = \; timeit.default_timer() - time_start. if ecs: time_start = timeit.default_timer(); # compute the forward propagation; R = range(n_ts); for k in R:; if dyn.oper_dtype == Qobj:; dyn._fwd_evo[k+1] = dyn._prop[k]*dyn._fwd_evo[k]; else:; dyn._fwd_evo[k+1] = dyn._prop[k].dot(dyn._fwd_evo[k]). if ecs:; ecs.wall_time_fwd_prop_compute = \; timeit.default_timer() - time_start; time_start = timeit.default_timer(); # compute the onward propagation; if dyn.fid_computer.uses_onwd_evo:; dyn._onwd_evo[n_ts-1] = dyn._prop[n_ts-1]; R = range(n_ts-2, -1, -1); for k in R:; if dyn.oper_dtype == Qobj:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1]*dyn._prop[k]; else:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1].dot(dyn._prop[k]). if dyn.fid_computer.uses_onto",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:9900,Testability,log,logging,9900,"qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop_compute = \; timeit.default_timer() - time_start. if ecs: time_start = timeit.default_timer(); # compute the forward propagation; R = range(n_ts); for k in R:; if dyn.oper_dtype == Qobj:; dyn._fwd_evo[k+1] = dyn._prop[k]*dyn._fwd_evo[k]; else:; dyn._fwd_evo[k+1] = dyn._prop[k].dot(dyn._fwd_evo[k]). if ecs:; ecs.wall_time_fwd_prop_compute = \; timeit.default_timer() - time_start; time_start = timeit.default_timer(); # compute the onward propagation; if dyn.fid_computer.uses_onwd_evo:; dyn._onwd_evo[n_ts-1] = dyn._prop[n_ts-1]; R = range(n_ts-2, -1, -1); for k in R:; if dyn.oper_dtype == Qobj:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1]*dyn._prop[k]; else:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1].dot(dyn._prop[k]). if dyn.fid_computer.uses_onto",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:14694,Testability,log,logging,14694,".evo_t2targ_recalc[-1] = False. # The _calc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will have changed Hamiltonians; i.e. any where control amplitudes have changed for that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fi",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:14718,Testability,log,logger,14718," = False. # The _calc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will have changed Hamiltonians; i.e. any where control amplitudes have changed for that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients a",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:14725,Testability,log,log,14725,"alc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will have changed Hamiltonians; i.e. any where control amplitudes have changed for that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalcu",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:14729,Testability,log,logging,14729,"alc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will have changed Hamiltonians; i.e. any where control amplitudes have changed for that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalcu",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:15196,Testability,log,logging,15196,"that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_n",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:15212,Testability,log,logger,15212,"k (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:16513,Testability,log,logging,16513,".evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalculates the evo_init2t (forward) and evo_t2targ (onward) time; evolution operators; DynGen (Hamiltonians etc) and prop (propagator) are calculated; as necessary; """"""; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""recomputing evolution ""; ""(DynUpdate)""). dyn = self.parent; n_ts = dyn.num_tslots; # find the op slots that have been marked for update now; # and need recalculation; evo_init2t_recomp_now = self.evo_init2t_calc_now & \; self.evo_init2t_recalc; evo_t2targ_recomp_now = self.evo_t2targ_calc_now & \; self.evo_t2targ_recalc. # to recomupte evo_init2t, will need to start; # at a cell that has been computed; if np.any(evo_init2t_recomp_now):; for k in range(n_ts, 0, -1):; if evo_init2t_recomp_now[k] and self.evo_init2t_recalc[k-1]:; evo_init2t_recomp_now[k-1] = True. # for evo_t2targ, will also need to start; # at a cell that has been computed; if np.any(evo_t2targ_recomp_now):; for k in range(0, n_ts):; if evo_t2targ_recomp_now[k] and self.evo_t2targ_recalc[k+1]:; evo_t2targ_recomp_now[k+1] = True. # determine which dyn gen and prop need recalculating now in order to; # calculate the forwrd and onward evolutions; prop_recomp_now =",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:16537,Testability,log,logger,16537,"st_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalculates the evo_init2t (forward) and evo_t2targ (onward) time; evolution operators; DynGen (Hamiltonians etc) and prop (propagator) are calculated; as necessary; """"""; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""recomputing evolution ""; ""(DynUpdate)""). dyn = self.parent; n_ts = dyn.num_tslots; # find the op slots that have been marked for update now; # and need recalculation; evo_init2t_recomp_now = self.evo_init2t_calc_now & \; self.evo_init2t_recalc; evo_t2targ_recomp_now = self.evo_t2targ_calc_now & \; self.evo_t2targ_recalc. # to recomupte evo_init2t, will need to start; # at a cell that has been computed; if np.any(evo_init2t_recomp_now):; for k in range(n_ts, 0, -1):; if evo_init2t_recomp_now[k] and self.evo_init2t_recalc[k-1]:; evo_init2t_recomp_now[k-1] = True. # for evo_t2targ, will also need to start; # at a cell that has been computed; if np.any(evo_t2targ_recomp_now):; for k in range(0, n_ts):; if evo_t2targ_recomp_now[k] and self.evo_t2targ_recalc[k+1]:; evo_t2targ_recomp_now[k+1] = True. # determine which dyn gen and prop need recalculating now in order to; # calculate the forwrd and onward evolutions; prop_recomp_now = (evo_init2t_recomp_no",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:16544,Testability,log,log,16544," True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalculates the evo_init2t (forward) and evo_t2targ (onward) time; evolution operators; DynGen (Hamiltonians etc) and prop (propagator) are calculated; as necessary; """"""; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""recomputing evolution ""; ""(DynUpdate)""). dyn = self.parent; n_ts = dyn.num_tslots; # find the op slots that have been marked for update now; # and need recalculation; evo_init2t_recomp_now = self.evo_init2t_calc_now & \; self.evo_init2t_recalc; evo_t2targ_recomp_now = self.evo_t2targ_calc_now & \; self.evo_t2targ_recalc. # to recomupte evo_init2t, will need to start; # at a cell that has been computed; if np.any(evo_init2t_recomp_now):; for k in range(n_ts, 0, -1):; if evo_init2t_recomp_now[k] and self.evo_init2t_recalc[k-1]:; evo_init2t_recomp_now[k-1] = True. # for evo_t2targ, will also need to start; # at a cell that has been computed; if np.any(evo_t2targ_recomp_now):; for k in range(0, n_ts):; if evo_t2targ_recomp_now[k] and self.evo_t2targ_recalc[k+1]:; evo_t2targ_recomp_now[k+1] = True. # determine which dyn gen and prop need recalculating now in order to; # calculate the forwrd and onward evolutions; prop_recomp_now = (evo_init2t_recomp_now[1:]; | evo_t2ta",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:16548,Testability,log,logging,16548," True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalculates the evo_init2t (forward) and evo_t2targ (onward) time; evolution operators; DynGen (Hamiltonians etc) and prop (propagator) are calculated; as necessary; """"""; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""recomputing evolution ""; ""(DynUpdate)""). dyn = self.parent; n_ts = dyn.num_tslots; # find the op slots that have been marked for update now; # and need recalculation; evo_init2t_recomp_now = self.evo_init2t_calc_now & \; self.evo_init2t_recalc; evo_t2targ_recomp_now = self.evo_t2targ_calc_now & \; self.evo_t2targ_recalc. # to recomupte evo_init2t, will need to start; # at a cell that has been computed; if np.any(evo_init2t_recomp_now):; for k in range(n_ts, 0, -1):; if evo_init2t_recomp_now[k] and self.evo_init2t_recalc[k-1]:; evo_init2t_recomp_now[k-1] = True. # for evo_t2targ, will also need to start; # at a cell that has been computed; if np.any(evo_t2targ_recomp_now):; for k in range(0, n_ts):; if evo_t2targ_recomp_now[k] and self.evo_t2targ_recalc[k+1]:; evo_t2targ_recomp_now[k+1] = True. # determine which dyn gen and prop need recalculating now in order to; # calculate the forwrd and onward evolutions; prop_recomp_now = (evo_init2t_recomp_now[1:]; | evo_t2ta",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:11764,Usability,simpl,simply,11764,"[k]; else:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1].dot(dyn._prop[k]). if dyn.fid_computer.uses_onto_evo:; #R = range(n_ts-1, -1, -1); R = range(n_ts-1, -1, -1); for k in R:; if dyn.oper_dtype == Qobj:; dyn._onto_evo[k] = dyn._onto_evo[k+1]*dyn._prop[k]; else:; dyn._onto_evo[k] = dyn._onto_evo[k+1].dot(dyn._prop[k]). if ecs:; ecs.wall_time_onwd_prop_compute = \; timeit.default_timer() - time_start; ; if dyn.stats:; dyn.stats.wall_time_dyn_gen_compute += \; ecs.wall_time_dyn_gen_compute; dyn.stats.wall_time_prop_compute += \; ecs.wall_time_prop_compute; dyn.stats.wall_time_fwd_prop_compute += \; ecs.wall_time_fwd_prop_compute; dyn.stats.wall_time_onwd_prop_compute += \; ecs.wall_time_onwd_prop_compute; ; if dyn.unitarity_check_level:; dyn.check_unitarity(); ; if dyn.dump:; self.dump_current(). [docs] def get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; _func_deprecation(""'get_timeslot_for_fidelity_calc' is deprecated. ""; ""Use '_get_timeslot_for_fidelity_calc'""); return self._get_timeslot_for_fidelity_calc. def _get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; return self.parent.num_tslots. class TSlotCompDynUpdate(TimeslotComputer):; """"""; Timeslot Computer - Dynamic Update; ********************************; ***** CURRENTLY HAS ISSUES *****; ***** AJGP 2014-10-02; ***** and is therefore not being maintained; ***** i.e. changes made to _UpdateAll are not being implemented here; ********************************; Updates only the dynamics generators, propagators and evolutions as; required when a subset of the ctrl amplitudes are updated.; Will update all if all amps have changed.; """""". def reset(self):; self.dyn_gen_recalc = None; self.prop_recalc = None; self.evo_init2t_recalc = None; self.evo_t2targ_re",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:12112,Usability,simpl,simply,12112,"cs:; ecs.wall_time_onwd_prop_compute = \; timeit.default_timer() - time_start; ; if dyn.stats:; dyn.stats.wall_time_dyn_gen_compute += \; ecs.wall_time_dyn_gen_compute; dyn.stats.wall_time_prop_compute += \; ecs.wall_time_prop_compute; dyn.stats.wall_time_fwd_prop_compute += \; ecs.wall_time_fwd_prop_compute; dyn.stats.wall_time_onwd_prop_compute += \; ecs.wall_time_onwd_prop_compute; ; if dyn.unitarity_check_level:; dyn.check_unitarity(); ; if dyn.dump:; self.dump_current(). [docs] def get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; _func_deprecation(""'get_timeslot_for_fidelity_calc' is deprecated. ""; ""Use '_get_timeslot_for_fidelity_calc'""); return self._get_timeslot_for_fidelity_calc. def _get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; return self.parent.num_tslots. class TSlotCompDynUpdate(TimeslotComputer):; """"""; Timeslot Computer - Dynamic Update; ********************************; ***** CURRENTLY HAS ISSUES *****; ***** AJGP 2014-10-02; ***** and is therefore not being maintained; ***** i.e. changes made to _UpdateAll are not being implemented here; ********************************; Updates only the dynamics generators, propagators and evolutions as; required when a subset of the ctrl amplitudes are updated.; Will update all if all amps have changed.; """""". def reset(self):; self.dyn_gen_recalc = None; self.prop_recalc = None; self.evo_init2t_recalc = None; self.evo_t2targ_recalc = None; self.dyn_gen_calc_now = None; self.prop_calc_now = None; self.evo_init2t_calc_now = None; self.evo_t2targ_calc_now = None; TimeslotComputer.reset(self); self.id_text = 'DYNAMIC'; self.apply_params(). def init_comp(self):; """"""; Initialise the flags; """"""; ####; # These maps are used to determine what needs to",MatchSource.WIKI,docs/4.5/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:2466,Deployability,integrat,integrate,2466," ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides exact solvers for a system-bath setup using the; hierarchy equations of motion (HEOM).; """""". # Authors: Neill Lambert, Anubhav Vardhan, Alexander Pitchford; # Contact: nwlambert@gmail.com. import timeit; import numpy as np; #from scipy.special import factorial; import scipy.sparse as sp; import scipy.integrate; from copy import copy; from qutip import Qobj, qeye; from qutip.states import enr_state_dictionaries; from qutip.superoperator import liouvillian, spre, spost; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.solver import Options, Result, Stats; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.heom import cy_pad_csr; from qutip.cy.spmath import zcsr_kron; from qutip.fastsparse import fast_csr_matrix, fast_identity. [docs]class HEOMSolver(object):; """"""; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentia",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:7402,Deployability,integrat,integrate,7402,"ar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections; config; integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return stats. [docs]class HSolverDL(HEOMSolver):; """"""; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; re",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:13400,Deployability,integrat,integrate,13400," L_he; N_he_interact += 1. he_state_neigh[k] = n_k. if n_excite <= N_c - 1:; # find the hierarchy element index of the neighbour after; # this element, for this Matsubara term; he_state_neigh[k] = n_k + 1; he_idx_neigh = he2idx[tuple(he_state_neigh)]. op = commQ; if renorm:; op = -1j*norm_plus[n_k, k]*op; else:; op = -1j*op. L_he = cy_pad_csr(op, N_he, N_he, he_idx, he_idx_neigh); L_helems += L_he; N_he_interact += 1. he_state_neigh[k] = n_k. if stats:; stats.add_timing('hierarchy contruct',; timeit.default_timer() - start_helem_constr,; ss_conf); stats.add_count('Num hierarchy elements', N_he, ss_conf); stats.add_count('Num he interactions', N_he_interact, ss_conf). # Setup Liouvillian; if stats:; start_louvillian = timeit.default_timer(). H_he = zcsr_kron(unit_helems, liouvillian(H_sys).data). L_helems += H_he. if stats:; stats.add_timing('Liouvillian contruct',; timeit.default_timer() - start_louvillian,; ss_conf). if stats: start_integ_conf = timeit.default_timer(). r = scipy.integrate.ode(cy_ode_rhs). r.set_f_params(L_helems.data, L_helems.indices, L_helems.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step). if stats:; time_now = timeit.default_timer(); stats.add_timing('Liouvillian contruct',; time_now - start_integ_conf,; ss_conf); if ss_conf.total_time is None:; ss_conf.total_time = time_now - start_config; else:; ss_conf.total_time += time_now - start_config. self._ode = r; self._N_he = N_he; self._sup_dim = sup_dim; self._configured = True. [docs] def run(self, rho0, tlist):; """"""; Function to solve for an open quantum system using the; HEOM model. Parameters; ----------; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation.; """"""",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:15474,Deployability,integrat,integrate,15474,".stats; r = self._ode. if not self._configured:; raise RuntimeError(""Solver must be configured before it is run""); if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; raise RuntimeError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('initialize',; timeit.default_timer() - start_init, ss_run); start_integ = timeit.default_timer(). dt = np.diff(tlist); n_tsteps = len(tlist); for t_idx, t in enumerate(tlist):; if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); rho = Qobj(r.y[:sup_dim].reshape(rho0.shape), dims=rho0.dims); output.states.append(rho). if stats:; time_now = timeit.default_timer(); stats.add_timing('integrate',; time_now - start_integ, ss_run); if ss_run.total_time is None:; ss_run.total_time = time_now - start_run; else:; ss_run.total_time += time_now - start_run; stats.total_time = ss_conf.total_time + ss_run.total_time. return output. def _calc_matsubara_params(self):; """"""; Calculate the Matsubara coefficents and frequencies. Returns; -------; c, nu: both list(float). """"""; c = []; nu = []; lam0 = self.coup_strength; gam = self.cut_freq; hbar = self.planck; beta = 1.0/(self.boltzmann*self.temperature); N_m = self.N_exp. g = 2*np.pi / (beta*hbar); for k in range(N_m):; if k == 0:; nu.append(gam); c.append(lam0*gam*; (1.0/np.tan(gam*hbar*beta/2.0) - 1j) / hbar); else:; nu.append(k*g); c.append(4*lam0*gam*nu[k] /; ((nu[k]**2 - gam**2)*beta*hbar**2)). self.exp_coeff = c; self.exp_freq = nu; return c, nu. def _",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:15656,Deployability,integrat,integrate,15656,"meError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('initialize',; timeit.default_timer() - start_init, ss_run); start_integ = timeit.default_timer(). dt = np.diff(tlist); n_tsteps = len(tlist); for t_idx, t in enumerate(tlist):; if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); rho = Qobj(r.y[:sup_dim].reshape(rho0.shape), dims=rho0.dims); output.states.append(rho). if stats:; time_now = timeit.default_timer(); stats.add_timing('integrate',; time_now - start_integ, ss_run); if ss_run.total_time is None:; ss_run.total_time = time_now - start_run; else:; ss_run.total_time += time_now - start_run; stats.total_time = ss_conf.total_time + ss_run.total_time. return output. def _calc_matsubara_params(self):; """"""; Calculate the Matsubara coefficents and frequencies. Returns; -------; c, nu: both list(float). """"""; c = []; nu = []; lam0 = self.coup_strength; gam = self.cut_freq; hbar = self.planck; beta = 1.0/(self.boltzmann*self.temperature); N_m = self.N_exp. g = 2*np.pi / (beta*hbar); for k in range(N_m):; if k == 0:; nu.append(gam); c.append(lam0*gam*; (1.0/np.tan(gam*hbar*beta/2.0) - 1j) / hbar); else:; nu.append(k*g); c.append(4*lam0*gam*nu[k] /; ((nu[k]**2 - gam**2)*beta*hbar**2)). self.exp_coeff = c; self.exp_freq = nu; return c, nu. def _calc_renorm_factors(self):; """"""; Calculate the renormalisation factors. Returns; -------; norm_plus, norm_minus : array[N_c, N_m] of float; """"""; c = self.exp_coeff; N_m = self.N_exp; N_c = self.N_cu",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:18783,Deployability,update,updated,18783,"(float(n)/abs(c[k])). return norm_plus, norm_minus. def _pad_csr(A, row_scale, col_scale, insertrow=0, insertcol=0):; """"""; Expand the input csr_matrix to a greater space as given by the scale.; Effectively inserting A into a larger matrix; zeros([A.shape[0]*row_scale, A.shape[1]*col_scale]; at the position [A.shape[0]*insertrow, A.shape[1]*insertcol]; The same could be achieved through using a kron with a matrix with; one element set to 1. However, this is more efficient; """""". # ajgpitch 2016-03-08:; # Clearly this is a very simple operation in dense matrices; # It seems strange that there is nothing equivalent in sparse however,; # after much searching most threads suggest directly addressing; # the underlying arrays, as done here.; # This certainly proved more efficient than other methods such as stacking; #TODO: Perhaps cythonize and move to spmatfuncs. if not isinstance(A, sp.csr_matrix):; raise TypeError(""First parameter must be a csr matrix""); nrowin = A.shape[0]; ncolin = A.shape[1]; nrowout = nrowin*row_scale; ncolout = ncolin*col_scale. A._shape = (nrowout, ncolout); if insertcol == 0:; pass; elif insertcol > 0 and insertcol < col_scale:; A.indices = A.indices + insertcol*ncolin; else:; raise ValueError(""insertcol must be >= 0 and < col_scale""). if insertrow == 0:; A.indptr = np.concatenate((A.indptr,; np.array([A.indptr[-1]]*(row_scale-1)*nrowin))); elif insertrow == row_scale-1:; A.indptr = np.concatenate((np.array([0]*(row_scale - 1)*nrowin),; A.indptr)); elif insertrow > 0 and insertrow < row_scale - 1:; A.indptr = np.concatenate((np.array([0]*insertrow*nrowin), A.indptr,; np.array([A.indptr[-1]]*(row_scale - insertrow - 1)*nrowin))); else:; raise ValueError(""insertrow must be >= 0 and < row_scale""). return A. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:4430,Energy Efficiency,reduce,reduced,4430,"he bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve). This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate. There are opportunities to develop a more general spectral density code. Attributes; ----------; H_sys : Qobj; System Hamiltonian. coup_op : Qobj; Operator describing the coupling between system and bath. coup_strength : float; Coupling strength. temperature : float; Bath temperature, in units corresponding to planck. N_cut : int; Cutoff parameter for the bath. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. planck : float; reduced Planck constant. boltzmann : float; Boltzmann's constant. options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats : :class:`qutip.solver.Stats`; optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms; """"""; def __init__(self):; raise NotImplementedError(""This is a abstract class only. ""; ""Use a subclass, for example HSolverDL""). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; self.planck = 1.0; self.boltzmann = 1.0; self.H_sys = None; self.coup_op = None; self.coup_strength = 0.0; self.temperature = 1.0; self.N_c",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:17338,Energy Efficiency,efficient,efficient,17338,"se:; nu.append(k*g); c.append(4*lam0*gam*nu[k] /; ((nu[k]**2 - gam**2)*beta*hbar**2)). self.exp_coeff = c; self.exp_freq = nu; return c, nu. def _calc_renorm_factors(self):; """"""; Calculate the renormalisation factors. Returns; -------; norm_plus, norm_minus : array[N_c, N_m] of float; """"""; c = self.exp_coeff; N_m = self.N_exp; N_c = self.N_cut. norm_plus = np.empty((N_c+1, N_m)); norm_minus = np.empty((N_c+1, N_m)); for k in range(N_m):; for n in range(N_c+1):; norm_plus[n, k] = np.sqrt(abs(c[k])*(n + 1)); norm_minus[n, k] = np.sqrt(float(n)/abs(c[k])). return norm_plus, norm_minus. def _pad_csr(A, row_scale, col_scale, insertrow=0, insertcol=0):; """"""; Expand the input csr_matrix to a greater space as given by the scale.; Effectively inserting A into a larger matrix; zeros([A.shape[0]*row_scale, A.shape[1]*col_scale]; at the position [A.shape[0]*insertrow, A.shape[1]*insertcol]; The same could be achieved through using a kron with a matrix with; one element set to 1. However, this is more efficient; """""". # ajgpitch 2016-03-08:; # Clearly this is a very simple operation in dense matrices; # It seems strange that there is nothing equivalent in sparse however,; # after much searching most threads suggest directly addressing; # the underlying arrays, as done here.; # This certainly proved more efficient than other methods such as stacking; #TODO: Perhaps cythonize and move to spmatfuncs. if not isinstance(A, sp.csr_matrix):; raise TypeError(""First parameter must be a csr matrix""); nrowin = A.shape[0]; ncolin = A.shape[1]; nrowout = nrowin*row_scale; ncolout = ncolin*col_scale. A._shape = (nrowout, ncolout); if insertcol == 0:; pass; elif insertcol > 0 and insertcol < col_scale:; A.indices = A.indices + insertcol*ncolin; else:; raise ValueError(""insertcol must be >= 0 and < col_scale""). if insertrow == 0:; A.indptr = np.concatenate((A.indptr,; np.array([A.indptr[-1]]*(row_scale-1)*nrowin))); elif insertrow == row_scale-1:; A.indptr = np.concatenate((np.array([0]*(row_sca",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:17645,Energy Efficiency,efficient,efficient,17645,"ut. norm_plus = np.empty((N_c+1, N_m)); norm_minus = np.empty((N_c+1, N_m)); for k in range(N_m):; for n in range(N_c+1):; norm_plus[n, k] = np.sqrt(abs(c[k])*(n + 1)); norm_minus[n, k] = np.sqrt(float(n)/abs(c[k])). return norm_plus, norm_minus. def _pad_csr(A, row_scale, col_scale, insertrow=0, insertcol=0):; """"""; Expand the input csr_matrix to a greater space as given by the scale.; Effectively inserting A into a larger matrix; zeros([A.shape[0]*row_scale, A.shape[1]*col_scale]; at the position [A.shape[0]*insertrow, A.shape[1]*insertcol]; The same could be achieved through using a kron with a matrix with; one element set to 1. However, this is more efficient; """""". # ajgpitch 2016-03-08:; # Clearly this is a very simple operation in dense matrices; # It seems strange that there is nothing equivalent in sparse however,; # after much searching most threads suggest directly addressing; # the underlying arrays, as done here.; # This certainly proved more efficient than other methods such as stacking; #TODO: Perhaps cythonize and move to spmatfuncs. if not isinstance(A, sp.csr_matrix):; raise TypeError(""First parameter must be a csr matrix""); nrowin = A.shape[0]; ncolin = A.shape[1]; nrowout = nrowin*row_scale; ncolout = ncolin*col_scale. A._shape = (nrowout, ncolout); if insertcol == 0:; pass; elif insertcol > 0 and insertcol < col_scale:; A.indices = A.indices + insertcol*ncolin; else:; raise ValueError(""insertcol must be >= 0 and < col_scale""). if insertrow == 0:; A.indptr = np.concatenate((A.indptr,; np.array([A.indptr[-1]]*(row_scale-1)*nrowin))); elif insertrow == row_scale-1:; A.indptr = np.concatenate((np.array([0]*(row_scale - 1)*nrowin),; A.indptr)); elif insertrow > 0 and insertrow < row_scale - 1:; A.indptr = np.concatenate((np.array([0]*insertrow*nrowin), A.indptr,; np.array([A.indptr[-1]]*(row_scale - insertrow - 1)*nrowin))); else:; raise ValueError(""insertrow must be >= 0 and < row_scale""). return A. © Copyright 2011 and later, P.D. Nation, J.R. Johans",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:2466,Integrability,integrat,integrate,2466," ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides exact solvers for a system-bath setup using the; hierarchy equations of motion (HEOM).; """""". # Authors: Neill Lambert, Anubhav Vardhan, Alexander Pitchford; # Contact: nwlambert@gmail.com. import timeit; import numpy as np; #from scipy.special import factorial; import scipy.sparse as sp; import scipy.integrate; from copy import copy; from qutip import Qobj, qeye; from qutip.states import enr_state_dictionaries; from qutip.superoperator import liouvillian, spre, spost; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.solver import Options, Result, Stats; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.heom import cy_pad_csr; from qutip.cy.spmath import zcsr_kron; from qutip.fastsparse import fast_csr_matrix, fast_identity. [docs]class HEOMSolver(object):; """"""; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentia",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:7402,Integrability,integrat,integrate,7402,"ar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections; config; integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return stats. [docs]class HSolverDL(HEOMSolver):; """"""; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; re",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:7741,Integrability,depend,depend,7741,"t; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections; config; integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return stats. [docs]class HSolverDL(HEOMSolver):; """"""; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. self.reset(). if options is None:; self.options = Options(); else:; self.options = options. self.progress_bar = False; if progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the config",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:13400,Integrability,integrat,integrate,13400," L_he; N_he_interact += 1. he_state_neigh[k] = n_k. if n_excite <= N_c - 1:; # find the hierarchy element index of the neighbour after; # this element, for this Matsubara term; he_state_neigh[k] = n_k + 1; he_idx_neigh = he2idx[tuple(he_state_neigh)]. op = commQ; if renorm:; op = -1j*norm_plus[n_k, k]*op; else:; op = -1j*op. L_he = cy_pad_csr(op, N_he, N_he, he_idx, he_idx_neigh); L_helems += L_he; N_he_interact += 1. he_state_neigh[k] = n_k. if stats:; stats.add_timing('hierarchy contruct',; timeit.default_timer() - start_helem_constr,; ss_conf); stats.add_count('Num hierarchy elements', N_he, ss_conf); stats.add_count('Num he interactions', N_he_interact, ss_conf). # Setup Liouvillian; if stats:; start_louvillian = timeit.default_timer(). H_he = zcsr_kron(unit_helems, liouvillian(H_sys).data). L_helems += H_he. if stats:; stats.add_timing('Liouvillian contruct',; timeit.default_timer() - start_louvillian,; ss_conf). if stats: start_integ_conf = timeit.default_timer(). r = scipy.integrate.ode(cy_ode_rhs). r.set_f_params(L_helems.data, L_helems.indices, L_helems.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step). if stats:; time_now = timeit.default_timer(); stats.add_timing('Liouvillian contruct',; time_now - start_integ_conf,; ss_conf); if ss_conf.total_time is None:; ss_conf.total_time = time_now - start_config; else:; ss_conf.total_time += time_now - start_config. self._ode = r; self._N_he = N_he; self._sup_dim = sup_dim; self._configured = True. [docs] def run(self, rho0, tlist):; """"""; Function to solve for an open quantum system using the; HEOM model. Parameters; ----------; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation.; """"""",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:15474,Integrability,integrat,integrate,15474,".stats; r = self._ode. if not self._configured:; raise RuntimeError(""Solver must be configured before it is run""); if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; raise RuntimeError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('initialize',; timeit.default_timer() - start_init, ss_run); start_integ = timeit.default_timer(). dt = np.diff(tlist); n_tsteps = len(tlist); for t_idx, t in enumerate(tlist):; if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); rho = Qobj(r.y[:sup_dim].reshape(rho0.shape), dims=rho0.dims); output.states.append(rho). if stats:; time_now = timeit.default_timer(); stats.add_timing('integrate',; time_now - start_integ, ss_run); if ss_run.total_time is None:; ss_run.total_time = time_now - start_run; else:; ss_run.total_time += time_now - start_run; stats.total_time = ss_conf.total_time + ss_run.total_time. return output. def _calc_matsubara_params(self):; """"""; Calculate the Matsubara coefficents and frequencies. Returns; -------; c, nu: both list(float). """"""; c = []; nu = []; lam0 = self.coup_strength; gam = self.cut_freq; hbar = self.planck; beta = 1.0/(self.boltzmann*self.temperature); N_m = self.N_exp. g = 2*np.pi / (beta*hbar); for k in range(N_m):; if k == 0:; nu.append(gam); c.append(lam0*gam*; (1.0/np.tan(gam*hbar*beta/2.0) - 1j) / hbar); else:; nu.append(k*g); c.append(4*lam0*gam*nu[k] /; ((nu[k]**2 - gam**2)*beta*hbar**2)). self.exp_coeff = c; self.exp_freq = nu; return c, nu. def _",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:15656,Integrability,integrat,integrate,15656,"meError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('initialize',; timeit.default_timer() - start_init, ss_run); start_integ = timeit.default_timer(). dt = np.diff(tlist); n_tsteps = len(tlist); for t_idx, t in enumerate(tlist):; if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); rho = Qobj(r.y[:sup_dim].reshape(rho0.shape), dims=rho0.dims); output.states.append(rho). if stats:; time_now = timeit.default_timer(); stats.add_timing('integrate',; time_now - start_integ, ss_run); if ss_run.total_time is None:; ss_run.total_time = time_now - start_run; else:; ss_run.total_time += time_now - start_run; stats.total_time = ss_conf.total_time + ss_run.total_time. return output. def _calc_matsubara_params(self):; """"""; Calculate the Matsubara coefficents and frequencies. Returns; -------; c, nu: both list(float). """"""; c = []; nu = []; lam0 = self.coup_strength; gam = self.cut_freq; hbar = self.planck; beta = 1.0/(self.boltzmann*self.temperature); N_m = self.N_exp. g = 2*np.pi / (beta*hbar); for k in range(N_m):; if k == 0:; nu.append(gam); c.append(lam0*gam*; (1.0/np.tan(gam*hbar*beta/2.0) - 1j) / hbar); else:; nu.append(k*g); c.append(4*lam0*gam*nu[k] /; ((nu[k]**2 - gam**2)*beta*hbar**2)). self.exp_coeff = c; self.exp_freq = nu; return c, nu. def _calc_renorm_factors(self):; """"""; Calculate the renormalisation factors. Returns; -------; norm_plus, norm_minus : array[N_c, N_m] of float; """"""; c = self.exp_coeff; N_m = self.N_exp; N_c = self.N_cu",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:4127,Modifiability,coupling,coupling,4127,"duction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve). This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate. There are opportunities to develop a more general spectral density code. Attributes; ----------; H_sys : Qobj; System Hamiltonian. coup_op : Qobj; Operator describing the coupling between system and bath. coup_strength : float; Coupling strength. temperature : float; Bath temperature, in units corresponding to planck. N_cut : int; Cutoff parameter for the bath. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. planck : float; reduced Planck constant. boltzmann : float; Boltzmann's constant. options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats : :class:`qutip.solver.Stats`; optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms; """"""; def __init__(self):; raise ",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:5607,Modifiability,config,configured,5607,"ess_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats : :class:`qutip.solver.Stats`; optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms; """"""; def __init__(self):; raise NotImplementedError(""This is a abstract class only. ""; ""Use a subclass, for example HSolverDL""). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; self.planck = 1.0; self.boltzmann = 1.0; self.H_sys = None; self.coup_op = None; self.coup_strength = 0.0; self.temperature = 1.0; self.N_cut = 10; self.N_exp = 2; self.N_he = 0. self.exp_coeff = None; self.exp_freq = None. self.options = None; self.progress_bar = None; self.stats = None. self.ode = None; self.configured = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters; ----------; options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:5638,Modifiability,config,configure,5638,"ner for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms; """"""; def __init__(self):; raise NotImplementedError(""This is a abstract class only. ""; ""Use a subclass, for example HSolverDL""). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; self.planck = 1.0; self.boltzmann = 1.0; self.H_sys = None; self.coup_op = None; self.coup_strength = 0.0; self.temperature = 1.0; self.N_cut = 10; self.N_exp = 2; self.N_he = 0. self.exp_coeff = None; self.exp_freq = None. self.options = None; self.progress_bar = None; self.stats = None. self.ode = None; self.configured = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters; ----------; options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.bolt",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:7394,Modifiability,config,config,7394,"ar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections; config; integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return stats. [docs]class HSolverDL(HEOMSolver):; """"""; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; re",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:7434,Modifiability,config,config,7434,"ar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections; config; integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return stats. [docs]class HSolverDL(HEOMSolver):; """"""; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; re",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:8080,Modifiability,coupling,coupling,8080,"ats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections; config; integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return stats. [docs]class HSolverDL(HEOMSolver):; """"""; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. self.reset(). if options is None:; self.options = Options(); else:; self.options = options. self.progress_bar = False; if progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the configure method; self.configure(H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=planck, boltzmann=boltzmann,; renorm=renorm, bnd_cut_approx=bnd_cut_approx, stats=stats). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; HEOMSolver.reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:8717,Modifiability,config,configure,8717,"nfinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. self.reset(). if options is None:; self.options = Options(); else:; self.options = options. self.progress_bar = False; if progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the configure method; self.configure(H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=planck, boltzmann=boltzmann,; renorm=renorm, bnd_cut_approx=bnd_cut_approx, stats=stats). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; HEOMSolver.reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Calls configure from :class:`HEOMSolver` and sets any attributes; that are specific to this subclass; """"""; start_config = timeit.default_timer(). HEOMSolver.configure(self, H_sys, coup_op, coup_strength,; temperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cu",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:8740,Modifiability,config,configure,8740,"ies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. self.reset(). if options is None:; self.options = Options(); else:; self.options = options. self.progress_bar = False; if progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the configure method; self.configure(H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=planck, boltzmann=boltzmann,; renorm=renorm, bnd_cut_approx=bnd_cut_approx, stats=stats). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; HEOMSolver.reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Calls configure from :class:`HEOMSolver` and sets any attributes; that are specific to this subclass; """"""; start_config = timeit.default_timer(). HEOMSolver.configure(self, H_sys, coup_op, coup_strength,; temperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cut_approx is not None: self.bnd_cut_approx = bnd_cut_approx. # Load local values for optional parameters; # Constants and ",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:9097,Modifiability,config,configure,9097,"_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. self.reset(). if options is None:; self.options = Options(); else:; self.options = options. self.progress_bar = False; if progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the configure method; self.configure(H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=planck, boltzmann=boltzmann,; renorm=renorm, bnd_cut_approx=bnd_cut_approx, stats=stats). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; HEOMSolver.reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Calls configure from :class:`HEOMSolver` and sets any attributes; that are specific to this subclass; """"""; start_config = timeit.default_timer(). HEOMSolver.configure(self, H_sys, coup_op, coup_strength,; temperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cut_approx is not None: self.bnd_cut_approx = bnd_cut_approx. # Load local values for optional parameters; # Constants and Hamiltonian.; hbar = self.planck; options = self.options; progress_bar = self.progress_bar; stats = self.stats. if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; ss_conf = stats.add_section('config'). c, nu = self._calc_matsubara_params(). if renorm:; norm_plus, norm_minus = self._calc_renorm_factors(); if stats:; stats.add_message('options', 'renormalisation', ss_conf); # Dimensions et by system; N_temp",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:9305,Modifiability,config,configure,9305,"_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. self.reset(). if options is None:; self.options = Options(); else:; self.options = options. self.progress_bar = False; if progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the configure method; self.configure(H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=planck, boltzmann=boltzmann,; renorm=renorm, bnd_cut_approx=bnd_cut_approx, stats=stats). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; HEOMSolver.reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Calls configure from :class:`HEOMSolver` and sets any attributes; that are specific to this subclass; """"""; start_config = timeit.default_timer(). HEOMSolver.configure(self, H_sys, coup_op, coup_strength,; temperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cut_approx is not None: self.bnd_cut_approx = bnd_cut_approx. # Load local values for optional parameters; # Constants and Hamiltonian.; hbar = self.planck; options = self.options; progress_bar = self.progress_bar; stats = self.stats. if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; ss_conf = stats.add_section('config'). c, nu = self._calc_matsubara_params(). if renorm:; norm_plus, norm_minus = self._calc_renorm_factors(); if stats:; stats.add_message('options', 'renormalisation', ss_conf); # Dimensions et by system; N_temp",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:9456,Modifiability,config,configure,9456,"f progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the configure method; self.configure(H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=planck, boltzmann=boltzmann,; renorm=renorm, bnd_cut_approx=bnd_cut_approx, stats=stats). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; HEOMSolver.reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Calls configure from :class:`HEOMSolver` and sets any attributes; that are specific to this subclass; """"""; start_config = timeit.default_timer(). HEOMSolver.configure(self, H_sys, coup_op, coup_strength,; temperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cut_approx is not None: self.bnd_cut_approx = bnd_cut_approx. # Load local values for optional parameters; # Constants and Hamiltonian.; hbar = self.planck; options = self.options; progress_bar = self.progress_bar; stats = self.stats. if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; ss_conf = stats.add_section('config'). c, nu = self._calc_matsubara_params(). if renorm:; norm_plus, norm_minus = self._calc_renorm_factors(); if stats:; stats.add_message('options', 'renormalisation', ss_conf); # Dimensions et by system; N_temp = 1; for i in H_sys.dims[0]:; N_temp *= i; sup_dim = N_temp**2; unit_sys = qeye(N_temp). # Use shorthands (mainly as in referenced PRL); lam0 = self.coup_strength; gam = self.cut_freq; N_c = self.N_cut; N_m = self.N_exp; Q = coup_op # Q as shorthand for coupling operator; beta = 1.0/(s",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:9981,Modifiability,config,config,9981,"reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Calls configure from :class:`HEOMSolver` and sets any attributes; that are specific to this subclass; """"""; start_config = timeit.default_timer(). HEOMSolver.configure(self, H_sys, coup_op, coup_strength,; temperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cut_approx is not None: self.bnd_cut_approx = bnd_cut_approx. # Load local values for optional parameters; # Constants and Hamiltonian.; hbar = self.planck; options = self.options; progress_bar = self.progress_bar; stats = self.stats. if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; ss_conf = stats.add_section('config'). c, nu = self._calc_matsubara_params(). if renorm:; norm_plus, norm_minus = self._calc_renorm_factors(); if stats:; stats.add_message('options', 'renormalisation', ss_conf); # Dimensions et by system; N_temp = 1; for i in H_sys.dims[0]:; N_temp *= i; sup_dim = N_temp**2; unit_sys = qeye(N_temp). # Use shorthands (mainly as in referenced PRL); lam0 = self.coup_strength; gam = self.cut_freq; N_c = self.N_cut; N_m = self.N_exp; Q = coup_op # Q as shorthand for coupling operator; beta = 1.0/(self.boltzmann*self.temperature). # Ntot is the total number of ancillary elements in the hierarchy; # Ntot = factorial(N_c + N_m) / (factorial(N_c)*factorial(N_m)); # Turns out to be the same as nstates from state_number_enumerate; N_he, he2idx, idx2he = enr_state_dictionaries([N_c + 1]*N_m , N_c). unit_helems = fast_identity(N_he); if self.bnd_cut_approx:; # the Tanimura boundary cut off operator; if stats:; stats.add_message('options', 'boundary cutoff",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:10041,Modifiability,config,config,10041,"f.renorm = False; self.bnd_cut_approx = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Calls configure from :class:`HEOMSolver` and sets any attributes; that are specific to this subclass; """"""; start_config = timeit.default_timer(). HEOMSolver.configure(self, H_sys, coup_op, coup_strength,; temperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cut_approx is not None: self.bnd_cut_approx = bnd_cut_approx. # Load local values for optional parameters; # Constants and Hamiltonian.; hbar = self.planck; options = self.options; progress_bar = self.progress_bar; stats = self.stats. if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; ss_conf = stats.add_section('config'). c, nu = self._calc_matsubara_params(). if renorm:; norm_plus, norm_minus = self._calc_renorm_factors(); if stats:; stats.add_message('options', 'renormalisation', ss_conf); # Dimensions et by system; N_temp = 1; for i in H_sys.dims[0]:; N_temp *= i; sup_dim = N_temp**2; unit_sys = qeye(N_temp). # Use shorthands (mainly as in referenced PRL); lam0 = self.coup_strength; gam = self.cut_freq; N_c = self.N_cut; N_m = self.N_exp; Q = coup_op # Q as shorthand for coupling operator; beta = 1.0/(self.boltzmann*self.temperature). # Ntot is the total number of ancillary elements in the hierarchy; # Ntot = factorial(N_c + N_m) / (factorial(N_c)*factorial(N_m)); # Turns out to be the same as nstates from state_number_enumerate; N_he, he2idx, idx2he = enr_state_dictionaries([N_c + 1]*N_m , N_c). unit_helems = fast_identity(N_he); if self.bnd_cut_approx:; # the Tanimura boundary cut off operator; if stats:; stats.add_message('options', 'boundary cutoff approx', ss_conf); op = -2*spre(Q)*s",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:10512,Modifiability,coupling,coupling,10512,"mperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cut_approx is not None: self.bnd_cut_approx = bnd_cut_approx. # Load local values for optional parameters; # Constants and Hamiltonian.; hbar = self.planck; options = self.options; progress_bar = self.progress_bar; stats = self.stats. if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; ss_conf = stats.add_section('config'). c, nu = self._calc_matsubara_params(). if renorm:; norm_plus, norm_minus = self._calc_renorm_factors(); if stats:; stats.add_message('options', 'renormalisation', ss_conf); # Dimensions et by system; N_temp = 1; for i in H_sys.dims[0]:; N_temp *= i; sup_dim = N_temp**2; unit_sys = qeye(N_temp). # Use shorthands (mainly as in referenced PRL); lam0 = self.coup_strength; gam = self.cut_freq; N_c = self.N_cut; N_m = self.N_exp; Q = coup_op # Q as shorthand for coupling operator; beta = 1.0/(self.boltzmann*self.temperature). # Ntot is the total number of ancillary elements in the hierarchy; # Ntot = factorial(N_c + N_m) / (factorial(N_c)*factorial(N_m)); # Turns out to be the same as nstates from state_number_enumerate; N_he, he2idx, idx2he = enr_state_dictionaries([N_c + 1]*N_m , N_c). unit_helems = fast_identity(N_he); if self.bnd_cut_approx:; # the Tanimura boundary cut off operator; if stats:; stats.add_message('options', 'boundary cutoff approx', ss_conf); op = -2*spre(Q)*spost(Q.dag()) + spre(Q.dag()*Q) + spost(Q.dag()*Q). approx_factr = ((2*lam0 / (beta*gam*hbar)) - 1j*lam0) / hbar; for k in range(N_m):; approx_factr -= (c[k] / nu[k]); L_bnd = -approx_factr*op.data; L_helems = zcsr_kron(unit_helems, L_bnd); else:; L_helems = fast_csr_matrix(shape=(N_he*sup_dim, N_he*sup_dim)). # Build the hierarchy element interaction matrix; if stats: start_helem_constr = timeit.default_timer(). unit_sup = spre(unit_sys).data; spreQ = spre(Q).da",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:14286,Modifiability,evolve,evolves,14286,"contruct',; timeit.default_timer() - start_louvillian,; ss_conf). if stats: start_integ_conf = timeit.default_timer(). r = scipy.integrate.ode(cy_ode_rhs). r.set_f_params(L_helems.data, L_helems.indices, L_helems.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step). if stats:; time_now = timeit.default_timer(); stats.add_timing('Liouvillian contruct',; time_now - start_integ_conf,; ss_conf); if ss_conf.total_time is None:; ss_conf.total_time = time_now - start_config; else:; ss_conf.total_time += time_now - start_config. self._ode = r; self._N_he = N_he; self._sup_dim = sup_dim; self._configured = True. [docs] def run(self, rho0, tlist):; """"""; Function to solve for an open quantum system using the; HEOM model. Parameters; ----------; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation.; """""". start_run = timeit.default_timer(). sup_dim = self._sup_dim; stats = self.stats; r = self._ode. if not self._configured:; raise RuntimeError(""Solver must be configured before it is run""); if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; raise RuntimeError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('in",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:14564,Modifiability,config,configured,14564,"=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step). if stats:; time_now = timeit.default_timer(); stats.add_timing('Liouvillian contruct',; time_now - start_integ_conf,; ss_conf); if ss_conf.total_time is None:; ss_conf.total_time = time_now - start_config; else:; ss_conf.total_time += time_now - start_config. self._ode = r; self._N_he = N_he; self._sup_dim = sup_dim; self._configured = True. [docs] def run(self, rho0, tlist):; """"""; Function to solve for an open quantum system using the; HEOM model. Parameters; ----------; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation.; """""". start_run = timeit.default_timer(). sup_dim = self._sup_dim; stats = self.stats; r = self._ode. if not self._configured:; raise RuntimeError(""Solver must be configured before it is run""); if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; raise RuntimeError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('initialize',; timeit.default_timer() - start_init, ss_run); start_integ = timeit.default_timer(). dt = np.diff(tlist); n_tsteps = len(tlist); for t_idx, t in enumerate(tlist):; if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); rho = Qobj(r.y[:sup_dim].reshape(rho0.shape), dims=rho0.dims); outp",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:14636,Modifiability,config,config,14636,"max_step=options.max_step). if stats:; time_now = timeit.default_timer(); stats.add_timing('Liouvillian contruct',; time_now - start_integ_conf,; ss_conf); if ss_conf.total_time is None:; ss_conf.total_time = time_now - start_config; else:; ss_conf.total_time += time_now - start_config. self._ode = r; self._N_he = N_he; self._sup_dim = sup_dim; self._configured = True. [docs] def run(self, rho0, tlist):; """"""; Function to solve for an open quantum system using the; HEOM model. Parameters; ----------; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation.; """""". start_run = timeit.default_timer(). sup_dim = self._sup_dim; stats = self.stats; r = self._ode. if not self._configured:; raise RuntimeError(""Solver must be configured before it is run""); if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; raise RuntimeError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('initialize',; timeit.default_timer() - start_init, ss_run); start_integ = timeit.default_timer(). dt = np.diff(tlist); n_tsteps = len(tlist); for t_idx, t in enumerate(tlist):; if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); rho = Qobj(r.y[:sup_dim].reshape(rho0.shape), dims=rho0.dims); output.states.append(rho). if stats:; time_now = timeit.default_timer(); stats.add_timing('integrate',; time_now - start_",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:14690,Modifiability,config,config,14690,"max_step=options.max_step). if stats:; time_now = timeit.default_timer(); stats.add_timing('Liouvillian contruct',; time_now - start_integ_conf,; ss_conf); if ss_conf.total_time is None:; ss_conf.total_time = time_now - start_config; else:; ss_conf.total_time += time_now - start_config. self._ode = r; self._N_he = N_he; self._sup_dim = sup_dim; self._configured = True. [docs] def run(self, rho0, tlist):; """"""; Function to solve for an open quantum system using the; HEOM model. Parameters; ----------; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation.; """""". start_run = timeit.default_timer(). sup_dim = self._sup_dim; stats = self.stats; r = self._ode. if not self._configured:; raise RuntimeError(""Solver must be configured before it is run""); if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; raise RuntimeError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('initialize',; timeit.default_timer() - start_init, ss_run); start_integ = timeit.default_timer(). dt = np.diff(tlist); n_tsteps = len(tlist); for t_idx, t in enumerate(tlist):; if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); rho = Qobj(r.y[:sup_dim].reshape(rho0.shape), dims=rho0.dims); output.states.append(rho). if stats:; time_now = timeit.default_timer(); stats.add_timing('integrate',; time_now - start_",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:3884,Performance,perform,performance,3884,"n; from qutip.fastsparse import fast_csr_matrix, fast_identity. [docs]class HEOMSolver(object):; """"""; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve). This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate. There are opportunities to develop a more general spectral density code. Attributes; ----------; H_sys : Qobj; System Hamiltonian. coup_op : Qobj; Operator describing the coupling between system and bath. coup_strength : float; Coupling strength. temperature : float; Bath temperature, in units corresponding to planck. N_cut : int; Cutoff parameter for the bath. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. planck : float; reduced Planck constant. boltzmann : float; Boltzmann's constant. options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats : :class:`qutip.solver.Stats`; optional container for holding performance statitics; If None is set, then statistics a",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:4816,Performance,perform,performance,4816,"odel, and there; are some performance advantages to assuming this model where it is; appropriate. There are opportunities to develop a more general spectral density code. Attributes; ----------; H_sys : Qobj; System Hamiltonian. coup_op : Qobj; Operator describing the coupling between system and bath. coup_strength : float; Coupling strength. temperature : float; Bath temperature, in units corresponding to planck. N_cut : int; Cutoff parameter for the bath. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. planck : float; reduced Planck constant. boltzmann : float; Boltzmann's constant. options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats : :class:`qutip.solver.Stats`; optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms; """"""; def __init__(self):; raise NotImplementedError(""This is a abstract class only. ""; ""Use a subclass, for example HSolverDL""). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; self.planck = 1.0; self.boltzmann = 1.0; self.H_sys = None; self.coup_op = None; self.coup_strength = 0.0; self.temperature = 1.0; self.N_cut = 10; self.N_exp = 2; self.N_he = 0. self.exp_coeff = None; self.exp_freq = None. self.options = None; self.progress_bar = None; self.stats = None. self.ode = None; self.configured = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Configure the solver using th",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:6454,Performance,perform,performance,6454,".exp_freq = None. self.options = None; self.progress_bar = None; self.stats = None. self.ode = None; self.configured = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters; ----------; options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections; config; integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return st",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:6286,Usability,progress bar,progress bar,6286,"f.planck = 1.0; self.boltzmann = 1.0; self.H_sys = None; self.coup_op = None; self.coup_strength = 0.0; self.temperature = 1.0; self.N_cut = 10; self.N_exp = 2; self.N_he = 0. self.exp_coeff = None; self.exp_freq = None. self.options = None; self.progress_bar = None; self.stats = None. self.ode = None; self.configured = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters; ----------; options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object s",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:6333,Usability,progress bar,progress bar,6333,"f.planck = 1.0; self.boltzmann = 1.0; self.H_sys = None; self.coup_op = None; self.coup_strength = 0.0; self.temperature = 1.0; self.N_cut = 10; self.N_exp = 2; self.N_he = 0. self.exp_coeff = None; self.exp_freq = None. self.options = None; self.progress_bar = None; self.stats = None. self.ode = None; self.configured = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters; ----------; options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object s",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html:17403,Usability,simpl,simple,17403,"c_renorm_factors(self):; """"""; Calculate the renormalisation factors. Returns; -------; norm_plus, norm_minus : array[N_c, N_m] of float; """"""; c = self.exp_coeff; N_m = self.N_exp; N_c = self.N_cut. norm_plus = np.empty((N_c+1, N_m)); norm_minus = np.empty((N_c+1, N_m)); for k in range(N_m):; for n in range(N_c+1):; norm_plus[n, k] = np.sqrt(abs(c[k])*(n + 1)); norm_minus[n, k] = np.sqrt(float(n)/abs(c[k])). return norm_plus, norm_minus. def _pad_csr(A, row_scale, col_scale, insertrow=0, insertcol=0):; """"""; Expand the input csr_matrix to a greater space as given by the scale.; Effectively inserting A into a larger matrix; zeros([A.shape[0]*row_scale, A.shape[1]*col_scale]; at the position [A.shape[0]*insertrow, A.shape[1]*insertcol]; The same could be achieved through using a kron with a matrix with; one element set to 1. However, this is more efficient; """""". # ajgpitch 2016-03-08:; # Clearly this is a very simple operation in dense matrices; # It seems strange that there is nothing equivalent in sparse however,; # after much searching most threads suggest directly addressing; # the underlying arrays, as done here.; # This certainly proved more efficient than other methods such as stacking; #TODO: Perhaps cythonize and move to spmatfuncs. if not isinstance(A, sp.csr_matrix):; raise TypeError(""First parameter must be a csr matrix""); nrowin = A.shape[0]; ncolin = A.shape[1]; nrowout = nrowin*row_scale; ncolout = ncolin*col_scale. A._shape = (nrowout, ncolout); if insertcol == 0:; pass; elif insertcol > 0 and insertcol < col_scale:; A.indices = A.indices + insertcol*ncolin; else:; raise ValueError(""insertcol must be >= 0 and < col_scale""). if insertrow == 0:; A.indptr = np.concatenate((A.indptr,; np.array([A.indptr[-1]]*(row_scale-1)*nrowin))); elif insertrow == row_scale-1:; A.indptr = np.concatenate((np.array([0]*(row_scale - 1)*nrowin),; A.indptr)); elif insertrow > 0 and insertrow < row_scale - 1:; A.indptr = np.concatenate((np.array([0]*insertrow*nrowin), A.indptr,;",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:3552,Deployability,integrat,integrator,3552,"s MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_mat",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:3739,Deployability,integrat,integrator,3739," :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:3813,Deployability,integrat,integrator,3813,"iouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = in",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:3970,Deployability,integrat,integrator,3970,"ors. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; -------",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:4786,Deployability,integrat,integrator,4786,"or'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:4799,Deployability,integrat,integrator,4799,"or'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:5537,Deployability,integrat,integrator,5537,"(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to t",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:5553,Deployability,integrat,integrator,5553,"elf.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; que",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:5773,Deployability,integrat,integrator,5773,"ons.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : :class:`qutip.Qobj`; system collapse operator that couples to the output field in; question (only needs to be specifie",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:5789,Deployability,integrat,integrator,5789,"grator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : :class:`qutip.Qobj`; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:8012,Deployability,integrat,integrator,8012," generalized partial trace is performed; and a propagator for a single system is returned. Returns; -------; : :class:`qutip.Qobj`; time-propagator for computing field correlation function; """"""; if c1 is None and len(self.L1) == 1:; c1 = self.L1[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); if c2 is None and len(self.L2) == 1:; c2 = self.L2[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); klist = []; slist = []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : fl",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:8028,Deployability,integrat,integrator,8028,"for a single system is returned. Returns; -------; : :class:`qutip.Qobj`; time-propagator for computing field correlation function; """"""; if c1 is None and len(self.L1) == 1:; c1 = self.L1[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); if c2 is None and len(self.L2) == 1:; c2 = self.L2[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); klist = []; slist = []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`qutip.Qobj`; ",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:8608,Deployability,integrat,integrator,8608," []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`qutip.Qobj`; density matrix at time :math:`t`; """"""; if qt.isket(rho0):; rho0 = qt.ket2dm(rho0). E = self.propagator(t, tau); rhovec = qt.operator_to_vector(rho0); return qt.vector_to_operator(E*rhovec). [docs] def outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None):; """"""; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). blist : array_like; List",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:8624,Deployability,integrat,integrator,8624,"append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`qutip.Qobj`; density matrix at time :math:`t`; """"""; if qt.isket(rho0):; rho0 = qt.ket2dm(rho0). E = self.propagator(t, tau); rhovec = qt.operator_to_vector(rho0); return qt.vector_to_operator(E*rhovec). [docs] def outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None):; """"""; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). blist : array_like; List of integers specifying the field operators:; 0: I (nothi",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:12219,Deployability,integrat,integrator,12219,"one, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:12296,Deployability,integrat,integrator,12296,"one, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:12329,Deployability,integrat,integrator,12329,"one, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:12548,Deployability,integrat,integrator,12548,"one, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:12680,Deployability,integrat,integrator,12680,"one, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:12924,Deployability,update,updated,12924,"one, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:5355,Energy Efficiency,reduce,reduced,5355,"ce(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of correspond",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:8805,Energy Efficiency,reduce,reduced,8805,"; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`qutip.Qobj`; density matrix at time :math:`t`; """"""; if qt.isket(rho0):; rho0 = qt.ket2dm(rho0). E = self.propagator(t, tau); rhovec = qt.operator_to_vector(rho0); return qt.vector_to_operator(E*rhovec). [docs] def outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None):; """"""; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. ",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:3552,Integrability,integrat,integrator,3552,"s MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_mat",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:3739,Integrability,integrat,integrator,3739," :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:3813,Integrability,integrat,integrator,3813,"iouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = in",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:3970,Integrability,integrat,integrator,3970,"ors. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; -------",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:4786,Integrability,integrat,integrator,4786,"or'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:4799,Integrability,integrat,integrator,4799,"or'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:5537,Integrability,integrat,integrator,5537,"(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to t",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:5553,Integrability,integrat,integrator,5553,"elf.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; que",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:5773,Integrability,integrat,integrator,5773,"ons.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : :class:`qutip.Qobj`; system collapse operator that couples to the output field in; question (only needs to be specifie",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:5789,Integrability,integrat,integrator,5789,"grator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : :class:`qutip.Qobj`; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:8012,Integrability,integrat,integrator,8012," generalized partial trace is performed; and a propagator for a single system is returned. Returns; -------; : :class:`qutip.Qobj`; time-propagator for computing field correlation function; """"""; if c1 is None and len(self.L1) == 1:; c1 = self.L1[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); if c2 is None and len(self.L2) == 1:; c2 = self.L2[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); klist = []; slist = []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : fl",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:8028,Integrability,integrat,integrator,8028,"for a single system is returned. Returns; -------; : :class:`qutip.Qobj`; time-propagator for computing field correlation function; """"""; if c1 is None and len(self.L1) == 1:; c1 = self.L1[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); if c2 is None and len(self.L2) == 1:; c2 = self.L2[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); klist = []; slist = []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`qutip.Qobj`; ",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:8608,Integrability,integrat,integrator,8608," []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`qutip.Qobj`; density matrix at time :math:`t`; """"""; if qt.isket(rho0):; rho0 = qt.ket2dm(rho0). E = self.propagator(t, tau); rhovec = qt.operator_to_vector(rho0); return qt.vector_to_operator(E*rhovec). [docs] def outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None):; """"""; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). blist : array_like; List",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:8624,Integrability,integrat,integrator,8624,"append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`qutip.Qobj`; density matrix at time :math:`t`; """"""; if qt.isket(rho0):; rho0 = qt.ket2dm(rho0). E = self.propagator(t, tau); rhovec = qt.operator_to_vector(rho0); return qt.vector_to_operator(E*rhovec). [docs] def outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None):; """"""; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). blist : array_like; List of integers specifying the field operators:; 0: I (nothi",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:12219,Integrability,integrat,integrator,12219,"one, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:12296,Integrability,integrat,integrator,12296,"one, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:12329,Integrability,integrat,integrator,12329,"one, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:12548,Integrability,integrat,integrator,12548,"one, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:12680,Integrability,integrat,integrator,12680,"one, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:2886,Modifiability,coupling,coupling,2886,"LUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """""". import numpy as np; import warnings. import qutip as qt. [docs]class MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver op",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:3042,Modifiability,coupling,coupling,3042,"#############################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """""". import numpy as np; import warnings. import qutip as qt. [docs]class MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:;",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:11625,Modifiability,coupling,coupling,11625,".dims = op.dims; for i in range(1, l):; h = qt.tensor(I, h); for i in range(l+1, k+1):; h = qt.tensor(h, I); return h. def _genptrace(E, k):; """"""; Perform a gneralized partial trace on a superoperator E, tracing out all; subsystems but one.; """"""; for l in range(k-1):; nsys = len(E.dims[0][0]); E = qt.tensor_contract(E, (0, 2*nsys+1), (nsys, 3*nsys+1)); return E. def _generator(k, H, L1, L2, S=None, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [],",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:5232,Performance,perform,performed,5232," qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List o",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:7013,Performance,perform,performed,7013,"ute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : :class:`qutip.Qobj`; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notrace : bool {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; -------; : :class:`qutip.Qobj`; time-propagator for computing field correlation function; """"""; if c1 is None and len(self.L1) == 1:; c1 = self.L1[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); if c2 is None and len(self.L2) == 1:; c2 = self.L2[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); klist = []; slist = []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, i",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:2341,Usability,feedback,feedback,2341,"TRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """""". import numpy as np; import warnings. import qutip as qt. [docs]class MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to a",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:2704,Usability,feedback,feedback,2704,"S (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """""". import numpy as np; import warnings. import qutip as qt. [docs]class MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagato",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:2904,Usability,feedback,feedback,2904,"LUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """""". import numpy as np; import warnings. import qutip as qt. [docs]class MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver op",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:3062,Usability,feedback,feedback,3062,"#############################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """""". import numpy as np; import warnings. import qutip as qt. [docs]class MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:;",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:3269,Usability,feedback,feedback,3269,"s module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """""". import numpy as np; import warnings. import qutip as qt. [docs]class MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinst",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:7347,Usability,feedback,feedback,7347,"_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : :class:`qutip.Qobj`; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notrace : bool {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; -------; : :class:`qutip.Qobj`; time-propagator for computing field correlation function; """"""; if c1 is None and len(self.L1) == 1:; c1 = self.L1[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); if c2 is None and len(self.L2) == 1:; c2 = self.L2[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); klist = []; slist = []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html:7539,Usability,feedback,feedback,7539,"qutip.Qobj`; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : :class:`qutip.Qobj`; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notrace : bool {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; -------; : :class:`qutip.Qobj`; time-propagator for computing field correlation function; """"""; if c1 is None and len(self.L1) == 1:; c1 = self.L1[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); if c2 is None and len(self.L2) == 1:; c2 = self.L2[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); klist = []; slist = []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blis",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html:8192,Deployability,update,updated,8192,"tates:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """"""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist.append(T); if n > 1:; diff.append((Tlist[-1]-Tlist[-2]).norm()); if diff[-1] < opt.thres:; # Below threshold for truncation; print('breaking', (Tlist[-1]-Tlist[-2]).norm(), n); break; return Tlist, diff. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html:2964,Usability,learn,learningtimes,2964,"AGE.; ###############################################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module contains an implementation of the non-Markovian transfer tensor; method (TTM), introduced in [1]. [1] Javier Cerrillo and Jianshu Cao, Phys. Rev. Lett 112, 110401 (2014); """""". import numpy as np. from qutip import (Options, spre, vector_to_operator, operator_to_vector,; ket2dm, isket); from qutip.solver import Result; from qutip.expect import expect_rho_vec. [docs]class TTMSolverOptions:; """"""Class of options for the Transfer Tensor Method solver. Attributes; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times :math:`t_n` at which to calculate :math:`\\rho(t_n)`. learningtimes : array_like; List of times :math:`t_k` to use as learning times if argument; `dynmaps` is a callback function. thres : float; Threshold for halting. Halts if :math:`||T_{n}-T_{n-1}||` is below; treshold. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, dynmaps=None, times=[], learningtimes=[],; thres=0.0, options=None):. if options is None:; options = Options(). self.dynmaps = dynmaps; self.times = times; self.learningtimes = learningtimes; self.thres = thres; self.store_states = options.store_states. [docs]def ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None,; **kwargs):; """"""; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of tim",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html:3028,Usability,learn,learning,3028,"AGE.; ###############################################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module contains an implementation of the non-Markovian transfer tensor; method (TTM), introduced in [1]. [1] Javier Cerrillo and Jianshu Cao, Phys. Rev. Lett 112, 110401 (2014); """""". import numpy as np. from qutip import (Options, spre, vector_to_operator, operator_to_vector,; ket2dm, isket); from qutip.solver import Result; from qutip.expect import expect_rho_vec. [docs]class TTMSolverOptions:; """"""Class of options for the Transfer Tensor Method solver. Attributes; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times :math:`t_n` at which to calculate :math:`\\rho(t_n)`. learningtimes : array_like; List of times :math:`t_k` to use as learning times if argument; `dynmaps` is a callback function. thres : float; Threshold for halting. Halts if :math:`||T_{n}-T_{n-1}||` is below; treshold. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, dynmaps=None, times=[], learningtimes=[],; thres=0.0, options=None):. if options is None:; options = Options(). self.dynmaps = dynmaps; self.times = times; self.learningtimes = learningtimes; self.thres = thres; self.store_states = options.store_states. [docs]def ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None,; **kwargs):; """"""; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of tim",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html:3297,Usability,learn,learningtimes,3297,"sfer tensor; method (TTM), introduced in [1]. [1] Javier Cerrillo and Jianshu Cao, Phys. Rev. Lett 112, 110401 (2014); """""". import numpy as np. from qutip import (Options, spre, vector_to_operator, operator_to_vector,; ket2dm, isket); from qutip.solver import Result; from qutip.expect import expect_rho_vec. [docs]class TTMSolverOptions:; """"""Class of options for the Transfer Tensor Method solver. Attributes; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times :math:`t_n` at which to calculate :math:`\\rho(t_n)`. learningtimes : array_like; List of times :math:`t_k` to use as learning times if argument; `dynmaps` is a callback function. thres : float; Threshold for halting. Halts if :math:`||T_{n}-T_{n-1}||` is below; treshold. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, dynmaps=None, times=[], learningtimes=[],; thres=0.0, options=None):. if options is None:; options = Options(). self.dynmaps = dynmaps; self.times = times; self.learningtimes = learningtimes; self.thres = thres; self.store_states = options.store_states. [docs]def ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None,; **kwargs):; """"""; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of times :math:`t_n` at which to compute :math:`\\rho(t_n)`.; Must be uniformily spaced. e_ops : list of :class:`qutip.Qobj` / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times :",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html:3434,Usability,learn,learningtimes,3434,"ptions, spre, vector_to_operator, operator_to_vector,; ket2dm, isket); from qutip.solver import Result; from qutip.expect import expect_rho_vec. [docs]class TTMSolverOptions:; """"""Class of options for the Transfer Tensor Method solver. Attributes; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times :math:`t_n` at which to calculate :math:`\\rho(t_n)`. learningtimes : array_like; List of times :math:`t_k` to use as learning times if argument; `dynmaps` is a callback function. thres : float; Threshold for halting. Halts if :math:`||T_{n}-T_{n-1}||` is below; treshold. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, dynmaps=None, times=[], learningtimes=[],; thres=0.0, options=None):. if options is None:; options = Options(). self.dynmaps = dynmaps; self.times = times; self.learningtimes = learningtimes; self.thres = thres; self.store_states = options.store_states. [docs]def ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None,; **kwargs):; """"""; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of times :math:`t_n` at which to compute :math:`\\rho(t_n)`.; Must be uniformily spaced. e_ops : list of :class:`qutip.Qobj` / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times :math:`t_k` for which we have knowledge of the dynamical; maps :math:`E(t_k)`. tensors : array_like; optional list of precomputed tensors :math:`T_k`. kwargs : dict",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html:3450,Usability,learn,learningtimes,3450,"ptions, spre, vector_to_operator, operator_to_vector,; ket2dm, isket); from qutip.solver import Result; from qutip.expect import expect_rho_vec. [docs]class TTMSolverOptions:; """"""Class of options for the Transfer Tensor Method solver. Attributes; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times :math:`t_n` at which to calculate :math:`\\rho(t_n)`. learningtimes : array_like; List of times :math:`t_k` to use as learning times if argument; `dynmaps` is a callback function. thres : float; Threshold for halting. Halts if :math:`||T_{n}-T_{n-1}||` is below; treshold. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, dynmaps=None, times=[], learningtimes=[],; thres=0.0, options=None):. if options is None:; options = Options(). self.dynmaps = dynmaps; self.times = times; self.learningtimes = learningtimes; self.thres = thres; self.store_states = options.store_states. [docs]def ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None,; **kwargs):; """"""; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of times :math:`t_n` at which to compute :math:`\\rho(t_n)`.; Must be uniformily spaced. e_ops : list of :class:`qutip.Qobj` / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times :math:`t_k` for which we have knowledge of the dynamical; maps :math:`E(t_k)`. tensors : array_like; optional list of precomputed tensors :math:`T_k`. kwargs : dict",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html:3578,Usability,learn,learningtimes,3578,"""""""Class of options for the Transfer Tensor Method solver. Attributes; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times :math:`t_n` at which to calculate :math:`\\rho(t_n)`. learningtimes : array_like; List of times :math:`t_k` to use as learning times if argument; `dynmaps` is a callback function. thres : float; Threshold for halting. Halts if :math:`||T_{n}-T_{n-1}||` is below; treshold. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, dynmaps=None, times=[], learningtimes=[],; thres=0.0, options=None):. if options is None:; options = Options(). self.dynmaps = dynmaps; self.times = times; self.learningtimes = learningtimes; self.thres = thres; self.store_states = options.store_states. [docs]def ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None,; **kwargs):; """"""; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of times :math:`t_n` at which to compute :math:`\\rho(t_n)`.; Must be uniformily spaced. e_ops : list of :class:`qutip.Qobj` / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times :math:`t_k` for which we have knowledge of the dynamical; maps :math:`E(t_k)`. tensors : array_like; optional list of precomputed tensors :math:`T_k`. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; output: :class:`qutip.solver.Result`; An instance of the class :class:`",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html:4246,Usability,learn,learningtimes,4246,"times=[],; thres=0.0, options=None):. if options is None:; options = Options(). self.dynmaps = dynmaps; self.times = times; self.learningtimes = learningtimes; self.thres = thres; self.store_states = options.store_states. [docs]def ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None,; **kwargs):; """"""; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of times :math:`t_n` at which to compute :math:`\\rho(t_n)`.; Must be uniformily spaced. e_ops : list of :class:`qutip.Qobj` / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times :math:`t_k` for which we have knowledge of the dynamical; maps :math:`E(t_k)`. tensors : array_like; optional list of precomputed tensors :math:`T_k`. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; output: :class:`qutip.solver.Result`; An instance of the class :class:`qutip.solver.Result`.; """""". opt = TTMSolverOptions(dynmaps=dynmaps, times=times,; learningtimes=learningtimes, **kwargs). diff = None. if isket(rho0):; rho0 = ket2dm(rho0). output = Result(); e_sops_data = []. if callable(e_ops):; n_expt_op = 0; expt_callback = True. else:; try:; tmp = e_ops[:]; del tmp. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; opt.store_states = True. for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(len(times))); else:; output.expect.append(np.zeros(len(times), dtype=complex)); except TypeError:; raise TypeError(""Argument 'e_ops' s",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html:4711,Usability,learn,learningtimes,4711," precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of times :math:`t_n` at which to compute :math:`\\rho(t_n)`.; Must be uniformily spaced. e_ops : list of :class:`qutip.Qobj` / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times :math:`t_k` for which we have knowledge of the dynamical; maps :math:`E(t_k)`. tensors : array_like; optional list of precomputed tensors :math:`T_k`. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; output: :class:`qutip.solver.Result`; An instance of the class :class:`qutip.solver.Result`.; """""". opt = TTMSolverOptions(dynmaps=dynmaps, times=times,; learningtimes=learningtimes, **kwargs). diff = None. if isket(rho0):; rho0 = ket2dm(rho0). output = Result(); e_sops_data = []. if callable(e_ops):; n_expt_op = 0; expt_callback = True. else:; try:; tmp = e_ops[:]; del tmp. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; opt.store_states = True. for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(len(times))); else:; output.expect.append(np.zeros(len(times), dtype=complex)); except TypeError:; raise TypeError(""Argument 'e_ops' should be a callable or"" +; ""list-like.""). if tensors is None:; tensors, diff = _generatetensors(dynmaps, learningtimes, opt=opt). if rho0.isoper:; # vectorize density matrix; rho0vec = operator_to_vector(rho0); else:; # rho0 might be a super in which case we should not vectorize; rho0vec = rho0. K = len(tensors); states = [rho0vec]; for n in range(1, len(times)):; states.append(None); for k in ",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html:4725,Usability,learn,learningtimes,4725," precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of times :math:`t_n` at which to compute :math:`\\rho(t_n)`.; Must be uniformily spaced. e_ops : list of :class:`qutip.Qobj` / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times :math:`t_k` for which we have knowledge of the dynamical; maps :math:`E(t_k)`. tensors : array_like; optional list of precomputed tensors :math:`T_k`. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; output: :class:`qutip.solver.Result`; An instance of the class :class:`qutip.solver.Result`.; """""". opt = TTMSolverOptions(dynmaps=dynmaps, times=times,; learningtimes=learningtimes, **kwargs). diff = None. if isket(rho0):; rho0 = ket2dm(rho0). output = Result(); e_sops_data = []. if callable(e_ops):; n_expt_op = 0; expt_callback = True. else:; try:; tmp = e_ops[:]; del tmp. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; opt.store_states = True. for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(len(times))); else:; output.expect.append(np.zeros(len(times), dtype=complex)); except TypeError:; raise TypeError(""Argument 'e_ops' should be a callable or"" +; ""list-like.""). if tensors is None:; tensors, diff = _generatetensors(dynmaps, learningtimes, opt=opt). if rho0.isoper:; # vectorize density matrix; rho0vec = operator_to_vector(rho0); else:; # rho0 might be a super in which case we should not vectorize; rho0vec = rho0. K = len(tensors); states = [rho0vec]; for n in range(1, len(times)):; states.append(None); for k in ",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html:5411,Usability,learn,learningtimes,5411,"tional list of precomputed tensors :math:`T_k`. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; output: :class:`qutip.solver.Result`; An instance of the class :class:`qutip.solver.Result`.; """""". opt = TTMSolverOptions(dynmaps=dynmaps, times=times,; learningtimes=learningtimes, **kwargs). diff = None. if isket(rho0):; rho0 = ket2dm(rho0). output = Result(); e_sops_data = []. if callable(e_ops):; n_expt_op = 0; expt_callback = True. else:; try:; tmp = e_ops[:]; del tmp. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; opt.store_states = True. for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(len(times))); else:; output.expect.append(np.zeros(len(times), dtype=complex)); except TypeError:; raise TypeError(""Argument 'e_ops' should be a callable or"" +; ""list-like.""). if tensors is None:; tensors, diff = _generatetensors(dynmaps, learningtimes, opt=opt). if rho0.isoper:; # vectorize density matrix; rho0vec = operator_to_vector(rho0); else:; # rho0 might be a super in which case we should not vectorize; rho0vec = rho0. K = len(tensors); states = [rho0vec]; for n in range(1, len(times)):; states.append(None); for k in range(n):; if n-k < K:; states[-1] += tensors[n-k]*states[k]; for i, r in enumerate(states):; if opt.store_states or expt_callback:; if r.type == 'operator-ket':; states[i] = vector_to_operator(r); else:; states[i] = r; if expt_callback:; # use callback method; e_ops(times[i], states[i]); for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][i] = expect_rho_vec(e_sops_data[m], r, 0); else:; output.expect[m][i] = expect_rho_vec(e_sops_data[m], r, 1). output.solver = ""ttmsolve""; output.times = times. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """,MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html:6358,Usability,learn,learningtimes,6358,"dynmaps, learningtimes, opt=opt). if rho0.isoper:; # vectorize density matrix; rho0vec = operator_to_vector(rho0); else:; # rho0 might be a super in which case we should not vectorize; rho0vec = rho0. K = len(tensors); states = [rho0vec]; for n in range(1, len(times)):; states.append(None); for k in range(n):; if n-k < K:; states[-1] += tensors[n-k]*states[k]; for i, r in enumerate(states):; if opt.store_states or expt_callback:; if r.type == 'operator-ket':; states[i] = vector_to_operator(r); else:; states[i] = r; if expt_callback:; # use callback method; e_ops(times[i], states[i]); for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][i] = expect_rho_vec(e_sops_data[m], r, 0); else:; output.expect[m][i] = expect_rho_vec(e_sops_data[m], r, 1). output.solver = ""ttmsolve""; output.times = times. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """"""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; d",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html:6688,Usability,learn,learningtimes,6688,"one); for k in range(n):; if n-k < K:; states[-1] += tensors[n-k]*states[k]; for i, r in enumerate(states):; if opt.store_states or expt_callback:; if r.type == 'operator-ket':; states[i] = vector_to_operator(r); else:; states[i] = r; if expt_callback:; # use callback method; e_ops(times[i], states[i]); for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][i] = expect_rho_vec(e_sops_data[m], r, 0); else:; output.expect[m][i] = expect_rho_vec(e_sops_data[m], r, 1). output.solver = ""ttmsolve""; output.times = times. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """"""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = k",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html:6776,Usability,learn,learningtimes,6776,"back:; if r.type == 'operator-ket':; states[i] = vector_to_operator(r); else:; states[i] = r; if expt_callback:; # use callback method; e_ops(times[i], states[i]); for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][i] = expect_rho_vec(e_sops_data[m], r, 0); else:; output.expect[m][i] = expect_rho_vec(e_sops_data[m], r, 1). output.solver = ""ttmsolve""; output.times = times. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """"""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html:7170,Usability,learn,learningtimes,7170,"put.solver = ""ttmsolve""; output.times = times. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """"""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist.append(T); if n > 1:; diff.append((Tlist[-1]-Tlist[-2]).norm()); if diff[-1] < opt.thres:; # Below threshold for truncation; print('breaking', (Tlist[-1]-Tlist[-2]).norm(), n); break; return Tlist, diff. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html:7221,Usability,learn,learnintimes,7221,"put.solver = ""ttmsolve""; output.times = times. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """"""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist.append(T); if n > 1:; diff.append((Tlist[-1]-Tlist[-2]).norm()); if diff[-1] < opt.thres:; # Below threshold for truncation; print('breaking', (Tlist[-1]-Tlist[-2]).norm(), n); break; return Tlist, diff. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html:7325,Usability,learn,learningtimes,7325,"tates:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """"""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist.append(T); if n > 1:; diff.append((Tlist[-1]-Tlist[-2]).norm()); if diff[-1] < opt.thres:; # Below threshold for truncation; print('breaking', (Tlist[-1]-Tlist[-2]).norm(), n); break; return Tlist, diff. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html:7355,Usability,learn,learningtimes,7355,"tates:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """"""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist.append(T); if n > 1:; diff.append((Tlist[-1]-Tlist[-2]).norm()); if diff[-1] < opt.thres:; # Below threshold for truncation; print('breaking', (Tlist[-1]-Tlist[-2]).norm(), n); break; return Tlist, diff. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html:7633,Usability,learn,learningtimes,7633,"tates:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """"""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist.append(T); if n > 1:; diff.append((Tlist[-1]-Tlist[-2]).norm()); if diff[-1] < opt.thres:; # Below threshold for truncation; print('breaking', (Tlist[-1]-Tlist[-2]).norm(), n); break; return Tlist, diff. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html:7647,Usability,learn,learningtimes,7647,"tates:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """"""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist.append(T); if n > 1:; diff.append((Tlist[-1]-Tlist[-2]).norm()); if diff[-1] < opt.thres:; # Below threshold for truncation; print('breaking', (Tlist[-1]-Tlist[-2]).norm(), n); break; return Tlist, diff. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.5/modules/qutip/qip/circuit.html:34307,Deployability,update,updated,34307,"= ""TOFFOLI"":; col.append(r"" \targ ""); else:; col.append(r"" \gate{%s} "" %; _gate_label(gate.name, gate.arg_label)). elif gate.controls and n in gate.controls:; m = (gate.targets[0] - n) * (-1 if self.reverse_states; else 1); col.append(r"" \ctrl{%d} "" % m). elif (not gate.controls and not gate.targets):; # global gate; if ((self.reverse_states and n == self.N - 1) or; (not self.reverse_states and n == 0)):; col.append(r"" \multigate{%d}{%s} "" %; (self.N - 1,; _gate_label(gate.name, gate.arg_label))); else:; col.append(r"" \ghost{%s} "" %; (_gate_label(gate.name, gate.arg_label))). else:; col.append(r"" \qw ""). col.append(r"" \qw ""); rows.append(col). input_states = [""\lstick{\ket{"" + x + ""}}"" if x is not None; else """" for x in self.input_states]. code = """"; n_iter = (reversed(range(self.N)) if self.reverse_states; else range(self.N)); for n in n_iter:; code += r"" & %s"" % input_states[n]; for m in range(len(gates)):; code += r"" & %s"" % rows[m][n]; code += r"" & \qw \\ "" + ""\n"". return code. def _repr_png_(self):; return _latex_compile(self.latex_code(), format=""png""). def _repr_svg_(self):; return _latex_compile(self.latex_code(), format=""svg""). @property; def png(self):; from IPython.display import Image; return Image(self._repr_png_(), embed=True). @property; def svg(self):; from IPython.display import SVG; return SVG(self._repr_svg_()). def qasm(self):. code = ""# qasm code generated by QuTiP\n\n"". for n in range(self.N):; code += ""\tqubit\tq%d\n"" % n. code += ""\n"". for gate in self.gates:; code += ""\t%s\t"" % gate.name; qtargets = [""q%d"" %; t for t in gate.targets] if gate.targets else []; qcontrols = ([""q%d"" % c for c in gate.controls] if gate.controls; else []); code += "","".join(qtargets + qcontrols); code += ""\n"". return code. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/qip/circuit.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/circuit.html
https://qutip.org/docs/4.5/modules/qutip/qip/circuit.html:8597,Modifiability,variab,variable,8597,"trols=None, arg_value=None,; arg_label=None, index=None):; """"""; Adds a gate with specified parameters to the circuit. Parameters; ----------; gate: string or `Gate`; Gate name. If gate is an instance of `Gate`, parameters are; unpacked and added.; targets: list; Gate targets.; controls: list; Gate controls.; arg_value: float; Argument value(phi).; arg_label: string; Label for gate representation.; index : list; Positions to add the gate.; """"""; if isinstance(gate, Gate):; name = gate.name; targets = gate.targets; controls = gate.controls; arg_value = gate.arg_value; arg_label = gate.arg_label. else:; name = gate. if index is None:; self.gates.append(Gate(name, targets=targets, controls=controls,; arg_value=arg_value, arg_label=arg_label)). else:; for position in index:; self.gates.insert(position, Gate(name, targets=targets,; controls=controls,; arg_value=arg_value,; arg_label=arg_label)). def add_1q_gate(self, name, start=0, end=None, qubits=None,; arg_value=None, arg_label=None):; """"""; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters; ----------; name : string; Gate name.; start : int; Starting location of qubits.; end : int; Last qubit for the gate.; qubits : list; Specific qubits for applying gates.; arg_value : float; Argument value(phi).; arg_label : string; Label for gate representation.; """"""; if name not in [""RX"", ""RY"", ""RZ"", ""SNOT"", ""SQRTNOT"", ""PHASEGATE""]:; raise ValueError(""%s is not a single qubit gate"" % name). if qubits is not None:; for i in range(len(qubits)):; self.gates.append(Gate(name, targets=qubits[i], controls=None,; arg_value=arg_value,; arg_label=arg_label)). else:; if end is None:; end = self.N - 1; for i in range(start, end):; self.gates.append(Gate(name, targets=i, controls=None,; arg_value=arg_value,; arg_label=arg_label)). def add_circuit(self, qc, start=0):; """"""; Adds a block of a qubit circuit to the mai",MatchSource.WIKI,docs/4.5/modules/qutip/qip/circuit.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/circuit.html
https://qutip.org/docs/4.5/modules/qutip/qip/circuit.html:31322,Modifiability,variab,variable,31322,"gets[0])); elif gate.name == ""CSIGN"":; self.U_list.append(csign(self.N,; gate.controls[0], gate.targets[0])); elif gate.name == ""BERKELEY"":; self.U_list.append(berkeley(self.N, gate.targets)); elif gate.name == ""SWAPalpha"":; self.U_list.append(swapalpha(gate.arg_value, self.N,; gate.targets)); elif gate.name == ""SWAP"":; self.U_list.append(swap(self.N, gate.targets)); elif gate.name == ""ISWAP"":; self.U_list.append(iswap(self.N, gate.targets)); elif gate.name == ""SQRTSWAP"":; self.U_list.append(sqrtswap(self.N, gate.targets)); elif gate.name == ""SQRTISWAP"":; self.U_list.append(sqrtiswap(self.N, gate.targets)); elif gate.name == ""FREDKIN"":; self.U_list.append(fredkin(self.N, gate.controls[0],; gate.targets)); elif gate.name == ""TOFFOLI"":; self.U_list.append(toffoli(self.N, gate.controls,; gate.targets[0])); elif gate.name == ""GLOBALPHASE"":; self.U_list.append(globalphase(gate.arg_value, self.N)); elif gate.name in self.user_gates:; if gate.controls is not None:; raise ValueError(; ""A user defined gate {} takes only ""; ""`targets` variable."".format(gate.name)); func = self.user_gates[gate.name]; para_num = len(inspect.getfullargspec(func)[0]); if para_num == 0:; oper = func(); elif para_num == 1:; oper = func(gate.arg_value); else:; raise ValueError(; ""gate function takes at most one parameters.""); self.U_list.append(expand_operator(; oper, N=self.N,; targets=gate.targets, dims=self.dims)). else:; raise NotImplementedError(; ""{} gate is an unknown gate."".format(gate.name)). return self.U_list. def latex_code(self):; rows = []. gates = self.gates. for gate in gates:; col = []; for n in range(self.N):; if gate.targets and n in gate.targets:. if len(gate.targets) > 1:; if gate.name == ""SWAP"":; col.append(r"" \qswap \qwx ""). elif ((self.reverse_states and; n == max(gate.targets)) or; (not self.reverse_states and; n == min(gate.targets))):; col.append(r"" \multigate{%d}{%s} "" %; (len(gate.targets) - 1,; _gate_label(gate.name,; gate.arg_label))); else:; col.append(r"" \ghost{%s} """,MatchSource.WIKI,docs/4.5/modules/qutip/qip/circuit.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/circuit.html
https://qutip.org/docs/4.5/modules/qutip/qip/noise.html:10228,Availability,avail,available,10228,".t1) != N or len(self.t2) != N:; raise ValueError(; ""Length of t1 or t2 does not match N, ""; ""len(t1)={}, len(t2)={}"".format(; len(self.t1), len(self.t2))); lindblad_noise = Pulse(None, None). if self.targets is None:; targets = range(N); else:; targets = self.targets; for qu_ind in targets:; t1 = self.t1[qu_ind]; t2 = self.t2[qu_ind]; if t1 is not None:; op = 1/np.sqrt(t1) * destroy(2); lindblad_noise.add_lindblad_noise(op, qu_ind, coeff=True); if t2 is not None:; # Keep the total dephasing ~ exp(-t/t2); if t1 is not None:; if 2*t1 < t2:; raise ValueError(; ""t1={}, t2={} does not fulfill ""; ""2*t1>t2"".format(t1, t2)); T2_eff = 1./(1./t2-1./2./t1); else:; T2_eff = t2; op = 1/np.sqrt(2*T2_eff) * sigmaz(); lindblad_noise.add_lindblad_noise(op, qu_ind, coeff=True); return lindblad_noise. [docs]class ControlAmpNoise(Noise):; """"""; The noise in the amplitude of the control pulse. Parameters; ----------; coeff: list; A list of the coefficients for the control Hamiltonians.; For available choices, see :class:`qutip.QobjEvo`.; tlist: array_like, optional; A NumPy array specifies the time of each coefficient.; indices: list of int, optional; The indices of target pulse in the list of pulses.; Attributes; ----------; coeff: list; A list of the coefficients for the control Hamiltonians.; For available choices, see :class:`qutip.QobjEvo`.; tlist: array_like; A NumPy array specifies the time of each coefficient.; indices: list of int; The indices of target pulse in the list of pulses. """"""; def __init__(self, coeff, tlist=None, indices=None):; self.coeff = coeff; self.tlist = tlist; self.indices = indices. [docs] def get_noisy_dynamics(self, pulses):; """"""; Return a list of pulses containing the input pulse with additional; coherent noise. Parameters; ----------; pulses: list of :class:`qutip.qip.Pulse`; The input pulses, on which the noise object will be applied. Returns; -------; noisy_pulses: list of :class:`qutip.qip.Pulse`; The input `Pulse` object with additional coherent noise",MatchSource.WIKI,docs/4.5/modules/qutip/qip/noise.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/noise.html
https://qutip.org/docs/4.5/modules/qutip/qip/noise.html:10543,Availability,avail,available,10543," t2 = self.t2[qu_ind]; if t1 is not None:; op = 1/np.sqrt(t1) * destroy(2); lindblad_noise.add_lindblad_noise(op, qu_ind, coeff=True); if t2 is not None:; # Keep the total dephasing ~ exp(-t/t2); if t1 is not None:; if 2*t1 < t2:; raise ValueError(; ""t1={}, t2={} does not fulfill ""; ""2*t1>t2"".format(t1, t2)); T2_eff = 1./(1./t2-1./2./t1); else:; T2_eff = t2; op = 1/np.sqrt(2*T2_eff) * sigmaz(); lindblad_noise.add_lindblad_noise(op, qu_ind, coeff=True); return lindblad_noise. [docs]class ControlAmpNoise(Noise):; """"""; The noise in the amplitude of the control pulse. Parameters; ----------; coeff: list; A list of the coefficients for the control Hamiltonians.; For available choices, see :class:`qutip.QobjEvo`.; tlist: array_like, optional; A NumPy array specifies the time of each coefficient.; indices: list of int, optional; The indices of target pulse in the list of pulses.; Attributes; ----------; coeff: list; A list of the coefficients for the control Hamiltonians.; For available choices, see :class:`qutip.QobjEvo`.; tlist: array_like; A NumPy array specifies the time of each coefficient.; indices: list of int; The indices of target pulse in the list of pulses. """"""; def __init__(self, coeff, tlist=None, indices=None):; self.coeff = coeff; self.tlist = tlist; self.indices = indices. [docs] def get_noisy_dynamics(self, pulses):; """"""; Return a list of pulses containing the input pulse with additional; coherent noise. Parameters; ----------; pulses: list of :class:`qutip.qip.Pulse`; The input pulses, on which the noise object will be applied. Returns; -------; noisy_pulses: list of :class:`qutip.qip.Pulse`; The input `Pulse` object with additional coherent noise.; """"""; if self.indices is None:; indices = range(len(pulses)); else:; indices = self.indices; for i in indices:; pulse = pulses[i]; if isinstance(self.coeff, (int, float)):; coeff = pulse.coeff * self.coeff; else:; coeff = self.coeff; if self.tlist is None:; tlist = pulse.tlist; else:; tlist = self.tlist; pulses[",MatchSource.WIKI,docs/4.5/modules/qutip/qip/noise.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/noise.html
https://qutip.org/docs/4.5/modules/qutip/qip/noise.html:13901,Availability,error,error,13901,"se, self).__init__(coeff=None, tlist=None); self.rand_gen = rand_gen; self.kwargs = kwargs; if ""size"" in kwargs:; raise ValueError(""size is preditermined inside the noise object.""); self.dt = dt; self.indices = indices. [docs] def get_noisy_dynamics(self, pulses):; """"""; Return a list of pulses containing the input pulse with additional; coherent noise. Parameters; ----------; pulses: list of :class:`qutip.qip.Pulse`; The input pulses, on which the noise object will be applied. Returns; -------; noisy_pulses: list of :class:`qutip.qip.Pulse`; The input `Pulse` object with additional coherent noise.; """"""; if self.indices is None:; indices = range(len(pulses)); else:; indices = self.indices; t_max = -np.inf; t_min = np.inf; for pulse in pulses:; t_max = max(max(pulse.tlist), t_max); t_min = min(min(pulse.tlist), t_min); # create new tlist and random coeff; num_rand = int(np.floor((t_max - t_min) / self.dt)) + 1; tlist = (np.arange(0, self.dt*num_rand, self.dt)[:num_rand] + t_min); # [:num_rand] for round of error like 0.2*6=1.2000000000002. for i in indices:; pulse = pulses[i]; coeff = self.rand_gen(**self.kwargs, size=num_rand); pulses[i].add_coherent_noise(; pulse.qobj, pulse.targets, tlist, coeff); return pulses. [docs]class UserNoise(Noise):; """"""; Template class for user defined noise. It is classified as a pulse; dependent noise. By calling the method `get_noisy_dynamics`,; it should return the input pulses with additional; coherent and/or lindblad noise. If there are; pulse independent noise, a dummy Pulse can be created by; ``Pulse(None, None)``. The modified input pulses should always; be at the begining of the list, followed by the dummy pulses.; """"""; def __init__(self):; pass. [docs] def get_noisy_dynamics(self, pulses, dims):; """"""; Template method.; It should return a list of pulses with noise. Parameters; ----------; pulses: list of :class:`qutip.qip.Pulse`; The input pulses, on which the noise object will be applied. dims: list, optional; The dimension of t",MatchSource.WIKI,docs/4.5/modules/qutip/qip/noise.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/noise.html
https://qutip.org/docs/4.5/modules/qutip/qip/noise.html:15249,Deployability,update,updated,15249," object will be applied. Returns; -------; noisy_pulses: list of :class:`qutip.qip.Pulse`; The input `Pulse` object with additional coherent noise.; """"""; if self.indices is None:; indices = range(len(pulses)); else:; indices = self.indices; t_max = -np.inf; t_min = np.inf; for pulse in pulses:; t_max = max(max(pulse.tlist), t_max); t_min = min(min(pulse.tlist), t_min); # create new tlist and random coeff; num_rand = int(np.floor((t_max - t_min) / self.dt)) + 1; tlist = (np.arange(0, self.dt*num_rand, self.dt)[:num_rand] + t_min); # [:num_rand] for round of error like 0.2*6=1.2000000000002. for i in indices:; pulse = pulses[i]; coeff = self.rand_gen(**self.kwargs, size=num_rand); pulses[i].add_coherent_noise(; pulse.qobj, pulse.targets, tlist, coeff); return pulses. [docs]class UserNoise(Noise):; """"""; Template class for user defined noise. It is classified as a pulse; dependent noise. By calling the method `get_noisy_dynamics`,; it should return the input pulses with additional; coherent and/or lindblad noise. If there are; pulse independent noise, a dummy Pulse can be created by; ``Pulse(None, None)``. The modified input pulses should always; be at the begining of the list, followed by the dummy pulses.; """"""; def __init__(self):; pass. [docs] def get_noisy_dynamics(self, pulses, dims):; """"""; Template method.; It should return a list of pulses with noise. Parameters; ----------; pulses: list of :class:`qutip.qip.Pulse`; The input pulses, on which the noise object will be applied. dims: list, optional; The dimension of the components system, the default value is; [2,2...,2] for qubits system. Returns; -------; noisy_pulses: list of :class:`qutip.qip.Pulse`; The input `Pulse` object with additional noise.; """"""; return pulses. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/qip/noise.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/noise.html
https://qutip.org/docs/4.5/modules/qutip/qip/noise.html:2318,Integrability,depend,dependent,2318,"; If list, it is the dimension of the component systems.; t1: list or float, optional; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all qubits.; t2: list of float, optional; Characterize the decoherence of dephasing for; each qubit. A list of size `N` or a float for all qubits.; device_noise: bool; If pulse independent noise such as relaxation are included.; Default is False. Returns; -------; noisy_pulses: list of :class:`qutip.qip.Pulse`; The noisy pulses.; """"""; # first the control pulse with noise,; # then additional pulse independent noise.; noisy_pulses = process_pulse_noise(pulses, noise_list, dims); if device_noise:; noisy_pulses += process_device_noise(noise_list, dims, t1, t2); return noisy_pulses. def process_device_noise(noise_list, dims, t1=None, t2=None):; """"""; Apply pulse independent noise to the input list of pulses.; It does not modify the input; pulse, but return a new one containing the noise.; Pulse dependent noise will be ignored. Parameters; ----------; noise_list: list of :class:`qutip.qip.noise`; A list of noise objects.; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems.; t1: list or float, optional; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all qubits.; t2: list of float, optional; Characterize the decoherence of dephasing for; each qubit. A list of size `N` or a float for all qubits. Returns; -------; noisy_pulses: list of :class:`qutip.qip.Pulse`; A list of Dummy pulse objects with zero Hamiltonian; by non-trivial noise.; """"""; device_noise = []; if (t1 is not None) or (t2 is not None):; device_noise += [RelaxationNoise(t1, t2).get_noisy_dynamics(dims)]. for noise in noise_list:; if isinstance(noise, (DecoherenceNoise, RelaxationNoise)):; device_noise += [noise.get_noisy_dynamics(dims)]. return device_noise. def process",MatchSource.WIKI,docs/4.5/modules/qutip/qip/noise.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/noise.html
https://qutip.org/docs/4.5/modules/qutip/qip/noise.html:3388,Integrability,depend,dependent,3388,"noise_list: list of :class:`qutip.qip.noise`; A list of noise objects.; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems.; t1: list or float, optional; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all qubits.; t2: list of float, optional; Characterize the decoherence of dephasing for; each qubit. A list of size `N` or a float for all qubits. Returns; -------; noisy_pulses: list of :class:`qutip.qip.Pulse`; A list of Dummy pulse objects with zero Hamiltonian; by non-trivial noise.; """"""; device_noise = []; if (t1 is not None) or (t2 is not None):; device_noise += [RelaxationNoise(t1, t2).get_noisy_dynamics(dims)]. for noise in noise_list:; if isinstance(noise, (DecoherenceNoise, RelaxationNoise)):; device_noise += [noise.get_noisy_dynamics(dims)]. return device_noise. def process_pulse_noise(pulses, noise_list, dims):; """"""; Apply pulse dependent noise to the input list of pulses.; It does not modify the input; pulse, but return a new one containing the noise.; Device noise noise will be ignored. Parameters; ----------; pulses: list of :class:`qutip.qip.Pulse`; The input pulses, on which the noise object will be applied.; noise_list: list of :class:`qutip.qip.noise`; A list of noise objects.; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. noisy_pulses: list of :class:`qutip.qip.Pulse`; The list of pulses with pulse dependent noise.; """"""; noisy_pulses = deepcopy(pulses); for noise in noise_list:; if isinstance(noise, ControlAmpNoise):; noisy_pulses = noise.get_noisy_dynamics(noisy_pulses); elif isinstance(noise, UserNoise):; noisy_pulses = noise.get_noisy_dynamics(pulses, dims); return noisy_pulses. class Noise(object):; """"""; The base class representing noise in a processor.; The noise object c",MatchSource.WIKI,docs/4.5/modules/qutip/qip/noise.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/noise.html
https://qutip.org/docs/4.5/modules/qutip/qip/noise.html:3990,Integrability,depend,dependent,3990,"ts with zero Hamiltonian; by non-trivial noise.; """"""; device_noise = []; if (t1 is not None) or (t2 is not None):; device_noise += [RelaxationNoise(t1, t2).get_noisy_dynamics(dims)]. for noise in noise_list:; if isinstance(noise, (DecoherenceNoise, RelaxationNoise)):; device_noise += [noise.get_noisy_dynamics(dims)]. return device_noise. def process_pulse_noise(pulses, noise_list, dims):; """"""; Apply pulse dependent noise to the input list of pulses.; It does not modify the input; pulse, but return a new one containing the noise.; Device noise noise will be ignored. Parameters; ----------; pulses: list of :class:`qutip.qip.Pulse`; The input pulses, on which the noise object will be applied.; noise_list: list of :class:`qutip.qip.noise`; A list of noise objects.; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. noisy_pulses: list of :class:`qutip.qip.Pulse`; The list of pulses with pulse dependent noise.; """"""; noisy_pulses = deepcopy(pulses); for noise in noise_list:; if isinstance(noise, ControlAmpNoise):; noisy_pulses = noise.get_noisy_dynamics(noisy_pulses); elif isinstance(noise, UserNoise):; noisy_pulses = noise.get_noisy_dynamics(pulses, dims); return noisy_pulses. class Noise(object):; """"""; The base class representing noise in a processor.; The noise object can be added to :class:`qutip.qip.device.Processor` and; contributes to evolution.; """"""; def __init__(self):; pass. def _check_coeff_num(self, coeffs, ops_num):; if len(coeffs) != ops_num:; raise ValueError(; ""The length of coeffs is not {}"".format(ops_num)). [docs]class DecoherenceNoise(Noise):; """"""; The decoherence noise in a processor. It generates lindblad noise; according to the given collapse operator `c_ops`. Parameters; ----------; c_ops: :class:`qutip.Qobj` or list; The Hamiltonian representing the dynamics of the noise.; targets: int or list, optional; The indices of qubits that are acted",MatchSource.WIKI,docs/4.5/modules/qutip/qip/noise.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/noise.html
https://qutip.org/docs/4.5/modules/qutip/qip/noise.html:14218,Integrability,depend,dependent,14218,"itional; coherent noise. Parameters; ----------; pulses: list of :class:`qutip.qip.Pulse`; The input pulses, on which the noise object will be applied. Returns; -------; noisy_pulses: list of :class:`qutip.qip.Pulse`; The input `Pulse` object with additional coherent noise.; """"""; if self.indices is None:; indices = range(len(pulses)); else:; indices = self.indices; t_max = -np.inf; t_min = np.inf; for pulse in pulses:; t_max = max(max(pulse.tlist), t_max); t_min = min(min(pulse.tlist), t_min); # create new tlist and random coeff; num_rand = int(np.floor((t_max - t_min) / self.dt)) + 1; tlist = (np.arange(0, self.dt*num_rand, self.dt)[:num_rand] + t_min); # [:num_rand] for round of error like 0.2*6=1.2000000000002. for i in indices:; pulse = pulses[i]; coeff = self.rand_gen(**self.kwargs, size=num_rand); pulses[i].add_coherent_noise(; pulse.qobj, pulse.targets, tlist, coeff); return pulses. [docs]class UserNoise(Noise):; """"""; Template class for user defined noise. It is classified as a pulse; dependent noise. By calling the method `get_noisy_dynamics`,; it should return the input pulses with additional; coherent and/or lindblad noise. If there are; pulse independent noise, a dummy Pulse can be created by; ``Pulse(None, None)``. The modified input pulses should always; be at the begining of the list, followed by the dummy pulses.; """"""; def __init__(self):; pass. [docs] def get_noisy_dynamics(self, pulses, dims):; """"""; Template method.; It should return a list of pulses with noise. Parameters; ----------; pulses: list of :class:`qutip.qip.Pulse`; The input pulses, on which the noise object will be applied. dims: list, optional; The dimension of the components system, the default value is; [2,2...,2] for qubits system. Returns; -------; noisy_pulses: list of :class:`qutip.qip.Pulse`; The input `Pulse` object with additional noise.; """"""; return pulses. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahme",MatchSource.WIKI,docs/4.5/modules/qutip/qip/noise.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/noise.html
https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html:15545,Deployability,integrat,integrated,15545,"ise; for the drift evolution. Returns; -------; noisy_evo: :class:`qutip.QobjEvo`; A `QobjEvo` representing the ideal evolution and coherent noise.; c_ops: list of :class:`qutip.QobjEvo`; Always an empty list for Drift; """"""; return self.get_ideal_qobjevo(dims), []. def _find_common_tlist(qobjevo_list):; """"""; Find the common `tlist` of a list of :class:`qutip.QobjEvo`.; """"""; all_tlists = [qu.tlist for qu in qobjevo_list; if isinstance(qu, QobjEvo) and qu.tlist is not None]; if not all_tlists:; return None; full_tlist = np.unique(np.sort(np.hstack(all_tlists))); return full_tlist. ########################################################################; # These functions are moved here from qutip.qip.device.processor.py; ########################################################################. def _merge_qobjevo(qobjevo_list, full_tlist=None):; """"""; Combine a list of `:class:qutip.QobjEvo` into one,; different tlist will be merged.; """"""; # TODO This method can be eventually integrated into QobjEvo, for; # which a more thorough test is required. # no qobjevo; if not qobjevo_list:; raise ValueError(""qobjevo_list is empty.""). if full_tlist is None:; full_tlist = _find_common_tlist(qobjevo_list); spline_types_num = set(); args = {}; for qu in qobjevo_list:; if isinstance(qu, QobjEvo):; try:; spline_types_num.add(qu.args[""_step_func_coeff""]); except Exception:; pass; args.update(qu.args); if len(spline_types_num) > 1:; raise ValueError(""Cannot merge Qobjevo with different spline kinds.""). for i, qobjevo in enumerate(qobjevo_list):; if isinstance(qobjevo, Qobj):; qobjevo_list[i] = QobjEvo(qobjevo); qobjevo = qobjevo_list[i]; for j, ele in enumerate(qobjevo.ops):; if isinstance(ele.coeff, np.ndarray):; new_coeff = _fill_coeff(; ele.coeff, qobjevo.tlist, full_tlist, args); qobjevo_list[i].ops[j].coeff = new_coeff; qobjevo_list[i].tlist = full_tlist. qobjevo = sum(qobjevo_list); return qobjevo. def _fill_coeff(old_coeffs, old_tlist, full_tlist, args=None):; """"""; Make a step fun",MatchSource.WIKI,docs/4.5/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html:15946,Deployability,update,update,15946,".tlist for qu in qobjevo_list; if isinstance(qu, QobjEvo) and qu.tlist is not None]; if not all_tlists:; return None; full_tlist = np.unique(np.sort(np.hstack(all_tlists))); return full_tlist. ########################################################################; # These functions are moved here from qutip.qip.device.processor.py; ########################################################################. def _merge_qobjevo(qobjevo_list, full_tlist=None):; """"""; Combine a list of `:class:qutip.QobjEvo` into one,; different tlist will be merged.; """"""; # TODO This method can be eventually integrated into QobjEvo, for; # which a more thorough test is required. # no qobjevo; if not qobjevo_list:; raise ValueError(""qobjevo_list is empty.""). if full_tlist is None:; full_tlist = _find_common_tlist(qobjevo_list); spline_types_num = set(); args = {}; for qu in qobjevo_list:; if isinstance(qu, QobjEvo):; try:; spline_types_num.add(qu.args[""_step_func_coeff""]); except Exception:; pass; args.update(qu.args); if len(spline_types_num) > 1:; raise ValueError(""Cannot merge Qobjevo with different spline kinds.""). for i, qobjevo in enumerate(qobjevo_list):; if isinstance(qobjevo, Qobj):; qobjevo_list[i] = QobjEvo(qobjevo); qobjevo = qobjevo_list[i]; for j, ele in enumerate(qobjevo.ops):; if isinstance(ele.coeff, np.ndarray):; new_coeff = _fill_coeff(; ele.coeff, qobjevo.tlist, full_tlist, args); qobjevo_list[i].ops[j].coeff = new_coeff; qobjevo_list[i].tlist = full_tlist. qobjevo = sum(qobjevo_list); return qobjevo. def _fill_coeff(old_coeffs, old_tlist, full_tlist, args=None):; """"""; Make a step function coefficients compatible with a longer `tlist` by; filling the empty slot with the nearest left value. The returned `coeff` always have the same size as the `tlist`.; If `step_func`, the last element is 0.; """"""; if args is None:; args = {}; if ""_step_func_coeff"" in args and args[""_step_func_coeff""]:; if len(old_coeffs) == len(old_tlist) - 1:; old_coeffs = np.concatenate([old_coeffs, [",MatchSource.WIKI,docs/4.5/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html:17653,Deployability,update,updated,17653,"mmon_tlist(qobjevo_list); spline_types_num = set(); args = {}; for qu in qobjevo_list:; if isinstance(qu, QobjEvo):; try:; spline_types_num.add(qu.args[""_step_func_coeff""]); except Exception:; pass; args.update(qu.args); if len(spline_types_num) > 1:; raise ValueError(""Cannot merge Qobjevo with different spline kinds.""). for i, qobjevo in enumerate(qobjevo_list):; if isinstance(qobjevo, Qobj):; qobjevo_list[i] = QobjEvo(qobjevo); qobjevo = qobjevo_list[i]; for j, ele in enumerate(qobjevo.ops):; if isinstance(ele.coeff, np.ndarray):; new_coeff = _fill_coeff(; ele.coeff, qobjevo.tlist, full_tlist, args); qobjevo_list[i].ops[j].coeff = new_coeff; qobjevo_list[i].tlist = full_tlist. qobjevo = sum(qobjevo_list); return qobjevo. def _fill_coeff(old_coeffs, old_tlist, full_tlist, args=None):; """"""; Make a step function coefficients compatible with a longer `tlist` by; filling the empty slot with the nearest left value. The returned `coeff` always have the same size as the `tlist`.; If `step_func`, the last element is 0.; """"""; if args is None:; args = {}; if ""_step_func_coeff"" in args and args[""_step_func_coeff""]:; if len(old_coeffs) == len(old_tlist) - 1:; old_coeffs = np.concatenate([old_coeffs, [0]]); new_n = len(full_tlist); old_ind = 0 # index for old coeffs and tlist; new_coeff = np.zeros(new_n); for new_ind in range(new_n):; t = full_tlist[new_ind]; if t < old_tlist[0]:; new_coeff[new_ind] = 0.; continue; if t > old_tlist[-1]:; new_coeff[new_ind] = 0.; continue; if old_tlist[old_ind+1] == t:; old_ind += 1; new_coeff[new_ind] = old_coeffs[old_ind]; else:; sp = CubicSpline(old_tlist, old_coeffs); new_coeff = sp(full_tlist); new_coeff *= (full_tlist <= old_tlist[-1]); new_coeff *= (full_tlist >= old_tlist[0]); return new_coeff. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html:3954,Integrability,depend,dependent,3954,"ficient will be treated as a step function.; E.g. ``tlist=[0,1,2]`` and ``coeff=[3,2]``, means that the; coefficient is 3 in t=[0,1) and 2 in t=[2,3). It requires; ``len(coeff)=len(tlist)-1`` or ``len(coeff)=len(tlist)``, but; in the second case the last element of `coeff` has no effect. -""cubic"": Use cubic interpolation for the coefficient. It requires; ``len(coeff)=len(tlist)``; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns; -------; qobjevo: :class:`qutip.QobjEvo`; The `QobjEvo` representation of the evolution element.; """"""; try:; return self._get_qobjevo_helper(spline_kind, dims=dims); except Exception as err:; print(; ""The Evolution element went wrong was\n {}"".format(str(self))); raise(err). def __str__(self):; return str({""qobj"": self.qobj,; ""targets"": self.targets,; ""tlist"": self.tlist,; ""coeff"": self.coeff; }). [docs]class Pulse():; """"""; Representation of a control pulse and the pulse dependent noise.; The pulse is characterized by the ideal control pulse, the coherent; noise and the lindblad noise. The later two are lists of; noisy evolution dynamics.; Each dynamic element is characterized by four variables:; `qobj`, `targets`, `tlist` and `coeff`. See examples for different construction behavior. Parameters; ----------; qobj: :class:'qutip.Qobj'; The Hamiltonian of the ideal pulse.; targets: list; target qubits of the ideal pulse; (or subquantum system of other dimensions).; tlist: array-like, optional; `tlist` of the ideal pulse.; A list of time at which the time-dependent coefficients are applied.; `tlist` does not have to be equidistant, but must have the same length; or one element shorter compared to `coeff`. See documentation for; the parameter `spline_kind`.; coeff: array-like or bool, optional; Time-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to `",MatchSource.WIKI,docs/4.5/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html:4547,Integrability,depend,dependent,4547,"n of the evolution element.; """"""; try:; return self._get_qobjevo_helper(spline_kind, dims=dims); except Exception as err:; print(; ""The Evolution element went wrong was\n {}"".format(str(self))); raise(err). def __str__(self):; return str({""qobj"": self.qobj,; ""targets"": self.targets,; ""tlist"": self.tlist,; ""coeff"": self.coeff; }). [docs]class Pulse():; """"""; Representation of a control pulse and the pulse dependent noise.; The pulse is characterized by the ideal control pulse, the coherent; noise and the lindblad noise. The later two are lists of; noisy evolution dynamics.; Each dynamic element is characterized by four variables:; `qobj`, `targets`, `tlist` and `coeff`. See examples for different construction behavior. Parameters; ----------; qobj: :class:'qutip.Qobj'; The Hamiltonian of the ideal pulse.; targets: list; target qubits of the ideal pulse; (or subquantum system of other dimensions).; tlist: array-like, optional; `tlist` of the ideal pulse.; A list of time at which the time-dependent coefficients are applied.; `tlist` does not have to be equidistant, but must have the same length; or one element shorter compared to `coeff`. See documentation for; the parameter `spline_kind`.; coeff: array-like or bool, optional; Time-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for the parameter `spline_kind`.; If a bool, the coefficient is a constant 1 or 0.; spline_kind: str, optional; Type of the coefficient interpolation:; ""step_func"" or ""cubic"". -""step_func"":; The coefficient will be treated as a step function.; E.g. ``tlist=[0,1,2]`` and ``coeff=[3,2]``, means that the coefficient; is 3 in t=[0,1) and 2 in t=[2,3). It requires; ``len(coeff)=len(tlist)-1`` or ``len(coeff)=len(tlist)``, but; in the second case the last element of `coeff` has no effect. -""cubic"":; Use cubic interpolation for the coefficient. It requires; ``len(coeff)=len(tlist)``; label: str; ",MatchSource.WIKI,docs/4.5/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html:4795,Integrability,depend,dependent,4795,".qobj,; ""targets"": self.targets,; ""tlist"": self.tlist,; ""coeff"": self.coeff; }). [docs]class Pulse():; """"""; Representation of a control pulse and the pulse dependent noise.; The pulse is characterized by the ideal control pulse, the coherent; noise and the lindblad noise. The later two are lists of; noisy evolution dynamics.; Each dynamic element is characterized by four variables:; `qobj`, `targets`, `tlist` and `coeff`. See examples for different construction behavior. Parameters; ----------; qobj: :class:'qutip.Qobj'; The Hamiltonian of the ideal pulse.; targets: list; target qubits of the ideal pulse; (or subquantum system of other dimensions).; tlist: array-like, optional; `tlist` of the ideal pulse.; A list of time at which the time-dependent coefficients are applied.; `tlist` does not have to be equidistant, but must have the same length; or one element shorter compared to `coeff`. See documentation for; the parameter `spline_kind`.; coeff: array-like or bool, optional; Time-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for the parameter `spline_kind`.; If a bool, the coefficient is a constant 1 or 0.; spline_kind: str, optional; Type of the coefficient interpolation:; ""step_func"" or ""cubic"". -""step_func"":; The coefficient will be treated as a step function.; E.g. ``tlist=[0,1,2]`` and ``coeff=[3,2]``, means that the coefficient; is 3 in t=[0,1) and 2 in t=[2,3). It requires; ``len(coeff)=len(tlist)-1`` or ``len(coeff)=len(tlist)``, but; in the second case the last element of `coeff` has no effect. -""cubic"":; Use cubic interpolation for the coefficient. It requires; ``len(coeff)=len(tlist)``; label: str; The label (name) of the pulse. Attributes; ----------; ideal_pulse: :class:`qutip.qip.pulse._EvoElement`; The ideal dynamic of the control pulse.; coherent_noise: list of :class:`qutip.qip.pulse._EvoElement`; The coherent noise caused by the control p",MatchSource.WIKI,docs/4.5/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html:5859,Integrability,depend,dependent,5859,"se.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for the parameter `spline_kind`.; If a bool, the coefficient is a constant 1 or 0.; spline_kind: str, optional; Type of the coefficient interpolation:; ""step_func"" or ""cubic"". -""step_func"":; The coefficient will be treated as a step function.; E.g. ``tlist=[0,1,2]`` and ``coeff=[3,2]``, means that the coefficient; is 3 in t=[0,1) and 2 in t=[2,3). It requires; ``len(coeff)=len(tlist)-1`` or ``len(coeff)=len(tlist)``, but; in the second case the last element of `coeff` has no effect. -""cubic"":; Use cubic interpolation for the coefficient. It requires; ``len(coeff)=len(tlist)``; label: str; The label (name) of the pulse. Attributes; ----------; ideal_pulse: :class:`qutip.qip.pulse._EvoElement`; The ideal dynamic of the control pulse.; coherent_noise: list of :class:`qutip.qip.pulse._EvoElement`; The coherent noise caused by the control pulse. Each dynamic element is; still characterized by a time-dependent Hamiltonian.; lindblad_noise: list of :class:`qutip.qip.pulse._EvoElement`; The dissipative noise of the control pulse. Each dynamic element; will be treated as a (time-dependent) lindblad operator in the; master equation.; spline_kind: str; See parameter `spline_kind`.; label: str; See parameter `label`. Examples; --------; Create a pulse that is turned off. >>> Pulse(sigmaz(), 0); >>> Pulse(sigmaz(), 0, None, None). Create a time dependent pulse. >>> tlist = np.array([0., 1., 2., 4.]); >>> coeff = np.array([0.5, 1.2, 0.8]); >>> spline_kind = ""step_func""; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=coeff, spline_kind=""step_func""). Create a time independent pulse. >>> Pulse(sigmaz(), 0, coeff=True). Create a constant pulse with time range. >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=True). Create an dummy Pulse (H=0). >>> Pulse(None, None). """"""; def __init__(self, qobj, targets, tlist=None, coeff=None,; spline_kind=None, label=None):; self.spline_kind = spline_ki",MatchSource.WIKI,docs/4.5/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html:6038,Integrability,depend,dependent,6038,"ne_kind: str, optional; Type of the coefficient interpolation:; ""step_func"" or ""cubic"". -""step_func"":; The coefficient will be treated as a step function.; E.g. ``tlist=[0,1,2]`` and ``coeff=[3,2]``, means that the coefficient; is 3 in t=[0,1) and 2 in t=[2,3). It requires; ``len(coeff)=len(tlist)-1`` or ``len(coeff)=len(tlist)``, but; in the second case the last element of `coeff` has no effect. -""cubic"":; Use cubic interpolation for the coefficient. It requires; ``len(coeff)=len(tlist)``; label: str; The label (name) of the pulse. Attributes; ----------; ideal_pulse: :class:`qutip.qip.pulse._EvoElement`; The ideal dynamic of the control pulse.; coherent_noise: list of :class:`qutip.qip.pulse._EvoElement`; The coherent noise caused by the control pulse. Each dynamic element is; still characterized by a time-dependent Hamiltonian.; lindblad_noise: list of :class:`qutip.qip.pulse._EvoElement`; The dissipative noise of the control pulse. Each dynamic element; will be treated as a (time-dependent) lindblad operator in the; master equation.; spline_kind: str; See parameter `spline_kind`.; label: str; See parameter `label`. Examples; --------; Create a pulse that is turned off. >>> Pulse(sigmaz(), 0); >>> Pulse(sigmaz(), 0, None, None). Create a time dependent pulse. >>> tlist = np.array([0., 1., 2., 4.]); >>> coeff = np.array([0.5, 1.2, 0.8]); >>> spline_kind = ""step_func""; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=coeff, spline_kind=""step_func""). Create a time independent pulse. >>> Pulse(sigmaz(), 0, coeff=True). Create a constant pulse with time range. >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=True). Create an dummy Pulse (H=0). >>> Pulse(None, None). """"""; def __init__(self, qobj, targets, tlist=None, coeff=None,; spline_kind=None, label=None):; self.spline_kind = spline_kind; self.ideal_pulse = _EvoElement(qobj, targets, tlist, coeff); self.coherent_noise = []; self.lindblad_noise = []; self.label = label. @property; def qobj(self):; """"""; See parameter `qobj`.; """"""; ",MatchSource.WIKI,docs/4.5/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html:6305,Integrability,depend,dependent,6305,"equires; ``len(coeff)=len(tlist)-1`` or ``len(coeff)=len(tlist)``, but; in the second case the last element of `coeff` has no effect. -""cubic"":; Use cubic interpolation for the coefficient. It requires; ``len(coeff)=len(tlist)``; label: str; The label (name) of the pulse. Attributes; ----------; ideal_pulse: :class:`qutip.qip.pulse._EvoElement`; The ideal dynamic of the control pulse.; coherent_noise: list of :class:`qutip.qip.pulse._EvoElement`; The coherent noise caused by the control pulse. Each dynamic element is; still characterized by a time-dependent Hamiltonian.; lindblad_noise: list of :class:`qutip.qip.pulse._EvoElement`; The dissipative noise of the control pulse. Each dynamic element; will be treated as a (time-dependent) lindblad operator in the; master equation.; spline_kind: str; See parameter `spline_kind`.; label: str; See parameter `label`. Examples; --------; Create a pulse that is turned off. >>> Pulse(sigmaz(), 0); >>> Pulse(sigmaz(), 0, None, None). Create a time dependent pulse. >>> tlist = np.array([0., 1., 2., 4.]); >>> coeff = np.array([0.5, 1.2, 0.8]); >>> spline_kind = ""step_func""; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=coeff, spline_kind=""step_func""). Create a time independent pulse. >>> Pulse(sigmaz(), 0, coeff=True). Create a constant pulse with time range. >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=True). Create an dummy Pulse (H=0). >>> Pulse(None, None). """"""; def __init__(self, qobj, targets, tlist=None, coeff=None,; spline_kind=None, label=None):; self.spline_kind = spline_kind; self.ideal_pulse = _EvoElement(qobj, targets, tlist, coeff); self.coherent_noise = []; self.lindblad_noise = []; self.label = label. @property; def qobj(self):; """"""; See parameter `qobj`.; """"""; return self.ideal_pulse.qobj. @qobj.setter; def qobj(self, x):; self.ideal_pulse.qobj = x. @property; def targets(self):; """"""; See parameter `targets`.; """"""; return self.ideal_pulse.targets. @targets.setter; def targets(self, x):; self.ideal_pulse.targets = x. @prop",MatchSource.WIKI,docs/4.5/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html:7714,Integrability,depend,dependent,7714," (H=0). >>> Pulse(None, None). """"""; def __init__(self, qobj, targets, tlist=None, coeff=None,; spline_kind=None, label=None):; self.spline_kind = spline_kind; self.ideal_pulse = _EvoElement(qobj, targets, tlist, coeff); self.coherent_noise = []; self.lindblad_noise = []; self.label = label. @property; def qobj(self):; """"""; See parameter `qobj`.; """"""; return self.ideal_pulse.qobj. @qobj.setter; def qobj(self, x):; self.ideal_pulse.qobj = x. @property; def targets(self):; """"""; See parameter `targets`.; """"""; return self.ideal_pulse.targets. @targets.setter; def targets(self, x):; self.ideal_pulse.targets = x. @property; def tlist(self):; """"""; See parameter `tlist`; """"""; return self.ideal_pulse.tlist. @tlist.setter; def tlist(self, x):; self.ideal_pulse.tlist = x. @property; def coeff(self):; """"""; See parameter `coeff`.; """"""; return self.ideal_pulse.coeff. @coeff.setter; def coeff(self, x):; self.ideal_pulse.coeff = x. [docs] def add_coherent_noise(self, qobj, targets, tlist=None, coeff=None):; """"""; Add a new (time-dependent) Hamiltonian to the coherent noise. Parameters; ----------; qobj: :class:'qutip.Qobj'; The Hamiltonian of the pulse.; targets: list; target qubits of the pulse; (or subquantum system of other dimensions).; tlist: array-like, optional; A list of time at which the time-dependent coefficients are; applied.; `tlist` does not have to be equidistant, but must have the same; length; or one element shorter compared to `coeff`. See documentation for; the parameter `spline_kind` of :class:`qutip.qip.Pulse`.; coeff: array-like or bool, optional; Time-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for; the parameter `spline_kind` of :class:`qutip.qip.Pulse`.; If a bool, the coefficient is a constant 1 or 0.; """"""; self.coherent_noise.append(_EvoElement(qobj, targets, tlist, coeff)). [docs] def add_lindblad_noise(self, qobj, targets, tlist=None, coeff=None):; """""";",MatchSource.WIKI,docs/4.5/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html:7992,Integrability,depend,dependent,7992," @property; def qobj(self):; """"""; See parameter `qobj`.; """"""; return self.ideal_pulse.qobj. @qobj.setter; def qobj(self, x):; self.ideal_pulse.qobj = x. @property; def targets(self):; """"""; See parameter `targets`.; """"""; return self.ideal_pulse.targets. @targets.setter; def targets(self, x):; self.ideal_pulse.targets = x. @property; def tlist(self):; """"""; See parameter `tlist`; """"""; return self.ideal_pulse.tlist. @tlist.setter; def tlist(self, x):; self.ideal_pulse.tlist = x. @property; def coeff(self):; """"""; See parameter `coeff`.; """"""; return self.ideal_pulse.coeff. @coeff.setter; def coeff(self, x):; self.ideal_pulse.coeff = x. [docs] def add_coherent_noise(self, qobj, targets, tlist=None, coeff=None):; """"""; Add a new (time-dependent) Hamiltonian to the coherent noise. Parameters; ----------; qobj: :class:'qutip.Qobj'; The Hamiltonian of the pulse.; targets: list; target qubits of the pulse; (or subquantum system of other dimensions).; tlist: array-like, optional; A list of time at which the time-dependent coefficients are; applied.; `tlist` does not have to be equidistant, but must have the same; length; or one element shorter compared to `coeff`. See documentation for; the parameter `spline_kind` of :class:`qutip.qip.Pulse`.; coeff: array-like or bool, optional; Time-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for; the parameter `spline_kind` of :class:`qutip.qip.Pulse`.; If a bool, the coefficient is a constant 1 or 0.; """"""; self.coherent_noise.append(_EvoElement(qobj, targets, tlist, coeff)). [docs] def add_lindblad_noise(self, qobj, targets, tlist=None, coeff=None):; """"""; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters; ----------; qobj: :class:'qutip.Qobj'; The collapse operator of the lindblad noise.; targets: list; target qubits of the collapse operator; (or subquantum system of other dimensions).; tlist: array-like, optional;",MatchSource.WIKI,docs/4.5/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html:8270,Integrability,depend,dependent,8270,"; self.ideal_pulse.targets = x. @property; def tlist(self):; """"""; See parameter `tlist`; """"""; return self.ideal_pulse.tlist. @tlist.setter; def tlist(self, x):; self.ideal_pulse.tlist = x. @property; def coeff(self):; """"""; See parameter `coeff`.; """"""; return self.ideal_pulse.coeff. @coeff.setter; def coeff(self, x):; self.ideal_pulse.coeff = x. [docs] def add_coherent_noise(self, qobj, targets, tlist=None, coeff=None):; """"""; Add a new (time-dependent) Hamiltonian to the coherent noise. Parameters; ----------; qobj: :class:'qutip.Qobj'; The Hamiltonian of the pulse.; targets: list; target qubits of the pulse; (or subquantum system of other dimensions).; tlist: array-like, optional; A list of time at which the time-dependent coefficients are; applied.; `tlist` does not have to be equidistant, but must have the same; length; or one element shorter compared to `coeff`. See documentation for; the parameter `spline_kind` of :class:`qutip.qip.Pulse`.; coeff: array-like or bool, optional; Time-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for; the parameter `spline_kind` of :class:`qutip.qip.Pulse`.; If a bool, the coefficient is a constant 1 or 0.; """"""; self.coherent_noise.append(_EvoElement(qobj, targets, tlist, coeff)). [docs] def add_lindblad_noise(self, qobj, targets, tlist=None, coeff=None):; """"""; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters; ----------; qobj: :class:'qutip.Qobj'; The collapse operator of the lindblad noise.; targets: list; target qubits of the collapse operator; (or subquantum system of other dimensions).; tlist: array-like, optional; A list of time at which the time-dependent coefficients are; applied.; `tlist` does not have to be equidistant, but must have the same; length; or one element shorter compared to `coeff`.; See documentation for; the parameter `spline_kind` of :class:`qutip.qip.Pulse`.; coeff: array-like or",MatchSource.WIKI,docs/4.5/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html:8704,Integrability,depend,dependent,8704," coeff=None):; """"""; Add a new (time-dependent) Hamiltonian to the coherent noise. Parameters; ----------; qobj: :class:'qutip.Qobj'; The Hamiltonian of the pulse.; targets: list; target qubits of the pulse; (or subquantum system of other dimensions).; tlist: array-like, optional; A list of time at which the time-dependent coefficients are; applied.; `tlist` does not have to be equidistant, but must have the same; length; or one element shorter compared to `coeff`. See documentation for; the parameter `spline_kind` of :class:`qutip.qip.Pulse`.; coeff: array-like or bool, optional; Time-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for; the parameter `spline_kind` of :class:`qutip.qip.Pulse`.; If a bool, the coefficient is a constant 1 or 0.; """"""; self.coherent_noise.append(_EvoElement(qobj, targets, tlist, coeff)). [docs] def add_lindblad_noise(self, qobj, targets, tlist=None, coeff=None):; """"""; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters; ----------; qobj: :class:'qutip.Qobj'; The collapse operator of the lindblad noise.; targets: list; target qubits of the collapse operator; (or subquantum system of other dimensions).; tlist: array-like, optional; A list of time at which the time-dependent coefficients are; applied.; `tlist` does not have to be equidistant, but must have the same; length; or one element shorter compared to `coeff`.; See documentation for; the parameter `spline_kind` of :class:`qutip.qip.Pulse`.; coeff: array-like or bool, optional; Time-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for; the parameter `spline_kind` of :class:`qutip.qip.Pulse`.; If a bool, the coefficient is a constant 1 or 0.; """"""; self.lindblad_noise.append(_EvoElement(qobj, targets, tlist, coeff)). [docs] def get_ideal_qobj(self, dims):; """"""; Get the",MatchSource.WIKI,docs/4.5/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html:9012,Integrability,depend,dependent,9012,"ent coefficients are; applied.; `tlist` does not have to be equidistant, but must have the same; length; or one element shorter compared to `coeff`. See documentation for; the parameter `spline_kind` of :class:`qutip.qip.Pulse`.; coeff: array-like or bool, optional; Time-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for; the parameter `spline_kind` of :class:`qutip.qip.Pulse`.; If a bool, the coefficient is a constant 1 or 0.; """"""; self.coherent_noise.append(_EvoElement(qobj, targets, tlist, coeff)). [docs] def add_lindblad_noise(self, qobj, targets, tlist=None, coeff=None):; """"""; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters; ----------; qobj: :class:'qutip.Qobj'; The collapse operator of the lindblad noise.; targets: list; target qubits of the collapse operator; (or subquantum system of other dimensions).; tlist: array-like, optional; A list of time at which the time-dependent coefficients are; applied.; `tlist` does not have to be equidistant, but must have the same; length; or one element shorter compared to `coeff`.; See documentation for; the parameter `spline_kind` of :class:`qutip.qip.Pulse`.; coeff: array-like or bool, optional; Time-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for; the parameter `spline_kind` of :class:`qutip.qip.Pulse`.; If a bool, the coefficient is a constant 1 or 0.; """"""; self.lindblad_noise.append(_EvoElement(qobj, targets, tlist, coeff)). [docs] def get_ideal_qobj(self, dims):; """"""; Get the Hamiltonian of the ideal pulse. Parameters; ----------; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns; -------; qobj: :class:`qutip.Qobj`; The Hamiltonian of the ideal pulse.; """"""; return self.id",MatchSource.WIKI,docs/4.5/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html:9291,Integrability,depend,dependent,9291,"ts of the pulse noise.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for; the parameter `spline_kind` of :class:`qutip.qip.Pulse`.; If a bool, the coefficient is a constant 1 or 0.; """"""; self.coherent_noise.append(_EvoElement(qobj, targets, tlist, coeff)). [docs] def add_lindblad_noise(self, qobj, targets, tlist=None, coeff=None):; """"""; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters; ----------; qobj: :class:'qutip.Qobj'; The collapse operator of the lindblad noise.; targets: list; target qubits of the collapse operator; (or subquantum system of other dimensions).; tlist: array-like, optional; A list of time at which the time-dependent coefficients are; applied.; `tlist` does not have to be equidistant, but must have the same; length; or one element shorter compared to `coeff`.; See documentation for; the parameter `spline_kind` of :class:`qutip.qip.Pulse`.; coeff: array-like or bool, optional; Time-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for; the parameter `spline_kind` of :class:`qutip.qip.Pulse`.; If a bool, the coefficient is a constant 1 or 0.; """"""; self.lindblad_noise.append(_EvoElement(qobj, targets, tlist, coeff)). [docs] def get_ideal_qobj(self, dims):; """"""; Get the Hamiltonian of the ideal pulse. Parameters; ----------; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns; -------; qobj: :class:`qutip.Qobj`; The Hamiltonian of the ideal pulse.; """"""; return self.ideal_pulse.get_qobj(dims). [docs] def get_ideal_qobjevo(self, dims):; """"""; Get a `QobjEvo` representation of the ideal evolution. Parameters; ----------; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of t",MatchSource.WIKI,docs/4.5/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html:11007,Integrability,depend,dependent,11007,"et_qobj(dims). [docs] def get_ideal_qobjevo(self, dims):; """"""; Get a `QobjEvo` representation of the ideal evolution. Parameters; ----------; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns; -------; ideal_evo: :class:`qutip.QobjEvo`; A `QobjEvo` representing the ideal evolution.; """"""; return self.ideal_pulse.get_qobjevo(self.spline_kind, dims). [docs] def get_noisy_qobjevo(self, dims):; """"""; Get the `QobjEvo` representation of the noisy evolution. The result; can be used directly as input for the qutip solvers. Parameters; ----------; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns; -------; noisy_evo: :class:`qutip.QobjEvo`; A `QobjEvo` representing the ideal evolution and coherent noise.; c_ops: list of :class:`qutip.QobjEvo`; A list of (time-dependent) lindbald operators.; """"""; ideal_qu = self.get_ideal_qobjevo(dims); noise_qu_list = [noise.get_qobjevo(self.spline_kind, dims); for noise in self.coherent_noise]; qu = _merge_qobjevo([ideal_qu] + noise_qu_list); c_ops = [noise.get_qobjevo(self.spline_kind, dims); for noise in self.lindblad_noise]; full_tlist = self.get_full_tlist(); qu = _merge_qobjevo([qu], full_tlist); for i, c_op in enumerate(c_ops):; c_ops[i] = _merge_qobjevo([c_op], full_tlist); return qu, c_ops. [docs] def get_full_tlist(self):; """"""; Return the full tlist of the pulses and noise.; It means that if different `tlist`s are present, they will be merged; to one with all time points stored in a sorted array. Returns; -------; full_tlist: array-like 1d; The full time sequence for the nosiy evolution.; """"""; # TODO add test; all_tlists = []; all_tlists.append(self.ideal_pulse.tlist); for pulse in self.coherent_noise:; all_tlists.append(pulse.tlist); for c_op in self.lindblad_noise:; all_tlists.append(c_op.tlist); ",MatchSource.WIKI,docs/4.5/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html:15545,Integrability,integrat,integrated,15545,"ise; for the drift evolution. Returns; -------; noisy_evo: :class:`qutip.QobjEvo`; A `QobjEvo` representing the ideal evolution and coherent noise.; c_ops: list of :class:`qutip.QobjEvo`; Always an empty list for Drift; """"""; return self.get_ideal_qobjevo(dims), []. def _find_common_tlist(qobjevo_list):; """"""; Find the common `tlist` of a list of :class:`qutip.QobjEvo`.; """"""; all_tlists = [qu.tlist for qu in qobjevo_list; if isinstance(qu, QobjEvo) and qu.tlist is not None]; if not all_tlists:; return None; full_tlist = np.unique(np.sort(np.hstack(all_tlists))); return full_tlist. ########################################################################; # These functions are moved here from qutip.qip.device.processor.py; ########################################################################. def _merge_qobjevo(qobjevo_list, full_tlist=None):; """"""; Combine a list of `:class:qutip.QobjEvo` into one,; different tlist will be merged.; """"""; # TODO This method can be eventually integrated into QobjEvo, for; # which a more thorough test is required. # no qobjevo; if not qobjevo_list:; raise ValueError(""qobjevo_list is empty.""). if full_tlist is None:; full_tlist = _find_common_tlist(qobjevo_list); spline_types_num = set(); args = {}; for qu in qobjevo_list:; if isinstance(qu, QobjEvo):; try:; spline_types_num.add(qu.args[""_step_func_coeff""]); except Exception:; pass; args.update(qu.args); if len(spline_types_num) > 1:; raise ValueError(""Cannot merge Qobjevo with different spline kinds.""). for i, qobjevo in enumerate(qobjevo_list):; if isinstance(qobjevo, Qobj):; qobjevo_list[i] = QobjEvo(qobjevo); qobjevo = qobjevo_list[i]; for j, ele in enumerate(qobjevo.ops):; if isinstance(ele.coeff, np.ndarray):; new_coeff = _fill_coeff(; ele.coeff, qobjevo.tlist, full_tlist, args); qobjevo_list[i].ops[j].coeff = new_coeff; qobjevo_list[i].tlist = full_tlist. qobjevo = sum(qobjevo_list); return qobjevo. def _fill_coeff(old_coeffs, old_tlist, full_tlist, args=None):; """"""; Make a step fun",MatchSource.WIKI,docs/4.5/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html:719,Modifiability,variab,variables,719,". . qutip.qip.pulse — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Module code »; qutip.qip.pulse. Source code for qutip.qip.pulse; from copy import deepcopy. import numpy as np; from scipy.interpolate import CubicSpline. from qutip.qobjevo import QobjEvo; from qutip.qobj import Qobj; from qutip.qip.operations import expand_operator; from qutip.operators import identity. __all__ = [""Pulse"", ""Drift""]. class _EvoElement():; """"""; The class object saving the information of one evolution element.; Each dynamic element is characterized by four variables:; `qobj`, `targets`, `tlist` and `coeff`. For documentation and use instruction of the attributes, please; refer to :class:`qutip.qip.Pulse`.; """"""; def __init__(self, qobj, targets, tlist=None, coeff=None):; self.qobj = qobj; self.targets = targets; self.tlist = tlist; self.coeff = coeff. def get_qobj(self, dims):; """"""; Get the `Qobj` representation of the element. If `qobj` is None,; a zero :class:`qutip.Qobj` with the corresponding dimension is; returned. Parameters; ----------; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns; -------; qobj: :class:`qutip.Qobj`; The operator of this element.; """"""; if isinstance(dims, (int, np.integer)):; dims = [2] * dims; if self.qobj is None:; qobj = identity(dims[0]) * 0.; targets = 0; else:; qobj = self.qobj; targets = self.targets; return expand_operator(qobj, len(dims), targets, dims). def _get_qobjevo_helper(self, spline_kind, dims):; """"""; Please refer to `_Evoelement.get_qobjevo` for documentation.; """"""; mat = self.get_qobj(dims); if self.tlist is None and self.coeff is None:; qu = QobjEvo(mat) * 0.; elif isinstance(self.coeff, bool):; if self.coeff:; if self.tlist is None:; qu = QobjEvo(ma",MatchSource.WIKI,docs/4.5/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html:4172,Modifiability,variab,variables,4172," last element of `coeff` has no effect. -""cubic"": Use cubic interpolation for the coefficient. It requires; ``len(coeff)=len(tlist)``; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns; -------; qobjevo: :class:`qutip.QobjEvo`; The `QobjEvo` representation of the evolution element.; """"""; try:; return self._get_qobjevo_helper(spline_kind, dims=dims); except Exception as err:; print(; ""The Evolution element went wrong was\n {}"".format(str(self))); raise(err). def __str__(self):; return str({""qobj"": self.qobj,; ""targets"": self.targets,; ""tlist"": self.tlist,; ""coeff"": self.coeff; }). [docs]class Pulse():; """"""; Representation of a control pulse and the pulse dependent noise.; The pulse is characterized by the ideal control pulse, the coherent; noise and the lindblad noise. The later two are lists of; noisy evolution dynamics.; Each dynamic element is characterized by four variables:; `qobj`, `targets`, `tlist` and `coeff`. See examples for different construction behavior. Parameters; ----------; qobj: :class:'qutip.Qobj'; The Hamiltonian of the ideal pulse.; targets: list; target qubits of the ideal pulse; (or subquantum system of other dimensions).; tlist: array-like, optional; `tlist` of the ideal pulse.; A list of time at which the time-dependent coefficients are applied.; `tlist` does not have to be equidistant, but must have the same length; or one element shorter compared to `coeff`. See documentation for; the parameter `spline_kind`.; coeff: array-like or bool, optional; Time-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for the parameter `spline_kind`.; If a bool, the coefficient is a constant 1 or 0.; spline_kind: str, optional; Type of the coefficient interpolation:; ""step_func"" or ""cubic"". -""step_func"":; The coefficient will be treated ",MatchSource.WIKI,docs/4.5/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html:13125,Performance,tune,tuned,13125,"sts:; return None; full_tlist = np.unique(np.sort(np.hstack(all_tlists))); return full_tlist. [docs] def print_info(self):; """"""; Print the information of the pulse, including the ideal dynamics,; the coherent noise and the lindblad noise.; """"""; print(""-----------------------------------""; ""-----------------------------------""); if self.label is not None:; print(""Pulse label:"", self.label); print(""The pulse contains: {} coherent noise elements and {} ""; ""Lindblad noise elements."".format(; len(self.coherent_noise), len(self.lindblad_noise))); print(); print(""Ideal pulse:""); print(self.ideal_pulse); if self.coherent_noise:; print(); print(""Coherent noise:""); for ele in self.coherent_noise:; print(ele); if self.lindblad_noise:; print(); print(""Lindblad noise:""); for ele in self.lindblad_noise:; print(ele); print(""-----------------------------------""; ""-----------------------------------""). class Drift():; """"""; The time independent drift Hamiltonian. Usually its the intrinsic; evolution of the quantum system that can not be tuned. Parameters; ----------; qobj: :class:`qutip.Qobj` or list of :class:`qutip.Qobj`, optional; The drift Hamiltonians. Attributes; ----------; qobj: list of :class:`qutip.Qobj`; A list of the the drift Hamiltonians.; """"""; def __init__(self, qobj=None):; if qobj is None:; self.drift_hamiltonians = []; elif isinstance(qobj, list):; self.drift_hamiltonians = qobj; else:; self.drift_hamiltonians = [qobj]. def add_drift(self, qobj, targets):; """"""; Add a Hamiltonian to the drift. Parameters; ----------; qobj: :class:'qutip.Qobj'; The collapse operator of the lindblad noise.; targets: list; target qubits of the collapse operator; (or subquantum system of other dimensions).; """"""; self.drift_hamiltonians.append(_EvoElement(qobj, targets)). def get_ideal_qobjevo(self, dims):; """"""; Get the QobjEvo representation of the drift Hamiltonian. Parameters; ----------; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the s",MatchSource.WIKI,docs/4.5/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html:11811,Testability,test,test,11811,"nent systems. Returns; -------; noisy_evo: :class:`qutip.QobjEvo`; A `QobjEvo` representing the ideal evolution and coherent noise.; c_ops: list of :class:`qutip.QobjEvo`; A list of (time-dependent) lindbald operators.; """"""; ideal_qu = self.get_ideal_qobjevo(dims); noise_qu_list = [noise.get_qobjevo(self.spline_kind, dims); for noise in self.coherent_noise]; qu = _merge_qobjevo([ideal_qu] + noise_qu_list); c_ops = [noise.get_qobjevo(self.spline_kind, dims); for noise in self.lindblad_noise]; full_tlist = self.get_full_tlist(); qu = _merge_qobjevo([qu], full_tlist); for i, c_op in enumerate(c_ops):; c_ops[i] = _merge_qobjevo([c_op], full_tlist); return qu, c_ops. [docs] def get_full_tlist(self):; """"""; Return the full tlist of the pulses and noise.; It means that if different `tlist`s are present, they will be merged; to one with all time points stored in a sorted array. Returns; -------; full_tlist: array-like 1d; The full time sequence for the nosiy evolution.; """"""; # TODO add test; all_tlists = []; all_tlists.append(self.ideal_pulse.tlist); for pulse in self.coherent_noise:; all_tlists.append(pulse.tlist); for c_op in self.lindblad_noise:; all_tlists.append(c_op.tlist); all_tlists = [tlist for tlist in all_tlists if tlist is not None]; if not all_tlists:; return None; full_tlist = np.unique(np.sort(np.hstack(all_tlists))); return full_tlist. [docs] def print_info(self):; """"""; Print the information of the pulse, including the ideal dynamics,; the coherent noise and the lindblad noise.; """"""; print(""-----------------------------------""; ""-----------------------------------""); if self.label is not None:; print(""Pulse label:"", self.label); print(""The pulse contains: {} coherent noise elements and {} ""; ""Lindblad noise elements."".format(; len(self.coherent_noise), len(self.lindblad_noise))); print(); print(""Ideal pulse:""); print(self.ideal_pulse); if self.coherent_noise:; print(); print(""Coherent noise:""); for ele in self.coherent_noise:; print(ele); if self.lindblad_noi",MatchSource.WIKI,docs/4.5/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html:15599,Testability,test,test,15599,"ise; for the drift evolution. Returns; -------; noisy_evo: :class:`qutip.QobjEvo`; A `QobjEvo` representing the ideal evolution and coherent noise.; c_ops: list of :class:`qutip.QobjEvo`; Always an empty list for Drift; """"""; return self.get_ideal_qobjevo(dims), []. def _find_common_tlist(qobjevo_list):; """"""; Find the common `tlist` of a list of :class:`qutip.QobjEvo`.; """"""; all_tlists = [qu.tlist for qu in qobjevo_list; if isinstance(qu, QobjEvo) and qu.tlist is not None]; if not all_tlists:; return None; full_tlist = np.unique(np.sort(np.hstack(all_tlists))); return full_tlist. ########################################################################; # These functions are moved here from qutip.qip.device.processor.py; ########################################################################. def _merge_qobjevo(qobjevo_list, full_tlist=None):; """"""; Combine a list of `:class:qutip.QobjEvo` into one,; different tlist will be merged.; """"""; # TODO This method can be eventually integrated into QobjEvo, for; # which a more thorough test is required. # no qobjevo; if not qobjevo_list:; raise ValueError(""qobjevo_list is empty.""). if full_tlist is None:; full_tlist = _find_common_tlist(qobjevo_list); spline_types_num = set(); args = {}; for qu in qobjevo_list:; if isinstance(qu, QobjEvo):; try:; spline_types_num.add(qu.args[""_step_func_coeff""]); except Exception:; pass; args.update(qu.args); if len(spline_types_num) > 1:; raise ValueError(""Cannot merge Qobjevo with different spline kinds.""). for i, qobjevo in enumerate(qobjevo_list):; if isinstance(qobjevo, Qobj):; qobjevo_list[i] = QobjEvo(qobjevo); qobjevo = qobjevo_list[i]; for j, ele in enumerate(qobjevo.ops):; if isinstance(ele.coeff, np.ndarray):; new_coeff = _fill_coeff(; ele.coeff, qobjevo.tlist, full_tlist, args); qobjevo_list[i].ops[j].coeff = new_coeff; qobjevo_list[i].tlist = full_tlist. qobjevo = sum(qobjevo_list); return qobjevo. def _fill_coeff(old_coeffs, old_tlist, full_tlist, args=None):; """"""; Make a step fun",MatchSource.WIKI,docs/4.5/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.5/modules/qutip/qip/qubits.html:2850,Deployability,update,updated,2850,"rials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['qubit_states']. from qutip.tensor import tensor; from numpy import sqrt; from qutip.states import basis. [docs]def qubit_states(N=1, states=[0]):; """"""; Function to define initial state of the qubits. Parameters; ----------; N : Integer; Number of qubits in the register.; states : List; Initial state of each qubit. Returns; ----------; qstates : Qobj; List of qubits. """"""; state_list = []; for i in range(N):; if N > len(states) and i >= len(states):; state_list.append(0); else:; state_list.append(states[i]). return tensor([alpha * basis(2, 1) + sqrt(1 - alpha**2) * basis(2, 0); for alpha in state_list]). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/qip/qubits.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/qubits.html
https://qutip.org/docs/4.5/modules/qutip/qip/algorithms/qft.html:4662,Deployability,update,updated,4662,"arr, arr); L = phase * (L * M); L = np.exp(L); dims = [[2] * N, [2] * N]; return Qobj(1.0 / np.sqrt(N2) * L, dims=dims). [docs]def qft_steps(N=1, swapping=True):; """"""; Quantum Fourier Transform operator on N qubits returning the individual; steps as unitary matrices operating from left to right. Parameters; ----------; N: int; Number of qubits.; swap: boolean; Flag indicating sequence of swap gates to be applied at the end or not. Returns; -------; U_step_list: list of qobj; List of Hadamard and controlled rotation gates implementing QFT. """"""; if N < 1:; raise ValueError(""Minimum value of N can be 1""). U_step_list = []; if N == 1:; U_step_list.append(snot()); else:; for i in range(N):; for j in range(i):; U_step_list.append(cphase(np.pi / (2 ** (i - j)), N,; control=i, target=j)); U_step_list.append(snot(N, i)); if swapping:; for i in range(N // 2):; U_step_list.append(swap(N, [N - i - 1, i])). return U_step_list. [docs]def qft_gate_sequence(N=1, swapping=True):; """"""; Quantum Fourier Transform operator on N qubits returning the gate sequence. Parameters; ----------; N: int; Number of qubits.; swap: boolean; Flag indicating sequence of swap gates to be applied at the end or not. Returns; -------; qc: instance of QubitCircuit; Gate sequence of Hadamard and controlled rotation gates implementing; QFT.; """""". if N < 1:; raise ValueError(""Minimum value of N can be 1""). qc = QubitCircuit(N); if N == 1:; qc.add_gate(""SNOT"", targets=[0]); else:; for i in range(N):; for j in range(i):; qc.add_gate(""CPHASE"", targets=[j], controls=[i],; arg_label=r""{\pi/2^{%d}}"" % (i - j),; arg_value=np.pi / (2 ** (i - j))); qc.add_gate(""SNOT"", targets=[i]); if swapping:; for i in range(N // 2):; qc.add_gate(""SWAP"", targets=[N - i - 1, i]). return qc. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/qip/algorithms/qft.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/algorithms/qft.html
https://qutip.org/docs/4.5/modules/qutip/qip/device/modelprocessor.html:2643,Availability,avail,available,2643,"T NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from collections.abc import Iterable; import numbers. import numpy as np. from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.qip.operations.gates import globalphase; from qutip.tensor import tensor; from qutip.mesolve import mesolve; from qutip.qip.circuit import QubitCircuit; from qutip.qip.device.processor import Processor. __all__ = ['ModelProcessor']. [docs]class ModelProcessor(Processor):; """"""; The base class for a circuit processor simulating a physical device,; e.g cavityQED, spinchain.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically.; It cannot be used alone, please refer to the sub-classes.; (Only additional attributes are documented here, for others please; refer to the parent class :class:`qutip.qip.device.Processor`). Parameters; ----------; N: int; The number of component systems. correct_global_phase: boolean, optional; If true, the analytical solution will track the global phase. It; has no effect on the numerical solution. t1: list or float; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all qubits. t2: list of float; Characterize the decoherence of dephasing for; each qubit. A list of size `N` or a float for all qubits. Attributes; ----------; params: dict; A Python dictionary contains the name and the value of the parameters; in the physical realization, such as laser frequency, detuning etc. correct_global_phase: f",MatchSource.WIKI,docs/4.5/modules/qutip/qip/device/modelprocessor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/modelprocessor.html
https://qutip.org/docs/4.5/modules/qutip/qip/device/modelprocessor.html:7968,Deployability,update,updated,7968,"ix; """"""; return (self.ctrls, self.get_full_coeffs().T). [docs] def pulse_matrix(self):; """"""; Generates the pulse matrix for the desired physical system. Returns; -------; t, u, labels:; Returns the total time and label for every operation.; """"""; dt = 0.01; H_ops, H_u = self.get_ops_and_u(). # FIXME This might becomes a problem if new tlist other than; # int the default pulses are added.; tlist = self.get_full_tlist(); diff_tlist = tlist[1:] - tlist[:-1]; t_tot = sum(diff_tlist); n_t = int(np.ceil(t_tot / dt)); n_ops = len(H_ops). t = np.linspace(0, t_tot, n_t); u = np.zeros((n_ops, n_t)). t_start = 0; for n in range(len(diff_tlist)):. t_idx_len = int(np.floor(diff_tlist[n] / dt)). mm = 0; for m in range(len(H_ops)):; u[mm, t_start:(t_start + t_idx_len)] = (np.ones(t_idx_len) *; H_u[n, m]); mm += 1. t_start += t_idx_len. return t, u, self.get_ops_labels(). [docs] def plot_pulses(self, title=None, noisy=None, figsize=(12, 6), dpi=None):; """"""; Maps the physical interaction between the circuit components for the; desired physical system. Returns; -------; fig, ax: Figure; Maps the physical interaction between the circuit components.; """"""; # TODO add test; if noisy is not None:; return super(ModelProcessor, self).plot_pulses(; title=title, noisy=noisy); import matplotlib.pyplot as plt; t, u, u_labels = self.pulse_matrix(); fig, ax = plt.subplots(1, 1, figsize=figsize, dpi=dpi). for n, uu in enumerate(u):; ax.plot(t, u[n], label=u_labels[n]). ax.axis('tight'); ax.set_ylim(-1.5 * 2 * np.pi, 1.5 * 2 * np.pi); ax.legend(loc='center left',; bbox_to_anchor=(1, 0.5), ncol=(1 + len(u) // 16)); ax.set_ylabel(""Control pulse amplitude""); ax.set_xlabel(""Time""); if title is not None:; ax.set_title(title); fig.tight_layout(); return fig, ax. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/qip/device/modelprocessor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/modelprocessor.html
https://qutip.org/docs/4.5/modules/qutip/qip/device/modelprocessor.html:7221,Testability,test,test,7221,"ix; """"""; return (self.ctrls, self.get_full_coeffs().T). [docs] def pulse_matrix(self):; """"""; Generates the pulse matrix for the desired physical system. Returns; -------; t, u, labels:; Returns the total time and label for every operation.; """"""; dt = 0.01; H_ops, H_u = self.get_ops_and_u(). # FIXME This might becomes a problem if new tlist other than; # int the default pulses are added.; tlist = self.get_full_tlist(); diff_tlist = tlist[1:] - tlist[:-1]; t_tot = sum(diff_tlist); n_t = int(np.ceil(t_tot / dt)); n_ops = len(H_ops). t = np.linspace(0, t_tot, n_t); u = np.zeros((n_ops, n_t)). t_start = 0; for n in range(len(diff_tlist)):. t_idx_len = int(np.floor(diff_tlist[n] / dt)). mm = 0; for m in range(len(H_ops)):; u[mm, t_start:(t_start + t_idx_len)] = (np.ones(t_idx_len) *; H_u[n, m]); mm += 1. t_start += t_idx_len. return t, u, self.get_ops_labels(). [docs] def plot_pulses(self, title=None, noisy=None, figsize=(12, 6), dpi=None):; """"""; Maps the physical interaction between the circuit components for the; desired physical system. Returns; -------; fig, ax: Figure; Maps the physical interaction between the circuit components.; """"""; # TODO add test; if noisy is not None:; return super(ModelProcessor, self).plot_pulses(; title=title, noisy=noisy); import matplotlib.pyplot as plt; t, u, u_labels = self.pulse_matrix(); fig, ax = plt.subplots(1, 1, figsize=figsize, dpi=dpi). for n, uu in enumerate(u):; ax.plot(t, u[n], label=u_labels[n]). ax.axis('tight'); ax.set_ylim(-1.5 * 2 * np.pi, 1.5 * 2 * np.pi); ax.legend(loc='center left',; bbox_to_anchor=(1, 0.5), ncol=(1 + len(u) // 16)); ax.set_ylabel(""Control pulse amplitude""); ax.set_xlabel(""Time""); if title is not None:; ax.set_title(title); fig.tight_layout(); return fig, ax. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/qip/device/modelprocessor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/modelprocessor.html
https://qutip.org/docs/4.5/modules/qutip/qip/device/modelprocessor.html:4449,Usability,simpl,simplicity,4449,"ts. Attributes; ----------; params: dict; A Python dictionary contains the name and the value of the parameters; in the physical realization, such as laser frequency, detuning etc. correct_global_phase: float; Save the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution.; """"""; def __init__(self, N, correct_global_phase=True, t1=None, t2=None):; super(ModelProcessor, self).__init__(N, t1=t1, t2=t2); self.correct_global_phase = correct_global_phase; self.global_phase = 0.; self._paras = {}. def _para_list(self, para, N):; """"""; Transfer a parameter to list form and multiplied by 2*pi.; """"""; if isinstance(para, numbers.Real):; return [para * 2 * np.pi] * N; elif isinstance(para, Iterable):; return [c * 2 * np.pi for c in para]. [docs] def set_up_params(self):; """"""; Save the parameters in the attribute `params` and check the validity.; (Defined in subclasses). Notes; -----; All parameters will be multiplied by 2*pi for simplicity; """"""; raise NotImplementedError(""Parameters should be defined in subclass.""). @property; def params(self):; return self._paras. @params.setter; def params(self, par):; self.set_up_params(**par). [docs] def run_state(self, init_state=None, analytical=False, qc=None,; states=None, **kwargs):; """"""; If `analytical` is False, use :func:`qutip.mesolve` to; calculate the time of the state evolution; and return the result. Other arguments of mesolve can be; given as keyword arguments.; If `analytical` is True, calculate the propagator; with matrix exponentiation and return a list of matrices. Parameters; ----------; init_state: Qobj; Initial density matrix or state vector (ket). analytical: boolean; If True, calculate the evolution with matrices exponentiation. qc: :class:`qutip.qip.QubitCircuit`, optional; A quantum circuit. If given, it first calls the ``load_circuit``; and then calculate the evolution. states: :class:`qutip.Qobj`, optional; Old API, same as init_state. **kwargs; Keyword argu",MatchSource.WIKI,docs/4.5/modules/qutip/qip/device/modelprocessor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/modelprocessor.html
https://qutip.org/docs/4.5/modules/qutip/qip/device/optpulseprocessor.html:2668,Availability,avail,available,2668,"AL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from collections.abc import Iterable; import warnings; import numbers. import numpy as np. from qutip.qobj import Qobj; import qutip.control.pulseoptim as cpo; from qutip.operators import identity; from qutip.tensor import tensor; from qutip.mesolve import mesolve; from qutip.qip.circuit import QubitCircuit; from qutip.qip.device.processor import Processor; from qutip.qip.operations.gates import gate_sequence_product. __all__ = ['OptPulseProcessor']. [docs]class OptPulseProcessor(Processor):; """"""; A processor, which takes the Hamiltonian available; as dynamic generators, calls the; `qutip.control.optimize_pulse_unitary` function; to find an optimized pulse sequence for the desired quantum circuit.; The processor can simulate the evolution under the given; control pulses using :func:`qutip.mesolve`.; (For attributes documentation, please; refer to the parent class :class:`qutip.qip.device.Processor`). Parameters; ----------; N: int; The number of component systems. drift: `:class:`qutip.Qobj`; The drift Hamiltonian. The size must match the whole quantum system. t1: list or float; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all qubits. t2: list of float; Characterize the decoherence of dephasing for; each qubit. A list of size `N` or a float for all qubits. dims: list; The dimension of each component system.; Default value is a; qubit system of ``dim=[2,2,2,...,2]``; """"""; def __init__(self, N, drift=None, t1=None, t2=None, dims=None):; super(OptP",MatchSource.WIKI,docs/4.5/modules/qutip/qip/device/optpulseprocessor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/optpulseprocessor.html
https://qutip.org/docs/4.5/modules/qutip/qip/device/optpulseprocessor.html:5506,Availability,toler,tolerance,5506,"sigmaz(), ctrls=[sigmax()]); # num_tslots and evo_time are two keyword arguments; tlist, coeffs = processor.load_circuit(; qc, num_tslots=num_tslots, evo_time=evo_time). # Different parameters for different gates; qc = QubitCircuit(N=2); qc.add_gate(""SNOT"", 0); qc.add_gate(""SWAP"", targets=[0, 1]); qc.add_gate('CNOT', controls=1, targets=[0]). processor = OptPulseProcessor(N=2, drift=tensor([sigmaz()]*2)); processor.add_control(sigmax(), cyclic_permutation=True); processor.add_control(sigmay(), cyclic_permutation=True); processor.add_control(tensor([sigmay(), sigmay()])); setting_args = {""SNOT"": {""num_tslots"": 10, ""evo_time"": 1},; ""SWAP"": {""num_tslots"": 30, ""evo_time"": 3},; ""CNOT"": {""num_tslots"": 30, ""evo_time"": 3}}; tlist, coeffs = processor.load_circuit(qc, setting_args=setting_args,; merge_gates=False). Parameters; ----------; qc: :class:`qutip.QubitCircuit` or list of Qobj; The quantum circuit to be translated. min_fid_err: float, optional; The minimal fidelity tolerance, if the fidelity error of any; gate decomposition is higher, a warning will be given.; Default is infinite. merge_gates: boolean, optimal; If True, merge all gate/Qobj into one Qobj and then; find the optimal pulses for this unitary matrix. If False,; find the optimal pulses for each gate/Qobj. setting_args: dict, optional; Only considered if merge_gates is False.; It is a dictionary containing keyword arguments; for different gates. E.g:; setting_args = {""SNOT"": {""num_tslots"": 10, ""evo_time"": 1},; ""SWAP"": {""num_tslots"": 30, ""evo_time"": 3},; ""CNOT"": {""num_tslots"": 30, ""evo_time"": 3}}. verbose: boolean, optional; If true, the information for each decomposed gate; will be shown. Default is False. **kwargs; keyword arguments for `qutip.control.optimize_pulse_unitary`. Returns; -------; tlist: array_like; A NumPy array specifies the time of each coefficient. coeffs: array_like; A 2d NumPy array of the shape (len(ctrls), len(tlist)-1). Each; row corresponds to the control pulse sequence for; one Hamilt",MatchSource.WIKI,docs/4.5/modules/qutip/qip/device/optpulseprocessor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/optpulseprocessor.html
https://qutip.org/docs/4.5/modules/qutip/qip/device/optpulseprocessor.html:5533,Availability,error,error,5533,"sigmaz(), ctrls=[sigmax()]); # num_tslots and evo_time are two keyword arguments; tlist, coeffs = processor.load_circuit(; qc, num_tslots=num_tslots, evo_time=evo_time). # Different parameters for different gates; qc = QubitCircuit(N=2); qc.add_gate(""SNOT"", 0); qc.add_gate(""SWAP"", targets=[0, 1]); qc.add_gate('CNOT', controls=1, targets=[0]). processor = OptPulseProcessor(N=2, drift=tensor([sigmaz()]*2)); processor.add_control(sigmax(), cyclic_permutation=True); processor.add_control(sigmay(), cyclic_permutation=True); processor.add_control(tensor([sigmay(), sigmay()])); setting_args = {""SNOT"": {""num_tslots"": 10, ""evo_time"": 1},; ""SWAP"": {""num_tslots"": 30, ""evo_time"": 3},; ""CNOT"": {""num_tslots"": 30, ""evo_time"": 3}}; tlist, coeffs = processor.load_circuit(qc, setting_args=setting_args,; merge_gates=False). Parameters; ----------; qc: :class:`qutip.QubitCircuit` or list of Qobj; The quantum circuit to be translated. min_fid_err: float, optional; The minimal fidelity tolerance, if the fidelity error of any; gate decomposition is higher, a warning will be given.; Default is infinite. merge_gates: boolean, optimal; If True, merge all gate/Qobj into one Qobj and then; find the optimal pulses for this unitary matrix. If False,; find the optimal pulses for each gate/Qobj. setting_args: dict, optional; Only considered if merge_gates is False.; It is a dictionary containing keyword arguments; for different gates. E.g:; setting_args = {""SNOT"": {""num_tslots"": 10, ""evo_time"": 1},; ""SWAP"": {""num_tslots"": 30, ""evo_time"": 3},; ""CNOT"": {""num_tslots"": 30, ""evo_time"": 3}}. verbose: boolean, optional; If true, the information for each decomposed gate; will be shown. Default is False. **kwargs; keyword arguments for `qutip.control.optimize_pulse_unitary`. Returns; -------; tlist: array_like; A NumPy array specifies the time of each coefficient. coeffs: array_like; A 2d NumPy array of the shape (len(ctrls), len(tlist)-1). Each; row corresponds to the control pulse sequence for; one Hamilt",MatchSource.WIKI,docs/4.5/modules/qutip/qip/device/optpulseprocessor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/optpulseprocessor.html
https://qutip.org/docs/4.5/modules/qutip/qip/device/optpulseprocessor.html:7787,Availability,error,error,7787,"qc, Iterable):; props = qc; gates = None # using list of Qobj, no gates name; else:; raise ValueError(; ""qc should be a ""; ""QubitCircuit or a list of Qobj""); if merge_gates: # merge all gates/Qobj into one Qobj; props = [gate_sequence_product(props)]; gates = None. time_record = [] # a list for all the gates; coeff_record = []; last_time = 0. # used in concatenation of tlist; for prop_ind, U_targ in enumerate(props):; U_0 = identity(U_targ.dims[0]). # If qc is a QubitCircuit and setting_args is not empty,; # we update the kwargs for each gate.; # keyword arguments in setting_arg have priority; if gates is not None and setting_args:; kwargs.update(setting_args[gates[prop_ind]]). full_drift_ham = self.drift.get_ideal_qobjevo(self.dims).cte; full_ctrls_hams = [pulse.get_ideal_qobj(self.dims); for pulse in self.pulses]; result = cpo.optimize_pulse_unitary(; full_drift_ham, full_ctrls_hams, U_0, U_targ, **kwargs). if result.fid_err > min_fid_err:; warnings.warn(; ""The fidelity error of gate {} is higher ""; ""than required limit. Use verbose=True to see""; ""the more detailed information."".format(prop_ind)). time_record.append(result.time[1:] + last_time); last_time += result.time[-1]; coeff_record.append(result.final_amps.T). if verbose:; print(""********** Gate {} **********"".format(prop_ind)); print(""Final fidelity error {}"".format(result.fid_err)); print(""Final gradient normal {}"".format(; result.grad_norm_final)); print(""Terminated due to {}"".format(result.termination_reason)); print(""Number of iterations {}"".format(result.num_iter)). tlist = np.hstack([[0.]] + time_record); for i in range(len(self.pulses)):; self.pulses[i].tlist = tlist; coeffs = np.vstack([np.hstack(coeff_record)]); self.coeffs = coeffs. return tlist, coeffs. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/qip/device/optpulseprocessor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/optpulseprocessor.html
https://qutip.org/docs/4.5/modules/qutip/qip/device/optpulseprocessor.html:8130,Availability,error,error,8130,"qc, Iterable):; props = qc; gates = None # using list of Qobj, no gates name; else:; raise ValueError(; ""qc should be a ""; ""QubitCircuit or a list of Qobj""); if merge_gates: # merge all gates/Qobj into one Qobj; props = [gate_sequence_product(props)]; gates = None. time_record = [] # a list for all the gates; coeff_record = []; last_time = 0. # used in concatenation of tlist; for prop_ind, U_targ in enumerate(props):; U_0 = identity(U_targ.dims[0]). # If qc is a QubitCircuit and setting_args is not empty,; # we update the kwargs for each gate.; # keyword arguments in setting_arg have priority; if gates is not None and setting_args:; kwargs.update(setting_args[gates[prop_ind]]). full_drift_ham = self.drift.get_ideal_qobjevo(self.dims).cte; full_ctrls_hams = [pulse.get_ideal_qobj(self.dims); for pulse in self.pulses]; result = cpo.optimize_pulse_unitary(; full_drift_ham, full_ctrls_hams, U_0, U_targ, **kwargs). if result.fid_err > min_fid_err:; warnings.warn(; ""The fidelity error of gate {} is higher ""; ""than required limit. Use verbose=True to see""; ""the more detailed information."".format(prop_ind)). time_record.append(result.time[1:] + last_time); last_time += result.time[-1]; coeff_record.append(result.final_amps.T). if verbose:; print(""********** Gate {} **********"".format(prop_ind)); print(""Final fidelity error {}"".format(result.fid_err)); print(""Final gradient normal {}"".format(; result.grad_norm_final)); print(""Terminated due to {}"".format(result.termination_reason)); print(""Number of iterations {}"".format(result.num_iter)). tlist = np.hstack([[0.]] + time_record); for i in range(len(self.pulses)):; self.pulses[i].tlist = tlist; coeffs = np.vstack([np.hstack(coeff_record)]); self.coeffs = coeffs. return tlist, coeffs. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/qip/device/optpulseprocessor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/optpulseprocessor.html
https://qutip.org/docs/4.5/modules/qutip/qip/device/optpulseprocessor.html:7317,Deployability,update,update,7317,"-------; tlist: array_like; A NumPy array specifies the time of each coefficient. coeffs: array_like; A 2d NumPy array of the shape (len(ctrls), len(tlist)-1). Each; row corresponds to the control pulse sequence for; one Hamiltonian. Notes; -----; len(tlist)-1=coeffs.shape[1] since tlist gives the beginning and the; end of the pulses; """"""; if setting_args is None:; setting_args = {}; if isinstance(qc, QubitCircuit):; props = qc.propagators(); gates = [g.name for g in qc.gates]; elif isinstance(qc, Iterable):; props = qc; gates = None # using list of Qobj, no gates name; else:; raise ValueError(; ""qc should be a ""; ""QubitCircuit or a list of Qobj""); if merge_gates: # merge all gates/Qobj into one Qobj; props = [gate_sequence_product(props)]; gates = None. time_record = [] # a list for all the gates; coeff_record = []; last_time = 0. # used in concatenation of tlist; for prop_ind, U_targ in enumerate(props):; U_0 = identity(U_targ.dims[0]). # If qc is a QubitCircuit and setting_args is not empty,; # we update the kwargs for each gate.; # keyword arguments in setting_arg have priority; if gates is not None and setting_args:; kwargs.update(setting_args[gates[prop_ind]]). full_drift_ham = self.drift.get_ideal_qobjevo(self.dims).cte; full_ctrls_hams = [pulse.get_ideal_qobj(self.dims); for pulse in self.pulses]; result = cpo.optimize_pulse_unitary(; full_drift_ham, full_ctrls_hams, U_0, U_targ, **kwargs). if result.fid_err > min_fid_err:; warnings.warn(; ""The fidelity error of gate {} is higher ""; ""than required limit. Use verbose=True to see""; ""the more detailed information."".format(prop_ind)). time_record.append(result.time[1:] + last_time); last_time += result.time[-1]; coeff_record.append(result.final_amps.T). if verbose:; print(""********** Gate {} **********"".format(prop_ind)); print(""Final fidelity error {}"".format(result.fid_err)); print(""Final gradient normal {}"".format(; result.grad_norm_final)); print(""Terminated due to {}"".format(result.termination_reason)); pri",MatchSource.WIKI,docs/4.5/modules/qutip/qip/device/optpulseprocessor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/optpulseprocessor.html
https://qutip.org/docs/4.5/modules/qutip/qip/device/optpulseprocessor.html:7448,Deployability,update,update,7448,"row corresponds to the control pulse sequence for; one Hamiltonian. Notes; -----; len(tlist)-1=coeffs.shape[1] since tlist gives the beginning and the; end of the pulses; """"""; if setting_args is None:; setting_args = {}; if isinstance(qc, QubitCircuit):; props = qc.propagators(); gates = [g.name for g in qc.gates]; elif isinstance(qc, Iterable):; props = qc; gates = None # using list of Qobj, no gates name; else:; raise ValueError(; ""qc should be a ""; ""QubitCircuit or a list of Qobj""); if merge_gates: # merge all gates/Qobj into one Qobj; props = [gate_sequence_product(props)]; gates = None. time_record = [] # a list for all the gates; coeff_record = []; last_time = 0. # used in concatenation of tlist; for prop_ind, U_targ in enumerate(props):; U_0 = identity(U_targ.dims[0]). # If qc is a QubitCircuit and setting_args is not empty,; # we update the kwargs for each gate.; # keyword arguments in setting_arg have priority; if gates is not None and setting_args:; kwargs.update(setting_args[gates[prop_ind]]). full_drift_ham = self.drift.get_ideal_qobjevo(self.dims).cte; full_ctrls_hams = [pulse.get_ideal_qobj(self.dims); for pulse in self.pulses]; result = cpo.optimize_pulse_unitary(; full_drift_ham, full_ctrls_hams, U_0, U_targ, **kwargs). if result.fid_err > min_fid_err:; warnings.warn(; ""The fidelity error of gate {} is higher ""; ""than required limit. Use verbose=True to see""; ""the more detailed information."".format(prop_ind)). time_record.append(result.time[1:] + last_time); last_time += result.time[-1]; coeff_record.append(result.final_amps.T). if verbose:; print(""********** Gate {} **********"".format(prop_ind)); print(""Final fidelity error {}"".format(result.fid_err)); print(""Final gradient normal {}"".format(; result.grad_norm_final)); print(""Terminated due to {}"".format(result.termination_reason)); print(""Number of iterations {}"".format(result.num_iter)). tlist = np.hstack([[0.]] + time_record); for i in range(len(self.pulses)):; self.pulses[i].tlist = tlist; coeff",MatchSource.WIKI,docs/4.5/modules/qutip/qip/device/optpulseprocessor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/optpulseprocessor.html
https://qutip.org/docs/4.5/modules/qutip/qip/device/optpulseprocessor.html:8711,Deployability,update,updated,8711,"qc, Iterable):; props = qc; gates = None # using list of Qobj, no gates name; else:; raise ValueError(; ""qc should be a ""; ""QubitCircuit or a list of Qobj""); if merge_gates: # merge all gates/Qobj into one Qobj; props = [gate_sequence_product(props)]; gates = None. time_record = [] # a list for all the gates; coeff_record = []; last_time = 0. # used in concatenation of tlist; for prop_ind, U_targ in enumerate(props):; U_0 = identity(U_targ.dims[0]). # If qc is a QubitCircuit and setting_args is not empty,; # we update the kwargs for each gate.; # keyword arguments in setting_arg have priority; if gates is not None and setting_args:; kwargs.update(setting_args[gates[prop_ind]]). full_drift_ham = self.drift.get_ideal_qobjevo(self.dims).cte; full_ctrls_hams = [pulse.get_ideal_qobj(self.dims); for pulse in self.pulses]; result = cpo.optimize_pulse_unitary(; full_drift_ham, full_ctrls_hams, U_0, U_targ, **kwargs). if result.fid_err > min_fid_err:; warnings.warn(; ""The fidelity error of gate {} is higher ""; ""than required limit. Use verbose=True to see""; ""the more detailed information."".format(prop_ind)). time_record.append(result.time[1:] + last_time); last_time += result.time[-1]; coeff_record.append(result.final_amps.T). if verbose:; print(""********** Gate {} **********"".format(prop_ind)); print(""Final fidelity error {}"".format(result.fid_err)); print(""Final gradient normal {}"".format(; result.grad_norm_final)); print(""Terminated due to {}"".format(result.termination_reason)); print(""Number of iterations {}"".format(result.num_iter)). tlist = np.hstack([[0.]] + time_record); for i in range(len(self.pulses)):; self.pulses[i].tlist = tlist; coeffs = np.vstack([np.hstack(coeff_record)]); self.coeffs = coeffs. return tlist, coeffs. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/qip/device/optpulseprocessor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/optpulseprocessor.html
https://qutip.org/docs/4.5/modules/qutip/qip/device/optpulseprocessor.html:2773,Performance,optimiz,optimized,2773,"SINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from collections.abc import Iterable; import warnings; import numbers. import numpy as np. from qutip.qobj import Qobj; import qutip.control.pulseoptim as cpo; from qutip.operators import identity; from qutip.tensor import tensor; from qutip.mesolve import mesolve; from qutip.qip.circuit import QubitCircuit; from qutip.qip.device.processor import Processor; from qutip.qip.operations.gates import gate_sequence_product. __all__ = ['OptPulseProcessor']. [docs]class OptPulseProcessor(Processor):; """"""; A processor, which takes the Hamiltonian available; as dynamic generators, calls the; `qutip.control.optimize_pulse_unitary` function; to find an optimized pulse sequence for the desired quantum circuit.; The processor can simulate the evolution under the given; control pulses using :func:`qutip.mesolve`.; (For attributes documentation, please; refer to the parent class :class:`qutip.qip.device.Processor`). Parameters; ----------; N: int; The number of component systems. drift: `:class:`qutip.Qobj`; The drift Hamiltonian. The size must match the whole quantum system. t1: list or float; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all qubits. t2: list of float; Characterize the decoherence of dephasing for; each qubit. A list of size `N` or a float for all qubits. dims: list; The dimension of each component system.; Default value is a; qubit system of ``dim=[2,2,2,...,2]``; """"""; def __init__(self, N, drift=None, t1=None, t2=None, dims=None):; super(OptPulseProcessor, self).__init__(; N, t1=t1, t2=t2, dims=dims); if drift is not None:; self.add_drift(drift, list(range(N))); self.sp",MatchSource.WIKI,docs/4.5/modules/qutip/qip/device/optpulseprocessor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/optpulseprocessor.html
https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html:2896,Availability,avail,available,2896," WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from collections.abc import Iterable; import warnings; from copy import deepcopy. import numpy as np; from scipy.interpolate import CubicSpline. from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.operators import identity; from qutip.qip.operations.gates import expand_operator, globalphase; from qutip.tensor import tensor; from qutip.mesolve import mesolve; from qutip.qip.circuit import QubitCircuit; from qutip.qip.noise import (; Noise, RelaxationNoise, DecoherenceNoise,; ControlAmpNoise, RandomNoise, UserNoise, process_noise); from qutip.qip.pulse import Pulse, Drift, _merge_qobjevo, _fill_coeff. __all__ = ['Processor']. [docs]class Processor(object):; """"""; A simulator of a quantum device based on the QuTiP solver; :func:`qutip.mesolve`.; It is defined by the available driving Hamiltonian and; the decoherence time for each component systems.; The processor can simulate the evolution under the given; control pulses. Noisy evolution is supported by; :class:`qutip.qip.Noise` and can be added to the processor. Parameters; ----------; N: int; The number of component systems. t1: list or float, optional; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all qubits. t2: list of float, optional; Characterize the decoherence of dephasing for; each qubit. A list of size `N` or a float for all qubits. dims: list, optional; The dimension of each component system.; Default value is a; qubit system of ``dim=[2,2,2,...,2]``. spline_kind: str, optional; Type of the coefficient interpolation. Default is ""step_func""; Note that they have different requirement for the length of `coeff'. -""step_func"":; The coefficient will be treated as a step function.; E.g. ``tlist=[0,1,2]`` and ``coeff=[3,2]``, means that the coefficient; is 3 in t=[0,1)",MatchSource.WIKI,docs/4.5/modules/qutip/qip/device/processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html
https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html:15809,Deployability,update,update,15809,"d `get_noisy_pulses` and create the `QobjEvo`; from it. Parameters; ----------; args: dict, optional; Arguments for :class:`qutip.QobjEvo`; noisy: bool, optional; If noise are included. Default is False. Returns; -------; qobjevo: :class:`qutip.QobjEvo`; The :class:`qutip.QobjEvo` representation of the unitary evolution.; c_ops: list of :class:`qutip.QobjEvo`; A list of lindblad operators is also returned. if ``noisy==Flase``,; it is always an empty list.; """"""; # TODO test it for non array-like coeff; # check validity; self._is_pulses_valid(). if args is None:; args = {}; else:; args = args; # set step function. if not noisy:; dynamics = self.pulses; else:; dynamics = self.get_noisy_pulses(; device_noise=True, drift=True). qu_list = []; c_ops = []; for pulse in dynamics:; if noisy:; qu, new_c_ops = pulse.get_noisy_qobjevo(dims=self.dims); c_ops += new_c_ops; else:; qu = pulse.get_ideal_qobjevo(dims=self.dims); qu_list.append(qu). final_qu = _merge_qobjevo(qu_list); final_qu.args.update(args). if noisy:; return final_qu, c_ops; else:; return final_qu, []. [docs] def run_analytically(self, init_state=None, qc=None):; """"""; Simulate the state evolution under the given `qutip.QubitCircuit`; with matrice exponentiation. It will calculate the propagator; with matrix exponentiation and return a list of :class:`qutip.Qobj`.; This method won't include noise or collpase. Parameters; ----------; qc: :class:`qutip.qip.QubitCircuit`, optional; Takes the quantum circuit to be implemented. If not given, use; the quantum circuit saved in the processor by ``load_circuit``. init_state: :class:`qutip.Qobj`, optional; The initial state of the qubits in the register. Returns; -------; evo_result: :class:`qutip.Result`; An instance of the class; :class:`qutip.Result` will be returned.; """"""; # TODO change init_state to init_state; if init_state is not None:; U_list = [init_state]; else:; U_list = []; tlist = self.get_full_tlist(); # TODO replace this by get_complete_coeff; coeffs = np.array",MatchSource.WIKI,docs/4.5/modules/qutip/qip/device/processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html
https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html:21948,Deployability,update,updated,21948,"*kwargs); return evo_result. [docs] def load_circuit(self, qc):; """"""; Translate an :class:`qutip.qip.QubitCircuit` to its; corresponding Hamiltonians. (Defined in subclasses); """"""; raise NotImplementedError(""Use the function in the sub-class""). [docs] def eliminate_auxillary_modes(self, U):; """"""; Eliminate the auxillary modes like the cavity modes in cqed.; (Defined in subclasses); """"""; return U. [docs] def plot_pulses(self, title=None, figsize=None, dpi=None):; """"""; Plot the pulse amplitude. Parameters; ----------; noisy: bool, optional; If true, plot the noisy pulses. title: str; Title for the plot. figsize: tuple; The size of the figure. dpi: int; The dpi of the figure. Returns; -------; fig: matplotlib.figure.Figure; The `Figure` object for the plot. ax: matplotlib.axes._subplots.AxesSubplot; The axes for the plot. Notes; -----; ``plot_pulses`` only works for array_like coefficients; """"""; import matplotlib.pyplot as plt. fig, ax = plt.subplots(1, 1, figsize=figsize, dpi=dpi); ax.set_ylabel(""Control pulse amplitude""); ax.set_xlabel(""Time""). # TODO add test; coeffs = self.coeffs; tlist = self.get_full_tlist(). for i in range(len(coeffs)):; if not isinstance(coeffs[i], (Iterable, np.ndarray)):; raise ValueError(; ""plot_pulse only accepts array_like coefficients.""); if self.spline_kind == ""step_func"":; if len(coeffs[i]) == len(tlist) - 1:; coeffs[i] = np.hstack(; [coeffs[i], coeffs[i][-1:]]); else:; coeffs[i][-1] = coeffs[i][-2]; ax.step(tlist, coeffs[i], where='post'); elif self.spline_kind == ""cubic"":; sp = CubicSpline(tlist, coeffs[i]); t_line = np.linspace(tlist[0], tlist[-1], 200); c_line = [sp(t) for t in t_line]; ax.plot(t_line, c_line); if title is not None:; ax.set_title(title); fig.tight_layout(); return fig, ax. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/qip/device/processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html
https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html:10125,Integrability,depend,dependent,10125,"id(); if not self.pulses:; return np.array((0, 0), dtype=float); full_tlist = self.get_full_tlist(); coeffs_list = []; for pulse in self.pulses:; if isinstance(pulse.coeff, bool):; if pulse.coeff:; coeffs_list.append(np.ones(full_tlist)); else:; coeffs_list.append(np.zeros(full_tlist)); if not isinstance(pulse.coeff, np.ndarray):; raise ValueError(; ""get_full_coeffs only works for ""; ""NumPy array or bool coeff.""); if self.spline_kind == ""step_func"":; arg = {""_step_func_coeff"": True}; coeffs_list.append(; _fill_coeff(pulse.coeff, pulse.tlist, full_tlist, arg)); elif self.spline_kind == ""cubic"":; coeffs_list.append(; _fill_coeff(pulse.coeff, pulse.tlist, full_tlist, {})); else:; raise ValueError(""Unknown spline kind.""); return np.array(coeffs_list). [docs] def set_all_tlist(self, tlist):; # TODO add tests; """"""; Set `tlist` for all the pulses. It can be used to set `tlist` if; all pulses are controlled by the same time sequence. Parameters; ----------; tlist: array-like, optional; A list of time at which the time-dependent coefficients are; applied. See :class:`qutip.qip.Pulse` for detailed information`; """"""; for pulse in self.pulses:; pulse.tlist = tlist. [docs] def add_pulse(self, pulse):; """"""; Add a new pulse to the device. Parameters; ----------; pulse: :class:`qutip.qip.Pulse`; `Pulse` object to be added.; """"""; if isinstance(pulse, Pulse):; if pulse.spline_kind is None:; pulse.spline_kind = self.spline_kind; self.pulses.append(pulse); else:; raise ValueError(""Invalid input, pulse must be a Pulse object""). [docs] def remove_pulse(self, indices):; """"""; Remove the control pulse with given indices. Parameters; ----------; indices: int or list of int; The indices of the control Hamiltonians to be removed.; """"""; if not isinstance(indices, Iterable):; indices = [indices]; indices.sort(reverse=True); for ind in indices:; del self.pulses[ind]. def _is_pulses_valid(self):; """"""; Check if the pulses are in the correct shape. Returns: bool; If they are valid or not; """"""; for i,",MatchSource.WIKI,docs/4.5/modules/qutip/qip/device/processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html
https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html:13467,Performance,load,loadtxt,13467,"slot. Parameters; ----------; file_name: string; Name of the file. inctime: bool, optional; True if the time list should be included in the first column.; """"""; self._is_pulses_valid(); # TODO this works only for step_func; # TODO replace this by get_complete_coeffs; coeffs = np.array(self.get_full_coeffs()); if inctime:; shp = coeffs.T.shape; data = np.empty((shp[0], shp[1] + 1), dtype=np.float); data[:, 0] = self.get_full_tlist(); data[:, 1:] = coeffs.T; else:; data = coeffs.T. np.savetxt(file_name, data, delimiter='\t', fmt='%1.16f'). [docs] def read_coeff(self, file_name, inctime=True):; """"""; Read the control amplitudes matrix and time list; saved in the file by `save_amp`. Parameters; ----------; file_name: string; Name of the file. inctime: bool, optional; True if the time list in included in the first column. Returns; -------; tlist: array_like; The time list read from the file. coeffs: array_like; The pulse matrix read from the file.; """"""; data = np.loadtxt(file_name, delimiter='\t'); if not inctime:; self.coeffs = data.T; return self.coeffs; else:; tlist = data[:, 0]; self.set_all_tlist(tlist); self.coeffs = data[:, 1:].T; return self.get_full_tlist, self.coeffs. [docs] def get_noisy_pulses(self, device_noise=False, drift=False):; """"""; It takes the pulses defined in the `Processor` and; adds noise according to `Processor.noise`. It does not modify the; pulses saved in `Processor.pulses` but returns a new list.; The length of the new list of noisy pulses might be longer; because of drift Hamiltonian and device noise. They will be; added to the end of the pulses list. Parameters; ----------; device_noise: bool, optional; If true, include pulse independent noise such as single qubit; Relaxation. Default is False.; drift: bool, optional; If true, include drift Hamiltonians. Default is False. Returns; -------; noisy_pulses: list of :class""`qutip.qip.Pulse`/:class:`qutip.qip.Drift`; A list of noisy pulses.; """"""; # TODO add tests; pulses = deepcopy(self.pulses); no",MatchSource.WIKI,docs/4.5/modules/qutip/qip/device/processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html
https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html:9073,Testability,test,tests,9073," pulses.""); for i, coeff in enumerate(coeffs_list):; self.pulses[i].coeff = coeff. [docs] def get_full_tlist(self):; """"""; Return the full tlist of the ideal pulses.; It means that if different `tlist`s are present, they will be merged; to one with all time points stored in a sorted array. Returns; -------; full_tlist: array-like 1d; The full time sequence for the ideal evolution.; """"""; all_tlists = [pulse.tlist; for pulse in self.pulses if pulse.tlist is not None]; if not all_tlists:; return None; return np.unique(np.sort(np.hstack(all_tlists))). [docs] def get_full_coeffs(self):; """"""; Return the full coefficients in a 2d matrix form.; Each row corresponds to one pulse. If the `tlist` are; different for different pulses, the length of each row; will be same as the `full_tlist` (see method; `get_full_tlist`). Interpolation is used for; adding the missing coefficient according to `spline_kind`. Returns; -------; coeffs: array-like 2d; The coefficients for all ideal pulses.; """"""; # TODO add tests; self._is_pulses_valid(); if not self.pulses:; return np.array((0, 0), dtype=float); full_tlist = self.get_full_tlist(); coeffs_list = []; for pulse in self.pulses:; if isinstance(pulse.coeff, bool):; if pulse.coeff:; coeffs_list.append(np.ones(full_tlist)); else:; coeffs_list.append(np.zeros(full_tlist)); if not isinstance(pulse.coeff, np.ndarray):; raise ValueError(; ""get_full_coeffs only works for ""; ""NumPy array or bool coeff.""); if self.spline_kind == ""step_func"":; arg = {""_step_func_coeff"": True}; coeffs_list.append(; _fill_coeff(pulse.coeff, pulse.tlist, full_tlist, arg)); elif self.spline_kind == ""cubic"":; coeffs_list.append(; _fill_coeff(pulse.coeff, pulse.tlist, full_tlist, {})); else:; raise ValueError(""Unknown spline kind.""); return np.array(coeffs_list). [docs] def set_all_tlist(self, tlist):; # TODO add tests; """"""; Set `tlist` for all the pulses. It can be used to set `tlist` if; all pulses are controlled by the same time sequence. Parameters; ----------; tlist: ",MatchSource.WIKI,docs/4.5/modules/qutip/qip/device/processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html
https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html:9908,Testability,test,tests,9908," is used for; adding the missing coefficient according to `spline_kind`. Returns; -------; coeffs: array-like 2d; The coefficients for all ideal pulses.; """"""; # TODO add tests; self._is_pulses_valid(); if not self.pulses:; return np.array((0, 0), dtype=float); full_tlist = self.get_full_tlist(); coeffs_list = []; for pulse in self.pulses:; if isinstance(pulse.coeff, bool):; if pulse.coeff:; coeffs_list.append(np.ones(full_tlist)); else:; coeffs_list.append(np.zeros(full_tlist)); if not isinstance(pulse.coeff, np.ndarray):; raise ValueError(; ""get_full_coeffs only works for ""; ""NumPy array or bool coeff.""); if self.spline_kind == ""step_func"":; arg = {""_step_func_coeff"": True}; coeffs_list.append(; _fill_coeff(pulse.coeff, pulse.tlist, full_tlist, arg)); elif self.spline_kind == ""cubic"":; coeffs_list.append(; _fill_coeff(pulse.coeff, pulse.tlist, full_tlist, {})); else:; raise ValueError(""Unknown spline kind.""); return np.array(coeffs_list). [docs] def set_all_tlist(self, tlist):; # TODO add tests; """"""; Set `tlist` for all the pulses. It can be used to set `tlist` if; all pulses are controlled by the same time sequence. Parameters; ----------; tlist: array-like, optional; A list of time at which the time-dependent coefficients are; applied. See :class:`qutip.qip.Pulse` for detailed information`; """"""; for pulse in self.pulses:; pulse.tlist = tlist. [docs] def add_pulse(self, pulse):; """"""; Add a new pulse to the device. Parameters; ----------; pulse: :class:`qutip.qip.Pulse`; `Pulse` object to be added.; """"""; if isinstance(pulse, Pulse):; if pulse.spline_kind is None:; pulse.spline_kind = self.spline_kind; self.pulses.append(pulse); else:; raise ValueError(""Invalid input, pulse must be a Pulse object""). [docs] def remove_pulse(self, indices):; """"""; Remove the control pulse with given indices. Parameters; ----------; indices: int or list of int; The indices of the control Hamiltonians to be removed.; """"""; if not isinstance(indices, Iterable):; indices = [indices]; indices",MatchSource.WIKI,docs/4.5/modules/qutip/qip/device/processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html
https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html:14455,Testability,test,tests,14455," = np.loadtxt(file_name, delimiter='\t'); if not inctime:; self.coeffs = data.T; return self.coeffs; else:; tlist = data[:, 0]; self.set_all_tlist(tlist); self.coeffs = data[:, 1:].T; return self.get_full_tlist, self.coeffs. [docs] def get_noisy_pulses(self, device_noise=False, drift=False):; """"""; It takes the pulses defined in the `Processor` and; adds noise according to `Processor.noise`. It does not modify the; pulses saved in `Processor.pulses` but returns a new list.; The length of the new list of noisy pulses might be longer; because of drift Hamiltonian and device noise. They will be; added to the end of the pulses list. Parameters; ----------; device_noise: bool, optional; If true, include pulse independent noise such as single qubit; Relaxation. Default is False.; drift: bool, optional; If true, include drift Hamiltonians. Default is False. Returns; -------; noisy_pulses: list of :class""`qutip.qip.Pulse`/:class:`qutip.qip.Drift`; A list of noisy pulses.; """"""; # TODO add tests; pulses = deepcopy(self.pulses); noisy_pulses = process_noise(; pulses, self.noise, self.dims, t1=self.t1, t2=self.t2,; device_noise=device_noise); if drift:; noisy_pulses += [self.drift]; return noisy_pulses. [docs] def get_qobjevo(self, args=None, noisy=False):; """"""; Create a :class:`qutip.QobjEvo` representation of the evolution.; It calls the method `get_noisy_pulses` and create the `QobjEvo`; from it. Parameters; ----------; args: dict, optional; Arguments for :class:`qutip.QobjEvo`; noisy: bool, optional; If noise are included. Default is False. Returns; -------; qobjevo: :class:`qutip.QobjEvo`; The :class:`qutip.QobjEvo` representation of the unitary evolution.; c_ops: list of :class:`qutip.QobjEvo`; A list of lindblad operators is also returned. if ``noisy==Flase``,; it is always an empty list.; """"""; # TODO test it for non array-like coeff; # check validity; self._is_pulses_valid(). if args is None:; args = {}; else:; args = args; # set step function. if not noisy:; dynamics = ",MatchSource.WIKI,docs/4.5/modules/qutip/qip/device/processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html
https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html:15288,Testability,test,test,15288,"ult is False. Returns; -------; noisy_pulses: list of :class""`qutip.qip.Pulse`/:class:`qutip.qip.Drift`; A list of noisy pulses.; """"""; # TODO add tests; pulses = deepcopy(self.pulses); noisy_pulses = process_noise(; pulses, self.noise, self.dims, t1=self.t1, t2=self.t2,; device_noise=device_noise); if drift:; noisy_pulses += [self.drift]; return noisy_pulses. [docs] def get_qobjevo(self, args=None, noisy=False):; """"""; Create a :class:`qutip.QobjEvo` representation of the evolution.; It calls the method `get_noisy_pulses` and create the `QobjEvo`; from it. Parameters; ----------; args: dict, optional; Arguments for :class:`qutip.QobjEvo`; noisy: bool, optional; If noise are included. Default is False. Returns; -------; qobjevo: :class:`qutip.QobjEvo`; The :class:`qutip.QobjEvo` representation of the unitary evolution.; c_ops: list of :class:`qutip.QobjEvo`; A list of lindblad operators is also returned. if ``noisy==Flase``,; it is always an empty list.; """"""; # TODO test it for non array-like coeff; # check validity; self._is_pulses_valid(). if args is None:; args = {}; else:; args = args; # set step function. if not noisy:; dynamics = self.pulses; else:; dynamics = self.get_noisy_pulses(; device_noise=True, drift=True). qu_list = []; c_ops = []; for pulse in dynamics:; if noisy:; qu, new_c_ops = pulse.get_noisy_qobjevo(dims=self.dims); c_ops += new_c_ops; else:; qu = pulse.get_ideal_qobjevo(dims=self.dims); qu_list.append(qu). final_qu = _merge_qobjevo(qu_list); final_qu.args.update(args). if noisy:; return final_qu, c_ops; else:; return final_qu, []. [docs] def run_analytically(self, init_state=None, qc=None):; """"""; Simulate the state evolution under the given `qutip.QubitCircuit`; with matrice exponentiation. It will calculate the propagator; with matrix exponentiation and return a list of :class:`qutip.Qobj`.; This method won't include noise or collpase. Parameters; ----------; qc: :class:`qutip.qip.QubitCircuit`, optional; Takes the quantum circuit to be implement",MatchSource.WIKI,docs/4.5/modules/qutip/qip/device/processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html
https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html:21108,Testability,test,test,21108,"*kwargs); return evo_result. [docs] def load_circuit(self, qc):; """"""; Translate an :class:`qutip.qip.QubitCircuit` to its; corresponding Hamiltonians. (Defined in subclasses); """"""; raise NotImplementedError(""Use the function in the sub-class""). [docs] def eliminate_auxillary_modes(self, U):; """"""; Eliminate the auxillary modes like the cavity modes in cqed.; (Defined in subclasses); """"""; return U. [docs] def plot_pulses(self, title=None, figsize=None, dpi=None):; """"""; Plot the pulse amplitude. Parameters; ----------; noisy: bool, optional; If true, plot the noisy pulses. title: str; Title for the plot. figsize: tuple; The size of the figure. dpi: int; The dpi of the figure. Returns; -------; fig: matplotlib.figure.Figure; The `Figure` object for the plot. ax: matplotlib.axes._subplots.AxesSubplot; The axes for the plot. Notes; -----; ``plot_pulses`` only works for array_like coefficients; """"""; import matplotlib.pyplot as plt. fig, ax = plt.subplots(1, 1, figsize=figsize, dpi=dpi); ax.set_ylabel(""Control pulse amplitude""); ax.set_xlabel(""Time""). # TODO add test; coeffs = self.coeffs; tlist = self.get_full_tlist(). for i in range(len(coeffs)):; if not isinstance(coeffs[i], (Iterable, np.ndarray)):; raise ValueError(; ""plot_pulse only accepts array_like coefficients.""); if self.spline_kind == ""step_func"":; if len(coeffs[i]) == len(tlist) - 1:; coeffs[i] = np.hstack(; [coeffs[i], coeffs[i][-1:]]); else:; coeffs[i][-1] = coeffs[i][-2]; ax.step(tlist, coeffs[i], where='post'); elif self.spline_kind == ""cubic"":; sp = CubicSpline(tlist, coeffs[i]); t_line = np.linspace(tlist[0], tlist[-1], 200); c_line = [sp(t) for t in t_line]; ax.plot(t_line, c_line); if title is not None:; ax.set_title(title); fig.tight_layout(); return fig, ax. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/qip/device/processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html
https://qutip.org/docs/4.5/modules/qutip/qip/device/spinchain.html:2728,Availability,avail,available,2728,"OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; import numpy as np; from qutip.operators import sigmax, sigmay, sigmaz, identity; from qutip.tensor import tensor; from qutip.qip.circuit import QubitCircuit; from qutip.qip.device.processor import Processor; from qutip.qip.device.modelprocessor import ModelProcessor; from qutip.qip.pulse import Pulse; from qutip.qip.compiler.gatecompiler import GateCompiler; from qutip.qip.compiler.spinchaincompiler import SpinChainCompiler. __all__ = ['SpinChain', 'LinearSpinChain', 'CircularSpinChain']. [docs]class SpinChain(ModelProcessor):; """"""; The processor based on the physical implementation of; a spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically.; It is a base class and should not be used directly, please; refer the the subclasses :class:`qutip.qip.LinearSpinChain` and; :class:`qutip.qip.CircularSpinChain`.; (Only additional attributes are documented here, for others please; refer to the parent class :class:`qutip.qip.device.ModelProcessor`). Parameters; ----------; N: int; The number of qubits in the system. correct_global_phase: float; Save the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or list; The delta for each of the qubits in the system. sz: int or list; The epsilon for each of the qubits in the system. sxsy: int or list; The interaction strength for each of the qubit pair in the system. t1: list or float; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for al",MatchSource.WIKI,docs/4.5/modules/qutip/qip/device/spinchain.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/spinchain.html
https://qutip.org/docs/4.5/modules/qutip/qip/device/spinchain.html:13383,Availability,avail,available,13383,"1]) % N]); else:; qc_t.add_gate(gate.name,; [(end + gate.targets[0]) % N,; (end + gate.targets[1]) % N]); j = j + 1. else:; qc_t.add_gate(gate.name, gate.targets, gate.controls,; gate.arg_value, gate.arg_label). return qc_t. [docs] def eliminate_auxillary_modes(self, U):; return U. [docs] def optimize_circuit(self, qc):; """"""; Take a quantum circuit/algorithm and convert it into the; optimal form/basis for the desired physical system. Parameters; ----------; qc: :class:`qutip.QubitCircuit`; Takes the quantum circuit to be implemented. Returns; -------; qc: :class:`qutip.QubitCircuit`; The circuit representation with elementary gates; that can be implemented in this model.; """"""; self.qc0 = qc; self.qc1 = self.adjacent_gates(self.qc0); self.qc2 = self.qc1.resolve_gates(; basis=[""SQRTISWAP"", ""ISWAP"", ""RX"", ""RZ""]); return self.qc2. [docs]class LinearSpinChain(SpinChain):; """"""; A processor based on the physical implementation of; a linear spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically. Parameters; ----------; N: int; The number of qubits in the system. correct_global_phase: float; Save the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or list; The delta for each of the qubits in the system. sz: int or list; The epsilon for each of the qubits in the system. sxsy: int or list; The interaction strength for each of the qubit pair in the system. t1: list or float, optional; Characterize the decoherence of amplitude damping for; each qubit. t2: list of float, optional; Characterize the decoherence of dephasing for; each qubit.; """"""; def __init__(self, N, correct_global_phase=True,; sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None):. super(LinearSpinChain, self).__init__(; N, correct_global_phase=correct_global_phase,; sx=sx, sz=sz, sxsy=sxsy, t1=t1, t2=t2); self.set_u",MatchSource.WIKI,docs/4.5/modules/qutip/qip/device/spinchain.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/spinchain.html
https://qutip.org/docs/4.5/modules/qutip/qip/device/spinchain.html:15486,Availability,avail,available,15486,"nChain, self).set_up_ops(N). [docs] def set_up_params(self, sx, sz, sxsy):; # Doc same as in the parent class; super(LinearSpinChain, self).set_up_params(sx, sz); sxsy_para = self._para_list(sxsy, self.N-1); self._paras[""sxsy""] = sxsy_para. @property; def sxsy_ops(self):; return self.ctrls[2*self.N: 3*self.N-1]. @property; def sxsy_u(self):; return self.coeffs[2*self.N: 3*self.N-1]. [docs] def load_circuit(self, qc):; return super(LinearSpinChain, self).load_circuit(qc, ""linear""). def get_ops_labels(self):; return ([r""$\sigma_x^%d$"" % n for n in range(self.N)] +; [r""$\sigma_z^%d$"" % n for n in range(self.N)] +; [r""$\sigma_x^%d\sigma_x^{%d} + \sigma_y^%d\sigma_y^{%d}$""; % (n, n, n + 1, n + 1) for n in range(self.N - 1)]). [docs] def adjacent_gates(self, qc):; return super(LinearSpinChain, self).adjacent_gates(qc, ""linear""). [docs]class CircularSpinChain(SpinChain):; """"""; A processor based on the physical implementation of; a circular spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically. Parameters; ----------; N: int; The number of qubits in the system. correct_global_phase: float; Save the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or list; The delta for each of the qubits in the system. sz: int or list; The epsilon for each of the qubits in the system. sxsy: int or list; The interaction strength for each of the qubit pair in the system. t1: list or float, optional; Characterize the decoherence of amplitude damping for; each qubit. t2: list of float, optional; Characterize the decoherence of dephasing for; each qubit.; """"""; def __init__(self, N, correct_global_phase=True,; sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None):. super(CircularSpinChain, self).__init__(; N, correct_global_phase=correct_global_phase,; sx=sx, sz=sz, sxsy=sxsy, t1=t1, t2=t2); self.set",MatchSource.WIKI,docs/4.5/modules/qutip/qip/device/spinchain.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/spinchain.html
https://qutip.org/docs/4.5/modules/qutip/qip/device/spinchain.html:17782,Deployability,update,updated,17782,"nt or list; The delta for each of the qubits in the system. sz: int or list; The epsilon for each of the qubits in the system. sxsy: int or list; The interaction strength for each of the qubit pair in the system. t1: list or float, optional; Characterize the decoherence of amplitude damping for; each qubit. t2: list of float, optional; Characterize the decoherence of dephasing for; each qubit.; """"""; def __init__(self, N, correct_global_phase=True,; sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None):. super(CircularSpinChain, self).__init__(; N, correct_global_phase=correct_global_phase,; sx=sx, sz=sz, sxsy=sxsy, t1=t1, t2=t2); self.set_up_params(sx=sx, sz=sz, sxsy=sxsy); self.set_up_ops(N). [docs] def set_up_ops(self, N):; super(CircularSpinChain, self).set_up_ops(N); operator = tensor([sigmax(), sigmax()]) + tensor([sigmay(), sigmay()]); self.pulses.append(; Pulse(operator, [N-1, 0], spline_kind=self.spline_kind)). [docs] def set_up_params(self, sx, sz, sxsy):; # Doc same as in the parent class; super(CircularSpinChain, self).set_up_params(sx, sz); sxsy_para = self._para_list(sxsy, self.N); self._paras[""sxsy""] = sxsy_para. @property; def sxsy_ops(self):; return self.ctrls[2*self.N: 3*self.N]. @property; def sxsy_u(self):; return self.coeffs[2*self.N: 3*self.N]. [docs] def load_circuit(self, qc):; return super(CircularSpinChain, self).load_circuit(qc, ""circular""). def get_ops_labels(self):; return ([r""$\sigma_x^%d$"" % n for n in range(self.N)] +; [r""$\sigma_z^%d$"" % n for n in range(self.N)] +; [r""$\sigma_x^%d\sigma_x^{%d} + \sigma_y^%d\sigma_y^{%d}$""; % (n, n, (n + 1) % self.N, (n + 1) % self.N); for n in range(self.N)]). [docs] def adjacent_gates(self, qc):; return super(CircularSpinChain, self).adjacent_gates(qc, ""circular""). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/qip/device/spinchain.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/spinchain.html
https://qutip.org/docs/4.5/modules/qutip/qip/device/spinchain.html:5777,Usability,simpl,simplicity,5777," ops are set in the submethods. [docs] def set_up_ops(self, N):; """"""; Generate the Hamiltonians for the spinchain model and save them in the; attribute `ctrls`. Parameters; ----------; N: int; The number of qubits in the system.; """"""; # sx_ops; for m in range(N):; self.pulses.append(; Pulse(sigmax(), m, spline_kind=self.spline_kind)); # sz_ops; for m in range(N):; self.pulses.append(; Pulse(sigmaz(), m, spline_kind=self.spline_kind)); # sxsy_ops; operator = tensor([sigmax(), sigmax()]) + tensor([sigmay(), sigmay()]); for n in range(N - 1):; self.pulses.append(; Pulse(operator, [n, n+1], spline_kind=self.spline_kind)). [docs] def set_up_params(self, sx, sz):; """"""; Save the parameters in the attribute `params` and check the validity. Parameters; ----------; sx: float or list; The coefficient of sigmax in the model. sz: flaot or list; The coefficient of sigmaz in the model. Notes; -----; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity; """"""; sx_para = super(SpinChain, self)._para_list(sx, self.N); self._paras[""sx""] = sx_para; sz_para = super(SpinChain, self)._para_list(sz, self.N); self._paras[""sz""] = sz_para. @property; def sx_ops(self):; return self.ctrls[: self.N]. @property; def sz_ops(self):; return self.ctrls[self.N: 2*self.N]. @property; def sxsy_ops(self):; return self.ctrls[2*self.N:]. @property; def sx_u(self):; return self.coeffs[: self.N]. @property; def sz_u(self):; return self.coeffs[self.N: 2*self.N]. @property; def sxsy_u(self):; return self.coeffs[2*self.N:]. [docs] def load_circuit(self, qc, setup):; """"""; Decompose a :class:`qutip.QubitCircuit` in to the control; amplitude generating the corresponding evolution. Parameters; ----------; qc: :class:`qutip.QubitCircuit`; Takes the quantum circuit to be implemented. setup: string; ""linear"" or ""circular"" for two sub-calsses. Returns; -------; tlist: array_like; A NumPy array specifies the time of each coefficient. coeffs: array_like; A 2d NumPy",MatchSource.WIKI,docs/4.5/modules/qutip/qip/device/spinchain.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/spinchain.html
https://qutip.org/docs/4.5/modules/qutip/qip/operations/gates.html:31480,Deployability,update,updated,31480,"at are acted on.; dims : list, optional; A list of integer for the dimension of each composite system.; E.g ``[2, 2, 2, 2, 2]`` for 5 qubits system. If None, qubits system; will be the default option.; cyclic_permutation : boolean, optional; Expand for all cyclic permutation of the targets.; E.g. if ``N=3`` and `oper` is a 2-qubit operator,; the result will be a list of three operators,; each acting on qubits 0 and 1, 1 and 2, 2 and 0. Returns; -------; expanded_oper : :class:`qutip.Qobj`; The expanded qubits operator acting on a system with N qubits. Notes; -----; This is equivalent to gate_expand_1toN, gate_expand_2toN,; gate_expand_3toN in ``qutip.qip.gate.py``, but works for any dimension.; """"""; if dims is None:; dims = [2] * N; targets = _targets_to_list(targets, oper=oper, N=N); _check_qubits_oper(oper, dims=dims, targets=targets). # Call expand_operator for all cyclic permutation of the targets.; if cyclic_permutation:; oper_list = []; for i in range(N):; new_targets = np.mod(np.array(targets)+i, N); oper_list.append(; expand_operator(oper, N=N, targets=new_targets, dims=dims)); return oper_list. # Generate the correct order for qubits permutation,; # eg. if N = 5, targets = [3,0], the order is [1,2,3,0,4].; # If the operator is cnot,; # this order means that the 3rd qubit controls the 0th qubit.; new_order = [0] * N; for i, t in enumerate(targets):; new_order[t] = i; # allocate the rest qutbits (not targets) to the empty; # position in new_order; rest_pos = [q for q in list(range(N)) if q not in targets]; rest_qubits = list(range(len(targets), N)); for i, ind in enumerate(rest_pos):; new_order[ind] = rest_qubits[i]; id_list = [identity(dims[i]) for i in rest_pos]; return tensor([oper] + id_list).permute(new_order). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/qip/operations/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/operations/gates.html
https://qutip.org/docs/4.5/modules/qutip/qip/operations/gates.html:2216,Energy Efficiency,reduce,reduce,2216,"specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; import numbers; from collections.abc import Iterable; from itertools import product; from functools import partial, reduce; from operator import mul. import numpy as np; import scipy.sparse as sp; from qutip.qobj import Qobj; from qutip.operators import identity, qeye, sigmax; from qutip.tensor import tensor; from qutip.states import fock_dm. __all__ = ['rx', 'ry', 'rz', 'sqrtnot', 'snot', 'phasegate', 'qrot',; 'cphase', 'cnot',; 'csign', 'berkeley', 'swapalpha', 'swap', 'iswap', 'sqrtswap',; 'sqrtiswap', 'fredkin', 'molmer_sorensen',; 'toffoli', 'rotation', 'controlled_gate',; 'globalphase', 'hadamard_transform', 'gate_sequence_product',; 'gate_expand_1toN', 'gate_expand_2toN', 'gate_expand_3toN',; 'qubit_clifford_group', 'expand_operator']. #; # Single Qubit Gates; #. [docs]def rx(phi, N=None, target=0):; """"""Single-qubit rotation for operator sigmax with angle phi. Returns; -------; result : qobj; Quantum object for operator describing the rotation. """"""; if N is not None:; return gate_expand_1toN(rx(phi), N, target); else:; return Qobj([[np.cos(phi / 2), -1j * np.sin(phi /",MatchSource.WIKI,docs/4.5/modules/qutip/qip/operations/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/operations/gates.html
https://qutip.org/docs/4.5/modules/qutip/qip/operations/gates.html:19139,Energy Efficiency,power,powers,19139,"teger x.; """"""; tot = 0; while x:; tot += 1; x &= x - 1; return tot. [docs]def hadamard_transform(N=1):; """"""Quantum object representing the N-qubit Hadamard gate. Returns; -------; q : qobj; Quantum object representation of the N-qubit Hadamard gate. """"""; data = 2 ** (-N / 2) * np.array([[(-1) ** _hamming_distance(i & j); for i in range(2 ** N)]; for j in range(2 ** N)]). return Qobj(data, dims=[[2] * N, [2] * N]). [docs]def gate_sequence_product(U_list, left_to_right=True):; """"""; Calculate the overall unitary matrix for a given list of unitary operations. Parameters; ----------; U_list : list; List of gates implementing the quantum circuit. left_to_right : Boolean; Check if multiplication is to be done from left to right. Returns; -------; U_overall : qobj; Overall unitary matrix of a given quantum circuit. """"""; U_overall = 1; for U in U_list:; if left_to_right:; U_overall = U * U_overall; else:; U_overall = U_overall * U. return U_overall. def _powers(op, N):; """"""; Generator that yields powers of an operator `op`,; through to `N`.; """"""; acc = qeye(op.dims[0]); yield acc. for _ in range(N - 1):; acc *= op; yield acc. def qubit_clifford_group(N=None, target=0):; """"""; Generates the Clifford group on a single qubit,; using the presentation of the group given by Ross and Selinger; (http://www.mathstat.dal.ca/~selinger/newsynth/). Parameters; -----------. N : int or None; Number of qubits on which each operator is to be defined; (default: 1).; target : int; Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi ",MatchSource.WIKI,docs/4.5/modules/qutip/qip/operations/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/operations/gates.html
https://qutip.org/docs/4.5/modules/qutip/qip/operations/gates.html:20244,Energy Efficiency,reduce,reduce,20244,"cc. def qubit_clifford_group(N=None, target=0):; """"""; Generates the Clifford group on a single qubit,; using the presentation of the group given by Ross and Selinger; (http://www.mathstat.dal.ca/~selinger/newsynth/). Parameters; -----------. N : int or None; Number of qubits on which each operator is to be defined; (default: 1).; target : int; Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi / 8); H = snot(). X = sigmax(); S = phasegate(np.pi / 2); E = H * (S ** 3) * w ** 3. for op in map(partial(reduce, mul), product(_powers(E, 3),; _powers(X, 2), _powers(S, 4))):. # partial(reduce, mul) returns a function that takes products; # of its argument, by analogy to sum. Note that by analogy,; # sum can be written as partial(reduce, add). # product(...) yields the Cartesian product of its arguments.; # Here, each element is a tuple (E**i, X**j, S**k) such that; # partial(reduce, mul) acting on the tuple yields E**i * X**j * S**k. # Finally, we optionally expand the gate.; if N is not None:; yield gate_expand_1toN(op, N, target); else:; yield op. #; # Gate Expand; #. [docs]def gate_expand_1toN(U, N, target):; """"""; Create a Qobj representing a one-qubit gate that act on a system with N; qubits. Parameters; ----------; U : Qobj; The one-qubit gate. N : integer; The number of qubits in the target space. target : integer; The index of the target qubit. Returns; -------; gate : qobj; Quantum object representation of N-qubit gate. """""". if N < 1:; raise ValueError(""integer N must be larger or equal to 1""). if targe",MatchSource.WIKI,docs/4.5/modules/qutip/qip/operations/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/operations/gates.html
https://qutip.org/docs/4.5/modules/qutip/qip/operations/gates.html:20325,Energy Efficiency,reduce,reduce,20325,"bit,; using the presentation of the group given by Ross and Selinger; (http://www.mathstat.dal.ca/~selinger/newsynth/). Parameters; -----------. N : int or None; Number of qubits on which each operator is to be defined; (default: 1).; target : int; Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi / 8); H = snot(). X = sigmax(); S = phasegate(np.pi / 2); E = H * (S ** 3) * w ** 3. for op in map(partial(reduce, mul), product(_powers(E, 3),; _powers(X, 2), _powers(S, 4))):. # partial(reduce, mul) returns a function that takes products; # of its argument, by analogy to sum. Note that by analogy,; # sum can be written as partial(reduce, add). # product(...) yields the Cartesian product of its arguments.; # Here, each element is a tuple (E**i, X**j, S**k) such that; # partial(reduce, mul) acting on the tuple yields E**i * X**j * S**k. # Finally, we optionally expand the gate.; if N is not None:; yield gate_expand_1toN(op, N, target); else:; yield op. #; # Gate Expand; #. [docs]def gate_expand_1toN(U, N, target):; """"""; Create a Qobj representing a one-qubit gate that act on a system with N; qubits. Parameters; ----------; U : Qobj; The one-qubit gate. N : integer; The number of qubits in the target space. target : integer; The index of the target qubit. Returns; -------; gate : qobj; Quantum object representation of N-qubit gate. """""". if N < 1:; raise ValueError(""integer N must be larger or equal to 1""). if target >= N:; raise ValueError(""target must be integer < integer N""). return tensor([identity(2)] * (t",MatchSource.WIKI,docs/4.5/modules/qutip/qip/operations/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/operations/gates.html
https://qutip.org/docs/4.5/modules/qutip/qip/operations/gates.html:20471,Energy Efficiency,reduce,reduce,20471,"hstat.dal.ca/~selinger/newsynth/). Parameters; -----------. N : int or None; Number of qubits on which each operator is to be defined; (default: 1).; target : int; Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi / 8); H = snot(). X = sigmax(); S = phasegate(np.pi / 2); E = H * (S ** 3) * w ** 3. for op in map(partial(reduce, mul), product(_powers(E, 3),; _powers(X, 2), _powers(S, 4))):. # partial(reduce, mul) returns a function that takes products; # of its argument, by analogy to sum. Note that by analogy,; # sum can be written as partial(reduce, add). # product(...) yields the Cartesian product of its arguments.; # Here, each element is a tuple (E**i, X**j, S**k) such that; # partial(reduce, mul) acting on the tuple yields E**i * X**j * S**k. # Finally, we optionally expand the gate.; if N is not None:; yield gate_expand_1toN(op, N, target); else:; yield op. #; # Gate Expand; #. [docs]def gate_expand_1toN(U, N, target):; """"""; Create a Qobj representing a one-qubit gate that act on a system with N; qubits. Parameters; ----------; U : Qobj; The one-qubit gate. N : integer; The number of qubits in the target space. target : integer; The index of the target qubit. Returns; -------; gate : qobj; Quantum object representation of N-qubit gate. """""". if N < 1:; raise ValueError(""integer N must be larger or equal to 1""). if target >= N:; raise ValueError(""target must be integer < integer N""). return tensor([identity(2)] * (target) + [U] +; [identity(2)] * (N - target - 1)). [docs]def gate_expand_2toN(U, N, c",MatchSource.WIKI,docs/4.5/modules/qutip/qip/operations/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/operations/gates.html
https://qutip.org/docs/4.5/modules/qutip/qip/operations/gates.html:20620,Energy Efficiency,reduce,reduce,20620," Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi / 8); H = snot(). X = sigmax(); S = phasegate(np.pi / 2); E = H * (S ** 3) * w ** 3. for op in map(partial(reduce, mul), product(_powers(E, 3),; _powers(X, 2), _powers(S, 4))):. # partial(reduce, mul) returns a function that takes products; # of its argument, by analogy to sum. Note that by analogy,; # sum can be written as partial(reduce, add). # product(...) yields the Cartesian product of its arguments.; # Here, each element is a tuple (E**i, X**j, S**k) such that; # partial(reduce, mul) acting on the tuple yields E**i * X**j * S**k. # Finally, we optionally expand the gate.; if N is not None:; yield gate_expand_1toN(op, N, target); else:; yield op. #; # Gate Expand; #. [docs]def gate_expand_1toN(U, N, target):; """"""; Create a Qobj representing a one-qubit gate that act on a system with N; qubits. Parameters; ----------; U : Qobj; The one-qubit gate. N : integer; The number of qubits in the target space. target : integer; The index of the target qubit. Returns; -------; gate : qobj; Quantum object representation of N-qubit gate. """""". if N < 1:; raise ValueError(""integer N must be larger or equal to 1""). if target >= N:; raise ValueError(""target must be integer < integer N""). return tensor([identity(2)] * (target) + [U] +; [identity(2)] * (N - target - 1)). [docs]def gate_expand_2toN(U, N, control=None, target=None, targets=None):; """"""; Create a Qobj representing a two-qubit gate that act on a system with N; qubits. Parameters; ----------; U : Qobj; T",MatchSource.WIKI,docs/4.5/modules/qutip/qip/operations/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/operations/gates.html
https://qutip.org/docs/4.5/modules/qutip/qip/operations/gates.html:30969,Energy Efficiency,allocate,allocate,30969,"at are acted on.; dims : list, optional; A list of integer for the dimension of each composite system.; E.g ``[2, 2, 2, 2, 2]`` for 5 qubits system. If None, qubits system; will be the default option.; cyclic_permutation : boolean, optional; Expand for all cyclic permutation of the targets.; E.g. if ``N=3`` and `oper` is a 2-qubit operator,; the result will be a list of three operators,; each acting on qubits 0 and 1, 1 and 2, 2 and 0. Returns; -------; expanded_oper : :class:`qutip.Qobj`; The expanded qubits operator acting on a system with N qubits. Notes; -----; This is equivalent to gate_expand_1toN, gate_expand_2toN,; gate_expand_3toN in ``qutip.qip.gate.py``, but works for any dimension.; """"""; if dims is None:; dims = [2] * N; targets = _targets_to_list(targets, oper=oper, N=N); _check_qubits_oper(oper, dims=dims, targets=targets). # Call expand_operator for all cyclic permutation of the targets.; if cyclic_permutation:; oper_list = []; for i in range(N):; new_targets = np.mod(np.array(targets)+i, N); oper_list.append(; expand_operator(oper, N=N, targets=new_targets, dims=dims)); return oper_list. # Generate the correct order for qubits permutation,; # eg. if N = 5, targets = [3,0], the order is [1,2,3,0,4].; # If the operator is cnot,; # this order means that the 3rd qubit controls the 0th qubit.; new_order = [0] * N; for i, t in enumerate(targets):; new_order[t] = i; # allocate the rest qutbits (not targets) to the empty; # position in new_order; rest_pos = [q for q in list(range(N)) if q not in targets]; rest_qubits = list(range(len(targets), N)); for i, ind in enumerate(rest_pos):; new_order[ind] = rest_qubits[i]; id_list = [identity(dims[i]) for i in rest_pos]; return tensor([oper] + id_list).permute(new_order). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/modules/qutip/qip/operations/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/operations/gates.html
https://qutip.org/docs/4.6/apidoc/apidoc.html:2192,Deployability,update,updated,2192,"entation. API documentation¶; This chapter contains automatically generated API documentation, including a; complete list of QuTiP’s public classes and functions. Classes; Qobj; QobjEvo; eseries; Bloch sphere; Distributions; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Permutational Invariance; One-Dimensional Lattice; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Quantum Objects; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations; Operators and Superoperator Dimensions. Functions acting on states and operators; Expectation Values; Tensor; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continuous Variables. Measurement; Measurement of quantum states. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems; Scattering in Quantum Optical Systems; Permutational Invariance. Lattice; Lattice Properties; Topology. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms; Circuit. Non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utility Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; Semidefinite Programming; IPython Notebook Tools; Miscellaneous. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/apidoc/apidoc.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/apidoc.html
https://qutip.org/docs/4.6/apidoc/apidoc.html:1481,Integrability,depend,dependent,1481,"entation. API documentation¶; This chapter contains automatically generated API documentation, including a; complete list of QuTiP’s public classes and functions. Classes; Qobj; QobjEvo; eseries; Bloch sphere; Distributions; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Permutational Invariance; One-Dimensional Lattice; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Quantum Objects; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations; Operators and Superoperator Dimensions. Functions acting on states and operators; Expectation Values; Tensor; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continuous Variables. Measurement; Measurement of quantum states. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems; Scattering in Quantum Optical Systems; Permutational Invariance. Lattice; Lattice Properties; Topology. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms; Circuit. Non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utility Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; Semidefinite Programming; IPython Notebook Tools; Miscellaneous. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/apidoc/apidoc.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/apidoc.html
https://qutip.org/docs/4.6/apidoc/classes.html:6322,Availability,toler,tolerance,6322,"erators is Hermitian,; otherwise complex values are returned. dnorm(B=None)[source]¶; Calculates the diamond norm, or the diamond distance to another; operator. Parameters. Bqutip.Qobj or NoneIf B is not None, the diamond distance d(A, B) = dnorm(A - B); between this operator and B is returned instead of the diamond; norm. Returns. dfloatEither the diamond norm of this operator, or the diamond distance; from this operator to B. dual_chan()[source]¶; Dual channel of quantum object representing a completely positive; map. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000, phase_fix=None)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). phase_fixint, NoneIf not None, set the phase of each kets so that ket[phase_fix,0]; is real posi",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:7114,Availability,toler,tolerance,7114,"es ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000, phase_fix=None)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). phase_fixint, NoneIf not None, set the phase of each kets so that ket[phase_fix,0]; is real positive. Returns. eigvalsarrayArray of eigenvalues for operator. eigvecsarrayArray of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(states_inds, normalize=False)[source]¶; Creates a new quantum object with states in state_inds eliminated. Parameters. states_indslist of integerThe states that should be removed. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, nor",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:9170,Availability,avail,available,9170,"s only the states; corresponding to indices that are not in state_inds. Notes; Experimental. static evaluate(qobj_list, t, args)[source]¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, ‘sin(w * t)’]]. is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters. qobj_listlistA nested list of Qobj instances and corresponding time-dependent; coefficients. tfloatThe time for which to evaluate the time-dependent Qobj instance. argsdictionaryA dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns. outputqutip.QobjA Qobj instance that represents the value of qobj_list at time t. expm(method='dense')[source]¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters. methodstr {‘dense’, ‘sparse’}Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’. Since the; exponential of a matrix is nearly always dense, method=’dense’; is set as default.s. Returns. operqutip.QobjExponentiated quantum operator. Raises. TypeErrorQuantum operator is not square. extract_states(states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters. states_indslist of integerThe states that should be kept. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters. orderstr {‘C’, ‘F’}Return array in C (default) or Fortran ordering. squeeze",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:10633,Availability,toler,tolerance,10633,"w Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters. orderstr {‘C’, ‘F’}Return array in C (default) or Fortran ordering. squeezebool {False, True}Squeeze output array. Returns. dataarrayArray of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters. sparseboolUse sparse Eigensolver. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. inv(sparse=False)[source]¶; Matrix inverse of a quantum operator; Operator must be square. Returns. operqutip.QobjMatrix inverse of operator. Raises. TypeErrorQuantum object is not square. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type ‘bra’ or ‘ket’. ketqutip.QobjQuantum object of type ‘ket’. Returns. elemcomplexComplex valued matrix element. Notes; It is slightly more computationally efficient to use a ket; v",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:12245,Availability,toler,tolerance,12245,"square. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type ‘bra’ or ‘ket’. ketqutip.QobjQuantum object of type ‘ket’. Returns. elemcomplexComplex valued matrix element. Notes; It is slightly more computationally efficient to use a ket; vector for the ‘bra’ input. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters. normstrWhich norm to use for ket/bra vectors: L2 ‘l2’, max norm ‘max’,; or for operators: trace ‘tr’, Frobius ‘fro’, one ‘one’, or max; ‘max’. sparseboolUse sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tolfloatTolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used); for trace norm. Returns. normfloatThe requested norm of the operator or state quantum object. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(other)[source]¶; Overlap between two state vectors or two operators.; Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap; when one of the Qobj is an operator/density matrix. Parameters. otherqutip.QobjQuantum object for a state vector of type ‘ket’, ‘bra’ or density; matrix. Returns. overlapcomplexComplex valued overlap. Raises. TypeErrorCan only calculate overlap between a bra, ket and density matrix; quantum objects. Notes; Since QuTiP mainly deals with ket vectors, the most efficient inner; product call is the ket-ket version that computes the product; <self|other> w",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:15095,Availability,toler,tolerance,15095,"ty of a quantum object. Returns. state_purityfloatReturns the purity of a quantum object.; For a pure state, the purity is 1.; For a mixed state of dimension d, 1/d<=purity<1. sinm()[source]¶; Sine of a quantum operator.; Operator must be square. Returns. operqutip.QobjMatrix sine of operator. Raises. TypeErrorQuantum object is not square. Notes; Uses the Q.expm() method. sqrtm(sparse=False, tol=0, maxiter=100000)[source]¶; Sqrt of a quantum operator.; Operator must be square. Parameters. sparseboolUse sparse eigenvalue/vector solver. tolfloatTolerance used by sparse solver (0 = machine precision). maxiterintMaximum number of iterations used by sparse solver. Returns. operqutip.QobjMatrix square root of operator. Raises. TypeErrorQuantum object is not square. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. tidyup(atol=1e-12)[source]¶; Removes small elements from the quantum object. Parameters. atolfloatAbsolute tolerance used by tidyup. Default is set; via qutip global settings parameters. Returns. operqutip.QobjQuantum object with small elements removed. tr()[source]¶; Trace of a quantum object. Returns. tracefloatReturns the trace of the quantum object. trans()[source]¶; Transposed operator. Returns. operqutip.QobjTranspose of input operator. transform(inpt, inverse=False, sparse=True)[source]¶; Basis transform defined by input array.; Input array can be a matrix defining the transformation,; or a list of kets that defines the new basis. Parameters. inptarray_likeA matrix or list of kets defining the transformation. inverseboolWhether to return inverse transformation. sparseboolUse sparse matrices when possible. Can be slower. Returns. operqutip.QobjOperator in new basis. Notes; This function is still in development. trunc_neg(method='clip')[source]¶; Truncates negative eigenvalues and renormalizes.; Returns a new Qobj by removing the negative eigenvalues; of this instance, then renormalizing ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:19979,Availability,avail,available,19979," be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; args = {""_step_func_coeff"": True}. Examples of array-format usage are:; tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; QobjEvo that contains different tlist values, however.; Passing arguments; args is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string.; There are some “magic” names that can be specified, whose objects will be; overwritten when used within sesolve, mesolve and; mcsolve. This allows access to the solvers’ internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. ""state"": the current state as a Qobj; ""state_vec"": the current state as a column-stacked 1D np.ndarray; ""state_mat"": the current state as a 2D np.ndarray; ""expect_op_<n>"": the current expectation value of the element; e_ops[n], which is an argument to the solvers. Replace <n> with; an integer literal, e.g. ""expect_op_0"". This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; ""collapse"": (mcsolve only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; (time: float, which: int), where time is the time this collapse; happened, and which is an integer indexing the c_ops argument to; mcsolve. Parameters. Q_objectlist, Qobj or QobjEvoThe time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of [Qobj, time_dependence] pairs that are; summed to make the whole o",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:46422,Availability,toler,tolerance,46422,"d. optionsqutip.solver.OptionsGeneric solver options. Solver Options and Results¶. class ExpectOps(e_ops=[], super_=False)[source]¶; Contain and compute expectation values. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_t_tol=1e-06, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, steady_state_average=False, seeds=None, normalize_output=True, use_openmp=None, openmp_threads=None)[source]¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes. atolfloat {1e-8}Absolute tolerance. rtolfloat {1e-6}Relative tolerance. methodstr {‘adams’,’bdf’}Integration method. orderint {12}Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nstepsint {2500}Max. number of internal steps/call. first_stepfloat {0}Size of initial step (0 = automatic). min_stepfloat {0}Minimum step size (0 = automatic). max_stepfloat {0}Maximum step size (0 = automatic). tidybool {True,False}Tidyup Hamiltonian and initial state by removing small terms. num_cpusintNumber of cpus used by mcsolver (default = # of cpus). norm_tolfloatTolerance used when finding wavefunction norm in mcsolve. norm_stepsintMax. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_statesbool {False}Average states values over trajectories in stochastic solvers. average_expectbool {True}Average expectation values over trajectories for stochastic solvers. mc_corr_epsfloat {1e-10}Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when usi",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:46458,Availability,toler,tolerance,46458,"c solver options. Solver Options and Results¶. class ExpectOps(e_ops=[], super_=False)[source]¶; Contain and compute expectation values. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_t_tol=1e-06, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, steady_state_average=False, seeds=None, normalize_output=True, use_openmp=None, openmp_threads=None)[source]¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes. atolfloat {1e-8}Absolute tolerance. rtolfloat {1e-6}Relative tolerance. methodstr {‘adams’,’bdf’}Integration method. orderint {12}Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nstepsint {2500}Max. number of internal steps/call. first_stepfloat {0}Size of initial step (0 = automatic). min_stepfloat {0}Minimum step size (0 = automatic). max_stepfloat {0}Maximum step size (0 = automatic). tidybool {True,False}Tidyup Hamiltonian and initial state by removing small terms. num_cpusintNumber of cpus used by mcsolver (default = # of cpus). norm_tolfloatTolerance used when finding wavefunction norm in mcsolve. norm_stepsintMax. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_statesbool {False}Average states values over trajectories in stochastic solvers. average_expectbool {True}Average expectation values over trajectories for stochastic solvers. mc_corr_epsfloat {1e-10}Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve. ntrajint {500}Number of ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:47370,Availability,error,errors,47370,"options in evolution solvers. Attributes. atolfloat {1e-8}Absolute tolerance. rtolfloat {1e-6}Relative tolerance. methodstr {‘adams’,’bdf’}Integration method. orderint {12}Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nstepsint {2500}Max. number of internal steps/call. first_stepfloat {0}Size of initial step (0 = automatic). min_stepfloat {0}Minimum step size (0 = automatic). max_stepfloat {0}Maximum step size (0 = automatic). tidybool {True,False}Tidyup Hamiltonian and initial state by removing small terms. num_cpusintNumber of cpus used by mcsolver (default = # of cpus). norm_tolfloatTolerance used when finding wavefunction norm in mcsolve. norm_stepsintMax. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_statesbool {False}Average states values over trajectories in stochastic solvers. average_expectbool {True}Average expectation values over trajectories for stochastic solvers. mc_corr_epsfloat {1e-10}Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve. ntrajint {500}Number of trajectories in stochastic solvers. openmp_threadsintNumber of OPENMP threads to use. Default is number of cpu cores. rhs_reusebool {False,True}Reuse Hamiltonian data. rhs_with_statebool {False,True}Whether or not to include the state in the Hamiltonian function; callback signature. rhs_filenamestrName for compiled Cython file. seedsndarrayArray containing random number seeds for mcsolver. store_final_statebool {False, True}Whether or not to store the final state of the evolution in the; result class. store_statesbool {False, True}Whether or not to store the state vectors or density matrices in the; result class, even if expectation values operators are given. If no; expectation are provided, then states are stored by default and this; option has no effect. use_openmpbool {True, False}Use OPENMP for sparse matrix vector multiplication. Default; None means auto check. class Result[source]¶; Cla",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:56402,Availability,toler,tolerance,56402,"ues. m_opslist of qutip.QobjList of operators representing the measurement operators. The expected; format is a nested list with one measurement operator for each; stochastic increament, for each stochastic collapse operator. argsdictDictionary of parameters for time dependent systems. tolfloatTolerance of the solver for implicit methods. ntrajintNumber of trajectors. nsubstepsintNumber of sub steps between each time-spep given in times. dW_factorsarrayArray of length len(sc_ops), containing scaling factors for each; measurement operator in m_ops. solverstringName of the solver method to use for solving the stochastic; equations. Valid values are:. order 1/2 algorithms: ‘euler-maruyama’, ‘pc-euler’, ‘pc-euler-imp’; order 1 algorithms: ‘milstein’, ‘platen’, ‘milstein-imp’, ‘rouchon’; order 3/2 algorithms: ‘taylor1.5’, ‘taylor1.5-imp’, ‘explicit1.5’; order 2 algorithms: ‘taylor2.0’. See the documentation of stochastic_solvers; for a description of the solvers. Implicit methods can adjust; tolerance via the kw ‘tol’. Default is {‘tol’: 1e-6}. methodstring (‘homodyne’, ‘heterodyne’)The name of the type of measurement process that give rise to the; stochastic equation to solve. store_all_expectbool (default False)Whether or not to store the e_ops expect values for all paths. store_measurementbool (default False)Whether or not to store the measurement results in the; qutip.solver.Result instance returned by the solver. noiseint, or 1D array of int, or 4D array of float; int : seed of the noise; 1D array : length = ntraj, seeds for each trajectories.; 4D array : (ntraj, len(times), nsubsteps, len(sc_ops)*[1|2]).; Vector for the noise, the len of the last dimensions is doubled for; solvers of order 1.5. This corresponds to results.noise. noiseDepthintNumber of terms kept of the truncated series used to create the; noise used by taylor2.0 solver. normalizebool(default True for (photo)ssesolve, False for (photo)smesolve); Whether or not to normalize the wave function during th",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:57464,Availability,error,errors,57464,"‘tol’: 1e-6}. methodstring (‘homodyne’, ‘heterodyne’)The name of the type of measurement process that give rise to the; stochastic equation to solve. store_all_expectbool (default False)Whether or not to store the e_ops expect values for all paths. store_measurementbool (default False)Whether or not to store the measurement results in the; qutip.solver.Result instance returned by the solver. noiseint, or 1D array of int, or 4D array of float; int : seed of the noise; 1D array : length = ntraj, seeds for each trajectories.; 4D array : (ntraj, len(times), nsubsteps, len(sc_ops)*[1|2]).; Vector for the noise, the len of the last dimensions is doubled for; solvers of order 1.5. This corresponds to results.noise. noiseDepthintNumber of terms kept of the truncated series used to create the; noise used by taylor2.0 solver. normalizebool(default True for (photo)ssesolve, False for (photo)smesolve); Whether or not to normalize the wave function during the evolution.; Normalizing density matrices introduce numerical errors. optionsqutip.solver.OptionsGeneric solver options. Only options.average_states and; options.store_states are used. map_func: functionA map function or managing the calls to single-trajactory solvers. map_kwargs: dictionaryOptional keyword arguments to the map_func function function. progress_barqutip.ui.BaseProgressBarOptional progress bar class instance. Permutational Invariance¶. class Dicke(N, hamiltonian=None, emission=0.0, dephasing=0.0, pumping=0.0, collective_emission=0.0, collective_dephasing=0.0, collective_pumping=0.0)[source]¶; The Dicke class which builds the Lindbladian and Liouvillian matrix. Parameters. N: intThe number of two-level systems. hamiltonianqutip.QobjA Hamiltonian in the Dicke basis.; The matrix dimensions are (nds, nds),; with nds being the number of Dicke states.; The Hamiltonian can be built with the operators; given by the jspin functions. emission: floatIncoherent emission coefficient (also nonradiative emission).; default: ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:88002,Availability,avail,available,88002," measurement result to enable; post-selection. If specified, the measurement results are; set to the tuple of bits (sequentially) instead of being; chosen at random. Returns. result: CircuitResultReturn a CircuitResult object containing; output state and probability. run_statistics(state, cbits=None)[source]¶; Calculate all the possible outputs of a circuit; (varied by measurement gates). Parameters. stateketstate to be observed on specified by density matrix. cbitsList of ints, optionalinitialization of the classical bits. Returns. result: CircuitResultReturn a CircuitResult object containing; output states and and their probabilities. step()[source]¶; Return state after one step of circuit evolution; (gate or measurement). Returns. stateket or operstate after one evolution step. class Processor(N, t1=None, t2=None, dims=None, spline_kind='step_func')[source]¶; A simulator of a quantum device based on the QuTiP solver; qutip.mesolve. It is defined by the available driving Hamiltonian; and the decoherence time for each component systems. The processor can; simulate the evolution under the given control pulses. Noisy evolution is; supported by Noise and can be added to the processor. Parameters. N: intThe number of component systems. t1: list or float, optionalCharacterize the decoherence of amplitude damping for; each qubit. A list of size N or a float for all qubits. t2: list of float, optionalCharacterize the decoherence of dephasing for; each qubit. A list of size N or a float for all qubits. dims: list, optionalThe dimension of each component system.; Default value is a; qubit system of dim=[2,2,2,...,2]. spline_kind: str, optionalType of the coefficient interpolation. Default is “step_func”; Note that they have different requirement for the length of coeff. “step_func”:; The coefficient will be treated as a step function. E.g.; tlist=[0,1,2] and coeff=[3,2], means that the coefficient is; 3 in t=[0,1) and 2 in t=[2,3). It requires; len(coeff)=len(tlist)-1 or len",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:97371,Availability,avail,available,97371,"QobjInitial density matrix or state vector (ket). analytical: boolIf True, calculate the evolution with matrices exponentiation. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. solver: str“mesolve” or “mcsolve”. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.ResultIf analytical is False, an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)[source]¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)[source]¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. class OptPulseProcessor(N, drift=None, t1=None, t2=None, dims=None)[source]¶; A processor, which takes the Hamiltonian available; as dynamic generators, calls the; qutip.control.optimize_pulse_unitary function; to find an optimized pulse sequence for the desired quantum circuit.; The processor can simulate the evolution under the given; control pulses using qutip.mesolve.; (For attributes documentation, please; refer to the parent class Processor). Parameters. N: intThe number of component systems. drift: `:class:`qutip.Qobj`The drift Hamiltonian. The size must match the whole quantum system. t1: list or floatCharacterize the decoherence of amplitude damping for; each qubit. A list of size N or a float for all qubits. t2: list of floatCharacterize the decoherence of dephasing for; each qubit. A list of size N or a float for all qubits. dims: listThe dimension of each component system.; Default value is a; qubit system of dim=[2,2,2,...,2]. add_control(qobj, targets=None, cyclic_permutation=False, label=None)¶; Add a control Hamiltonian to the processor. It creates a ne",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:102316,Availability,toler,tolerance,102316,"rs. args: dict, optionalArguments for qutip.QobjEvo. noisy: bool, optionalIf noise are included. Default is False. Returns. qobjevo: qutip.QobjEvoThe qutip.QobjEvo representation of the unitary evolution. c_ops: list of qutip.QobjEvoA list of lindblad operators is also returned. if noisy==Flase,; it is always an empty list. load_circuit(qc, min_fid_err=inf, merge_gates=True, setting_args=None, verbose=False, **kwargs)[source]¶; Find the pulses realizing a given; QubitCircuit using; qutip.control.optimize_pulse_unitary. Further parameter for; for qutip.control.optimize_pulse_unitary needs to be given as; keyword arguments. By default, it first merge all the gates; into one unitary and then find the control pulses for it.; It can be turned off and one can set different parameters; for different gates. See examples for details. Parameters. qc: :class:`.QubitCircuit` or list of QobjThe quantum circuit to be translated. min_fid_err: float, optionalThe minimal fidelity tolerance, if the fidelity error of any; gate decomposition is higher, a warning will be given.; Default is infinite. merge_gates: boolean, optimalIf True, merge all gate/Qobj into one Qobj and then; find the optimal pulses for this unitary matrix. If False,; find the optimal pulses for each gate/Qobj. setting_args: dict, optionalOnly considered if merge_gates is False.; It is a dictionary containing keyword arguments; for different gates.; E.g.:; setting_args = {""SNOT"": {""num_tslots"": 10, ""evo_time"": 1},; ""SWAP"": {""num_tslots"": 30, ""evo_time"": 3},; ""CNOT"": {""num_tslots"": 30, ""evo_time"": 3}}. verbose: boolean, optionalIf true, the information for each decomposed gate; will be shown. Default is False. **kwargskeyword arguments for qutip.control.optimize_pulse_unitary. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)-1). Each; row corresponds to the control pulse sequence for; one Hamiltonian. Notes; len(tlis",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:102343,Availability,error,error,102343,"rs. args: dict, optionalArguments for qutip.QobjEvo. noisy: bool, optionalIf noise are included. Default is False. Returns. qobjevo: qutip.QobjEvoThe qutip.QobjEvo representation of the unitary evolution. c_ops: list of qutip.QobjEvoA list of lindblad operators is also returned. if noisy==Flase,; it is always an empty list. load_circuit(qc, min_fid_err=inf, merge_gates=True, setting_args=None, verbose=False, **kwargs)[source]¶; Find the pulses realizing a given; QubitCircuit using; qutip.control.optimize_pulse_unitary. Further parameter for; for qutip.control.optimize_pulse_unitary needs to be given as; keyword arguments. By default, it first merge all the gates; into one unitary and then find the control pulses for it.; It can be turned off and one can set different parameters; for different gates. See examples for details. Parameters. qc: :class:`.QubitCircuit` or list of QobjThe quantum circuit to be translated. min_fid_err: float, optionalThe minimal fidelity tolerance, if the fidelity error of any; gate decomposition is higher, a warning will be given.; Default is infinite. merge_gates: boolean, optimalIf True, merge all gate/Qobj into one Qobj and then; find the optimal pulses for this unitary matrix. If False,; find the optimal pulses for each gate/Qobj. setting_args: dict, optionalOnly considered if merge_gates is False.; It is a dictionary containing keyword arguments; for different gates.; E.g.:; setting_args = {""SNOT"": {""num_tslots"": 10, ""evo_time"": 1},; ""SWAP"": {""num_tslots"": 30, ""evo_time"": 3},; ""CNOT"": {""num_tslots"": 30, ""evo_time"": 3}}. verbose: boolean, optionalIf true, the information for each decomposed gate; will be shown. Default is False. **kwargskeyword arguments for qutip.control.optimize_pulse_unitary. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)-1). Each; row corresponds to the control pulse sequence for; one Hamiltonian. Notes; len(tlis",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:108181,Availability,avail,available,108181,"h matrices exponentiation. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. solver: str“mesolve” or “mcsolve”. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.ResultIf analytical is False, an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. class ModelProcessor(N, correct_global_phase=True, t1=None, t2=None)[source]¶; The base class for a circuit processor simulating a physical device,; e.g cavityQED, spinchain.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically.; It cannot be used alone, please refer to the sub-classes.; (Only additional attributes are documented here, for others please; refer to the parent class Processor). Parameters. N: intThe number of component systems. correct_global_phase: boolean, optionalIf true, the analytical solution will track the global phase. It; has no effect on the numerical solution. t1: list or floatCharacterize the decoherence of amplitude damping for; each qubit. A list of size N or a float for all qubits. t2: list of floatCharacterize the decoherence of dephasing for; each qubit. A list of size N or a float for all qubits. Attributes. params: dictA Python dictionary contains the name and the value of the parameters; in the physical realization, such as laser frequency, detuning etc. correct_global_phase: floatSave the global phase, the analytical solution; will track t",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:117201,Availability,avail,available,117201,"e, an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_params()[source]¶; Save the parameters in the attribute params and check the validity.; (Defined in subclasses); Notes; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)[source]¶; Transfer a parameter to an array. class SpinChain(N, correct_global_phase, sx, sz, sxsy, t1, t2)[source]¶; The processor based on the physical implementation of; a spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically.; It is a base class and should not be used directly, please; refer the the subclasses qutip.qip.device.LinearSpinChain and; qutip.qip.device.CircularSpinChain.; (Only additional attributes are documented here, for others please; refer to the parent class ModelProcessor). Parameters. N: intThe number of qubits in the system. correct_global_phase: floatSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or listThe delta for each of the qubits in the system. sz: int or listThe epsilon for each of the qubits in the system. sxsy: int or listThe interaction strength for each of the qubit pair in the system. t1: list or floatCharacterize the decoherence of amplitude damping for; each qubit. A list of size N or a float for all qubits. t2: list of floatCharacterize the decoherence ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:128604,Availability,avail,available,128604,"p_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class LinearSpinChain(N, correct_global_phase=True, sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None)[source]¶; A processor based on the physical implementation of; a linear spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically. Parameters. N: intThe number of qubits in the system. correct_global_phase: floatSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or listThe delta for each of the qubits in the system. sz: int or listThe epsilon for each of the qubits in the system. sxsy: int or listThe interaction strength for each of the qubit pair in the system. t1: list or float, optionalCharacterize the decoherence of amplitude damping for; each qubit. t2: list of float, optionalCharacterize the decoherence of dephasing for; each qubit. add_control(qobj, targets=None, cyclic_permutation=False, label=None)¶; Add a control Hamiltonian to the processor. It creates a new; Pulse; object for the device that is turned off; (tlist = None, coeff = None). To activate the pulse, one; can set its tlist and coe",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:139046,Availability,avail,available,139046,"ource]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz, sxsy)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class CircularSpinChain(N, correct_global_phase=True, sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None)[source]¶; A processor based on the physical implementation of; a circular spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically. Parameters. N: intThe number of qubits in the system. correct_global_phase: floatSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or listThe delta for each of the qubits in the system. sz: int or listThe epsilon for each of the qubits in the system. sxsy: int or listThe interaction strength for each of the qubit pair in the system. t1: list or float, optionalCharacterize the decoherence of amplitude damping for; each qubit. t2: list of float, optionalCharacterize the decoherence of dephasing for; each qubit. add_control(qobj, targets=None, cyclic_permutation=False, label=None)¶; Add a control Hamiltonian to the processor. It creates a new; Pulse; object for the device that is turned off; (tlist = None, coeff = None). To activate the pulse, one; can set its tlist and coe",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:149547,Availability,avail,available,149547,"and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz, sxsy)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class DispersiveCavityQED(N, correct_global_phase=True, num_levels=10, deltamax=1.0, epsmax=9.5, w0=10.0, wq=None, eps=9.5, delta=0.0, g=0.01, t1=None, t2=None)[source]¶; The processor based on the physical implementation of; a dispersive cavity QED system.; The available Hamiltonian of the system is predefined.; For a given pulse amplitude matrix, the processor can; calculate the state evolution under the given control pulse,; either analytically or numerically.; (Only additional attributes are documented here, for others please; refer to the parent class ModelProcessor). Parameters. N: intThe number of qubits in the system. correct_global_phase: float, optionalSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. num_levels: int, optionalThe number of energy levels in the resonator. deltamax: int or list, optionalThe coefficients of sigma-x for each of the qubits in the system. epsmax: int or list, optionalThe coefficients of sigma-z for each of the qubits in the system. w0: int, optionalThe base frequency of the resonator. eps: int or list, optionalThe epsilon for each of the qubits in the system. delta: int or list, optionalThe epsilon for each of the qubits in the system. g: int or list, optio",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:164811,Availability,avail,available,164811,"rize the decoherence of amplitude damping for; each qubit. t2: float or listCharacterize the decoherence of dephasing for; each qubit. targets: int or listThe indices of qubits that are acted on. get_noisy_dynamics(dims=None, pulses=None, systematic_noise=None)[source]¶; Return a pulses list added with noise and; the pulse independent noise in a dummy Pulse object. Parameters. dims: list, optionalThe dimension of the components system, the default value is; [2,2…,2] for qubits system. pulses: list of :class:`.Pulse`The input pulses, on which the noise object is to be applied. systematic_noise: :class:`.Pulse`The dummy pulse with no ideal control element. Returns. noisy_pulses: list of PulseNoisy pulses. systematic_noise: PulseThe dummy pulse representing pulse independent noise. class ControlAmpNoise(coeff, tlist=None, indices=None)[source]¶; The noise in the amplitude of the control pulse. Parameters. coeff: listA list of the coefficients for the control Hamiltonians.; For available choices, see qutip.QobjEvo. tlist: array_like, optionalA NumPy array specifies the time of each coefficient. indices: list of int, optionalThe indices of target pulse in the list of pulses. Attributes; ———-; coeff: listA list of the coefficients for the control Hamiltonians.; For available choices, see qutip.QobjEvo. tlist: array_likeA NumPy array specifies the time of each coefficient. indices: list of intThe indices of target pulse in the list of pulses. get_noisy_dynamics(dims=None, pulses=None, systematic_noise=None)[source]¶; Return a pulses list added with noise and; the pulse independent noise in a dummy Pulse object. Parameters. dims: list, optionalThe dimension of the components system, the default value is; [2,2…,2] for qubits system. pulses: list of :class:`.Pulse`The input pulses, on which the noise object is to be applied. systematic_noise: :class:`.Pulse`The dummy pulse with no ideal control element. Returns. noisy_pulses: list of PulseNoisy pulses. systematic_noise: PulseT",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:165102,Availability,avail,available,165102,"t added with noise and; the pulse independent noise in a dummy Pulse object. Parameters. dims: list, optionalThe dimension of the components system, the default value is; [2,2…,2] for qubits system. pulses: list of :class:`.Pulse`The input pulses, on which the noise object is to be applied. systematic_noise: :class:`.Pulse`The dummy pulse with no ideal control element. Returns. noisy_pulses: list of PulseNoisy pulses. systematic_noise: PulseThe dummy pulse representing pulse independent noise. class ControlAmpNoise(coeff, tlist=None, indices=None)[source]¶; The noise in the amplitude of the control pulse. Parameters. coeff: listA list of the coefficients for the control Hamiltonians.; For available choices, see qutip.QobjEvo. tlist: array_like, optionalA NumPy array specifies the time of each coefficient. indices: list of int, optionalThe indices of target pulse in the list of pulses. Attributes; ———-; coeff: listA list of the coefficients for the control Hamiltonians.; For available choices, see qutip.QobjEvo. tlist: array_likeA NumPy array specifies the time of each coefficient. indices: list of intThe indices of target pulse in the list of pulses. get_noisy_dynamics(dims=None, pulses=None, systematic_noise=None)[source]¶; Return a pulses list added with noise and; the pulse independent noise in a dummy Pulse object. Parameters. dims: list, optionalThe dimension of the components system, the default value is; [2,2…,2] for qubits system. pulses: list of :class:`.Pulse`The input pulses, on which the noise object is to be applied. systematic_noise: :class:`.Pulse`The dummy pulse with no ideal control element. Returns. noisy_pulses: list of PulseNoisy pulses. systematic_noise: PulseThe dummy pulse representing pulse independent noise. class RandomNoise(dt, rand_gen, indices=None, **kwargs)[source]¶; Random noise in the amplitude of the control pulse. The arguments for; the random generator need to be given as key word arguments. Parameters. dt: float, optionalThe time ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:188447,Availability,error,error,188447,"log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the pulse optim algorithm alg. disp_conv_msgboolSet true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_paramsDictionaryOptions for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_gradboolIf set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds for the parameters.; If not set before the run",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:192316,Availability,error,error,192316,"an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. property dumping¶; The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:192694,Availability,error,error,192694,"uring the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. property dumping¶; The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; Thi",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:192871,Availability,error,error,192871,"f they do. property dumping¶; The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimi",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:194119,Availability,error,error,194119,"ed as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algor",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:195301,Availability,error,error,195301,"l time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m ar",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:196657,Availability,error,error,196657,"ns; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses t",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:197850,Availability,error,error,197850,"f the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fid",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:198413,Availability,error,error,198413," None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It wil",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:198863,Availability,error,error,198863,"ptim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]¶; A summary of the most recent iteration of the pulse optimisation. Attributes. iter_numintIteration number of the pulse optimisation. fid_func_call_numintFidelity function call number of the pulse optimisation. grad_func_call_numintGradient function call number of the pulse optimisation. fid_errfloatFidelity error",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:199953,Availability,error,error,199953,"s which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]¶; A summary of the most recent iteration of the pulse optimisation. Attributes. iter_numintIteration number of the pulse optimisation. fid_func_call_numintFidelity function call number of the pulse optimisation. grad_func_call_numintGradient function call number of the pulse optimisation. fid_errfloatFidelity error. grad_normfloatfidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_timefloatTime spent computing the pulse optimisation so far; (in seconds of elapsed time). class TerminationConditions[source]¶; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes. fid_err_targfloatTarget fidelity error. fid_goalfloatgoal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_timefloat# maximum time for optimisation (seconds). min_gradient_normfloatMinimum normalised gradient after which optimisation will terminate. max_iterationsintegerMaximum iterations of the optimisation algorithm. max_fid_func_callsintegerMaximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factorfloatDetermines the accuracy of the result.;",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:200442,Availability,error,error,200442,"It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]¶; A summary of the most recent iteration of the pulse optimisation. Attributes. iter_numintIteration number of the pulse optimisation. fid_func_call_numintFidelity function call number of the pulse optimisation. grad_func_call_numintGradient function call number of the pulse optimisation. fid_errfloatFidelity error. grad_normfloatfidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_timefloatTime spent computing the pulse optimisation so far; (in seconds of elapsed time). class TerminationConditions[source]¶; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes. fid_err_targfloatTarget fidelity error. fid_goalfloatgoal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_timefloat# maximum time for optimisation (seconds). min_gradient_normfloatMinimum normalised gradient after which optimisation will terminate. max_iterationsintegerMaximum iterations of the optimisation algorithm. max_fid_func_callsintegerMaximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factorfloatDetermines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of the pulse optimisation attempt. Attribut",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:201605,Availability,error,error,201605,"onds). min_gradient_normfloatMinimum normalised gradient after which optimisation will terminate. max_iterationsintegerMaximum iterations of the optimisation algorithm. max_fid_func_callsintegerMaximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factorfloatDetermines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of the pulse optimisation attempt. Attributes. termination_reasonstringDescription of the reason for terminating the optimisation. fidelityfloatfinal (normalised) fidelity that was achieved. initial_fid_errfloatfidelity error before optimisation starting. fid_errfloatfinal fidelity error that was achieved. goal_achievedbooleanTrue is the fidely error achieved was below the target. grad_norm_finalfloatFinal value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reachedfloatTrue if the optimisation terminated due to the minimum value; of the gradient being reached. num_iterintegerNumber of iterations of the optimisation algorithm completed. max_iter_exceededbooleanTrue if the iteration limit was reached. max_fid_func_exceededbooleanTrue if the fidelity function call limit was reached. wall_timefloattime elapsed during the optimisation. wall_time_limit_exceededbooleanTrue if the wall time limit was reached. timearray[num_tslots+1] of floatTime are the start of each timeslot; with the final value being the total evolution time. initial_ampsarray[num_tslots, n_ctrls]The amplitudes at the start of the optimisation. final_ampsarray[num_tslots, n_ctrls]The amplitudes at the ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:201668,Availability,error,error,201668,"ter which optimisation will terminate. max_iterationsintegerMaximum iterations of the optimisation algorithm. max_fid_func_callsintegerMaximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factorfloatDetermines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of the pulse optimisation attempt. Attributes. termination_reasonstringDescription of the reason for terminating the optimisation. fidelityfloatfinal (normalised) fidelity that was achieved. initial_fid_errfloatfidelity error before optimisation starting. fid_errfloatfinal fidelity error that was achieved. goal_achievedbooleanTrue is the fidely error achieved was below the target. grad_norm_finalfloatFinal value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reachedfloatTrue if the optimisation terminated due to the minimum value; of the gradient being reached. num_iterintegerNumber of iterations of the optimisation algorithm completed. max_iter_exceededbooleanTrue if the iteration limit was reached. max_fid_func_exceededbooleanTrue if the fidelity function call limit was reached. wall_timefloattime elapsed during the optimisation. wall_time_limit_exceededbooleanTrue if the wall time limit was reached. timearray[num_tslots+1] of floatTime are the start of each timeslot; with the final value being the total evolution time. initial_ampsarray[num_tslots, n_ctrls]The amplitudes at the start of the optimisation. final_ampsarray[num_tslots, n_ctrls]The amplitudes at the end of the optimisation. evo_full_finalQobjThe evolution o",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:201732,Availability,error,error,201732,"mum iterations of the optimisation algorithm. max_fid_func_callsintegerMaximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factorfloatDetermines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of the pulse optimisation attempt. Attributes. termination_reasonstringDescription of the reason for terminating the optimisation. fidelityfloatfinal (normalised) fidelity that was achieved. initial_fid_errfloatfidelity error before optimisation starting. fid_errfloatfinal fidelity error that was achieved. goal_achievedbooleanTrue is the fidely error achieved was below the target. grad_norm_finalfloatFinal value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reachedfloatTrue if the optimisation terminated due to the minimum value; of the gradient being reached. num_iterintegerNumber of iterations of the optimisation algorithm completed. max_iter_exceededbooleanTrue if the iteration limit was reached. max_fid_func_exceededbooleanTrue if the fidelity function call limit was reached. wall_timefloattime elapsed during the optimisation. wall_time_limit_exceededbooleanTrue if the wall time limit was reached. timearray[num_tslots+1] of floatTime are the start of each timeslot; with the final value being the total evolution time. initial_ampsarray[num_tslots, n_ctrls]The amplitudes at the start of the optimisation. final_ampsarray[num_tslots, n_ctrls]The amplitudes at the end of the optimisation. evo_full_finalQobjThe evolution operator from t=0 to t=T based on the final amps. evo_full_initia",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:201857,Availability,error,error,201857,"alls to the fidelity function during; the optimisation algorithm. accuracy_factorfloatDetermines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of the pulse optimisation attempt. Attributes. termination_reasonstringDescription of the reason for terminating the optimisation. fidelityfloatfinal (normalised) fidelity that was achieved. initial_fid_errfloatfidelity error before optimisation starting. fid_errfloatfinal fidelity error that was achieved. goal_achievedbooleanTrue is the fidely error achieved was below the target. grad_norm_finalfloatFinal value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reachedfloatTrue if the optimisation terminated due to the minimum value; of the gradient being reached. num_iterintegerNumber of iterations of the optimisation algorithm completed. max_iter_exceededbooleanTrue if the iteration limit was reached. max_fid_func_exceededbooleanTrue if the fidelity function call limit was reached. wall_timefloattime elapsed during the optimisation. wall_time_limit_exceededbooleanTrue if the wall time limit was reached. timearray[num_tslots+1] of floatTime are the start of each timeslot; with the final value being the total evolution time. initial_ampsarray[num_tslots, n_ctrls]The amplitudes at the start of the optimisation. final_ampsarray[num_tslots, n_ctrls]The amplitudes at the end of the optimisation. evo_full_finalQobjThe evolution operator from t=0 to t=T based on the final amps. evo_full_initialQobjThe evolution operator from t=0 to t=T based on the initial amps. statsStatsObject con",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:204845,Availability,error,error,204845,"es of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_computerFidelityComputer (subclass instance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:204868,Availability,error,error,204868,"es of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_computerFidelityComputer (subclass instance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:220692,Availability,error,error,220692,"hat the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_normfloatNormalisation constant. fid_norm_funcfunctionUsed to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_funcfunctionUsed to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evobooleanflag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evoboolean; flag to specify whether the onto_evo evolution operator(see Dynamics) is used by the FidelityComputer. fid_errfloatLast computed value of the fidelity error. fidelityfloatLast computed value of the normalised fidelity. fidelity_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of floatLast computed values for the fidelity error gradients wrt the; control in the timeslot. grad_normfloatLast computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[so",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:220996,Availability,error,error,220996,"tion,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_normfloatNormalisation constant. fid_norm_funcfunctionUsed to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_funcfunctionUsed to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evobooleanflag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evoboolean; flag to specify whether the onto_evo evolution operator(see Dynamics) is used by the FidelityComputer. fid_errfloatLast computed value of the fidelity error. fidelityfloatLast computed value of the normalised fidelity. fidelity_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of floatLast computed values for the fidelity error gradients wrt the; control in the timeslot. grad_normfloatLast computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelit",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:221109,Availability,error,error,221109," file, which by default is WARN. dimensional_normfloatNormalisation constant. fid_norm_funcfunctionUsed to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_funcfunctionUsed to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evobooleanflag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evoboolean; flag to specify whether the onto_evo evolution operator(see Dynamics) is used by the FidelityComputer. fid_errfloatLast computed value of the fidelity error. fidelityfloatLast computed value of the normalised fidelity. fidelity_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of floatLast computed values for the fidelity error gradients wrt the; control in the timeslot. grad_normfloatLast computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:221978,Availability,error,error,221978,"ues for the fidelity error gradients wrt the; control in the timeslot. grad_normfloatLast computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. c",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:222310,Availability,error,error,222310,"itudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the a",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:223306,Availability,error,error,223306,"putes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:223410,Availability,error,error,223410,"der). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:225161,Availability,error,error,225161,"f the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:225241,Availability,error,error,225241,"f the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:225719,Availability,error,error,225719,"ent_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configurati",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:225810,Availability,error,error,225810,"data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses th",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:226063,Availability,error,error,226063," - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control ampli",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:226258,Availability,error,error,226258,"as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned a",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:226362,Availability,error,error,226362,"ance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:240838,Availability,error,error,240838,"ll_time_optim_startfloatStart time for the optimisation. wall_time_optim_endfloatEnd time for the optimisation. wall_time_optimfloatTime elasped during the optimisation. wall_time_dyn_gen_computefloatTotal wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_computefloatTotal wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_computefloatTotal wall (elasped) time computing combined forward propagation,; that is the time evolution from the start to a specific timeslot.; Excludes calculating the propagators themselves. wall_time_onwd_prop_computefloatTotal wall (elasped) time computing combined onward propagation,; that is the time evolution from a specific timeslot to the end time.; Excludes calculating the propagators themselves. wall_time_gradient_computefloatTotal wall (elasped) time computing the fidelity error gradient.; Excludes calculating the propagator gradients (in exact gradient; methods). num_fidelity_func_callsintegerNumber of calls to fidelity function by the optimisation algorithm. num_grad_func_callsintegerNumber of calls to gradient function by the optimisation algorithm. num_tslot_recomputeintegerNumber of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computesintegerNumber of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computesintegerNumber of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updatesintegerNumber of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iterfloatMean number of control amplitude updates per iteration. num_timeslot_changesintegerNumber of times the amplitudes of a any control in a timeslot",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:244413,Availability,error,error,244413,"mmary_sepstrdelimiter for the summary file.; default is a space. data_sepstrdelimiter for the data files (arrays saved to file).; default is a space. summary_filestrFile path for summary file.; Automatically generated. Can be set specifically. create_dump_dir()[source]¶; Checks dump directory exists, creates it if not. property level¶; The level of data dumping that will occur. SUMMARYA summary will be recorded. FULLAll possible dumping. CUSTOMSome customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes. dump_summaryboolWhen True summary items are appended to the iter_summary. iter_summarylist of optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. property dump_all¶; True if everything (ignoring the summary) is to be dumped. property dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters. ffilename or filehandleIf specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:19875,Deployability,update,updated,19875," The coeffients array must have the; same length as the tlist. The times of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; args = {""_step_func_coeff"": True}. Examples of array-format usage are:; tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; QobjEvo that contains different tlist values, however.; Passing arguments; args is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string.; There are some “magic” names that can be specified, whose objects will be; overwritten when used within sesolve, mesolve and; mcsolve. This allows access to the solvers’ internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. ""state"": the current state as a Qobj; ""state_vec"": the current state as a column-stacked 1D np.ndarray; ""state_mat"": the current state as a 2D np.ndarray; ""expect_op_<n>"": the current expectation value of the element; e_ops[n], which is an argument to the solvers. Replace <n> with; an integer literal, e.g. ""expect_op_0"". This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; ""collapse"": (mcsolve only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; (time: float, which: int), where time is the time this collapse; happened, and which is an integer indexing the c_ops argument to; mcsolve. Parameters. Q_objectlist, Qobj or QobjEvoThe time-dependent description of the quantum object. This is of the; same format as the first paramete",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:39192,Deployability,integrat,integrate,39192,"=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=N",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:40806,Deployability,integrat,integrator,40806,"pically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., l",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:41719,Deployability,integrat,integratorstr,41719,"yCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse o",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:41895,Deployability,integrat,integrator,41895,"e simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). Returns. : complexexpectation",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:41969,Deployability,integrat,integrator,41969,"ed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). Returns. : complexexpectation value of field correlation function. outfieldpropagato",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:46536,Deployability,integrat,integrator,46536,"]¶; Contain and compute expectation values. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_t_tol=1e-06, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, steady_state_average=False, seeds=None, normalize_output=True, use_openmp=None, openmp_threads=None)[source]¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes. atolfloat {1e-8}Absolute tolerance. rtolfloat {1e-6}Relative tolerance. methodstr {‘adams’,’bdf’}Integration method. orderint {12}Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nstepsint {2500}Max. number of internal steps/call. first_stepfloat {0}Size of initial step (0 = automatic). min_stepfloat {0}Minimum step size (0 = automatic). max_stepfloat {0}Maximum step size (0 = automatic). tidybool {True,False}Tidyup Hamiltonian and initial state by removing small terms. num_cpusintNumber of cpus used by mcsolver (default = # of cpus). norm_tolfloatTolerance used when finding wavefunction norm in mcsolve. norm_stepsintMax. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_statesbool {False}Average states values over trajectories in stochastic solvers. average_expectbool {True}Average expectation values over trajectories for stochastic solvers. mc_corr_epsfloat {1e-10}Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve. ntrajint {500}Number of trajectories in stochastic solvers. openmp_threadsintNumber of OPENMP threads to use. Default",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:60871,Deployability,integrat,integrate,60871,"pled basis.; default: (nds, nds). c_ops()[source]¶; Build collapse operators in the full Hilbert space 2^N. Returns. c_ops_list: listThe list with the collapse operators in the 2^N Hilbert space. coefficient_matrix()[source]¶; Build coefficient matrix for ODE for a diagonal problem. Returns. M: ndarrayThe matrix M of the coefficients for the ODE dp/dt = Mp.; p is the vector of the diagonal matrix elements; of the density matrix rho in the Dicke basis. lindbladian()[source]¶; Build the Lindbladian superoperator of the dissipative dynamics. Returns. lindbladianqutip.QobjThe Lindbladian matrix as a qutip.Qobj. liouvillian()[source]¶; Build the total Liouvillian using the Dicke basis. Returns. liouvqutip.QobjThe Liouvillian matrix for the system. pisolve(initial_state, tlist, options=None)[source]¶; Solve for diagonal Hamiltonians and initial states faster. Parameters. initial_statequtip.QobjAn initial state specified as a density matrix of; qutip.Qbj type. tlist: ndarrayA 1D numpy array of list of timesteps to integrate. optionsqutip.solver.OptionsThe options for the solver. Returns. result: listA dictionary of the type qutip.solver.Result which holds the; results of the evolution. class Pim(N, emission=0.0, dephasing=0, pumping=0, collective_emission=0, collective_pumping=0, collective_dephasing=0)[source]¶; The Permutation Invariant Matrix class.; Initialize the class with the parameters for generating a Permutation; Invariant matrix which evolves a given diagonal initial state p as:. dp/dt = Mp. Parameters. N: intThe number of two-level systems. emission: floatIncoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: floatLocal dephasing coefficient.; default: 0.0. pumping: floatIncoherent pumping coefficient.; default: 0.0. collective_emission: floatCollective (superradiant) emmission coefficient.; default: 0.0. collective_pumping: floatCollective pumping coefficient.; default: 0.0. collective_dephasing: floatCollective dephasing coeff",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:75380,Deployability,update,update,75380," 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. figmatplotlib Figure instanceIf given, use this figure instance for the visualization,. axmatplotlib Axes instanceIf given, render the visualization using this axis instance. figsizetupleSize of the new Figure instance, if one needs to be created. colorbar: BoolWhether or not the colorbar (in 2D visualization) should be used. cmap: matplotlib colormap instanceIf given, use this colormap for 2D visualizations. stylestringType of visualization: ‘colormap’ (default) or ‘surface’. Returns. fig, axtupleA tuple of matplotlib figure and axes instances. class WignerDistribution(rho=None, extent=[[- 5, 5], [- 5, 5]], steps=250)[source]¶. class QDistribution(rho=None, extent=[[- 5, 5], [- 5, 5]], steps=250)[source]¶. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[- 5, 5], [- 5, 5]], steps=250)[source]¶. update(state)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix. update_psi(psi)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction. update_rho(rho)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[- 5, 5], steps=250)[source]¶. update(psi)[source]¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[- 5, 5], steps=250)[source]¶. update(rho)[source]¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing¶. class Gate(*args, **kwargs)[source]¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. Parameters. namestringGate name. targetslist or intGate targets. controlslist or",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:75881,Deployability,update,update,75881,"map for 2D visualizations. stylestringType of visualization: ‘colormap’ (default) or ‘surface’. Returns. fig, axtupleA tuple of matplotlib figure and axes instances. class WignerDistribution(rho=None, extent=[[- 5, 5], [- 5, 5]], steps=250)[source]¶. class QDistribution(rho=None, extent=[[- 5, 5], [- 5, 5]], steps=250)[source]¶. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[- 5, 5], [- 5, 5]], steps=250)[source]¶. update(state)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix. update_psi(psi)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction. update_rho(rho)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[- 5, 5], steps=250)[source]¶. update(psi)[source]¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[- 5, 5], steps=250)[source]¶. update(rho)[source]¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing¶. class Gate(*args, **kwargs)[source]¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. Parameters. namestringGate name. targetslist or intGate targets. controlslist or intGate controls. arg_valuefloatArgument value(phi). arg_labelstringLabel for gate representation. classical_controlsint or list of int, optionalindices of classical bits to control gate on. control_valueint, optionalvalue of classical bits to control on, the classical controls are; interpreted as an integer with lowest bit being the first one.; If not specified, then the value is interpreted to be; 2 ** len(classical_controls) - 1 (i.e. all classical controls are 1). cla",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:76081,Deployability,update,update,76081," 5], [- 5, 5]], steps=250)[source]¶. class QDistribution(rho=None, extent=[[- 5, 5], [- 5, 5]], steps=250)[source]¶. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[- 5, 5], [- 5, 5]], steps=250)[source]¶. update(state)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix. update_psi(psi)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction. update_rho(rho)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[- 5, 5], steps=250)[source]¶. update(psi)[source]¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[- 5, 5], steps=250)[source]¶. update(rho)[source]¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing¶. class Gate(*args, **kwargs)[source]¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. Parameters. namestringGate name. targetslist or intGate targets. controlslist or intGate controls. arg_valuefloatArgument value(phi). arg_labelstringLabel for gate representation. classical_controlsint or list of int, optionalindices of classical bits to control gate on. control_valueint, optionalvalue of classical bits to control on, the classical controls are; interpreted as an integer with lowest bit being the first one.; If not specified, then the value is interpreted to be; 2 ** len(classical_controls) - 1 (i.e. all classical controls are 1). class Measurement(name, targets=None, index=None, classical_store=None)[source]¶; Representation of a quantum measurement, with its required parameters,; and target qubits. Parameters. namestringMeasurement name. targ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:174888,Deployability,continuous,continuous,174888,"nction; compile calls compiling method from the sub-class and concatenate; the compiled pulses. Parameters. N: intThe number of the component systems. params: dict, optionalA Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc.; It will be saved in the class attributes and can be used to calculate; the control pulses. pulse_dict: dict, optionalA map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; (pulse_label, coeff), instead of (pulse_index, coeff).; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer pulse_index needs to be used; in the compiling routine saved under the attributes gate_compiler. Attributes. gate_compiler: dictThe Python dictionary in the form of {gate_name: compiler_function}.; It saves the compiling routine for each gate. See sub-classes; for implementation.; Note that for continuous pulse, the first coeff should always be 0. args: dictArguments for individual compiling routines.; It adds more flexibility in customizing compiler. compile(circuit, schedule_mode=None, args=None)[source]¶; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters. circuit: :class:`.QubitCircuit` or list ofGate; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_com",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:187283,Deployability,configurat,configuration,187283,"hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list, optionalThe execution time needed for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, array_like).; This pulses will implement the desired gate. Attributes. targets: list, optionalThe target qubits. controls: list, optionalThe control qubits. used_qubits: setUnion of the control and target qubits. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses. This class implements the fidelity,; gradient and interation callback functions. All subclass objects must be; initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the pulse optim algorithm alg. disp_conv_msgboolSet true to display a convergence message; (for scipy.optimize.minimize methods ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:189829,Deployability,configurat,configuration,189829,"rapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamicsDynamics (subclass instance)describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). configOptimConfig instancevarious configuration options; (see OptimConfig for details). termination_conditionsTerminationCondition instanceattributes determine when the optimisation will end. pulse_generatorPulseGen (subclass instance)(can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. statsStatsattributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dumpdump.OptimDumpContainer for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumpingstringThe level of data dumping that will occur during the optimisation. dump_to_fileboolIf set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dum",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:192636,Deployability,update,update,192636,"uring the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. property dumping¶; The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; Thi",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:193234,Deployability,update,update,193234,"c_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:193761,Deployability,configurat,configuration,193761,"get, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:196535,Deployability,configurat,configuration,196535,"l minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which inclu",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:198155,Deployability,configurat,configuration,198155,"ablished implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall t",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:204654,Deployability,update,updated,204654,"ultiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_computerFidelityComputer (subclass instance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:212871,Deployability,configurat,configuration,212871,"ion operators (Qobj) from the initial to the given; timeslot. get_ctrl_dyn_gen(j)[source]¶; Get the dynamics generator for the control; Not implemented in the base class. Choose a subclass. get_drift_dim()[source]¶; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N. get_dyn_gen(k)[source]¶; Get the combined dynamics generator for the timeslot; Not implemented in the base class. Choose a subclass. get_num_ctrls()[source]¶; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. init_timeslots()[source]¶; Generate the timeslot duration array ‘tau’ based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array ‘time’ based on the tau values. initialize_controls(amps, init_tslots=True)[source]¶; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated. property num_ctrls¶; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. property onto_evo¶; List of evolution operators (Qobj) from the initial to the given; timeslot. property onwd_evo¶; List of evolution operators (Qobj) from the initial to the given; timeslot. property phase_application¶; scalar(string), default=’preop’; Determines how the phase is applied to the dynamics generators. ‘preop’ : P = expm(phase*dyn_gen); ‘postop’ : P = expm(dyn_gen*phase); ‘custom’ : Customised phase application. The ‘custom’ option assumes that the _apply_phase method has been; set to a custom function. Type; phase_application. property prop¶; List of propagators (Qobj) for each timeslot. property prop_grad¶; Array of propagator gradients (Qobj) for each timeslot, control. refresh_drift_attribs()[source]¶; Reset ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:216255,Deployability,configurat,configuration,216255,"amics described by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes. drift_hamQobjThis is the drift Hamiltonian for unitary dynamics; It is mapped to drift_dyn_gen during initialize_controls. ctrl_hamList of QobjThese are the control Hamiltonians for unitary dynamics; It is mapped to ctrl_dyn_gen during initialize_controls. HList of QobjThe combined drift and control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls. check_unitarity()[source]¶; Checks whether all propagators are unitary; For propagators found not to be unitary, the potential underlying; causes are investigated. initialize_controls(amplitudes, init_tslots=True)[source]¶; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated. property num_ctrls¶; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. class DynamicsSymplectic(optimconfig, params=None)[source]¶; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes. omegaarray[drift_dyn_gen.shape]matrix used in the calculation of propagators (time evolution); with symplectic systems. property dyn_gen_phase¶; The phasing operator for the symplectic group generators; usually refered to as Omega; By default this is applied as ‘postop’ dyn_gen*-Omega; If phase_application is ‘preop’ it is applied as Omega*dyn_gen. class PropagatorComputer(dynamics, params=None)[source]¶; Base for all Propagator Computer classes; that are used to calculate the propagators,; and a",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:218520,Deployability,configurat,configuration,218520,"cation. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exactbooleanindicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; PropagatorComputer subclasses that may be more efficient. reset()[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:218796,Deployability,configurat,configuration,218796,"iet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exactbooleanindicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; PropagatorComputer subclasses that may be more efficient. reset()[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attribute",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:218989,Deployability,configurat,configuration,218989,"es whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; PropagatorComputer subclasses that may be more efficient. reset()[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; a",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:219356,Deployability,configurat,configuration,219356,"ey value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; PropagatorComputer subclasses that may be more efficient. reset()[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_normfloatNormalisation constant. fid_norm_funcfunctionUsed to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_funcfunctionUsed to normalise the fidelity gradient; See SU",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:222115,Deployability,configurat,configuration,222115," fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradie",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:222174,Deployability,configurat,configuration,222174," to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_c",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:223536,Deployability,update,updates,223536,"der). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:223997,Deployability,configurat,configuration,223997,"culates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phas",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:224861,Deployability,configurat,configuration,224861,"tion uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:226488,Deployability,update,updates,226488,"ance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:226607,Deployability,configurat,configuration,226607,"erik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelinteg",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:226714,Deployability,configurat,configuration,226714,"ated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:227310,Deployability,configurat,configuration,227310,"ormalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. evo_comp_summaryEvoCompSummaryA summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:228785,Deployability,update,updated,228785,"g_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. evo_comp_summaryEvoCompSummaryA summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dump_current()[source]¶; Store a copy of the current time evolution. class TSlotCompUpdateAll(dynamics, params=None)[source]¶; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated. compare_amps(new_amps)[source]¶; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed. get_timeslot_for_fidelity_calc()[source]¶; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot. recompute_evolution()[source]¶; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary. class PulseGen(dyn=None, params=None)[source]¶; Pulse generator; Base class for all Pulse generators; The object can optionally be instantiated with a Dynamics object,; in which case the timeslots and amplitude scaling and offset; are copied from that.; Otherwise the class can be used independently by setting:; tau (array of timeslot durations); or; num_tslot",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:239392,Deployability,configurat,configurations,239392,"om the optimisation method; Typically this will be the basis coefficients. class PulseGenCrabFourier(dyn=None, num_coeffs=None, params=None)[source]¶; Generates a pulse using the Fourier basis functions, i.e. sin and cos. Attributes. freqsfloat array[num_coeffs]Frequencies for the basis functions. randomize_freqsboolIf True (default) the some random offset is applied to the frequencies. gen_pulse(coeffs=None)[source]¶; Generate a pulse using the Fourier basis with the freqs and; coeffs attributes. Parameters. coeffsfloat array[num_coeffs, num_basis_funcs]The basis coefficient values; If given this overides the default and sets the attribute; of the same name. init_freqs()[source]¶; Generate the frequencies; These are the Fourier harmonics with a uniformly distributed; random offset. init_pulse(num_coeffs=None)[source]¶; Set the initial freq and coefficient values. reset()[source]¶; reset attributes to default values. class Stats[source]¶; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes. dyn_gen_namestringText used in some report functions.; Makes sense to set it to ‘Hamiltonian’ when using unitary dynamics; Default is simply ‘dynamics generator’. num_iterintegerNumber of iterations of the optimisation algorithm. wall_time_optim_startfloatStart time for the optimisation. wall_time_optim_endfloatEnd time for the optimisation. wall_time_optimfloatTime elasped during the optimisation. wall_time_dyn_gen_computefloatTotal wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_computefloatTotal wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_computefloatTotal wall (elasped) time com",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:239431,Deployability,update,updated,239431,"om the optimisation method; Typically this will be the basis coefficients. class PulseGenCrabFourier(dyn=None, num_coeffs=None, params=None)[source]¶; Generates a pulse using the Fourier basis functions, i.e. sin and cos. Attributes. freqsfloat array[num_coeffs]Frequencies for the basis functions. randomize_freqsboolIf True (default) the some random offset is applied to the frequencies. gen_pulse(coeffs=None)[source]¶; Generate a pulse using the Fourier basis with the freqs and; coeffs attributes. Parameters. coeffsfloat array[num_coeffs, num_basis_funcs]The basis coefficient values; If given this overides the default and sets the attribute; of the same name. init_freqs()[source]¶; Generate the frequencies; These are the Fourier harmonics with a uniformly distributed; random offset. init_pulse(num_coeffs=None)[source]¶; Set the initial freq and coefficient values. reset()[source]¶; reset attributes to default values. class Stats[source]¶; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes. dyn_gen_namestringText used in some report functions.; Makes sense to set it to ‘Hamiltonian’ when using unitary dynamics; Default is simply ‘dynamics generator’. num_iterintegerNumber of iterations of the optimisation algorithm. wall_time_optim_startfloatStart time for the optimisation. wall_time_optim_endfloatEnd time for the optimisation. wall_time_optimfloatTime elasped during the optimisation. wall_time_dyn_gen_computefloatTotal wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_computefloatTotal wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_computefloatTotal wall (elasped) time com",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:241613,Deployability,update,updated,241613,"ll (elasped) time computing combined onward propagation,; that is the time evolution from a specific timeslot to the end time.; Excludes calculating the propagators themselves. wall_time_gradient_computefloatTotal wall (elasped) time computing the fidelity error gradient.; Excludes calculating the propagator gradients (in exact gradient; methods). num_fidelity_func_callsintegerNumber of calls to fidelity function by the optimisation algorithm. num_grad_func_callsintegerNumber of calls to gradient function by the optimisation algorithm. num_tslot_recomputeintegerNumber of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computesintegerNumber of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computesintegerNumber of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updatesintegerNumber of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iterfloatMean number of control amplitude updates per iteration. num_timeslot_changesintegerNumber of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_updatefloatMean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changesintegerNumber of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_updatefloatMean average number of control amplitudes that are changed per update. calculate()[source]¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]¶; Print a report of the stats to the console. class Dump[source]¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes. parentsome control object (Dynamics or Optimizer)aka the host. Object that generates the data that is dumped and is; hos",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:241694,Deployability,update,updates,241694,om a specific timeslot to the end time.; Excludes calculating the propagators themselves. wall_time_gradient_computefloatTotal wall (elasped) time computing the fidelity error gradient.; Excludes calculating the propagator gradients (in exact gradient; methods). num_fidelity_func_callsintegerNumber of calls to fidelity function by the optimisation algorithm. num_grad_func_callsintegerNumber of calls to gradient function by the optimisation algorithm. num_tslot_recomputeintegerNumber of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computesintegerNumber of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computesintegerNumber of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updatesintegerNumber of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iterfloatMean number of control amplitude updates per iteration. num_timeslot_changesintegerNumber of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_updatefloatMean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changesintegerNumber of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_updatefloatMean average number of control amplitudes that are changed per update. calculate()[source]¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]¶; Print a report of the stats to the console. class Dump[source]¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes. parentsome control object (Dynamics or Optimizer)aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dirstrdirectory where files (if any) will be written out; t,MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:241920,Deployability,update,update,241920,ating the propagator gradients (in exact gradient; methods). num_fidelity_func_callsintegerNumber of calls to fidelity function by the optimisation algorithm. num_grad_func_callsintegerNumber of calls to gradient function by the optimisation algorithm. num_tslot_recomputeintegerNumber of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computesintegerNumber of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computesintegerNumber of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updatesintegerNumber of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iterfloatMean number of control amplitude updates per iteration. num_timeslot_changesintegerNumber of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_updatefloatMean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changesintegerNumber of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_updatefloatMean average number of control amplitudes that are changed per update. calculate()[source]¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]¶; Print a report of the stats to the console. class Dump[source]¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes. parentsome control object (Dynamics or Optimizer)aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dirstrdirectory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. levelstri,MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:242123,Deployability,update,update,242123,gradient function by the optimisation algorithm. num_tslot_recomputeintegerNumber of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computesintegerNumber of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computesintegerNumber of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updatesintegerNumber of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iterfloatMean number of control amplitude updates per iteration. num_timeslot_changesintegerNumber of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_updatefloatMean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changesintegerNumber of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_updatefloatMean average number of control amplitudes that are changed per update. calculate()[source]¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]¶; Print a report of the stats to the console. class Dump[source]¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes. parentsome control object (Dynamics or Optimizer)aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dirstrdirectory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. levelstringThe level of data dumping that will occur. write_to_fileboolWhen set True data and summaries (as configured) will be written; interactively to file during the processing; Set during instantiation by th,MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:248118,Deployability,update,updated,248118,"ped. dump_onto_evoboolIf True onto (or backward) evolution operators are dumped. evo_dumpslist of EvoCompDumpItemA new dump item is appended at each recomputation of the evolution.; That is if any of the calculation objects are to be dumped. add_evo_comp_summary(dump_item_idx=None)[source]¶; add copy of current evo comp summary. add_evo_dump()[source]¶; Add dump of current time evolution generating objects. property dump_all¶; True if all of the calculation objects are to be dumped. property dump_any¶; True if any of the calculation objects are to be dumped. writeout(f=None)[source]¶; Write all the dump items and the summary out to file(s). Parameters. ffilename or filehandleIf specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated in; the dump_dir. If a filehandle is specified then it must be a byte; mode file as numpy.savetxt is used, and requires this. class DumpItem[source]¶; An item in a dump list. class EvoCompDumpItem(dump)[source]¶; A copy of all objects generated to calculate one time evolution. Note the; attributes are only set if the corresponding DynamicsDump; dump_* attribute is set. writeout(f=None)[source]¶; write all the objects out to files. Parameters. ffilename or filehandleIf specified then all object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DumpSummaryItem[source]¶; A summary of the most recent iteration. Abstract class only. Attributes. idxintIndex in the summary list in which this is stored. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:11599,Energy Efficiency,efficient,efficient,11599,"solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. inv(sparse=False)[source]¶; Matrix inverse of a quantum operator; Operator must be square. Returns. operqutip.QobjMatrix inverse of operator. Raises. TypeErrorQuantum object is not square. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type ‘bra’ or ‘ket’. ketqutip.QobjQuantum object of type ‘ket’. Returns. elemcomplexComplex valued matrix element. Notes; It is slightly more computationally efficient to use a ket; vector for the ‘bra’ input. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters. normstrWhich norm to use for ket/bra vectors: L2 ‘l2’, max norm ‘max’,; or for operators: trace ‘tr’, Frobius ‘fro’, one ‘one’, or max; ‘max’. sparseboolUse sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tolfloatTolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used); for trace norm. Returns. normfloatThe requested norm of the operator or state quantum object. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(other)[source]¶; Overlap between ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:13142,Energy Efficiency,efficient,efficient,13142,"(if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used); for trace norm. Returns. normfloatThe requested norm of the operator or state quantum object. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(other)[source]¶; Overlap between two state vectors or two operators.; Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap; when one of the Qobj is an operator/density matrix. Parameters. otherqutip.QobjQuantum object for a state vector of type ‘ket’, ‘bra’ or density; matrix. Returns. overlapcomplexComplex valued overlap. Raises. TypeErrorCan only calculate overlap between a bra, ket and density matrix; quantum objects. Notes; Since QuTiP mainly deals with ket vectors, the most efficient inner; product call is the ket-ket version that computes the product; <self|other> with both vectors expressed as kets. permute(order)[source]¶; Permutes a composite quantum object. Parameters. orderlist/arrayList specifying new tensor order. Returns. Pqutip.QobjPermuted quantum object. proj()[source]¶; Form the projector from a given ket or bra vector. Parameters. Qqutip.QobjInput bra or ket vector. Returns. Pqutip.QobjProjection operator. ptrace(sel, sparse=None)[source]¶; Partial trace of the quantum object. Parameters. selint/listAn int or list of components to keep after partial trace.; The order is unimportant; no transposition will be done and the; spaces will remain in the same order in the output. Returns. operqutip.QobjQuantum object representing partial trace with selected components; remaining. Notes; This function is identical to the qutip.qobj.ptrace function; that has been deprecated. purity()[source]¶; Calculate purity of a quantum object. Returns. state_purityfloatReturns the purity of a quant",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:25255,Energy Efficiency,reduce,reduce,25255,"s to new values. compile(code=False, matched=False, dense=False, omp=0)[source]¶; Create an associated Cython object for faster usage. This function is; called automatically by the solvers. Parameters. codebool, default FalseReturn the code string generated by compilation of any strings. matchedbool, default FalseIf True, the underlying sparse matrices used to represent each; element of the type will have their structures unified. This may; include adding explicit zeros to sparse matrices, but can be faster; in some cases due to not having to deal with repeated structural; mismatches. densebool, default FalseWhether to swap to using dense matrices to back the data. ompint, optionalThe number of OpenMP threads to use when doing matrix; multiplications, if QuTiP was compiled with OpenMP. Returns. compiled_strstr(Only if code was set to True). The code-generated string of; compiled calling code. compress()[source]¶; Merge together elements that share the same time-dependence, to reduce; the number of matrix multiplications and additions that need to be done; to evaluate this object.; Modifies the object inplace. conj()[source]¶; Return the matrix elementwise conjugation. copy()[source]¶; Return a copy of this object. dag()[source]¶; Return the matrix conjugate-transpose (dagger). expect(t, state, herm=False)[source]¶; Calculate the expectation value of this operator on the given; (time-independent) state at a particular time.; This is more efficient than expect(QobjEvo(t), state). Parameters. tfloatThe time to evaluate this operator at. stateQobj or np.ndarrayThe state to take the expectation value around. hermbool, default FalseWhether this operator and the state are both Hermitian. If True,; only the real part of the result will be returned. See also. expectGeneral-purpose expectation values. mul_mat(t, mat)[source]¶; Multiply this object evaluated at time t by a matrix (from the; right). Parameters. tfloatThe time to evaluate this object at. matQobj or np.ndarrayThe ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:25725,Energy Efficiency,efficient,efficient,25725," to sparse matrices, but can be faster; in some cases due to not having to deal with repeated structural; mismatches. densebool, default FalseWhether to swap to using dense matrices to back the data. ompint, optionalThe number of OpenMP threads to use when doing matrix; multiplications, if QuTiP was compiled with OpenMP. Returns. compiled_strstr(Only if code was set to True). The code-generated string of; compiled calling code. compress()[source]¶; Merge together elements that share the same time-dependence, to reduce; the number of matrix multiplications and additions that need to be done; to evaluate this object.; Modifies the object inplace. conj()[source]¶; Return the matrix elementwise conjugation. copy()[source]¶; Return a copy of this object. dag()[source]¶; Return the matrix conjugate-transpose (dagger). expect(t, state, herm=False)[source]¶; Calculate the expectation value of this operator on the given; (time-independent) state at a particular time.; This is more efficient than expect(QobjEvo(t), state). Parameters. tfloatThe time to evaluate this operator at. stateQobj or np.ndarrayThe state to take the expectation value around. hermbool, default FalseWhether this operator and the state are both Hermitian. If True,; only the real part of the result will be returned. See also. expectGeneral-purpose expectation values. mul_mat(t, mat)[source]¶; Multiply this object evaluated at time t by a matrix (from the; right). Parameters. tfloatThe time to evaluate this object at. matQobj or np.ndarrayThe matrix that is multiplied by this object. Returns. mat: Qobj or np.ndarrayThe matrix result in the same type as the input. mul_vec(t, vec)[source]¶; Multiply this object evaluated at time t by a vector. Parameters. tfloatThe time to evaluate this object at. vecQobj or np.ndarrayThe state-vector to multiply this object by. Returns. vec: Qobj or np.ndarrayThe vector result in the same type as the input. permute(order)[source]¶; Permute the tensor structure of the underly",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:34632,Energy Efficiency,efficient,efficient,34632,"= 1024)[source]¶; Class-based method of calculating the Husimi-Q function of many different; quantum states at fixed phase-space points 0.5*g* (xvec + i*yvec).; This class has slightly higher first-usage costs than qfunc, but; subsequent operations will be several times faster. However, it can require; quite a lot of memory. Call the created object as a function to retrieve; the Husimi-Q function. Parameters. xvec, yvecarray_likex- and y-coordinates at which to calculate the Husimi-Q function. gfloat, default sqrt(2)Scaling factor for a = 0.5 * g * (x + iy). The value of g is; related to the value of hbar in the commutation relation; \([x,\,y] = i\hbar\) via \(\hbar=2/g^2\), so the default; corresponds to \(\hbar=1\). memoryreal, default 1024Size in MB that may be used internally as workspace. This class will; raise MemoryError if subsequently passed a state of sufficiently; large dimension that this bound would be exceeded. In those cases, use; qfunc with precompute_memory=None instead to force using; the slower, more memory-efficient algorithm. See also. qfunca single function version, which will involve computing several quantities multiple times in order to use less memory. Examples; Initialise the class for a square set of coordinates, with some states we; want to investigate.; >>> xvec = np.linspace(-2, 2, 101); >>> states = [qutip.rand_dm(10) for _ in [None]*10]; >>> qfunc = qutip.QFunc(xvec, xvec). Now we can calculate the Husimi-Q function over each of the states more; efficiently with:; >>> husimiq = np.array([qfunc(state) for state in states]). Cubic Spline¶. class Cubic_Spline(a, b, y, alpha=0, beta=0)[source]¶; Calculates coefficients for a cubic spline; interpolation of a given data set.; This function assumes that the data is sampled; uniformly over a given interval. Parameters. afloatLower bound of the interval. bfloatUpper bound of the interval. yndarrayFunction values at interval points. alphafloatSecond-order derivative at a. Default is 0. betaflo",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:35093,Energy Efficiency,efficient,efficiently,35093,"mi-Q function. gfloat, default sqrt(2)Scaling factor for a = 0.5 * g * (x + iy). The value of g is; related to the value of hbar in the commutation relation; \([x,\,y] = i\hbar\) via \(\hbar=2/g^2\), so the default; corresponds to \(\hbar=1\). memoryreal, default 1024Size in MB that may be used internally as workspace. This class will; raise MemoryError if subsequently passed a state of sufficiently; large dimension that this bound would be exceeded. In those cases, use; qfunc with precompute_memory=None instead to force using; the slower, more memory-efficient algorithm. See also. qfunca single function version, which will involve computing several quantities multiple times in order to use less memory. Examples; Initialise the class for a square set of coordinates, with some states we; want to investigate.; >>> xvec = np.linspace(-2, 2, 101); >>> states = [qutip.rand_dm(10) for _ in [None]*10]; >>> qfunc = qutip.QFunc(xvec, xvec). Now we can calculate the Husimi-Q function over each of the states more; efficiently with:; >>> husimiq = np.array([qfunc(state) for state in states]). Cubic Spline¶. class Cubic_Spline(a, b, y, alpha=0, beta=0)[source]¶; Calculates coefficients for a cubic spline; interpolation of a given data set.; This function assumes that the data is sampled; uniformly over a given interval. Parameters. afloatLower bound of the interval. bfloatUpper bound of the interval. yndarrayFunction values at interval points. alphafloatSecond-order derivative at a. Default is 0. betafloatSecond-order derivative at b. Default is 0. Notes; This object can be called like a normal function with a; single or array of input points at which to evaluate; the interplating function.; Habermann & Kindermann, “Multidimensional Spline Interpolation:; Theory and Applications”, Comput Econ 30, 153 (2007). Attributes. afloatLower bound of the interval. bfloatUpper bound of the interval. coeffsndarrayArray of coeffcients defining cubic spline. Non-Markovian Solvers¶. class HEOM",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:44553,Energy Efficiency,reduce,reduced,44553,"e specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. : qutip.Qobjtime-propagator for computing field correlation function. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters. tfloatcurrent time. taufloattime-delay. notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; ——-; : :class:`qutip.Qobj`time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). tfloatcurrent time. taufloattime-delay. Returns. : qutip.Qobjdensity matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. Attributes. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. timesarray_likeList of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimesarray_likeList of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thresfloatThreshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. optionsqutip.solver.OptionsGeneric solver options. Solver Options and Results¶. class ExpectOps(e_ops=[], super_=False)[source]¶; Contai",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:44619,Energy Efficiency,reduce,reduced,44619,"tem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. : qutip.Qobjtime-propagator for computing field correlation function. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters. tfloatcurrent time. taufloattime-delay. notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; ——-; : :class:`qutip.Qobj`time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). tfloatcurrent time. taufloattime-delay. Returns. : qutip.Qobjdensity matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. Attributes. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. timesarray_likeList of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimesarray_likeList of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thresfloatThreshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. optionsqutip.solver.OptionsGeneric solver options. Solver Options and Results¶. class ExpectOps(e_ops=[], super_=False)[source]¶; Contain and compute expectation values. class Options(atol=1e-08, rtol=1",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:70561,Energy Efficiency,energy,energy,70561,"an of the lattice. display_lattice()[source]¶; Produces a graphic portraying the lattice symbolically with a unit cell; marked in it. Returns. inter_TQobjThe coefficient of $psi_{i,N}^{dagger}psi_{0,i+1}$, i.e. the; coupling between the two boundary sites of the two unit cells i and; i+1. display_unit_cell(label_on=False)[source]¶; Produces a graphic displaying the unit cell features with labels on if; defined by user. Also returns a dict of Qobj’s corresponding to the; labeled elements on the display. Returns. HcelldictHcell[i][j] is the Hamiltonian segment for $H_{i,j}$ labeled on the; graphic. distribute_operator(op)[source]¶; A function that returns an operator matrix that applies op to all the; cells in the 1d lattice. Parameters; op (qutip.Qobj) – Qobj representing the operator to be applied at all cells. Returns. op_Hqutip.QobjQuantum object representing the operator with op applied at all; cells. get_dispersion(knpoints=0)[source]¶; Returns dispersion relationship for the lattice with the specified; number of unit cells with a k array and a band energy array. Returns. knxanp.arrayknxA[j][0] is the jth good Quantum number k. val_knsnp.arrayval_kns[j][:] is the array of band energies of the jth band good at; all the good Quantum numbers of k. k()[source]¶; Returns the crystal momentum operator. All degrees of freedom has the; cell number at their correspondig entry in the position operator. Returns. Qobj(ks)qutip.QobjThe crystal momentum operator in units of 1/a. L is the number; of unit cells, a is the length of a unit cell which is always taken; to be 1. operator_at_cells(op, cells)[source]¶; A function that returns an operator matrix that applies op to specific; cells specified in the cells list. Parameters. opqutip.QobjQobj representing the operator to be applied at certain cells. cells: list of intThe cells at which the operator op is to be applied. Returns. Qobj(op_H)QobjQuantum object representing the operator with op applied at; the specified cells. op",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:73650,Energy Efficiency,reduce,reduced,73650,"try in the position operator. Returns. Qobj(xs)qutip.QobjThe position operator. Distribution functions¶. class Distribution(data=None, xvecs=[], xlabels=[])[source]¶; A class for representation spatial distribution functions.; The Distribution class can be used to prepresent spatial distribution; functions of arbitray dimension (although only 1D and 2D distributions; are used so far).; It is indented as a base class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters. dataarray_likeData for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs. xvecslistList of arrays that spans the space for each coordinate. xlabelslistList of labels for each coordinate. marginal(dim=0)[source]¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters. dimintThe dimension (coordinate index) along which to obtain the; marginal distribution. Returns. dDistributionsA new instances of Distribution that describes the marginal; distribution. project(dim=0)[source]¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters. dimintThe dimension (coordinate index) along which to obtain the; projected distribution. Returns. dDistributionsA new instances of Distribution that describes the projection. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. figmatplotlib Figure instanceIf given, use this figure instance for the visualization,. axmatplotlib ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:74050,Energy Efficiency,reduce,reduced-dimensionality,74050,"ented as a base class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters. dataarray_likeData for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs. xvecslistList of arrays that spans the space for each coordinate. xlabelslistList of labels for each coordinate. marginal(dim=0)[source]¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters. dimintThe dimension (coordinate index) along which to obtain the; marginal distribution. Returns. dDistributionsA new instances of Distribution that describes the marginal; distribution. project(dim=0)[source]¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters. dimintThe dimension (coordinate index) along which to obtain the; projected distribution. Returns. dDistributionsA new instances of Distribution that describes the projection. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. figmatplotlib Figure instanceIf given, use this figure instance for the visualization,. axmatplotlib Axes instanceIf given, render the visualization using this axis instance. figsizetupleSize of the new Figure instance, if one needs to be created. colorbar: BoolWhether or not the colorbar (in 2D visualization) should be used. cmap: matplotlib colormap instanceIf given, use this colormap for 2D visualizations. stylestringType of visualization: ‘colormap’ (default) or ‘surface’. Returns. fig, axtu",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:150116,Energy Efficiency,energy,energy,150116,"es; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class DispersiveCavityQED(N, correct_global_phase=True, num_levels=10, deltamax=1.0, epsmax=9.5, w0=10.0, wq=None, eps=9.5, delta=0.0, g=0.01, t1=None, t2=None)[source]¶; The processor based on the physical implementation of; a dispersive cavity QED system.; The available Hamiltonian of the system is predefined.; For a given pulse amplitude matrix, the processor can; calculate the state evolution under the given control pulse,; either analytically or numerically.; (Only additional attributes are documented here, for others please; refer to the parent class ModelProcessor). Parameters. N: intThe number of qubits in the system. correct_global_phase: float, optionalSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. num_levels: int, optionalThe number of energy levels in the resonator. deltamax: int or list, optionalThe coefficients of sigma-x for each of the qubits in the system. epsmax: int or list, optionalThe coefficients of sigma-z for each of the qubits in the system. w0: int, optionalThe base frequency of the resonator. eps: int or list, optionalThe epsilon for each of the qubits in the system. delta: int or list, optionalThe epsilon for each of the qubits in the system. g: int or list, optionalThe interaction strength for each of the qubit with the resonator. t1: list or floatCharacterize the decoherence of amplitude damping for; each qubit. A list of size N or a float for all qubits. t2: list of floatCharacterize the decoherence of dephasing for; each qubit. A list of size N or a float for all qubits. Attributes. sx_ops: listA list of sigmax Hamiltonians for each qubit. sz_ops: listA list of sigmaz Hamiltonians for each qubit. cavityqubit_ops: listA list of interacting Hamiltonians between cavity and each qubit. sx_u: arra",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:160307,Energy Efficiency,energy,energy,160307,"ol amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(N, num_levels, deltamax, epsmax, w0, wq, eps, delta, g)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, “w0”, “eps”, “delta”; and “g”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “g”, list element i is the interaction; between qubits i and i+1. Parameters. N: intThe number of qubits in the system. num_levels: intThe number of energy levels in the resonator. deltamax: listThe coefficients of sigma-x for each of the qubits in the system. epsmax: listThe coefficients of sigma-z for each of the qubits in the system. wo: intThe base frequency of the resonator. wq: listThe frequency of the qubits. eps: listThe epsilon for each of the qubits in the system. delta: listThe delta for each of the qubits in the system. g: listThe interaction strength for each of the qubit with the resonator. Notes; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class Noise[source]¶; The base class representing noise in a processor.; The noise object can be added to Processor and; contributes to evolution. get_noisy_dynamics(dims, pulses, systematic_noise)[source]¶; Return a pulses list added with noise and; the pulse independent noise in a dummy Pulse object. Parameters. dims: list, optionalThe dimension of the components system, the default value is; [2,2…,2] for qubits",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:175546,Energy Efficiency,schedul,schedule,175546,"ber of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer pulse_index needs to be used; in the compiling routine saved under the attributes gate_compiler. Attributes. gate_compiler: dictThe Python dictionary in the form of {gate_name: compiler_function}.; It saves the compiling routine for each gate. See sub-classes; for implementation.; Note that for continuous pulse, the first coeff should always be 0. args: dictArguments for individual compiling routines.; It adds more flexibility in customizing compiler. compile(circuit, schedule_mode=None, args=None)[source]¶; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters. circuit: :class:`.QubitCircuit` or list ofGate; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. class CavityQEDCompiler(N, params, pulse_dict, global_phase=0.0)[source]¶; Decompose a QubitCircuit into; the pulse sequence for the processor. Parameters. N: intThe number of qubits in the system. params: dictA Python dictionary contains the name and the value of the parameters.; See DispersiveCavityQED.set_up_params for the definition. global_phase: float, optionalRecord of the global phase change and will be returned. pulse_dict: dict, optionalA map between the pulse label and its index in the pulse list.; If g",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:177688,Energy Efficiency,schedul,schedule,177688," match the number of pulses; in the processor.; If it is empty, an integer pulse_index needs to be used; in the compiling routine saved under the attributes gate_compiler. Attributes. N: intThe number of the component systems. params: dictA Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc. pulse_dict: dictA map between the pulse label and its index in the pulse list. gate_compiler: dictThe Python dictionary in the form of {gate_name: decompose_function}.; It saves the decomposition scheme for each gate. compile(circuit, schedule_mode=None, args=None)¶; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters. circuit: :class:`.QubitCircuit` or list ofGate; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate; Notes; This version of sqrtiswap_compiler has very low fidelity, please use; iswap. class SpinChainCompiler(N, params, pulse_dict, setup='linear', global_phase=0.0)[source]¶; Compile a QubitCircuit into; the pulse sequence for the processor. Parameters. N: in",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:180355,Energy Efficiency,schedul,schedule,180355,"aved under the attributes gate_compiler. Attributes. N: intThe number of the component systems. params: dictA Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc. pulse_dict: dictA map between the pulse label and its index in the pulse list. gate_compiler: dictThe Python dictionary in the form of {gate_name: decompose_function}.; It saves the decomposition scheme for each gate. setup: string“linear” or “circular” for two sub-classes. global_phase: boolRecord of the global phase change and will be returned. compile(circuit, schedule_mode=None, args=None)¶; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters. circuit: :class:`.QubitCircuit` or list ofGate; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:181122,Energy Efficiency,schedul,scheduler,181122," A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419.; The scheduler includes two methods,; “ASAP”, as soon as possible, and “ALAP”, as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits.; The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters. method: str“ASAP” for as soon as possible.; “ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware cons",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:181173,Energy Efficiency,schedul,schedules,181173,"te_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419.; The scheduler includes two methods,; “ASAP”, as soon as possible, and “ALAP”, as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits.; The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters. method: str“ASAP” for as soon as possible.; “ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two inst",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:181219,Energy Efficiency,reduce,reduce,181219,"te_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419.; The scheduler includes two methods,; “ASAP”, as soon as possible, and “ALAP”, as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits.; The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters. method: str“ASAP” for as soon as possible.; “ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two inst",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:181354,Energy Efficiency,schedul,scheduler,181354,"ionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419.; The scheduler includes two methods,; “ASAP”, as soon as possible, and “ALAP”, as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits.; The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters. method: str“ASAP” for as soon as possible.; “ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Sinc",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:181548,Energy Efficiency,schedul,scheduler,181548,"pe (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419.; The scheduler includes two methods,; “ASAP”, as soon as possible, and “ALAP”, as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits.; The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters. method: str“ASAP” for as soon as possible.; “ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are th",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:181572,Energy Efficiency,schedul,schedule,181572,"pe (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419.; The scheduler includes two methods,; “ASAP”, as soon as possible, and “ALAP”, as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits.; The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters. method: str“ASAP” for as soon as possible.; “ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are th",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:181631,Energy Efficiency,reduce,reduce,181631,"pe (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419.; The scheduler includes two methods,; “ASAP”, as soon as possible, and “ALAP”, as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits.; The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters. method: str“ASAP” for as soon as possible.; “ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are th",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:182725,Energy Efficiency,schedul,schedule,182725,"“ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are the same gate and have the same controls or targets,; they are considered as commuting.; E.g. CNOT 0, 1 commute with CNOT 0, 2. schedule(circuit, gates_schedule=False, return_cycles_list=False, random_shuffle=False, repeat_num=0)[source]¶; Schedule a QubitCircuit,; a list of Gates or a list of Instruction.; For pulse schedule, the execution time for each Instruction; is given in its duration attributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instruct",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:182916,Energy Efficiency,schedul,schedule,182916,"ubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are the same gate and have the same controls or targets,; they are considered as commuting.; E.g. CNOT 0, 1 commute with CNOT 0, 2. schedule(circuit, gates_schedule=False, return_cycles_list=False, random_shuffle=False, repeat_num=0)[source]¶; Schedule a QubitCircuit,; a list of Gates or a list of Instruction.; For pulse schedule, the execution time for each Instruction; is given in its duration attributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:183009,Energy Efficiency,schedul,scheduler,183009,"e]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are the same gate and have the same controls or targets,; they are considered as commuting.; E.g. CNOT 0, 1 commute with CNOT 0, 2. schedule(circuit, gates_schedule=False, return_cycles_list=False, random_shuffle=False, repeat_num=0)[source]¶; Schedule a QubitCircuit,; a list of Gates or a list of Instruction.; For pulse schedule, the execution time for each Instruction; is given in its duration attributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distan",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:183708,Energy Efficiency,schedul,schedule,183708,"es_schedule=False, return_cycles_list=False, random_shuffle=False, repeat_num=0)[source]¶; Schedule a QubitCircuit,; a list of Gates or a list of Instruction.; For pulse schedule, the execution time for each Instruction; is given in its duration attributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:183831,Energy Efficiency,schedul,schedule,183831," of Gates or a list of Instruction.; For pulse schedule, the execution time for each Instruction; is given in its duration attributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gat",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:184191,Energy Efficiency,schedul,schedule,184191,"; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_s",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:184268,Energy Efficiency,schedul,schedule,184268,"e of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit impo",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:184461,Energy Efficiency,schedul,schedule,184461," time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_g",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:184540,Energy Efficiency,schedul,schedule,184540,"is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:184915,Energy Efficiency,schedul,schedule,184915,"ch instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:185069,Energy Efficiency,schedul,scheduling,185069,"istance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; [gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]; Notice that gate3 and gate4 commute with gate2,; therefore, the ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:185369,Energy Efficiency,schedul,scheduler,185369,"ction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; [gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles. class Instruction(gate, tlist=None, pulse_info=(), duration=1)[source]¶; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list,",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:185734,Energy Efficiency,schedul,scheduler,185734,"cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; [gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles. class Instruction(gate, tlist=None, pulse_info=(), duration=1)[source]¶; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list, optionalThe execution time needed for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, ar",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:185769,Energy Efficiency,schedul,scheduler,185769,"cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; [gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles. class Instruction(gate, tlist=None, pulse_info=(), duration=1)[source]¶; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list, optionalThe execution time needed for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, ar",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:185779,Energy Efficiency,schedul,schedule,185779,"ains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; [gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles. class Instruction(gate, tlist=None, pulse_info=(), duration=1)[source]¶; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list, optionalThe execution time needed for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, array_like).; This pulses will implement the desired gate. Attributes. target",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:186095,Energy Efficiency,reduce,reduce,186095,"re; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; [gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles. class Instruction(gate, tlist=None, pulse_info=(), duration=1)[source]¶; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list, optionalThe execution time needed for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, array_like).; This pulses will implement the desired gate. Attributes. targets: list, optionalThe target qubits. controls: list, optionalThe control qubits. used_qubits: setUnion of the control and target qubits. Optimal control¶. class Optimizer(config, dyn, params=None)[so",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:190229,Energy Efficiency,reduce,reduce,190229,"floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamicsDynamics (subclass instance)describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). configOptimConfig instancevarious configuration options; (see OptimConfig for details). termination_conditionsTerminationCondition instanceattributes determine when the optimisation will end. pulse_generatorPulseGen (subclass instance)(can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. statsStatsattributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dumpdump.OptimDumpContainer for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumpingstringThe level of data dumping that will occur during the optimisation. dump_to_fileboolIf set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dirstringBasically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summaryOptimIterSummarySummary of the most recent iteration.; Note this is only set if dummping is on. apply_method_params(params=Non",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:204424,Energy Efficiency,reduce,reduce,204424,"at is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_computerFidelityComputer (subclass instance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory s",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:219317,Energy Efficiency,efficient,efficient,219317," This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; PropagatorComputer subclasses that may be more efficient. reset()[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_normfloatNormalisation constant. fid_norm_funcfunctionUsed to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_nor",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:8346,Integrability,depend,dependent,8346,"sarrayArray of eigenvalues for operator. eigvecsarrayArray of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(states_inds, normalize=False)[source]¶; Creates a new quantum object with states in state_inds eliminated. Parameters. states_indslist of integerThe states that should be removed. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Notes; Experimental. static evaluate(qobj_list, t, args)[source]¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, ‘sin(w * t)’]]. is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters. qobj_listlistA nested list of Qobj instances and corresponding time-dependent; coefficients. tfloatThe time for which to evaluate the time-dependent Qobj instance. argsdictionaryA dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns. outputqutip.QobjA Qobj instance that represents the value of qobj_list at time t. expm(method='dense')[source]¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters. methodstr {‘dense’, ‘sparse’}Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’. Since the; exponential of a matrix is nearly always dense, method=’dense’; is set as default.s. Returns. operqutip.Q",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:8668,Integrability,depend,dependent,8668,"(states_inds, normalize=False)[source]¶; Creates a new quantum object with states in state_inds eliminated. Parameters. states_indslist of integerThe states that should be removed. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Notes; Experimental. static evaluate(qobj_list, t, args)[source]¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, ‘sin(w * t)’]]. is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters. qobj_listlistA nested list of Qobj instances and corresponding time-dependent; coefficients. tfloatThe time for which to evaluate the time-dependent Qobj instance. argsdictionaryA dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns. outputqutip.QobjA Qobj instance that represents the value of qobj_list at time t. expm(method='dense')[source]¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters. methodstr {‘dense’, ‘sparse’}Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’. Since the; exponential of a matrix is nearly always dense, method=’dense’; is set as default.s. Returns. operqutip.QobjExponentiated quantum operator. Raises. TypeErrorQuantum operator is not square. extract_states(states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters. states_indslist of integerThe states that should be kept. normalizeTrue / FalseWeather or not the new Qobj instance should ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:8739,Integrability,depend,dependent,8739,"in state_inds eliminated. Parameters. states_indslist of integerThe states that should be removed. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Notes; Experimental. static evaluate(qobj_list, t, args)[source]¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, ‘sin(w * t)’]]. is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters. qobj_listlistA nested list of Qobj instances and corresponding time-dependent; coefficients. tfloatThe time for which to evaluate the time-dependent Qobj instance. argsdictionaryA dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns. outputqutip.QobjA Qobj instance that represents the value of qobj_list at time t. expm(method='dense')[source]¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters. methodstr {‘dense’, ‘sparse’}Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’. Since the; exponential of a matrix is nearly always dense, method=’dense’; is set as default.s. Returns. operqutip.QobjExponentiated quantum operator. Raises. TypeErrorQuantum operator is not square. extract_states(states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters. states_indslist of integerThe states that should be kept. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or s",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:8844,Integrability,depend,dependent,8844,"e removed. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Notes; Experimental. static evaluate(qobj_list, t, args)[source]¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, ‘sin(w * t)’]]. is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters. qobj_listlistA nested list of Qobj instances and corresponding time-dependent; coefficients. tfloatThe time for which to evaluate the time-dependent Qobj instance. argsdictionaryA dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns. outputqutip.QobjA Qobj instance that represents the value of qobj_list at time t. expm(method='dense')[source]¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters. methodstr {‘dense’, ‘sparse’}Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’. Since the; exponential of a matrix is nearly always dense, method=’dense’; is set as default.s. Returns. operqutip.QobjExponentiated quantum operator. Raises. TypeErrorQuantum operator is not square. extract_states(states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters. states_indslist of integerThe states that should be kept. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:17084,Integrability,depend,dependent,17084,"lues; of this instance, then renormalizing to obtain a valid density; operator. Parameters. methodstrAlgorithm to use to remove negative eigenvalues. “clip”; simply discards negative eigenvalues, then renormalizes.; “sgs” uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns. operqutip.QobjA valid density operator. unit(inplace=False, norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters. inplaceboolDo an in-place normalization. normstrRequested norm for states / operators. sparseboolUse sparse eigensolver for trace norm. Does not affect other norms. tolfloatTolerance used by sparse eigensolver. maxiterintNumber of maximum iterations performed by sparse eigensolver. Returns. operqutip.QobjNormalized quantum object if not in-place,; else None. QobjEvo¶. class QobjEvo(Q_object=[], args={}, copy=True, tlist=None, state0=None, e_ops=[])[source]¶; A class for representing time-dependent quantum objects, such as quantum; operators and states.; Basic math operations are defined:. +, - : QobjEvo, Qobj, scalars.; *: Qobj, C number; / : C number. This object is constructed by passing a list of Qobj instances,; each of which may have an associated scalar time dependence. The list is; summed to produce the final result. In other words, if an instance of this; class is \(Q(t)\), then it is constructed from a set of constant; Qobj \(\{Q_k\}\) and time-dependent scalars \(f_k(t)\) by. \[Q(t) = \sum_k f_k(t) Q_k\]; If a scalar \(f_k(t)\) is not passed with a given Qobj, then; that term is assumed to be constant. The next section contains more detail; on the allowed forms of the constants, and gives several examples for how; to build instances of this class.; Time-dependence formats; There are three major formats for specifying a time-dependent scalar:. Python function; string; array. For function format, the function signature must be; f(t:",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:17366,Integrability,depend,dependence,17366,"to find the; positive operator that is nearest in the Shatten 2-norm. Returns. operqutip.QobjA valid density operator. unit(inplace=False, norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters. inplaceboolDo an in-place normalization. normstrRequested norm for states / operators. sparseboolUse sparse eigensolver for trace norm. Does not affect other norms. tolfloatTolerance used by sparse eigensolver. maxiterintNumber of maximum iterations performed by sparse eigensolver. Returns. operqutip.QobjNormalized quantum object if not in-place,; else None. QobjEvo¶. class QobjEvo(Q_object=[], args={}, copy=True, tlist=None, state0=None, e_ops=[])[source]¶; A class for representing time-dependent quantum objects, such as quantum; operators and states.; Basic math operations are defined:. +, - : QobjEvo, Qobj, scalars.; *: Qobj, C number; / : C number. This object is constructed by passing a list of Qobj instances,; each of which may have an associated scalar time dependence. The list is; summed to produce the final result. In other words, if an instance of this; class is \(Q(t)\), then it is constructed from a set of constant; Qobj \(\{Q_k\}\) and time-dependent scalars \(f_k(t)\) by. \[Q(t) = \sum_k f_k(t) Q_k\]; If a scalar \(f_k(t)\) is not passed with a given Qobj, then; that term is assumed to be constant. The next section contains more detail; on the allowed forms of the constants, and gives several examples for how; to build instances of this class.; Time-dependence formats; There are three major formats for specifying a time-dependent scalar:. Python function; string; array. For function format, the function signature must be; f(t: float, args: dict) -> complex, for example; def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the strin",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:17559,Integrability,depend,dependent,17559,"¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters. inplaceboolDo an in-place normalization. normstrRequested norm for states / operators. sparseboolUse sparse eigensolver for trace norm. Does not affect other norms. tolfloatTolerance used by sparse eigensolver. maxiterintNumber of maximum iterations performed by sparse eigensolver. Returns. operqutip.QobjNormalized quantum object if not in-place,; else None. QobjEvo¶. class QobjEvo(Q_object=[], args={}, copy=True, tlist=None, state0=None, e_ops=[])[source]¶; A class for representing time-dependent quantum objects, such as quantum; operators and states.; Basic math operations are defined:. +, - : QobjEvo, Qobj, scalars.; *: Qobj, C number; / : C number. This object is constructed by passing a list of Qobj instances,; each of which may have an associated scalar time dependence. The list is; summed to produce the final result. In other words, if an instance of this; class is \(Q(t)\), then it is constructed from a set of constant; Qobj \(\{Q_k\}\) and time-dependent scalars \(f_k(t)\) by. \[Q(t) = \sum_k f_k(t) Q_k\]; If a scalar \(f_k(t)\) is not passed with a given Qobj, then; that term is assumed to be constant. The next section contains more detail; on the allowed forms of the constants, and gives several examples for how; to build instances of this class.; Time-dependence formats; There are three major formats for specifying a time-dependent scalar:. Python function; string; array. For function format, the function signature must be; f(t: float, args: dict) -> complex, for example; def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:; pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos ac",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:17875,Integrability,depend,dependence,17875,"object if not in-place,; else None. QobjEvo¶. class QobjEvo(Q_object=[], args={}, copy=True, tlist=None, state0=None, e_ops=[])[source]¶; A class for representing time-dependent quantum objects, such as quantum; operators and states.; Basic math operations are defined:. +, - : QobjEvo, Qobj, scalars.; *: Qobj, C number; / : C number. This object is constructed by passing a list of Qobj instances,; each of which may have an associated scalar time dependence. The list is; summed to produce the final result. In other words, if an instance of this; class is \(Q(t)\), then it is constructed from a set of constant; Qobj \(\{Q_k\}\) and time-dependent scalars \(f_k(t)\) by. \[Q(t) = \sum_k f_k(t) Q_k\]; If a scalar \(f_k(t)\) is not passed with a given Qobj, then; that term is assumed to be constant. The next section contains more detail; on the allowed forms of the constants, and gives several examples for how; to build instances of this class.; Time-dependence formats; There are three major formats for specifying a time-dependent scalar:. Python function; string; array. For function format, the function signature must be; f(t: float, args: dict) -> complex, for example; def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:; pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:; H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype np.float64 or; np.complex128. A list of times (np.float64) at which the; coeffients must be given as tlist. The coeffients array must have the; same length as the tlist. Th",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:17947,Integrability,depend,dependent,17947,"object if not in-place,; else None. QobjEvo¶. class QobjEvo(Q_object=[], args={}, copy=True, tlist=None, state0=None, e_ops=[])[source]¶; A class for representing time-dependent quantum objects, such as quantum; operators and states.; Basic math operations are defined:. +, - : QobjEvo, Qobj, scalars.; *: Qobj, C number; / : C number. This object is constructed by passing a list of Qobj instances,; each of which may have an associated scalar time dependence. The list is; summed to produce the final result. In other words, if an instance of this; class is \(Q(t)\), then it is constructed from a set of constant; Qobj \(\{Q_k\}\) and time-dependent scalars \(f_k(t)\) by. \[Q(t) = \sum_k f_k(t) Q_k\]; If a scalar \(f_k(t)\) is not passed with a given Qobj, then; that term is assumed to be constant. The next section contains more detail; on the allowed forms of the constants, and gives several examples for how; to build instances of this class.; Time-dependence formats; There are three major formats for specifying a time-dependent scalar:. Python function; string; array. For function format, the function signature must be; f(t: float, args: dict) -> complex, for example; def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:; pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:; H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype np.float64 or; np.complex128. A list of times (np.float64) at which the; coeffients must be given as tlist. The coeffients array must have the; same length as the tlist. Th",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:20364,Integrability,depend,depending,20364,"not possible to create a single; QobjEvo that contains different tlist values, however.; Passing arguments; args is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string.; There are some “magic” names that can be specified, whose objects will be; overwritten when used within sesolve, mesolve and; mcsolve. This allows access to the solvers’ internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. ""state"": the current state as a Qobj; ""state_vec"": the current state as a column-stacked 1D np.ndarray; ""state_mat"": the current state as a 2D np.ndarray; ""expect_op_<n>"": the current expectation value of the element; e_ops[n], which is an argument to the solvers. Replace <n> with; an integer literal, e.g. ""expect_op_0"". This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; ""collapse"": (mcsolve only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; (time: float, which: int), where time is the time this collapse; happened, and which is an integer indexing the c_ops argument to; mcsolve. Parameters. Q_objectlist, Qobj or QobjEvoThe time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of [Qobj, time_dependence] pairs that are; summed to make the whole object. The time_dependence can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the Qobj instead; of the 2-element list. argsdict, optionalMapping of {str: object}, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous secti",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:20759,Integrability,depend,dependent,20759,"when used within sesolve, mesolve and; mcsolve. This allows access to the solvers’ internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. ""state"": the current state as a Qobj; ""state_vec"": the current state as a column-stacked 1D np.ndarray; ""state_mat"": the current state as a 2D np.ndarray; ""expect_op_<n>"": the current expectation value of the element; e_ops[n], which is an argument to the solvers. Replace <n> with; an integer literal, e.g. ""expect_op_0"". This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; ""collapse"": (mcsolve only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; (time: float, which: int), where time is the time this collapse; happened, and which is an integer indexing the c_ops argument to; mcsolve. Parameters. Q_objectlist, Qobj or QobjEvoThe time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of [Qobj, time_dependence] pairs that are; summed to make the whole object. The time_dependence can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the Qobj instead; of the 2-element list. argsdict, optionalMapping of {str: object}, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the “magic”; names used to access solver internals. tlistarray_like, optionalList of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in Q_object is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes. cteQobjConstant part of",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:21101,Integrability,depend,dependence,21101,"t state as a 2D np.ndarray; ""expect_op_<n>"": the current expectation value of the element; e_ops[n], which is an argument to the solvers. Replace <n> with; an integer literal, e.g. ""expect_op_0"". This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; ""collapse"": (mcsolve only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; (time: float, which: int), where time is the time this collapse; happened, and which is an integer indexing the c_ops argument to; mcsolve. Parameters. Q_objectlist, Qobj or QobjEvoThe time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of [Qobj, time_dependence] pairs that are; summed to make the whole object. The time_dependence can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the Qobj instead; of the 2-element list. argsdict, optionalMapping of {str: object}, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the “magic”; names used to access solver internals. tlistarray_like, optionalList of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in Q_object is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes. cteQobjConstant part of the QobjEvo. opslist of EvoElementInternal representation of the time-dependence structure of the; elements. argsdictThe current value of the args dictionary passed into the; constructor. dynamics_argslistNames of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the args parameter. tlistarray_likeList of tim",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:21575,Integrability,depend,dependences,21575,"at, which: int), where time is the time this collapse; happened, and which is an integer indexing the c_ops argument to; mcsolve. Parameters. Q_objectlist, Qobj or QobjEvoThe time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of [Qobj, time_dependence] pairs that are; summed to make the whole object. The time_dependence can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the Qobj instead; of the 2-element list. argsdict, optionalMapping of {str: object}, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the “magic”; names used to access solver internals. tlistarray_like, optionalList of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in Q_object is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes. cteQobjConstant part of the QobjEvo. opslist of EvoElementInternal representation of the time-dependence structure of the; elements. argsdictThe current value of the args dictionary passed into the; constructor. dynamics_argslistNames of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the args parameter. tlistarray_likeList of times at which the numpy-array coefficients are applied. compiledstrA string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevoCQobjCte or CQobjEvoTdCython version of the QobjEvo. coeff_getcallableObject called to obtain a list of all the coefficients at a particular; time. coeff_fileslistRuntime created files to delete with the instance. dummy_cteboolIs self.cte an empty Qobj. constboolIndicate",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:21833,Integrability,depend,dependence,21833,"e format as the first parameter to the general ODE solvers; in; general, it is a list of [Qobj, time_dependence] pairs that are; summed to make the whole object. The time_dependence can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the Qobj instead; of the 2-element list. argsdict, optionalMapping of {str: object}, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the “magic”; names used to access solver internals. tlistarray_like, optionalList of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in Q_object is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes. cteQobjConstant part of the QobjEvo. opslist of EvoElementInternal representation of the time-dependence structure of the; elements. argsdictThe current value of the args dictionary passed into the; constructor. dynamics_argslistNames of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the args parameter. tlistarray_likeList of times at which the numpy-array coefficients are applied. compiledstrA string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevoCQobjCte or CQobjEvoTdCython version of the QobjEvo. coeff_getcallableObject called to obtain a list of all the coefficients at a particular; time. coeff_fileslistRuntime created files to delete with the instance. dummy_cteboolIs self.cte an empty Qobj. constboolIndicates if quantum object is constant. type{“cte”, “string”, “func”, “array”, “spline”, “mixed_callable”, “mixed_compilable”}Information about the type of coefficients used in the entire object. num_objintNumber of Qobj in the QobjEvo. use_cythonbool",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:23040,Integrability,depend,dependent,23040,"vers will generate. These; are the magic names that were found in the args parameter. tlistarray_likeList of times at which the numpy-array coefficients are applied. compiledstrA string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevoCQobjCte or CQobjEvoTdCython version of the QobjEvo. coeff_getcallableObject called to obtain a list of all the coefficients at a particular; time. coeff_fileslistRuntime created files to delete with the instance. dummy_cteboolIs self.cte an empty Qobj. constboolIndicates if quantum object is constant. type{“cte”, “string”, “func”, “array”, “spline”, “mixed_callable”, “mixed_compilable”}Information about the type of coefficients used in the entire object. num_objintNumber of Qobj in the QobjEvo. use_cythonboolFlag to compile string to Cython or Python. safePickleboolFlag to not share pointers between thread. apply(function, *args, **kw_args)[source]¶; Apply the linear function function to every Qobj included in; this time-dependent object, and return a new QobjEvo with the; result.; Any additional arguments or keyword arguments will be appended to every; function call. apply_decorator(function, *args, str_mod=None, inplace_np=False, **kw_args)[source]¶; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result.; Any additional arguments and keyword arguments will be appended to the; function calls. Parameters. functioncallable(time_dependence, *args, **kwargs) -> time_dependence. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_modlistA 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string x will; become str_mod[0] + x + str_mod[1]. inplace_npbool, default FalseWhether this function should modify Numpy arrays inplace, or be; used lik",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:23315,Integrability,depend,dependent,23315,"piled_qobjevoCQobjCte or CQobjEvoTdCython version of the QobjEvo. coeff_getcallableObject called to obtain a list of all the coefficients at a particular; time. coeff_fileslistRuntime created files to delete with the instance. dummy_cteboolIs self.cte an empty Qobj. constboolIndicates if quantum object is constant. type{“cte”, “string”, “func”, “array”, “spline”, “mixed_callable”, “mixed_compilable”}Information about the type of coefficients used in the entire object. num_objintNumber of Qobj in the QobjEvo. use_cythonboolFlag to compile string to Cython or Python. safePickleboolFlag to not share pointers between thread. apply(function, *args, **kw_args)[source]¶; Apply the linear function function to every Qobj included in; this time-dependent object, and return a new QobjEvo with the; result.; Any additional arguments or keyword arguments will be appended to every; function call. apply_decorator(function, *args, str_mod=None, inplace_np=False, **kw_args)[source]¶; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result.; Any additional arguments and keyword arguments will be appended to the; function calls. Parameters. functioncallable(time_dependence, *args, **kwargs) -> time_dependence. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_modlistA 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string x will; become str_mod[0] + x + str_mod[1]. inplace_npbool, default FalseWhether this function should modify Numpy arrays inplace, or be; used like a regular decorator. Some decorators create incorrect; arrays as some transformations f'(t) = f(g(t)) create a; mismatch between the array and the associated time list. arguments(new_args)[source]¶; Update the scoped variables that were passed as args to new values. compile(code=F",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:23595,Integrability,depend,dependent,23595,"t. type{“cte”, “string”, “func”, “array”, “spline”, “mixed_callable”, “mixed_compilable”}Information about the type of coefficients used in the entire object. num_objintNumber of Qobj in the QobjEvo. use_cythonboolFlag to compile string to Cython or Python. safePickleboolFlag to not share pointers between thread. apply(function, *args, **kw_args)[source]¶; Apply the linear function function to every Qobj included in; this time-dependent object, and return a new QobjEvo with the; result.; Any additional arguments or keyword arguments will be appended to every; function call. apply_decorator(function, *args, str_mod=None, inplace_np=False, **kw_args)[source]¶; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result.; Any additional arguments and keyword arguments will be appended to the; function calls. Parameters. functioncallable(time_dependence, *args, **kwargs) -> time_dependence. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_modlistA 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string x will; become str_mod[0] + x + str_mod[1]. inplace_npbool, default FalseWhether this function should modify Numpy arrays inplace, or be; used like a regular decorator. Some decorators create incorrect; arrays as some transformations f'(t) = f(g(t)) create a; mismatch between the array and the associated time list. arguments(new_args)[source]¶; Update the scoped variables that were passed as args to new values. compile(code=False, matched=False, dense=False, omp=0)[source]¶; Create an associated Cython object for faster usage. This function is; called automatically by the solvers. Parameters. codebool, default FalseReturn the code string generated by compilation of any strings. matchedbool, default FalseIf True, the underlying sparse ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:23796,Integrability,wrap,wrap,23796,"ber of Qobj in the QobjEvo. use_cythonboolFlag to compile string to Cython or Python. safePickleboolFlag to not share pointers between thread. apply(function, *args, **kw_args)[source]¶; Apply the linear function function to every Qobj included in; this time-dependent object, and return a new QobjEvo with the; result.; Any additional arguments or keyword arguments will be appended to every; function call. apply_decorator(function, *args, str_mod=None, inplace_np=False, **kw_args)[source]¶; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result.; Any additional arguments and keyword arguments will be appended to the; function calls. Parameters. functioncallable(time_dependence, *args, **kwargs) -> time_dependence. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_modlistA 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string x will; become str_mod[0] + x + str_mod[1]. inplace_npbool, default FalseWhether this function should modify Numpy arrays inplace, or be; used like a regular decorator. Some decorators create incorrect; arrays as some transformations f'(t) = f(g(t)) create a; mismatch between the array and the associated time list. arguments(new_args)[source]¶; Update the scoped variables that were passed as args to new values. compile(code=False, matched=False, dense=False, omp=0)[source]¶; Create an associated Cython object for faster usage. This function is; called automatically by the solvers. Parameters. codebool, default FalseReturn the code string generated by compilation of any strings. matchedbool, default FalseIf True, the underlying sparse matrices used to represent each; element of the type will have their structures unified. This may; include adding explicit zeros to sparse matrices, but can be faster; in ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:23818,Integrability,depend,dependences,23818,"ber of Qobj in the QobjEvo. use_cythonboolFlag to compile string to Cython or Python. safePickleboolFlag to not share pointers between thread. apply(function, *args, **kw_args)[source]¶; Apply the linear function function to every Qobj included in; this time-dependent object, and return a new QobjEvo with the; result.; Any additional arguments or keyword arguments will be appended to every; function call. apply_decorator(function, *args, str_mod=None, inplace_np=False, **kw_args)[source]¶; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result.; Any additional arguments and keyword arguments will be appended to the; function calls. Parameters. functioncallable(time_dependence, *args, **kwargs) -> time_dependence. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_modlistA 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string x will; become str_mod[0] + x + str_mod[1]. inplace_npbool, default FalseWhether this function should modify Numpy arrays inplace, or be; used like a regular decorator. Some decorators create incorrect; arrays as some transformations f'(t) = f(g(t)) create a; mismatch between the array and the associated time list. arguments(new_args)[source]¶; Update the scoped variables that were passed as args to new values. compile(code=False, matched=False, dense=False, omp=0)[source]¶; Create an associated Cython object for faster usage. This function is; called automatically by the solvers. Parameters. codebool, default FalseReturn the code string generated by compilation of any strings. matchedbool, default FalseIf True, the underlying sparse matrices used to represent each; element of the type will have their structures unified. This may; include adding explicit zeros to sparse matrices, but can be faster; in ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:23848,Integrability,depend,dependence,23848,"fePickleboolFlag to not share pointers between thread. apply(function, *args, **kw_args)[source]¶; Apply the linear function function to every Qobj included in; this time-dependent object, and return a new QobjEvo with the; result.; Any additional arguments or keyword arguments will be appended to every; function call. apply_decorator(function, *args, str_mod=None, inplace_np=False, **kw_args)[source]¶; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result.; Any additional arguments and keyword arguments will be appended to the; function calls. Parameters. functioncallable(time_dependence, *args, **kwargs) -> time_dependence. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_modlistA 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string x will; become str_mod[0] + x + str_mod[1]. inplace_npbool, default FalseWhether this function should modify Numpy arrays inplace, or be; used like a regular decorator. Some decorators create incorrect; arrays as some transformations f'(t) = f(g(t)) create a; mismatch between the array and the associated time list. arguments(new_args)[source]¶; Update the scoped variables that were passed as args to new values. compile(code=False, matched=False, dense=False, omp=0)[source]¶; Create an associated Cython object for faster usage. This function is; called automatically by the solvers. Parameters. codebool, default FalseReturn the code string generated by compilation of any strings. matchedbool, default FalseIf True, the underlying sparse matrices used to represent each; element of the type will have their structures unified. This may; include adding explicit zeros to sparse matrices, but can be faster; in some cases due to not having to deal with repeated structural; mismatches. densebool, def",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:25240,Integrability,depend,dependence,25240,"s to new values. compile(code=False, matched=False, dense=False, omp=0)[source]¶; Create an associated Cython object for faster usage. This function is; called automatically by the solvers. Parameters. codebool, default FalseReturn the code string generated by compilation of any strings. matchedbool, default FalseIf True, the underlying sparse matrices used to represent each; element of the type will have their structures unified. This may; include adding explicit zeros to sparse matrices, but can be faster; in some cases due to not having to deal with repeated structural; mismatches. densebool, default FalseWhether to swap to using dense matrices to back the data. ompint, optionalThe number of OpenMP threads to use when doing matrix; multiplications, if QuTiP was compiled with OpenMP. Returns. compiled_strstr(Only if code was set to True). The code-generated string of; compiled calling code. compress()[source]¶; Merge together elements that share the same time-dependence, to reduce; the number of matrix multiplications and additions that need to be done; to evaluate this object.; Modifies the object inplace. conj()[source]¶; Return the matrix elementwise conjugation. copy()[source]¶; Return a copy of this object. dag()[source]¶; Return the matrix conjugate-transpose (dagger). expect(t, state, herm=False)[source]¶; Calculate the expectation value of this operator on the given; (time-independent) state at a particular time.; This is more efficient than expect(QobjEvo(t), state). Parameters. tfloatThe time to evaluate this operator at. stateQobj or np.ndarrayThe state to take the expectation value around. hermbool, default FalseWhether this operator and the state are both Hermitian. If True,; only the real part of the result will be returned. See also. expectGeneral-purpose expectation values. mul_mat(t, mat)[source]¶; Multiply this object evaluated at time t by a matrix (from the; right). Parameters. tfloatThe time to evaluate this object at. matQobj or np.ndarrayThe ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:27228,Integrability,depend,dependent,27228,"ight). Parameters. tfloatThe time to evaluate this object at. matQobj or np.ndarrayThe matrix that is multiplied by this object. Returns. mat: Qobj or np.ndarrayThe matrix result in the same type as the input. mul_vec(t, vec)[source]¶; Multiply this object evaluated at time t by a vector. Parameters. tfloatThe time to evaluate this object at. vecQobj or np.ndarrayThe state-vector to multiply this object by. Returns. vec: Qobj or np.ndarrayThe vector result in the same type as the input. permute(order)[source]¶; Permute the tensor structure of the underlying matrices into a new; format. See also. Qobj.permutethe same operation on constant quantum objects. tidyup(atol=1e-12)[source]¶; Removes small elements from this quantum object inplace. to_list()[source]¶; Return this operator in the list-like form used to initialised it, like; can be passed to mesolve. trans()[source]¶; Return the matrix transpose. eseries¶. class eseries(q=None, s=array([], dtype=float64))[source]¶; Class representation of an exponential-series expansion of; time-dependent quantum objects. Deprecated since version 4.6.0: eseries will be removed in QuTiP 5. Please use QobjEvo; for general time-dependence. Attributes. amplndarrayArray of amplitudes for exponential series. ratesndarrayArray of rates for exponential series. dimslistDimensions of exponential series components. shapelistShape corresponding to exponential series components. Methods. value(tlist); Evaluate an exponential series at the times listed in tlist. spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist. tidyup(); Returns a tidier version of the exponential series. spec(wlist)[source]¶; Evaluate the spectrum of an exponential series at frequencies; in wlist. Parameters. wlistarray_likeArray/list of frequenies. Returns. val_listndarrayValues of exponential series at frequencies in wlist. tidyup(*args)[source]¶; Returns a tidier version of exponential series. value(tlist)[source]¶; Evaluates an exponen",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:27360,Integrability,depend,dependence,27360,"rix result in the same type as the input. mul_vec(t, vec)[source]¶; Multiply this object evaluated at time t by a vector. Parameters. tfloatThe time to evaluate this object at. vecQobj or np.ndarrayThe state-vector to multiply this object by. Returns. vec: Qobj or np.ndarrayThe vector result in the same type as the input. permute(order)[source]¶; Permute the tensor structure of the underlying matrices into a new; format. See also. Qobj.permutethe same operation on constant quantum objects. tidyup(atol=1e-12)[source]¶; Removes small elements from this quantum object inplace. to_list()[source]¶; Return this operator in the list-like form used to initialised it, like; can be passed to mesolve. trans()[source]¶; Return the matrix transpose. eseries¶. class eseries(q=None, s=array([], dtype=float64))[source]¶; Class representation of an exponential-series expansion of; time-dependent quantum objects. Deprecated since version 4.6.0: eseries will be removed in QuTiP 5. Please use QobjEvo; for general time-dependence. Attributes. amplndarrayArray of amplitudes for exponential series. ratesndarrayArray of rates for exponential series. dimslistDimensions of exponential series components. shapelistShape corresponding to exponential series components. Methods. value(tlist); Evaluate an exponential series at the times listed in tlist. spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist. tidyup(); Returns a tidier version of the exponential series. spec(wlist)[source]¶; Evaluate the spectrum of an exponential series at frequencies; in wlist. Parameters. wlistarray_likeArray/list of frequenies. Returns. val_listndarrayValues of exponential series at frequencies in wlist. tidyup(*args)[source]¶; Returns a tidier version of exponential series. value(tlist)[source]¶; Evaluates an exponential series at the times listed in tlist. Parameters. tlistndarrayTimes at which to evaluate exponential series. Returns. val_listndarrayValues of exponential at times i",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:39192,Integrability,integrat,integrate,39192,"=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=N",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:39654,Integrability,depend,depend,39654," If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject s",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:40806,Integrability,integrat,integrator,40806,"pically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., l",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:41719,Integrability,integrat,integratorstr,41719,"yCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse o",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:41895,Integrability,integrat,integrator,41895,"e simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). Returns. : complexexpectation",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:41969,Integrability,integrat,integrator,41969,"ed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). Returns. : complexexpectation value of field correlation function. outfieldpropagato",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:46536,Integrability,integrat,integrator,46536,"]¶; Contain and compute expectation values. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_t_tol=1e-06, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, steady_state_average=False, seeds=None, normalize_output=True, use_openmp=None, openmp_threads=None)[source]¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes. atolfloat {1e-8}Absolute tolerance. rtolfloat {1e-6}Relative tolerance. methodstr {‘adams’,’bdf’}Integration method. orderint {12}Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nstepsint {2500}Max. number of internal steps/call. first_stepfloat {0}Size of initial step (0 = automatic). min_stepfloat {0}Minimum step size (0 = automatic). max_stepfloat {0}Maximum step size (0 = automatic). tidybool {True,False}Tidyup Hamiltonian and initial state by removing small terms. num_cpusintNumber of cpus used by mcsolver (default = # of cpus). norm_tolfloatTolerance used when finding wavefunction norm in mcsolve. norm_stepsintMax. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_statesbool {False}Average states values over trajectories in stochastic solvers. average_expectbool {True}Average expectation values over trajectories for stochastic solvers. mc_corr_epsfloat {1e-10}Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve. ntrajint {500}Number of trajectories in stochastic solvers. openmp_threadsintNumber of OPENMP threads to use. Default",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:50792,Integrability,message,message,50792,"ection called ‘main’ is created. Attributes. sectionsOrderedDict of _StatsSectionThese are the sections that are created automatically on instantiation; or added using add_section. headerstringSome text that will be used as the heading in the report; By default there is None. total_timefloatTime in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported. add_count(key, value, section=None)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters. keystringkey for the section.counts dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the count, or added to an existing count. sectionstring or _StatsSectionSection which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters. keystringkey for the section.messages dictionary; reusing a key will result in concatenation of value. valueintInitial value of the message, or added to an existing message. sepstringMessage will be prefixed with this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. section_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:50928,Integrability,message,message,50928," add_section. headerstringSome text that will be used as the heading in the report; By default there is None. total_timefloatTime in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported. add_count(key, value, section=None)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters. keystringkey for the section.counts dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the count, or added to an existing count. sectionstring or _StatsSectionSection which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters. keystringkey for the section.messages dictionary; reusing a key will result in concatenation of value. valueintInitial value of the message, or added to an existing message. sepstringMessage will be prefixed with this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. section_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will res",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:51019,Integrability,message,messages,51019,"e in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported. add_count(key, value, section=None)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters. keystringkey for the section.counts dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the count, or added to an existing count. sectionstring or _StatsSectionSection which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters. keystringkey for the section.messages dictionary; reusing a key will result in concatenation of value. valueintInitial value of the message, or added to an existing message. sepstringMessage will be prefixed with this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. section_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `cla",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:51122,Integrability,message,message,51122," that total timing percentages will be reported. add_count(key, value, section=None)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters. keystringkey for the section.counts dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the count, or added to an existing count. sectionstring or _StatsSectionSection which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters. keystringkey for the section.messages dictionary; reusing a key will result in concatenation of value. valueintInitial value of the message, or added to an existing message. sepstringMessage will be prefixed with this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. section_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `class`_StatsSectionSection which to add the timing to.; If None given, the ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:51155,Integrability,message,message,51155," that total timing percentages will be reported. add_count(key, value, section=None)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters. keystringkey for the section.counts dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the count, or added to an existing count. sectionstring or _StatsSectionSection which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters. keystringkey for the section.messages dictionary; reusing a key will result in concatenation of value. valueintInitial value of the message, or added to an existing message. sepstringMessage will be prefixed with this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. section_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `class`_StatsSectionSection which to add the timing to.; If None given, the ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:51299,Integrability,message,message,51299,"in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters. keystringkey for the section.counts dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the count, or added to an existing count. sectionstring or _StatsSectionSection which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters. keystringkey for the section.messages dictionary; reusing a key will result in concatenation of value. valueintInitial value of the message, or added to an existing message. sepstringMessage will be prefixed with this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. section_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `class`_StatsSectionSection which to add the timing to.; If None given, the default (first) section will be used. clear()[source]¶; Clear counts, timings and messages from all sections. report(output=<_io.TextIOWrapper n",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:52210,Integrability,message,messages,52210,"h this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. section_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `class`_StatsSectionSection which to add the timing to.; If None given, the default (first) section will be used. clear()[source]¶; Clear counts, timings and messages from all sections. report(output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>)[source]¶; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters. outputstreamfile or console stream - anything that support write - where; the output will be written. set_total_time(value, section=None)[source]¶; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters. valuefloatTime in seconds to complete the solver section. sectionstring or classSection which to set the total_time for; If None given, the total_time for complete solve is set. class",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:52356,Integrability,message,messages,52356,"given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. section_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `class`_StatsSectionSection which to add the timing to.; If None given, the default (first) section will be used. clear()[source]¶; Clear counts, timings and messages from all sections. report(output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>)[source]¶; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters. outputstreamfile or console stream - anything that support write - where; the output will be written. set_total_time(value, section=None)[source]¶; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters. valuefloatTime in seconds to complete the solver section. sectionstring or classSection which to set the total_time for; If None given, the total_time for complete solve is set. class StochasticSolverOptions(me, H=None, c_ops=[], sc_ops=[], state0=None, e_ops=[], m_ops=None, store_all_expect=False, st",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:52495,Integrability,message,messages,52495,"on_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `class`_StatsSectionSection which to add the timing to.; If None given, the default (first) section will be used. clear()[source]¶; Clear counts, timings and messages from all sections. report(output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>)[source]¶; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters. outputstreamfile or console stream - anything that support write - where; the output will be written. set_total_time(value, section=None)[source]¶; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters. valuefloatTime in seconds to complete the solver section. sectionstring or classSection which to set the total_time for; If None given, the total_time for complete solve is set. class StochasticSolverOptions(me, H=None, c_ops=[], sc_ops=[], state0=None, e_ops=[], m_ops=None, store_all_expect=False, store_measurement=False, dW_factors=None, solver=None, method='homodyne', normalize=None, times=None, nsubsteps=1, ntraj=1, tol=None, generate_noise=None, noise=None, progress_bar=None, map_func=None, map_kwargs=None, args={}, options=N",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:54252,Integrability,depend,dependent,54252,"=[], state0=None, e_ops=[], m_ops=None, store_all_expect=False, store_measurement=False, dW_factors=None, solver=None, method='homodyne', normalize=None, times=None, nsubsteps=1, ntraj=1, tol=None, generate_noise=None, noise=None, progress_bar=None, map_func=None, map_kwargs=None, args={}, options=None, noiseDepth=20)[source]¶; Class of options for stochastic solvers such as; qutip.stochastic.ssesolve, qutip.stochastic.smesolve, etc.; The stochastic solvers qutip.stochastic.general_stochastic,; qutip.stochastic.ssesolve, qutip.stochastic.smesolve,; qutip.stochastic.photocurrent_sesolve and; qutip.stochastic.photocurrent_mesolve; all take the same keyword arguments as; the constructor of these class, and internally they use these arguments to; construct an instance of this class, so it is rarely needed to explicitly; create an instance of this class.; Within the attribute list, a time_dependent_object is either. Qobj: a constant term; 2-element list of [Qobj, time_dependence]: a time-dependent term; where the Qobj will be multiplied by the time-dependent scalar. For more details on all allowed time-dependent objects, see the; documentation for QobjEvo. Attributes. Htime_dependent_object or list of time_dependent_objectSystem Hamiltonian in standard time-dependent list format. This is the; same as the argument that (e.g.) mesolve takes. If this is a; list of elements, they are summed. state0qutip.QobjInitial state vector (ket) or density matrix. timesarray_like of floatList of times for \(t\). Must be uniformly spaced. c_opslist of time_dependent_objectList of deterministic collapse operators. Each element of the list is; a separate operator; unlike the Hamiltonian, there is no implicit; summation over the terms. sc_opslist of time_dependent_objectList of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. Each element of",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:54314,Integrability,depend,dependent,54314,"=[], state0=None, e_ops=[], m_ops=None, store_all_expect=False, store_measurement=False, dW_factors=None, solver=None, method='homodyne', normalize=None, times=None, nsubsteps=1, ntraj=1, tol=None, generate_noise=None, noise=None, progress_bar=None, map_func=None, map_kwargs=None, args={}, options=None, noiseDepth=20)[source]¶; Class of options for stochastic solvers such as; qutip.stochastic.ssesolve, qutip.stochastic.smesolve, etc.; The stochastic solvers qutip.stochastic.general_stochastic,; qutip.stochastic.ssesolve, qutip.stochastic.smesolve,; qutip.stochastic.photocurrent_sesolve and; qutip.stochastic.photocurrent_mesolve; all take the same keyword arguments as; the constructor of these class, and internally they use these arguments to; construct an instance of this class, so it is rarely needed to explicitly; create an instance of this class.; Within the attribute list, a time_dependent_object is either. Qobj: a constant term; 2-element list of [Qobj, time_dependence]: a time-dependent term; where the Qobj will be multiplied by the time-dependent scalar. For more details on all allowed time-dependent objects, see the; documentation for QobjEvo. Attributes. Htime_dependent_object or list of time_dependent_objectSystem Hamiltonian in standard time-dependent list format. This is the; same as the argument that (e.g.) mesolve takes. If this is a; list of elements, they are summed. state0qutip.QobjInitial state vector (ket) or density matrix. timesarray_like of floatList of times for \(t\). Must be uniformly spaced. c_opslist of time_dependent_objectList of deterministic collapse operators. Each element of the list is; a separate operator; unlike the Hamiltonian, there is no implicit; summation over the terms. sc_opslist of time_dependent_objectList of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. Each element of",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:54369,Integrability,depend,dependent,54369,"od='homodyne', normalize=None, times=None, nsubsteps=1, ntraj=1, tol=None, generate_noise=None, noise=None, progress_bar=None, map_func=None, map_kwargs=None, args={}, options=None, noiseDepth=20)[source]¶; Class of options for stochastic solvers such as; qutip.stochastic.ssesolve, qutip.stochastic.smesolve, etc.; The stochastic solvers qutip.stochastic.general_stochastic,; qutip.stochastic.ssesolve, qutip.stochastic.smesolve,; qutip.stochastic.photocurrent_sesolve and; qutip.stochastic.photocurrent_mesolve; all take the same keyword arguments as; the constructor of these class, and internally they use these arguments to; construct an instance of this class, so it is rarely needed to explicitly; create an instance of this class.; Within the attribute list, a time_dependent_object is either. Qobj: a constant term; 2-element list of [Qobj, time_dependence]: a time-dependent term; where the Qobj will be multiplied by the time-dependent scalar. For more details on all allowed time-dependent objects, see the; documentation for QobjEvo. Attributes. Htime_dependent_object or list of time_dependent_objectSystem Hamiltonian in standard time-dependent list format. This is the; same as the argument that (e.g.) mesolve takes. If this is a; list of elements, they are summed. state0qutip.QobjInitial state vector (ket) or density matrix. timesarray_like of floatList of times for \(t\). Must be uniformly spaced. c_opslist of time_dependent_objectList of deterministic collapse operators. Each element of the list is; a separate operator; unlike the Hamiltonian, there is no implicit; summation over the terms. sc_opslist of time_dependent_objectList of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. Each element of the list is a separate operator, like; c_ops. e_opslist of qutip.QobjSingle operator or list of operators for which to ev",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:54527,Integrability,depend,dependent,54527,"s_bar=None, map_func=None, map_kwargs=None, args={}, options=None, noiseDepth=20)[source]¶; Class of options for stochastic solvers such as; qutip.stochastic.ssesolve, qutip.stochastic.smesolve, etc.; The stochastic solvers qutip.stochastic.general_stochastic,; qutip.stochastic.ssesolve, qutip.stochastic.smesolve,; qutip.stochastic.photocurrent_sesolve and; qutip.stochastic.photocurrent_mesolve; all take the same keyword arguments as; the constructor of these class, and internally they use these arguments to; construct an instance of this class, so it is rarely needed to explicitly; create an instance of this class.; Within the attribute list, a time_dependent_object is either. Qobj: a constant term; 2-element list of [Qobj, time_dependence]: a time-dependent term; where the Qobj will be multiplied by the time-dependent scalar. For more details on all allowed time-dependent objects, see the; documentation for QobjEvo. Attributes. Htime_dependent_object or list of time_dependent_objectSystem Hamiltonian in standard time-dependent list format. This is the; same as the argument that (e.g.) mesolve takes. If this is a; list of elements, they are summed. state0qutip.QobjInitial state vector (ket) or density matrix. timesarray_like of floatList of times for \(t\). Must be uniformly spaced. c_opslist of time_dependent_objectList of deterministic collapse operators. Each element of the list is; a separate operator; unlike the Hamiltonian, there is no implicit; summation over the terms. sc_opslist of time_dependent_objectList of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. Each element of the list is a separate operator, like; c_ops. e_opslist of qutip.QobjSingle operator or list of operators for which to evaluate; expectation values. m_opslist of qutip.QobjList of operators representing the measurement operators. The ex",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:55668,Integrability,depend,dependent,55668,"med. state0qutip.QobjInitial state vector (ket) or density matrix. timesarray_like of floatList of times for \(t\). Must be uniformly spaced. c_opslist of time_dependent_objectList of deterministic collapse operators. Each element of the list is; a separate operator; unlike the Hamiltonian, there is no implicit; summation over the terms. sc_opslist of time_dependent_objectList of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. Each element of the list is a separate operator, like; c_ops. e_opslist of qutip.QobjSingle operator or list of operators for which to evaluate; expectation values. m_opslist of qutip.QobjList of operators representing the measurement operators. The expected; format is a nested list with one measurement operator for each; stochastic increament, for each stochastic collapse operator. argsdictDictionary of parameters for time dependent systems. tolfloatTolerance of the solver for implicit methods. ntrajintNumber of trajectors. nsubstepsintNumber of sub steps between each time-spep given in times. dW_factorsarrayArray of length len(sc_ops), containing scaling factors for each; measurement operator in m_ops. solverstringName of the solver method to use for solving the stochastic; equations. Valid values are:. order 1/2 algorithms: ‘euler-maruyama’, ‘pc-euler’, ‘pc-euler-imp’; order 1 algorithms: ‘milstein’, ‘platen’, ‘milstein-imp’, ‘rouchon’; order 3/2 algorithms: ‘taylor1.5’, ‘taylor1.5-imp’, ‘explicit1.5’; order 2 algorithms: ‘taylor2.0’. See the documentation of stochastic_solvers; for a description of the solvers. Implicit methods can adjust; tolerance via the kw ‘tol’. Default is {‘tol’: 1e-6}. methodstring (‘homodyne’, ‘heterodyne’)The name of the type of measurement process that give rise to the; stochastic equation to solve. store_all_expectbool (default False)Whether or not to store the ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:60871,Integrability,integrat,integrate,60871,"pled basis.; default: (nds, nds). c_ops()[source]¶; Build collapse operators in the full Hilbert space 2^N. Returns. c_ops_list: listThe list with the collapse operators in the 2^N Hilbert space. coefficient_matrix()[source]¶; Build coefficient matrix for ODE for a diagonal problem. Returns. M: ndarrayThe matrix M of the coefficients for the ODE dp/dt = Mp.; p is the vector of the diagonal matrix elements; of the density matrix rho in the Dicke basis. lindbladian()[source]¶; Build the Lindbladian superoperator of the dissipative dynamics. Returns. lindbladianqutip.QobjThe Lindbladian matrix as a qutip.Qobj. liouvillian()[source]¶; Build the total Liouvillian using the Dicke basis. Returns. liouvqutip.QobjThe Liouvillian matrix for the system. pisolve(initial_state, tlist, options=None)[source]¶; Solve for diagonal Hamiltonians and initial states faster. Parameters. initial_statequtip.QobjAn initial state specified as a density matrix of; qutip.Qbj type. tlist: ndarrayA 1D numpy array of list of timesteps to integrate. optionsqutip.solver.OptionsThe options for the solver. Returns. result: listA dictionary of the type qutip.solver.Result which holds the; results of the evolution. class Pim(N, emission=0.0, dephasing=0, pumping=0, collective_emission=0, collective_pumping=0, collective_dephasing=0)[source]¶; The Permutation Invariant Matrix class.; Initialize the class with the parameters for generating a Permutation; Invariant matrix which evolves a given diagonal initial state p as:. dp/dt = Mp. Parameters. N: intThe number of two-level systems. emission: floatIncoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: floatLocal dephasing coefficient.; default: 0.0. pumping: floatIncoherent pumping coefficient.; default: 0.0. collective_emission: floatCollective (superradiant) emmission coefficient.; default: 0.0. collective_pumping: floatCollective pumping coefficient.; default: 0.0. collective_dephasing: floatCollective dephasing coeff",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:74462,Integrability,depend,depending,74462,"st of arrays that spans the space for each coordinate. xlabelslistList of labels for each coordinate. marginal(dim=0)[source]¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters. dimintThe dimension (coordinate index) along which to obtain the; marginal distribution. Returns. dDistributionsA new instances of Distribution that describes the marginal; distribution. project(dim=0)[source]¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters. dimintThe dimension (coordinate index) along which to obtain the; projected distribution. Returns. dDistributionsA new instances of Distribution that describes the projection. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. figmatplotlib Figure instanceIf given, use this figure instance for the visualization,. axmatplotlib Axes instanceIf given, render the visualization using this axis instance. figsizetupleSize of the new Figure instance, if one needs to be created. colorbar: BoolWhether or not the colorbar (in 2D visualization) should be used. cmap: matplotlib colormap instanceIf given, use this colormap for 2D visualizations. stylestringType of visualization: ‘colormap’ (default) or ‘surface’. Returns. fig, axtupleA tuple of matplotlib figure and axes instances. class WignerDistribution(rho=None, extent=[[- 5, 5], [- 5, 5]], steps=250)[source]¶. class QDistribution(rho=None, extent=[[- 5, 5], [- 5, 5]], steps=250)[source]¶. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[- 5, 5], [- 5, 5]], steps=250)[source]¶. update(state)[source]",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:97178,Integrability,depend,dependent,97178,"f analytical is True, calculate the propagator; with matrix exponentiation and return a list of matrices.; Noise will be neglected in this option. Parameters. init_state: QobjInitial density matrix or state vector (ket). analytical: boolIf True, calculate the evolution with matrices exponentiation. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. solver: str“mesolve” or “mcsolve”. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.ResultIf analytical is False, an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)[source]¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)[source]¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. class OptPulseProcessor(N, drift=None, t1=None, t2=None, dims=None)[source]¶; A processor, which takes the Hamiltonian available; as dynamic generators, calls the; qutip.control.optimize_pulse_unitary function; to find an optimized pulse sequence for the desired quantum circuit.; The processor can simulate the evolution under the given; control pulses using qutip.mesolve.; (For attributes documentation, please; refer to the parent class Processor). Parameters. N: intThe number of component systems. drift: `:class:`qutip.Qobj`The drift Hamiltonian. The size must match the whole quantum system. t1: list or floatCharacterize the decoherence of amplitude damping for; each qubit. A list of size N or a float for all qubits. t2: list of floatCharacterize the decoherence of dephasing for; each qubit. A list of size N or a float for all qubits. dims: listThe dimension of each component system.; Default value i",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:107927,Integrability,depend,dependent,107927,"rd arguments.; If analytical is True, calculate the propagator; with matrix exponentiation and return a list of matrices.; Noise will be neglected in this option. Parameters. init_state: QobjInitial density matrix or state vector (ket). analytical: boolIf True, calculate the evolution with matrices exponentiation. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. solver: str“mesolve” or “mcsolve”. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.ResultIf analytical is False, an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. class ModelProcessor(N, correct_global_phase=True, t1=None, t2=None)[source]¶; The base class for a circuit processor simulating a physical device,; e.g cavityQED, spinchain.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically.; It cannot be used alone, please refer to the sub-classes.; (Only additional attributes are documented here, for others please; refer to the parent class Processor). Parameters. N: intThe number of component systems. correct_global_phase: boolean, optionalIf true, the analytical solution will track the global phase. It; has no effect on the numerical solution. t1: list or floatCharacterize the decoherence of amplitude damping for; each qubit. A list of size N or a float for all qubits. t2: list of floatCharacterize the decoherence of dephasing for; each qubit. A list",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:116717,Integrability,depend,dependent,116717,"tor; with matrix exponentiation and return a list of matrices. Parameters. init_state: QobjInitial density matrix or state vector (ket). analytical: booleanIf True, calculate the evolution with matrices exponentiation. qc: :class:`.QubitCircuit`, optionalA quantum circuit. If given, it first calls the load_circuit; and then calculate the evolution. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.ResultIf analytical is False, an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_params()[source]¶; Save the parameters in the attribute params and check the validity.; (Defined in subclasses); Notes; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)[source]¶; Transfer a parameter to an array. class SpinChain(N, correct_global_phase, sx, sz, sxsy, t1, t2)[source]¶; The processor based on the physical implementation of; a spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically.; It is a base class and should not be used directly, please; refer the the subclasses qutip.qip.device.LinearSpinChain and; qutip.qip.device.CircularSpinChain.; (Only additional attributes are documented here, for others please; refer to the parent class ModelProcessor). Parameters. N: intThe number of qubits in the system. correct_global_ph",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:127547,Integrability,depend,dependent,127547,"tor; with matrix exponentiation and return a list of matrices. Parameters. init_state: QobjInitial density matrix or state vector (ket). analytical: booleanIf True, calculate the evolution with matrices exponentiation. qc: :class:`.QubitCircuit`, optionalA quantum circuit. If given, it first calls the load_circuit; and then calculate the evolution. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.ResultIf analytical is False, an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class LinearSpinChain(N, correct_global_phase=True, sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None)[source]¶; A processor based on the",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:137979,Integrability,depend,dependent,137979,"tor; with matrix exponentiation and return a list of matrices. Parameters. init_state: QobjInitial density matrix or state vector (ket). analytical: booleanIf True, calculate the evolution with matrices exponentiation. qc: :class:`.QubitCircuit`, optionalA quantum circuit. If given, it first calls the load_circuit; and then calculate the evolution. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.ResultIf analytical is False, an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz, sxsy)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class CircularSpinChain(N, correct_global_phase=True, sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None)[source]¶; A processor base",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:148421,Integrability,depend,dependent,148421,"tor; with matrix exponentiation and return a list of matrices. Parameters. init_state: QobjInitial density matrix or state vector (ket). analytical: booleanIf True, calculate the evolution with matrices exponentiation. qc: :class:`.QubitCircuit`, optionalA quantum circuit. If given, it first calls the load_circuit; and then calculate the evolution. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.ResultIf analytical is False, an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz, sxsy)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class DispersiveCavityQED(N, correct_global_phase=True, num_levels=10, deltamax=1.0, epsmax=9.5, w0=10.0, wq=None, eps=9.5, d",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:159605,Integrability,depend,dependent,159605,"tor; with matrix exponentiation and return a list of matrices. Parameters. init_state: QobjInitial density matrix or state vector (ket). analytical: booleanIf True, calculate the evolution with matrices exponentiation. qc: :class:`.QubitCircuit`, optionalA quantum circuit. If given, it first calls the load_circuit; and then calculate the evolution. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.ResultIf analytical is False, an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(N, num_levels, deltamax, epsmax, w0, wq, eps, delta, g)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, “w0”, “eps”, “delta”; and “g”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “g”, list element i is the interaction; between qubits i and i+1. Parameters. N: intThe number of qubits in the system. num_levels: intThe number of energy levels in the resonator. deltamax: listThe coefficients of sigma-x for each of the qubits in the system. epsmax: listThe coefficients of sigma-z for each of the qubits in the system. wo: intThe base frequency of the resonator. wq: listThe frequency of the qubits. eps: listThe ep",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:167725,Integrability,depend,dependent,167725,"tween two random amplitude. The coefficients; of the noise are the same within this time range. rand_gen: numpy.random, optionalA random generator in numpy.random, it has to take a size; parameter. indices: list of intThe indices of target pulse in the list of pulses. **kwargs:Key word arguments for the random number generator. get_noisy_dynamics(dims=None, pulses=None, systematic_noise=None)[source]¶; Return a pulses list added with noise and; the pulse independent noise in a dummy Pulse object. Parameters. dims: list, optionalThe dimension of the components system, the default value is; [2,2…,2] for qubits system. pulses: list of :class:`.Pulse`The input pulses, on which the noise object is to be applied. systematic_noise: :class:`.Pulse`The dummy pulse with no ideal control element. Returns. noisy_pulses: list of PulseNoisy pulses. systematic_noise: PulseThe dummy pulse representing pulse independent noise. class Pulse(qobj, targets, tlist=None, coeff=None, spline_kind=None, label='')[source]¶; Representation of a control pulse and the pulse dependent noise.; The pulse is characterized by the ideal control pulse, the coherent; noise and the lindblad noise. The later two are lists of; noisy evolution dynamics.; Each dynamic element is characterized by four variables:; qobj, targets, tlist and coeff.; See examples for different construction behavior. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the ideal pulse. targets: listtarget qubits of the ideal pulse; (or subquantum system of other dimensions). tlist: array-like, optionaltlist of the ideal pulse.; A list of time at which the time-dependent coefficients are applied.; tlist does not have to be equidistant, but must have the same length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind. coeff: array-like or bool, optionalTime-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to tlist.; ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:168289,Integrability,depend,dependent,168289,"ulses: list of :class:`.Pulse`The input pulses, on which the noise object is to be applied. systematic_noise: :class:`.Pulse`The dummy pulse with no ideal control element. Returns. noisy_pulses: list of PulseNoisy pulses. systematic_noise: PulseThe dummy pulse representing pulse independent noise. class Pulse(qobj, targets, tlist=None, coeff=None, spline_kind=None, label='')[source]¶; Representation of a control pulse and the pulse dependent noise.; The pulse is characterized by the ideal control pulse, the coherent; noise and the lindblad noise. The later two are lists of; noisy evolution dynamics.; Each dynamic element is characterized by four variables:; qobj, targets, tlist and coeff.; See examples for different construction behavior. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the ideal pulse. targets: listtarget qubits of the ideal pulse; (or subquantum system of other dimensions). tlist: array-like, optionaltlist of the ideal pulse.; A list of time at which the time-dependent coefficients are applied.; tlist does not have to be equidistant, but must have the same length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind. coeff: array-like or bool, optionalTime-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for the parameter spline_kind.; If a bool, the coefficient is a constant 1 or 0. spline_kind: str, optionalType of the coefficient interpolation:; “step_func” or “cubic”.; -“step_func”:; The coefficient will be treated as a step function.; E.g. tlist=[0,1,2] and coeff=[3,2], means that the coefficient; is 3 in t=[0,1) and 2 in t=[2,3). It requires; len(coeff)=len(tlist)-1 or len(coeff)=len(tlist), but; in the second case the last element of coeff has no effect.; -“cubic”:; Use cubic interpolation for the coefficient. It requires; len(coeff)=len(tlist). label: strThe label (name) of the pulse. Example",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:168528,Integrability,depend,dependent,168528,"seThe dummy pulse representing pulse independent noise. class Pulse(qobj, targets, tlist=None, coeff=None, spline_kind=None, label='')[source]¶; Representation of a control pulse and the pulse dependent noise.; The pulse is characterized by the ideal control pulse, the coherent; noise and the lindblad noise. The later two are lists of; noisy evolution dynamics.; Each dynamic element is characterized by four variables:; qobj, targets, tlist and coeff.; See examples for different construction behavior. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the ideal pulse. targets: listtarget qubits of the ideal pulse; (or subquantum system of other dimensions). tlist: array-like, optionaltlist of the ideal pulse.; A list of time at which the time-dependent coefficients are applied.; tlist does not have to be equidistant, but must have the same length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind. coeff: array-like or bool, optionalTime-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for the parameter spline_kind.; If a bool, the coefficient is a constant 1 or 0. spline_kind: str, optionalType of the coefficient interpolation:; “step_func” or “cubic”.; -“step_func”:; The coefficient will be treated as a step function.; E.g. tlist=[0,1,2] and coeff=[3,2], means that the coefficient; is 3 in t=[0,1) and 2 in t=[2,3). It requires; len(coeff)=len(tlist)-1 or len(coeff)=len(tlist), but; in the second case the last element of coeff has no effect.; -“cubic”:; Use cubic interpolation for the coefficient. It requires; len(coeff)=len(tlist). label: strThe label (name) of the pulse. Examples; Create a pulse that is turned off; >>> Pulse(sigmaz(), 0) ; >>> Pulse(sigmaz(), 0, None, None) . Create a time dependent pulse; >>> tlist = np.array([0., 1., 2., 4.]) ; >>> coeff = np.array([0.5, 1.2, 0.8]) ; >>> spline_kind = ""step_func"" ; ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:169403,Integrability,depend,dependent,169403,"shorter compared to coeff. See documentation for; the parameter spline_kind. coeff: array-like or bool, optionalTime-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for the parameter spline_kind.; If a bool, the coefficient is a constant 1 or 0. spline_kind: str, optionalType of the coefficient interpolation:; “step_func” or “cubic”.; -“step_func”:; The coefficient will be treated as a step function.; E.g. tlist=[0,1,2] and coeff=[3,2], means that the coefficient; is 3 in t=[0,1) and 2 in t=[2,3). It requires; len(coeff)=len(tlist)-1 or len(coeff)=len(tlist), but; in the second case the last element of coeff has no effect.; -“cubic”:; Use cubic interpolation for the coefficient. It requires; len(coeff)=len(tlist). label: strThe label (name) of the pulse. Examples; Create a pulse that is turned off; >>> Pulse(sigmaz(), 0) ; >>> Pulse(sigmaz(), 0, None, None) . Create a time dependent pulse; >>> tlist = np.array([0., 1., 2., 4.]) ; >>> coeff = np.array([0.5, 1.2, 0.8]) ; >>> spline_kind = ""step_func"" ; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=coeff, spline_kind=""step_func"") . Create a time independent pulse; >>> Pulse(sigmaz(), 0, coeff=True) . Create a constant pulse with time range; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=True) . Create an dummy Pulse (H=0); >>> Pulse(None, None) . Attributes. ideal_pulse: :class:`._EvoElement`The ideal dynamic of the control pulse. coherent_noise: list of :class:`._EvoElement`The coherent noise caused by the control pulse. Each dynamic element is; still characterized by a time-dependent Hamiltonian. lindblad_noise: list of :class:`._EvoElement`The dissipative noise of the control pulse. Each dynamic element; will be treated as a (time-dependent) lindblad operator in the; master equation. spline_kind: strSee parameter spline_kind. label: strSee parameter label. add_coherent_noise(qobj, targets, tlist=None, coeff=None)[source]¶",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:170057,Integrability,depend,dependent,170057,"ff)=len(tlist)-1 or len(coeff)=len(tlist), but; in the second case the last element of coeff has no effect.; -“cubic”:; Use cubic interpolation for the coefficient. It requires; len(coeff)=len(tlist). label: strThe label (name) of the pulse. Examples; Create a pulse that is turned off; >>> Pulse(sigmaz(), 0) ; >>> Pulse(sigmaz(), 0, None, None) . Create a time dependent pulse; >>> tlist = np.array([0., 1., 2., 4.]) ; >>> coeff = np.array([0.5, 1.2, 0.8]) ; >>> spline_kind = ""step_func"" ; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=coeff, spline_kind=""step_func"") . Create a time independent pulse; >>> Pulse(sigmaz(), 0, coeff=True) . Create a constant pulse with time range; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=True) . Create an dummy Pulse (H=0); >>> Pulse(None, None) . Attributes. ideal_pulse: :class:`._EvoElement`The ideal dynamic of the control pulse. coherent_noise: list of :class:`._EvoElement`The coherent noise caused by the control pulse. Each dynamic element is; still characterized by a time-dependent Hamiltonian. lindblad_noise: list of :class:`._EvoElement`The dissipative noise of the control pulse. Each dynamic element; will be treated as a (time-dependent) lindblad operator in the; master equation. spline_kind: strSee parameter spline_kind. label: strSee parameter label. add_coherent_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) Hamiltonian to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the pulse. targets: listtarget qubits of the pulse; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element l",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:170218,Integrability,depend,dependent,170218,"en(coeff)=len(tlist). label: strThe label (name) of the pulse. Examples; Create a pulse that is turned off; >>> Pulse(sigmaz(), 0) ; >>> Pulse(sigmaz(), 0, None, None) . Create a time dependent pulse; >>> tlist = np.array([0., 1., 2., 4.]) ; >>> coeff = np.array([0.5, 1.2, 0.8]) ; >>> spline_kind = ""step_func"" ; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=coeff, spline_kind=""step_func"") . Create a time independent pulse; >>> Pulse(sigmaz(), 0, coeff=True) . Create a constant pulse with time range; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=True) . Create an dummy Pulse (H=0); >>> Pulse(None, None) . Attributes. ideal_pulse: :class:`._EvoElement`The ideal dynamic of the control pulse. coherent_noise: list of :class:`._EvoElement`The coherent noise caused by the control pulse. Each dynamic element is; still characterized by a time-dependent Hamiltonian. lindblad_noise: list of :class:`._EvoElement`The dissipative noise of the control pulse. Each dynamic element; will be treated as a (time-dependent) lindblad operator in the; master equation. spline_kind: strSee parameter spline_kind. label: strSee parameter label. add_coherent_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) Hamiltonian to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the pulse. targets: listtarget qubits of the pulse; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for; the parameter spline_kind of Pulse.; If a bool, the coefficient is a constant 1 or 0. add_lindblad_noise(qobj, targets, tlist=None,",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:170430,Integrability,depend,dependent,170430,"nt pulse; >>> tlist = np.array([0., 1., 2., 4.]) ; >>> coeff = np.array([0.5, 1.2, 0.8]) ; >>> spline_kind = ""step_func"" ; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=coeff, spline_kind=""step_func"") . Create a time independent pulse; >>> Pulse(sigmaz(), 0, coeff=True) . Create a constant pulse with time range; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=True) . Create an dummy Pulse (H=0); >>> Pulse(None, None) . Attributes. ideal_pulse: :class:`._EvoElement`The ideal dynamic of the control pulse. coherent_noise: list of :class:`._EvoElement`The coherent noise caused by the control pulse. Each dynamic element is; still characterized by a time-dependent Hamiltonian. lindblad_noise: list of :class:`._EvoElement`The dissipative noise of the control pulse. Each dynamic element; will be treated as a (time-dependent) lindblad operator in the; master equation. spline_kind: strSee parameter spline_kind. label: strSee parameter label. add_coherent_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) Hamiltonian to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the pulse. targets: listtarget qubits of the pulse; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for; the parameter spline_kind of Pulse.; If a bool, the coefficient is a constant 1 or 0. add_lindblad_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The collapse operator of the lindblad noise. targets: listtarget ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:170688,Integrability,depend,dependent,170688,") . Create a constant pulse with time range; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=True) . Create an dummy Pulse (H=0); >>> Pulse(None, None) . Attributes. ideal_pulse: :class:`._EvoElement`The ideal dynamic of the control pulse. coherent_noise: list of :class:`._EvoElement`The coherent noise caused by the control pulse. Each dynamic element is; still characterized by a time-dependent Hamiltonian. lindblad_noise: list of :class:`._EvoElement`The dissipative noise of the control pulse. Each dynamic element; will be treated as a (time-dependent) lindblad operator in the; master equation. spline_kind: strSee parameter spline_kind. label: strSee parameter label. add_coherent_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) Hamiltonian to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the pulse. targets: listtarget qubits of the pulse; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for; the parameter spline_kind of Pulse.; If a bool, the coefficient is a constant 1 or 0. add_lindblad_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The collapse operator of the lindblad noise. targets: listtarget qubits of the collapse operator; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element short",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:170938,Integrability,depend,dependent,170938,"s:`._EvoElement`The coherent noise caused by the control pulse. Each dynamic element is; still characterized by a time-dependent Hamiltonian. lindblad_noise: list of :class:`._EvoElement`The dissipative noise of the control pulse. Each dynamic element; will be treated as a (time-dependent) lindblad operator in the; master equation. spline_kind: strSee parameter spline_kind. label: strSee parameter label. add_coherent_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) Hamiltonian to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the pulse. targets: listtarget qubits of the pulse; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for; the parameter spline_kind of Pulse.; If a bool, the coefficient is a constant 1 or 0. add_lindblad_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The collapse operator of the lindblad noise. targets: listtarget qubits of the collapse operator; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff.; See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documenta",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:171259,Integrability,depend,dependent,171259,"erator in the; master equation. spline_kind: strSee parameter spline_kind. label: strSee parameter label. add_coherent_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) Hamiltonian to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the pulse. targets: listtarget qubits of the pulse; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for; the parameter spline_kind of Pulse.; If a bool, the coefficient is a constant 1 or 0. add_lindblad_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The collapse operator of the lindblad noise. targets: listtarget qubits of the collapse operator; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff.; See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for; the parameter spline_kind of Pulse.; If a bool, the coefficient is a constant 1 or 0. property coeff¶; See parameter coeff. get_full_tlist(tol=1e-10)[source]¶; Return the full tlist of the pulses and noise. It means that if; different tlist are present, they will be merged to one with all; t",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:171547,Integrability,depend,dependent,171547,"e pulse. targets: listtarget qubits of the pulse; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for; the parameter spline_kind of Pulse.; If a bool, the coefficient is a constant 1 or 0. add_lindblad_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The collapse operator of the lindblad noise. targets: listtarget qubits of the collapse operator; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff.; See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for; the parameter spline_kind of Pulse.; If a bool, the coefficient is a constant 1 or 0. property coeff¶; See parameter coeff. get_full_tlist(tol=1e-10)[source]¶; Return the full tlist of the pulses and noise. It means that if; different tlist are present, they will be merged to one with all; time points stored in a sorted array. Returns. full_tlist: array-like 1dThe full time sequence for the noisy evolution. get_ideal_qobj(dims)[source]¶; Get the Hamiltonian of the ideal pulse. Parameters. dims: int or listDimension of the system.; If int, we assume it is the number of qubits in t",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:171798,Integrability,depend,dependent,171798,"r one element shorter compared to coeff. See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for; the parameter spline_kind of Pulse.; If a bool, the coefficient is a constant 1 or 0. add_lindblad_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The collapse operator of the lindblad noise. targets: listtarget qubits of the collapse operator; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff.; See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for; the parameter spline_kind of Pulse.; If a bool, the coefficient is a constant 1 or 0. property coeff¶; See parameter coeff. get_full_tlist(tol=1e-10)[source]¶; Return the full tlist of the pulses and noise. It means that if; different tlist are present, they will be merged to one with all; time points stored in a sorted array. Returns. full_tlist: array-like 1dThe full time sequence for the noisy evolution. get_ideal_qobj(dims)[source]¶; Get the Hamiltonian of the ideal pulse. Parameters. dims: int or listDimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns. qobj: qutip.QobjThe Hamiltonian of the ideal pulse. get_ideal_qobjevo(dims)[source]¶; Get a QobjEvo representation of the ideal evolution. Parameters. dims: int or listDimension of the sys",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:173463,Integrability,depend,dependent,173463,"ion of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns. qobj: qutip.QobjThe Hamiltonian of the ideal pulse. get_ideal_qobjevo(dims)[source]¶; Get a QobjEvo representation of the ideal evolution. Parameters. dims: int or listDimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns. ideal_evo: qutip.QobjEvoA QobjEvo representing the ideal evolution. get_noisy_qobjevo(dims)[source]¶; Get the QobjEvo representation of the noisy evolution. The; result can be used directly as input for the qutip solvers. Parameters. dims: int or listDimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns. noisy_evo: qutip.QobjEvoA QobjEvo representing the ideal evolution and coherent noise. c_ops: list of qutip.QobjEvoA list of (time-dependent) lindbald operators. print_info()[source]¶; Print the information of the pulse, including the ideal dynamics,; the coherent noise and the lindblad noise. property qobj¶; See parameter qobj. property targets¶; See parameter targets. property tlist¶; See parameter tlist. class GateCompiler(N, params=None, pulse_dict=None)[source]¶; Base class. It compiles a QubitCircuit into; the pulse sequence for the processor. The core member function; compile calls compiling method from the sub-class and concatenate; the compiled pulses. Parameters. N: intThe number of the component systems. params: dict, optionalA Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc.; It will be saved in the class attributes and can be used to calculate; the control pulses. pulse_dict: dict, optionalA map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; (pulse_label, coeff), instead of (pulse_in",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:174639,Integrability,rout,routine,174639,". property qobj¶; See parameter qobj. property targets¶; See parameter targets. property tlist¶; See parameter tlist. class GateCompiler(N, params=None, pulse_dict=None)[source]¶; Base class. It compiles a QubitCircuit into; the pulse sequence for the processor. The core member function; compile calls compiling method from the sub-class and concatenate; the compiled pulses. Parameters. N: intThe number of the component systems. params: dict, optionalA Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc.; It will be saved in the class attributes and can be used to calculate; the control pulses. pulse_dict: dict, optionalA map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; (pulse_label, coeff), instead of (pulse_index, coeff).; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer pulse_index needs to be used; in the compiling routine saved under the attributes gate_compiler. Attributes. gate_compiler: dictThe Python dictionary in the form of {gate_name: compiler_function}.; It saves the compiling routine for each gate. See sub-classes; for implementation.; Note that for continuous pulse, the first coeff should always be 0. args: dictArguments for individual compiling routines.; It adds more flexibility in customizing compiler. compile(circuit, schedule_mode=None, args=None)[source]¶; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters. circuit: :class:`.QubitCircuit` or list ofGate; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used i",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:174813,Integrability,rout,routine,174813,"lass. It compiles a QubitCircuit into; the pulse sequence for the processor. The core member function; compile calls compiling method from the sub-class and concatenate; the compiled pulses. Parameters. N: intThe number of the component systems. params: dict, optionalA Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc.; It will be saved in the class attributes and can be used to calculate; the control pulses. pulse_dict: dict, optionalA map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; (pulse_label, coeff), instead of (pulse_index, coeff).; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer pulse_index needs to be used; in the compiling routine saved under the attributes gate_compiler. Attributes. gate_compiler: dictThe Python dictionary in the form of {gate_name: compiler_function}.; It saves the compiling routine for each gate. See sub-classes; for implementation.; Note that for continuous pulse, the first coeff should always be 0. args: dictArguments for individual compiling routines.; It adds more flexibility in customizing compiler. compile(circuit, schedule_mode=None, args=None)[source]¶; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters. circuit: :class:`.QubitCircuit` or list ofGate; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tli",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:174987,Integrability,rout,routines,174987,"concatenate; the compiled pulses. Parameters. N: intThe number of the component systems. params: dict, optionalA Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc.; It will be saved in the class attributes and can be used to calculate; the control pulses. pulse_dict: dict, optionalA map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; (pulse_label, coeff), instead of (pulse_index, coeff).; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer pulse_index needs to be used; in the compiling routine saved under the attributes gate_compiler. Attributes. gate_compiler: dictThe Python dictionary in the form of {gate_name: compiler_function}.; It saves the compiling routine for each gate. See sub-classes; for implementation.; Note that for continuous pulse, the first coeff should always be 0. args: dictArguments for individual compiling routines.; It adds more flexibility in customizing compiler. compile(circuit, schedule_mode=None, args=None)[source]¶; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters. circuit: :class:`.QubitCircuit` or list ofGate; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate.",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:176752,Integrability,rout,routine,176752,"ient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. class CavityQEDCompiler(N, params, pulse_dict, global_phase=0.0)[source]¶; Decompose a QubitCircuit into; the pulse sequence for the processor. Parameters. N: intThe number of qubits in the system. params: dictA Python dictionary contains the name and the value of the parameters.; See DispersiveCavityQED.set_up_params for the definition. global_phase: float, optionalRecord of the global phase change and will be returned. pulse_dict: dict, optionalA map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; (pulse_label, coeff), instead of (pulse_index, coeff).; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer pulse_index needs to be used; in the compiling routine saved under the attributes gate_compiler. Attributes. N: intThe number of the component systems. params: dictA Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc. pulse_dict: dictA map between the pulse label and its index in the pulse list. gate_compiler: dictThe Python dictionary in the form of {gate_name: decompose_function}.; It saves the decomposition scheme for each gate. compile(circuit, schedule_mode=None, args=None)¶; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters. circuit: :class:`.QubitCircuit` or list ofGate; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA d",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:179288,Integrability,rout,routine,179288,"mpiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate; Notes; This version of sqrtiswap_compiler has very low fidelity, please use; iswap. class SpinChainCompiler(N, params, pulse_dict, setup='linear', global_phase=0.0)[source]¶; Compile a QubitCircuit into; the pulse sequence for the processor. Parameters. N: intThe number of qubits in the system. params: dictA Python dictionary contains the name and the value of the parameters.; See SpinChain.set_up_params for the definition. setup: string“linear” or “circular” for two sub-classes. global_phase: boolRecord of the global phase change and will be returned. pulse_dict: dict, optionalA map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; (pulse_label, coeff), instead of (pulse_index, coeff).; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer pulse_index needs to be used; in the compiling routine saved under the attributes gate_compiler. Attributes. N: intThe number of the component systems. params: dictA Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc. pulse_dict: dictA map between the pulse label and its index in the pulse list. gate_compiler: dictThe Python dictionary in the form of {gate_name: decompose_function}.; It saves the decomposition scheme for each gate. setup: string“linear” or “circular” for two sub-classes. global_phase: boolRecord of the global phase change and will be returned. compile(circuit, schedule_mode=None, args=None)¶; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters. circuit: :class:`.QubitCircuit` or list ofGate; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:183051,Integrability,depend,dependency,183051,"e]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are the same gate and have the same controls or targets,; they are considered as commuting.; E.g. CNOT 0, 1 commute with CNOT 0, 2. schedule(circuit, gates_schedule=False, return_cycles_list=False, random_shuffle=False, repeat_num=0)[source]¶; Schedule a QubitCircuit,; a list of Gates or a list of Instruction.; For pulse schedule, the execution time for each Instruction; is given in its duration attributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distan",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:183235,Integrability,depend,dependent,183235,"nstruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are the same gate and have the same controls or targets,; they are considered as commuting.; E.g. CNOT 0, 1 commute with CNOT 0, 2. schedule(circuit, gates_schedule=False, return_cycles_list=False, random_shuffle=False, repeat_num=0)[source]¶; Schedule a QubitCircuit,; a list of Gates or a list of Instruction.; For pulse schedule, the execution time for each Instruction; is given in its duration attributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate obje",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:183400,Integrability,depend,dependency,183400,"universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are the same gate and have the same controls or targets,; they are considered as commuting.; E.g. CNOT 0, 1 commute with CNOT 0, 2. schedule(circuit, gates_schedule=False, return_cycles_list=False, random_shuffle=False, repeat_num=0)[source]¶; Schedule a QubitCircuit,; a list of Gates or a list of Instruction.; For pulse schedule, the execution time for each Instruction; is given in its duration attributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalT",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:183944,Integrability,depend,dependency,183944,"ttributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly sc",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:186521,Integrability,depend,dependent,186521,"1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; [gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles. class Instruction(gate, tlist=None, pulse_info=(), duration=1)[source]¶; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list, optionalThe execution time needed for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, array_like).; This pulses will implement the desired gate. Attributes. targets: list, optionalThe target qubits. controls: list, optionalThe control qubits. used_qubits: setUnion of the control and target qubits. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses. This class implements the fidelity,; gradient and interation callback functions. All subclass objects must be; initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.loggin",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:188279,Integrability,message,message,188279," instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the pulse optim algorithm alg. disp_conv_msgboolSet true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_paramsDictionaryOptions for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_gradboolIf set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a s",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:194027,Integrability,wrap,wrapper,194027,"ation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object,",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:195570,Integrability,wrap,wrapper,195570,"all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:197026,Integrability,wrap,wrapper,197026,"thm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:198350,Integrability,wrap,wrapper,198350,"tions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter ter",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:198775,Integrability,wrap,wrapper,198775,"ied; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]¶; A summary of the most recent iteration of the pulse optimisation. Attributes. iter_numintIteration n",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:214551,Integrability,message,message,214551,"on assumes that the _apply_phase method has been; set to a custom function. Type; phase_application. property prop¶; List of propagators (Qobj) for each timeslot. property prop_grad¶; Array of propagator gradients (Qobj) for each timeslot, control. refresh_drift_attribs()[source]¶; Reset the dyn_shape, dyn_dims and time_depend_drift attribs. save_amps(file_name=None, times=None, amps=None, verbose=False)[source]¶; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters. file_namestringName of the file; If None given the def_amps_fname attribuite will be used. timesList type (or string)List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If ‘exclude’ then times will not be saved in the file, just; the amplitudes. ampsArray[num_tslots, num_ctrls]Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verboseBooleanIf True then an info message will be logged. unitarity_check()[source]¶; Checks whether all propagators are unitary. update_ctrl_amps(new_amps)[source]¶; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer. class DynamicsGenMat(optimconfig, params=None)[source]¶; This sub class can be used for any system where no additional; operator is applied to the dynamics generator before calculating; the propagator, e.g. classical dynamics, Lindbladian. class DynamicsUnitary(optimconfig, params=None)[source]¶; This is the subclass to use for systems with dynamics described by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes. drift_hamQobjThis is the drift Hamiltonian ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:242407,Integrability,depend,depends,242407,grad_computesintegerNumber of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updatesintegerNumber of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iterfloatMean number of control amplitude updates per iteration. num_timeslot_changesintegerNumber of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_updatefloatMean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changesintegerNumber of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_updatefloatMean average number of control amplitudes that are changed per update. calculate()[source]¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]¶; Print a report of the stats to the console. class Dump[source]¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes. parentsome control object (Dynamics or Optimizer)aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dirstrdirectory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. levelstringThe level of data dumping that will occur. write_to_fileboolWhen set True data and summaries (as configured) will be written; interactively to file during the processing; Set during instantiation by the host based on its dump_to_file attrib. dump_file_extstrDefault file extension for any file names that are auto generated. fname_basestrFirst part of any auto generated file names.; This is usually overridden in the subclass. dump_summaryboolIf True a summary is recorded each time a new item is added to the; the dump.; Default is True. ,MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:24231,Modifiability,variab,variables,24231,"None, inplace_np=False, **kw_args)[source]¶; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result.; Any additional arguments and keyword arguments will be appended to the; function calls. Parameters. functioncallable(time_dependence, *args, **kwargs) -> time_dependence. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_modlistA 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string x will; become str_mod[0] + x + str_mod[1]. inplace_npbool, default FalseWhether this function should modify Numpy arrays inplace, or be; used like a regular decorator. Some decorators create incorrect; arrays as some transformations f'(t) = f(g(t)) create a; mismatch between the array and the associated time list. arguments(new_args)[source]¶; Update the scoped variables that were passed as args to new values. compile(code=False, matched=False, dense=False, omp=0)[source]¶; Create an associated Cython object for faster usage. This function is; called automatically by the solvers. Parameters. codebool, default FalseReturn the code string generated by compilation of any strings. matchedbool, default FalseIf True, the underlying sparse matrices used to represent each; element of the type will have their structures unified. This may; include adding explicit zeros to sparse matrices, but can be faster; in some cases due to not having to deal with repeated structural; mismatches. densebool, default FalseWhether to swap to using dense matrices to back the data. ompint, optionalThe number of OpenMP threads to use when doing matrix; multiplications, if QuTiP was compiled with OpenMP. Returns. compiled_strstr(Only if code was set to True). The code-generated string of; compiled calling code. compress()[source]¶; Merge together elements that share the s",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:37224,Modifiability,coupling,coupling,37224,"this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve); This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code. Attributes. H_sysQobjSystem Hamiltonian. coup_opQobjOperator describing the coupling between system and bath. coup_strengthfloatCoupling strength. temperaturefloatBath temperature, in units corresponding to planck. N_cutintCutoff parameter for the bath. N_expintNumber of exponential terms used to approximate the bath correlation; functions. planckfloatreduced Planck constant. boltzmannfloatBoltzmann’s constant. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. statsqutip.solver.Statsoptional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=N",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:38118,Modifiability,config,configure,38118,"g strength. temperaturefloatBath temperature, in units corresponding to planck. N_cutintCutoff parameter for the bath. N_expintNumber of exponential terms used to approximate the bath correlation; functions. planckfloatreduced Planck constant. boltzmannfloatBoltzmann’s constant. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. statsqutip.solver.Statsoptional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys,",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:39184,Modifiability,config,config,39184,"=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=N",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:39971,Modifiability,coupling,coupling,39971,"s will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:40107,Modifiability,config,configure,40107,"lt values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of t",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:40309,Modifiability,config,configure,40309,"lt values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of t",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:40647,Modifiability,evolve,evolves,40647," exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conve",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:41101,Modifiability,coupling,coupling,41101," configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Co",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:41234,Modifiability,coupling,coupling,41234,"x=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dag",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:61311,Modifiability,evolve,evolves,61311,"n the Dicke basis. lindbladian()[source]¶; Build the Lindbladian superoperator of the dissipative dynamics. Returns. lindbladianqutip.QobjThe Lindbladian matrix as a qutip.Qobj. liouvillian()[source]¶; Build the total Liouvillian using the Dicke basis. Returns. liouvqutip.QobjThe Liouvillian matrix for the system. pisolve(initial_state, tlist, options=None)[source]¶; Solve for diagonal Hamiltonians and initial states faster. Parameters. initial_statequtip.QobjAn initial state specified as a density matrix of; qutip.Qbj type. tlist: ndarrayA 1D numpy array of list of timesteps to integrate. optionsqutip.solver.OptionsThe options for the solver. Returns. result: listA dictionary of the type qutip.solver.Result which holds the; results of the evolution. class Pim(N, emission=0.0, dephasing=0, pumping=0, collective_emission=0, collective_pumping=0, collective_dephasing=0)[source]¶; The Permutation Invariant Matrix class.; Initialize the class with the parameters for generating a Permutation; Invariant matrix which evolves a given diagonal initial state p as:. dp/dt = Mp. Parameters. N: intThe number of two-level systems. emission: floatIncoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: floatLocal dephasing coefficient.; default: 0.0. pumping: floatIncoherent pumping coefficient.; default: 0.0. collective_emission: floatCollective (superradiant) emmission coefficient.; default: 0.0. collective_pumping: floatCollective pumping coefficient.; default: 0.0. collective_dephasing: floatCollective dephasing coefficient.; default: 0.0. Attributes. N: intThe number of two-level systems. emission: floatIncoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: floatLocal dephasing coefficient.; default: 0.0. pumping: floatIncoherent pumping coefficient.; default: 0.0. collective_emission: floatCollective (superradiant) emmission coefficient.; default: 0.0. collective_dephasing: floatCollective dephasing coefficient.;",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:65790,Modifiability,coupling,coupling,65790," be checked. Returns. taus: dictA dictionary of key, val as {tau: value} consisting of the valid; taus for this row and column of the Dicke space element. One-Dimensional Lattice¶. class Lattice1d(num_cell=10, boundary='periodic', cell_num_site=1, cell_site_dof=[1], Hamiltonian_of_cell=None, inter_hop=None)[source]¶; A class for representing a 1d crystal.; The Lattice1d class can be defined with any specific unit cells and a; specified number of unit cells in the crystal. It can return dispersion; relationship, position operators, Hamiltonian in the position represention; etc. Parameters. num_cellintThe number of cells in the crystal. boundarystrSpecification of the type of boundary the crystal is defined with. cell_num_siteintThe number of sites in the unit cell. cell_site_doflist of int/ intThe tensor structure of the degrees of freedom at each site of a unit; cell. Hamiltonian_of_cellqutip.QobjThe Hamiltonian of the unit cell. inter_hopqutip.Qobj / list of QobjThe coupling between the unit cell at i and at (i+unit vector). Attributes. num_cellintThe number of unit cells in the crystal. cell_num_siteintThe nuber of sites in a unit cell. length_for_siteintThe length of the dimension per site of a unit cell. cell_tensor_configlist of intThe tensor structure of the cell in the form; [cell_num_site,cell_site_dof[:][0] ]. lattice_tensor_configlist of intThe tensor structure of the crystal in the; form [num_cell,cell_num_site,cell_site_dof[:][0]]. length_of_unit_cellintThe length of the dimension for a unit cell. period_bnd_cond_xint1 indicates “periodic” and 0 indicates “hardwall” boundary condition. inter_vec_listlist of listThe list of list of coefficients of inter unitcell vectors’ components; along Cartesian uit vectors. lattice_vectors_listlist of listThe list of list of coefficients of lattice basis vectors’ components; along Cartesian unit vectors. H_intraqutip.QobjThe Qobj storing the Hamiltonian of the unnit cell. H_inter_listlist of Qobj/ qutip.QobjThe list o",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:66810,Modifiability,coupling,coupling,66810,"and at (i+unit vector). Attributes. num_cellintThe number of unit cells in the crystal. cell_num_siteintThe nuber of sites in a unit cell. length_for_siteintThe length of the dimension per site of a unit cell. cell_tensor_configlist of intThe tensor structure of the cell in the form; [cell_num_site,cell_site_dof[:][0] ]. lattice_tensor_configlist of intThe tensor structure of the crystal in the; form [num_cell,cell_num_site,cell_site_dof[:][0]]. length_of_unit_cellintThe length of the dimension for a unit cell. period_bnd_cond_xint1 indicates “periodic” and 0 indicates “hardwall” boundary condition. inter_vec_listlist of listThe list of list of coefficients of inter unitcell vectors’ components; along Cartesian uit vectors. lattice_vectors_listlist of listThe list of list of coefficients of lattice basis vectors’ components; along Cartesian unit vectors. H_intraqutip.QobjThe Qobj storing the Hamiltonian of the unnit cell. H_inter_listlist of Qobj/ qutip.QobjThe list of coupling terms between unit cells of the lattice. is_realboolIndicates if the Hamiltonian is real or not. Hamiltonian()[source]¶; Returns the lattice Hamiltonian for the instance of Lattice1d. Returns. Qobj(Hamil)qutip.Qobjoper type Quantum object representing the lattice Hamiltonian. basis(cell, site, dof_ind)[source]¶; Returns a single particle wavefunction ket with the particle localized; at a specified dof at a specified site of a specified cell. Parameters. cell (int) – The cell at which the particle is to be localized.; site (int) – The site of the cell at which the particle is to be localized.; dof_ind (int/ list of int) – The index of the degrees of freedom with which the sigle particle; is to be localized. Returns. vec_iqutip.Qobjket type Quantum object representing the localized particle. bloch_wave_functions()[source]¶; Returns eigenvectors ($psi_n(k)$) of the Hamiltonian in a; numpy.ndarray for translationally symmetric lattices with periodic; boundary condition. \begin{eqnarray}; |\psi_n(k",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:69707,Modifiability,coupling,coupling,69707,"od quantum number k. cell_periodic_parts()[source]¶; Returns eigenvectors of the bulk Hamiltonian, i.e. the cell periodic; part($u_n(k)$) of the Bloch wavefunctios in a numpy.ndarray for; translationally symmetric lattices with periodic boundary condition. \begin{eqnarray}; |\psi_n(k) \rangle = |k \rangle \otimes | u_{n}(k) \rangle \\; | u_{n}(k) \rangle = a_n(k)|a\rangle + b_n(k)|b\rangle \\; \end{eqnarray}Please see section 1.2 of Asbóth, J. K., Oroszlány, L., & Pályi, A.; (2016). A short course on topological insulators. Lecture notes in; physics, 919 for a review. Returns. knxanp.arrayknxA[j][0] is the jth good Quantum number k. vec_knsnp.ndarray of Qobj’svec_kns[j] is the Oobj of type ket that holds an eigenvector of the; bulk Hamiltonian of the lattice. display_lattice()[source]¶; Produces a graphic portraying the lattice symbolically with a unit cell; marked in it. Returns. inter_TQobjThe coefficient of $psi_{i,N}^{dagger}psi_{0,i+1}$, i.e. the; coupling between the two boundary sites of the two unit cells i and; i+1. display_unit_cell(label_on=False)[source]¶; Produces a graphic displaying the unit cell features with labels on if; defined by user. Also returns a dict of Qobj’s corresponding to the; labeled elements on the display. Returns. HcelldictHcell[i][j] is the Hamiltonian segment for $H_{i,j}$ labeled on the; graphic. distribute_operator(op)[source]¶; A function that returns an operator matrix that applies op to all the; cells in the 1d lattice. Parameters; op (qutip.Qobj) – Qobj representing the operator to be applied at all cells. Returns. op_Hqutip.QobjQuantum object representing the operator with op applied at all; cells. get_dispersion(knpoints=0)[source]¶; Returns dispersion relationship for the lattice with the specified; number of unit cells with a k array and a band energy array. Returns. knxanp.arrayknxA[j][0] is the jth good Quantum number k. val_knsnp.arrayval_kns[j][:] is the array of band energies of the jth band good at; all the good Qua",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:78948,Modifiability,variab,variable,78948,"cified by the index. class QubitCircuit(N, input_states=None, output_states=None, reverse_states=True, user_gates=None, dims=None, num_cbits=0)[source]¶; Representation of a quantum program/algorithm, maintaining a sequence; of gates. Parameters. NintNumber of qubits in the system. user_gatesdictDefine a dictionary of the custom gates. See examples for detail. input_stateslistA list of string such as 0,’+’, “A”, “Y”. Only used for latex. dimslistA list of integer for the dimension of each composite system.; e.g [2,2,2,2,2] for 5 qubits system. If None, qubits system; will be the default option. num_cbitsintNumber of classical bits in the system. Examples; >>> def user_gate():; ... mat = np.array([[1., 0],; ... [0., 1.j]]); ... return Qobj(mat, dims=[[2], [2]]); >>> qubit_circuit = QubitCircuit(2, user_gates={""T"":user_gate}); >>> qubit_circuit.add_gate(""T"", targets=[0]). add_1q_gate(name, start=0, end=None, qubits=None, arg_value=None, arg_label=None, classical_controls=None, control_value=None)[source]¶; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters. namestringGate name. startintStarting location of qubits. endintLast qubit for the gate. qubitslistSpecific qubits for applying gates. arg_valuefloatArgument value(phi). arg_labelstringLabel for gate representation. add_circuit(qc, start=0)[source]¶; Adds a block of a qubit circuit to the main circuit.; Globalphase gates are not added. Parameters. qcQubitCircuitThe circuit block to be added to the main circuit. startintThe qubit on which the first gate is applied. add_gate(gate, targets=None, controls=None, arg_value=None, arg_label=None, index=None, classical_controls=None, control_value=None)[source]¶; Adds a gate with specified parameters to the circuit. Parameters. gate: string or :class:`.Gate`Gate name. If gate is an instance of Gate, parameters are; unpacked and added. targets:",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:86262,Modifiability,variab,variables,86262,"t(final_states, probabilities, cbits=None)[source]¶. get_cbits(index=None)[source]¶; Return list of classical bit outputs corresponding to the results. Parameters. index: intIndicates i-th output, probability pair to be returned. Returns. cbits: list of int or list of list of intlist of classical bit outputs. get_final_states(index=None)[source]¶; Return list of output states. Parameters. index: intIndicates i-th state to be returned. Returns. final_states: Qobj or list of Qobj.List of output kets or density matrices. get_probabilities(index=None)[source]¶; Return list of probabilities corresponding to the output states. Parameters. index: intIndicates i-th probability to be returned. Returns. probabilities: float or list of floatProbabilities associated with each output state. class CircuitSimulator(qc, state=None, cbits=None, U_list=None, measure_results=None, mode='state_vector_simulator', precompute_unitary=False)[source]¶. initialize(state=None, cbits=None, measure_results=None)[source]¶; Reset Simulator state variables to start a new run. Parameters. state: ket or operket or density matrix. cbits: list of int, optionalinitial value of classical bits. U_list: list of Qobj, optionallist of predefined unitaries corresponding to circuit. measure_resultstuple of ints, optionaloptional specification of each measurement result to enable; post-selection. If specified, the measurement results are; set to the tuple of bits (sequentially) instead of being; chosen at random. run(state, cbits=None, measure_results=None)[source]¶; Calculate the result of one instance of circuit run. Parameters. stateket or operstate vector or density matrix input. cbitsList of ints, optionalinitialization of the classical bits. measure_resultstuple of ints, optionaloptional specification of each measurement result to enable; post-selection. If specified, the measurement results are; set to the tuple of bits (sequentially) instead of being; chosen at random. Returns. result: CircuitResultRetu",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:128015,Modifiability,coupling,coupling,128015," an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class LinearSpinChain(N, correct_global_phase=True, sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None)[source]¶; A processor based on the physical implementation of; a linear spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically. Parameters. N: intThe number of qubits in the system. correct_global_phase: floatSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or listThe delta for each of the qubits in the system. sz: int or listThe epsil",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:138453,Modifiability,coupling,coupling,138453,"stance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz, sxsy)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class CircularSpinChain(N, correct_global_phase=True, sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None)[source]¶; A processor based on the physical implementation of; a circular spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically. Parameters. N: intThe number of qubits in the system. correct_global_phase: floatSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or listThe delta for each of the qubits in the system. sz: int or listThe e",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:148895,Modifiability,coupling,coupling,148895,"stance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz, sxsy)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class DispersiveCavityQED(N, correct_global_phase=True, num_levels=10, deltamax=1.0, epsmax=9.5, w0=10.0, wq=None, eps=9.5, delta=0.0, g=0.01, t1=None, t2=None)[source]¶; The processor based on the physical implementation of; a dispersive cavity QED system.; The available Hamiltonian of the system is predefined.; For a given pulse amplitude matrix, the processor can; calculate the state evolution under the given control pulse,; either analytically or numerically.; (Only additional attributes are documented here, for others please; refer to the parent class ModelProcessor). Parameters. N: intThe number of qubits in the system. correct_global_ph",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:160140,Modifiability,coupling,coupling,160140,"lytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(N, num_levels, deltamax, epsmax, w0, wq, eps, delta, g)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, “w0”, “eps”, “delta”; and “g”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “g”, list element i is the interaction; between qubits i and i+1. Parameters. N: intThe number of qubits in the system. num_levels: intThe number of energy levels in the resonator. deltamax: listThe coefficients of sigma-x for each of the qubits in the system. epsmax: listThe coefficients of sigma-z for each of the qubits in the system. wo: intThe base frequency of the resonator. wq: listThe frequency of the qubits. eps: listThe epsilon for each of the qubits in the system. delta: listThe delta for each of the qubits in the system. g: listThe interaction strength for each of the qubit with the resonator. Notes; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class Noise[source]¶; The base class representing noise in a processor.; The noise object can be added to Processor and; contributes to evolution. get_noisy_dynamics(dims, pulses, systematic_noise)[source]¶; Return a pulses list added with noise and; the pulse independent noise in a dumm",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:167943,Modifiability,variab,variables,167943,"s:Key word arguments for the random number generator. get_noisy_dynamics(dims=None, pulses=None, systematic_noise=None)[source]¶; Return a pulses list added with noise and; the pulse independent noise in a dummy Pulse object. Parameters. dims: list, optionalThe dimension of the components system, the default value is; [2,2…,2] for qubits system. pulses: list of :class:`.Pulse`The input pulses, on which the noise object is to be applied. systematic_noise: :class:`.Pulse`The dummy pulse with no ideal control element. Returns. noisy_pulses: list of PulseNoisy pulses. systematic_noise: PulseThe dummy pulse representing pulse independent noise. class Pulse(qobj, targets, tlist=None, coeff=None, spline_kind=None, label='')[source]¶; Representation of a control pulse and the pulse dependent noise.; The pulse is characterized by the ideal control pulse, the coherent; noise and the lindblad noise. The later two are lists of; noisy evolution dynamics.; Each dynamic element is characterized by four variables:; qobj, targets, tlist and coeff.; See examples for different construction behavior. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the ideal pulse. targets: listtarget qubits of the ideal pulse; (or subquantum system of other dimensions). tlist: array-like, optionaltlist of the ideal pulse.; A list of time at which the time-dependent coefficients are applied.; tlist does not have to be equidistant, but must have the same length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind. coeff: array-like or bool, optionalTime-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for the parameter spline_kind.; If a bool, the coefficient is a constant 1 or 0. spline_kind: str, optionalType of the coefficient interpolation:; “step_func” or “cubic”.; -“step_func”:; The coefficient will be treated as a step function.; E.g. tlist=[0,1,2] ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:186980,Modifiability,config,config,186980,"Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles. class Instruction(gate, tlist=None, pulse_info=(), duration=1)[source]¶; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list, optionalThe execution time needed for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, array_like).; This pulses will implement the desired gate. Attributes. targets: list, optionalThe target qubits. controls: list, optionalThe control qubits. used_qubits: setUnion of the control and target qubits. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses. This class implements the fidelity,; gradient and interation callback functions. All subclass objects must be; initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. algstringAlgo",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:187283,Modifiability,config,configuration,187283,"hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list, optionalThe execution time needed for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, array_like).; This pulses will implement the desired gate. Attributes. targets: list, optionalThe target qubits. controls: list, optionalThe control qubits. used_qubits: setUnion of the control and target qubits. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses. This class implements the fidelity,; gradient and interation callback functions. All subclass objects must be; initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the pulse optim algorithm alg. disp_conv_msgboolSet true to display a convergence message; (for scipy.optimize.minimize methods ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:189795,Modifiability,config,configOptimConfig,189795,"rapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamicsDynamics (subclass instance)describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). configOptimConfig instancevarious configuration options; (see OptimConfig for details). termination_conditionsTerminationCondition instanceattributes determine when the optimisation will end. pulse_generatorPulseGen (subclass instance)(can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. statsStatsattributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dumpdump.OptimDumpContainer for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumpingstringThe level of data dumping that will occur during the optimisation. dump_to_fileboolIf set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dum",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:189829,Modifiability,config,configuration,189829,"rapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamicsDynamics (subclass instance)describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). configOptimConfig instancevarious configuration options; (see OptimConfig for details). termination_conditionsTerminationCondition instanceattributes determine when the optimisation will end. pulse_generatorPulseGen (subclass instance)(can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. statsStatsattributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dumpdump.OptimDumpContainer for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumpingstringThe level of data dumping that will occur during the optimisation. dump_to_fileboolIf set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dum",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:192501,Modifiability,variab,variable,192501,"imize.minimize function. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. property dumping¶; The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is t",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:192905,Modifiability,variab,variables,192905,"f they do. property dumping¶; The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimi",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:193059,Modifiability,variab,variables,193059,"lt); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default fu",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:193099,Modifiability,variab,variable,193099,"dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:193761,Modifiability,config,configuration,193761,"get, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:195093,Modifiability,config,config,195093,"spect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; th",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:195926,Modifiability,config,config,195926," in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:196087,Modifiability,variab,variable,196087,", dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:196535,Modifiability,config,configuration,196535,"l minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which inclu",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:197590,Modifiability,config,config,197590,"mplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:198155,Modifiability,config,configuration,198155,"ablished implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall t",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:198194,Modifiability,config,config,198194,"SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation wil",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:212871,Modifiability,config,configuration,212871,"ion operators (Qobj) from the initial to the given; timeslot. get_ctrl_dyn_gen(j)[source]¶; Get the dynamics generator for the control; Not implemented in the base class. Choose a subclass. get_drift_dim()[source]¶; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N. get_dyn_gen(k)[source]¶; Get the combined dynamics generator for the timeslot; Not implemented in the base class. Choose a subclass. get_num_ctrls()[source]¶; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. init_timeslots()[source]¶; Generate the timeslot duration array ‘tau’ based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array ‘time’ based on the tau values. initialize_controls(amps, init_tslots=True)[source]¶; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated. property num_ctrls¶; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. property onto_evo¶; List of evolution operators (Qobj) from the initial to the given; timeslot. property onwd_evo¶; List of evolution operators (Qobj) from the initial to the given; timeslot. property phase_application¶; scalar(string), default=’preop’; Determines how the phase is applied to the dynamics generators. ‘preop’ : P = expm(phase*dyn_gen); ‘postop’ : P = expm(dyn_gen*phase); ‘custom’ : Customised phase application. The ‘custom’ option assumes that the _apply_phase method has been; set to a custom function. Type; phase_application. property prop¶; List of propagators (Qobj) for each timeslot. property prop_grad¶; Array of propagator gradients (Qobj) for each timeslot, control. refresh_drift_attribs()[source]¶; Reset ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:216255,Modifiability,config,configuration,216255,"amics described by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes. drift_hamQobjThis is the drift Hamiltonian for unitary dynamics; It is mapped to drift_dyn_gen during initialize_controls. ctrl_hamList of QobjThese are the control Hamiltonians for unitary dynamics; It is mapped to ctrl_dyn_gen during initialize_controls. HList of QobjThe combined drift and control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls. check_unitarity()[source]¶; Checks whether all propagators are unitary; For propagators found not to be unitary, the potential underlying; causes are investigated. initialize_controls(amplitudes, init_tslots=True)[source]¶; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated. property num_ctrls¶; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. class DynamicsSymplectic(optimconfig, params=None)[source]¶; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes. omegaarray[drift_dyn_gen.shape]matrix used in the calculation of propagators (time evolution); with symplectic systems. property dyn_gen_phase¶; The phasing operator for the symplectic group generators; usually refered to as Omega; By default this is applied as ‘postop’ dyn_gen*-Omega; If phase_application is ‘preop’ it is applied as Omega*dyn_gen. class PropagatorComputer(dynamics, params=None)[source]¶; Base for all Propagator Computer classes; that are used to calculate the propagators,; and a",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:218520,Modifiability,config,configuration,218520,"cation. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exactbooleanindicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; PropagatorComputer subclasses that may be more efficient. reset()[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:218796,Modifiability,config,configuration,218796,"iet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exactbooleanindicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; PropagatorComputer subclasses that may be more efficient. reset()[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attribute",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:218989,Modifiability,config,configuration,218989,"es whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; PropagatorComputer subclasses that may be more efficient. reset()[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; a",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:219356,Modifiability,config,configuration,219356,"ey value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; PropagatorComputer subclasses that may be more efficient. reset()[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_normfloatNormalisation constant. fid_norm_funcfunctionUsed to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_funcfunctionUsed to normalise the fidelity gradient; See SU",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:222115,Modifiability,config,configuration,222115," fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradie",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:222174,Modifiability,config,configuration,222174," to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_c",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:223759,Modifiability,config,config,223759,"fore it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:223997,Modifiability,config,configuration,223997,"culates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phas",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:224861,Modifiability,config,configuration,224861,"tion uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:226607,Modifiability,config,configuration,226607,"erik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelinteg",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:226714,Modifiability,config,configuration,226714,"ated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:227310,Modifiability,config,configuration,227310,"ormalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. evo_comp_summaryEvoCompSummaryA summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:239392,Modifiability,config,configurations,239392,"om the optimisation method; Typically this will be the basis coefficients. class PulseGenCrabFourier(dyn=None, num_coeffs=None, params=None)[source]¶; Generates a pulse using the Fourier basis functions, i.e. sin and cos. Attributes. freqsfloat array[num_coeffs]Frequencies for the basis functions. randomize_freqsboolIf True (default) the some random offset is applied to the frequencies. gen_pulse(coeffs=None)[source]¶; Generate a pulse using the Fourier basis with the freqs and; coeffs attributes. Parameters. coeffsfloat array[num_coeffs, num_basis_funcs]The basis coefficient values; If given this overides the default and sets the attribute; of the same name. init_freqs()[source]¶; Generate the frequencies; These are the Fourier harmonics with a uniformly distributed; random offset. init_pulse(num_coeffs=None)[source]¶; Set the initial freq and coefficient values. reset()[source]¶; reset attributes to default values. class Stats[source]¶; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes. dyn_gen_namestringText used in some report functions.; Makes sense to set it to ‘Hamiltonian’ when using unitary dynamics; Default is simply ‘dynamics generator’. num_iterintegerNumber of iterations of the optimisation algorithm. wall_time_optim_startfloatStart time for the optimisation. wall_time_optim_endfloatEnd time for the optimisation. wall_time_optimfloatTime elasped during the optimisation. wall_time_dyn_gen_computefloatTotal wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_computefloatTotal wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_computefloatTotal wall (elasped) time com",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:242970,Modifiability,config,configured,242970,"ged. mean_num_ctrl_amp_changes_per_updatefloatMean average number of control amplitudes that are changed per update. calculate()[source]¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]¶; Print a report of the stats to the console. class Dump[source]¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes. parentsome control object (Dynamics or Optimizer)aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dirstrdirectory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. levelstringThe level of data dumping that will occur. write_to_fileboolWhen set True data and summaries (as configured) will be written; interactively to file during the processing; Set during instantiation by the host based on its dump_to_file attrib. dump_file_extstrDefault file extension for any file names that are auto generated. fname_basestrFirst part of any auto generated file names.; This is usually overridden in the subclass. dump_summaryboolIf True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sepstrdelimiter for the summary file.; default is a space. data_sepstrdelimiter for the data files (arrays saved to file).; default is a space. summary_filestrFile path for summary file.; Automatically generated. Can be set specifically. create_dump_dir()[source]¶; Checks dump directory exists, creates it if not. property level¶; The level of data dumping that will occur. SUMMARYA summary will be recorded. FULLAll possible dumping. CUSTOMSome customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dum",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:4133,Performance,perform,performing,4133,"rator. dual_chan(); Dual channel of quantum object representing a CP map. eigenenergies(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object. eigenstates(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object. expm(); Matrix exponential of quantum object. full(order=’C’); Returns dense array of quantum object data attribute. groundstate(sparse=False, tol=0, maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum object. inv(); Return a Qobj corresponding to the matrix inverse of the operator. matrix_element(bra, ket); Returns the matrix element of operator between bra and ket vectors. norm(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator. permute(order); Returns composite qobj with indices reordered. proj(); Computes the projector for a ket or bra vector. ptrace(sel); Returns quantum object for selected dimensions after performing partial trace. sinm(); Sine of quantum object. sqrtm(); Matrix square root of quantum object. tidyup(atol=1e-12); Removes small elements from quantum object. tr(); Trace of quantum object. trans(); Transpose of quantum object. transform(inpt, inverse=False); Performs a basis transformation defined by inpt matrix. trunc_neg(method=’clip’); Removes negative eigenvalues and returns a new Qobj that is a valid density operator. unit(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. check_herm()[source]¶; Check if the quantum object is hermitian. Returns. ishermboolReturns the new value of isherm property. check_isunitary()[source]¶; Checks whether qobj is a unitary matrix. conj()[source]¶; Conjugate operator of quantum object. copy()[source]¶; Create identical copy. cosm()[source]¶; Cosine of a quantum operator.; Operator must be square. Returns. operqutip.QobjMatrix cosine of operator. Raises. TypeErrorQuantum object is not ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:6387,Performance,perform,performed,6387,"e)[source]¶; Calculates the diamond norm, or the diamond distance to another; operator. Parameters. Bqutip.Qobj or NoneIf B is not None, the diamond distance d(A, B) = dnorm(A - B); between this operator and B is returned instead of the diamond; norm. Returns. dfloatEither the diamond norm of this operator, or the diamond distance; from this operator to B. dual_chan()[source]¶; Dual channel of quantum object representing a completely positive; map. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000, phase_fix=None)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). phase_fixint, NoneIf not None, set the phase of each kets so that ket[phase_fix,0]; is real positive. Returns. eigvalsarrayArray of eigenvalues for operator. eigvecsarra",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:7179,Performance,perform,performed,7179,"lues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000, phase_fix=None)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). phase_fixint, NoneIf not None, set the phase of each kets so that ket[phase_fix,0]; is real positive. Returns. eigvalsarrayArray of eigenvalues for operator. eigvecsarrayArray of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(states_inds, normalize=False)[source]¶; Creates a new quantum object with states in state_inds eliminated. Parameters. states_indslist of integerThe states that should be removed. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:10698,Performance,perform,performed,10698,"represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters. orderstr {‘C’, ‘F’}Return array in C (default) or Fortran ordering. squeezebool {False, True}Squeeze output array. Returns. dataarrayArray of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters. sparseboolUse sparse Eigensolver. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. inv(sparse=False)[source]¶; Matrix inverse of a quantum operator; Operator must be square. Returns. operqutip.QobjMatrix inverse of operator. Raises. TypeErrorQuantum object is not square. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type ‘bra’ or ‘ket’. ketqutip.QobjQuantum object of type ‘ket’. Returns. elemcomplexComplex valued matrix element. Notes; It is slightly more computationally efficient to use a ket; vector for the ‘bra’ input. norm(norm=None, sparse=False, tol=0, maxiter=1",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:12310,Performance,perform,performed,12310,"e matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type ‘bra’ or ‘ket’. ketqutip.QobjQuantum object of type ‘ket’. Returns. elemcomplexComplex valued matrix element. Notes; It is slightly more computationally efficient to use a ket; vector for the ‘bra’ input. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters. normstrWhich norm to use for ket/bra vectors: L2 ‘l2’, max norm ‘max’,; or for operators: trace ‘tr’, Frobius ‘fro’, one ‘one’, or max; ‘max’. sparseboolUse sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tolfloatTolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used); for trace norm. Returns. normfloatThe requested norm of the operator or state quantum object. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(other)[source]¶; Overlap between two state vectors or two operators.; Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap; when one of the Qobj is an operator/density matrix. Parameters. otherqutip.QobjQuantum object for a state vector of type ‘ket’, ‘bra’ or density; matrix. Returns. overlapcomplexComplex valued overlap. Raises. TypeErrorCan only calculate overlap between a bra, ket and density matrix; quantum objects. Notes; Since QuTiP mainly deals with ket vectors, the most efficient inner; product call is the ket-ket version that computes the product; <self|other> with both vectors expressed as kets. permute(order)[source]¶; Permutes a composite",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:16841,Performance,perform,performed,16841,"perqutip.QobjOperator in new basis. Notes; This function is still in development. trunc_neg(method='clip')[source]¶; Truncates negative eigenvalues and renormalizes.; Returns a new Qobj by removing the negative eigenvalues; of this instance, then renormalizing to obtain a valid density; operator. Parameters. methodstrAlgorithm to use to remove negative eigenvalues. “clip”; simply discards negative eigenvalues, then renormalizes.; “sgs” uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns. operqutip.QobjA valid density operator. unit(inplace=False, norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters. inplaceboolDo an in-place normalization. normstrRequested norm for states / operators. sparseboolUse sparse eigensolver for trace norm. Does not affect other norms. tolfloatTolerance used by sparse eigensolver. maxiterintNumber of maximum iterations performed by sparse eigensolver. Returns. operqutip.QobjNormalized quantum object if not in-place,; else None. QobjEvo¶. class QobjEvo(Q_object=[], args={}, copy=True, tlist=None, state0=None, e_ops=[])[source]¶; A class for representing time-dependent quantum objects, such as quantum; operators and states.; Basic math operations are defined:. +, - : QobjEvo, Qobj, scalars.; *: Qobj, C number; / : C number. This object is constructed by passing a list of Qobj instances,; each of which may have an associated scalar time dependence. The list is; summed to produce the final result. In other words, if an instance of this; class is \(Q(t)\), then it is constructed from a set of constant; Qobj \(\{Q_k\}\) and time-dependent scalars \(f_k(t)\) by. \[Q(t) = \sum_k f_k(t) Q_k\]; If a scalar \(f_k(t)\) is not passed with a given Qobj, then; that term is assumed to be constant. The next section contains more detail; on the allowed forms of the constants, and gives several examples for how; to",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:37002,Performance,perform,performance,37002,"ndarrayArray of coeffcients defining cubic spline. Non-Markovian Solvers¶. class HEOMSolver[source]¶; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve); This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code. Attributes. H_sysQobjSystem Hamiltonian. coup_opQobjOperator describing the coupling between system and bath. coup_strengthfloatCoupling strength. temperaturefloatBath temperature, in units corresponding to planck. N_cutintCutoff parameter for the bath. N_expintNumber of exponential terms used to approximate the bath correlation; functions. planckfloatreduced Planck constant. boltzmannfloatBoltzmann’s constant. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. statsqutip.solver.Statsoptional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coefflis",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:37853,Performance,perform,performance,37853," density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code. Attributes. H_sysQobjSystem Hamiltonian. coup_opQobjOperator describing the coupling between system and bath. coup_strengthfloatCoupling strength. temperaturefloatBath temperature, in units corresponding to planck. N_cutintCutoff parameter for the bath. N_expintNumber of exponential terms used to approximate the bath correlation; functions. planckfloatreduced Planck constant. boltzmannfloatBoltzmann’s constant. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. statsqutip.solver.Statsoptional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:38898,Performance,perform,performance,38898,"overhead in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormb",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:43953,Performance,perform,performed,43953,"gator(blist, tlist, tau, c1=None, c2=None, notrace=False)[source]¶; Compute propagator for computing output field expectation values; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. : qutip.Qobjtime-propagator for computing field correlation function. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters. tfloatcurrent time. taufloattime-delay. notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; ——-; : :class:`qutip.Qobj`time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). tfloatcurrent time. taufloattime-delay. Returns. : qutip.Qobjdensity matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Tra",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:44437,Performance,perform,performed,44437,"oattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. : qutip.Qobjtime-propagator for computing field correlation function. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters. tfloatcurrent time. taufloattime-delay. notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; ——-; : :class:`qutip.Qobj`time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). tfloatcurrent time. taufloattime-delay. Returns. : qutip.Qobjdensity matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. Attributes. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. timesarray_likeList of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimesarray_likeList of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thresfloatThreshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. optionsqutip.solver.",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:49332,Performance,perform,performance,49332,"auto check. class Result[source]¶; Class for storing simulation results from any of the dynamics solvers. Attributes. solverstrWhich solver was used [e.g., ‘mesolve’, ‘mcsolve’, ‘brmesolve’, …]. timeslist/arrayTimes at which simulation data was collected. expectlist/arrayExpectation values (if requested) for simulation. statesarrayState of the simulation (density matrix or ket) evaluated at times. num_expectintNumber of expectation value operators in simulation. num_collapseintNumber of collapse operators in simualation. ntrajint/listNumber of trajectories (for stochastic solvers). A list indicates; that averaging of expectation values was done over a subset of total; number of trajectories. col_timeslistTimes at which state collpase occurred. Only for Monte Carlo solver. col_whichlistWhich collapse operator was responsible for each collapse in; col_times. Only for Monte Carlo solver. class SolverConfiguration[source]¶. class Stats(section_names=None)[source]¶; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor, then all statistics; will be added to one section ‘main’. Parameters. section_nameslistlist of keys that will be used as keys for the sections; These keys will also be used as names for the sections; The text in the output can be overidden by setting the header property; of the section; If no names are given then one section called ‘main’ is created. Attributes. sectionsOrderedDict of _StatsSectionThese are the sections that are created automatically on instantiation; or added using add_section. headerstringSome text that will be used as the heading in the report; By default there is None. total_timefloatTime in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported. add_count(key, value, section=None)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:97474,Performance,optimiz,optimized,97474,"`qutip.Qobj`, optionalOld API, same as init_state. solver: str“mesolve” or “mcsolve”. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.ResultIf analytical is False, an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)[source]¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)[source]¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. class OptPulseProcessor(N, drift=None, t1=None, t2=None, dims=None)[source]¶; A processor, which takes the Hamiltonian available; as dynamic generators, calls the; qutip.control.optimize_pulse_unitary function; to find an optimized pulse sequence for the desired quantum circuit.; The processor can simulate the evolution under the given; control pulses using qutip.mesolve.; (For attributes documentation, please; refer to the parent class Processor). Parameters. N: intThe number of component systems. drift: `:class:`qutip.Qobj`The drift Hamiltonian. The size must match the whole quantum system. t1: list or floatCharacterize the decoherence of amplitude damping for; each qubit. A list of size N or a float for all qubits. t2: list of floatCharacterize the decoherence of dephasing for; each qubit. A list of size N or a float for all qubits. dims: listThe dimension of each component system.; Default value is a; qubit system of dim=[2,2,2,...,2]. add_control(qobj, targets=None, cyclic_permutation=False, label=None)¶; Add a control Hamiltonian to the processor. It creates a new; Pulse; object for the device that is turned off; (tlist = None, coeff = None). To activate the pulse, one; can set its tlist and coeff. Param",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:181694,Performance,optimiz,optimized,181694,"lphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419.; The scheduler includes two methods,; “ASAP”, as soon as possible, and “ALAP”, as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits.; The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters. method: str“ASAP” for as soon as possible.; “ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are the same gate and have the same controls or targets,; they are considered as commuting.; E.g. CNOT 0, 1 commu",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:188299,Performance,optimiz,optimize,188299,"s; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the pulse optim algorithm alg. disp_conv_msgboolSet true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_paramsDictionaryOptions for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_gradboolIf set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:188360,Performance,optimiz,optimize,188360,") system; to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the pulse optim algorithm alg. disp_conv_msgboolSet true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_paramsDictionaryOptions for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_gradboolIf set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:190174,Performance,perform,performance,190174,"floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamicsDynamics (subclass instance)describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). configOptimConfig instancevarious configuration options; (see OptimConfig for details). termination_conditionsTerminationCondition instanceattributes determine when the optimisation will end. pulse_generatorPulseGen (subclass instance)(can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. statsStatsattributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dumpdump.OptimDumpContainer for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumpingstringThe level of data dumping that will occur during the optimisation. dump_to_fileboolIf set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dirstringBasically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summaryOptimIterSummarySummary of the most recent iteration.; Note this is only set if dummping is on. apply_method_params(params=Non",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:191492,Performance,optimiz,optimize,191492," a development debugging; but could be used for status information during a long optimisation. dumpingstringThe level of data dumping that will occur during the optimisation. dump_to_fileboolIf set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dirstringBasically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summaryOptimIterSummarySummary of the most recent iteration.; Note this is only set if dummping is on. apply_method_params(params=None)[source]¶; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. property dumping¶; The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the curre",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:194049,Performance,optimiz,optimize,194049,"t the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason fo",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:195593,Performance,optimiz,optimize,195593,"een tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Opti",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:196262,Performance,optimiz,optimize,196262,"mplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and detail",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:197049,Performance,optimiz,optimize,197049,"_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:197695,Performance,optimiz,optimize,197695," is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_opti",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:198304,Performance,optimiz,optimize,198304,"rm_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function v",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:198797,Performance,optimiz,optimize,198797,"imization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]¶; A summary of the most recent iteration of the pulse optimisation. Attributes. iter_numintIteration number of the pulse optimisation. fid_func_call_numintFidel",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:201077,Performance,optimiz,optimize,201077,"efloatTime spent computing the pulse optimisation so far; (in seconds of elapsed time). class TerminationConditions[source]¶; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes. fid_err_targfloatTarget fidelity error. fid_goalfloatgoal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_timefloat# maximum time for optimisation (seconds). min_gradient_normfloatMinimum normalised gradient after which optimisation will terminate. max_iterationsintegerMaximum iterations of the optimisation algorithm. max_fid_func_callsintegerMaximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factorfloatDetermines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of the pulse optimisation attempt. Attributes. termination_reasonstringDescription of the reason for terminating the optimisation. fidelityfloatfinal (normalised) fidelity that was achieved. initial_fid_errfloatfidelity error before optimisation starting. fid_errfloatfinal fidelity error that was achieved. goal_achievedbooleanTrue is the fidely error achieved was below the target. grad_norm_finalfloatFinal value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reachedfloatTrue if the optimisation terminated due to the minimum value; of the gradient being reached. num_iterintegerNumber of iterations of the optimisation algorithm completed. max_iter_exc",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:202870,Performance,optimiz,optimizerOptimizerInstance,202870,"if the optimisation terminated due to the minimum value; of the gradient being reached. num_iterintegerNumber of iterations of the optimisation algorithm completed. max_iter_exceededbooleanTrue if the iteration limit was reached. max_fid_func_exceededbooleanTrue if the fidelity function call limit was reached. wall_timefloattime elapsed during the optimisation. wall_time_limit_exceededbooleanTrue if the wall time limit was reached. timearray[num_tslots+1] of floatTime are the start of each timeslot; with the final value being the total evolution time. initial_ampsarray[num_tslots, n_ctrls]The amplitudes at the start of the optimisation. final_ampsarray[num_tslots, n_ctrls]The amplitudes at the end of the optimisation. evo_full_finalQobjThe evolution operator from t=0 to t=T based on the final amps. evo_full_initialQobjThe evolution operator from t=0 to t=T based on the initial amps. statsStatsObject contaning the stats for the run (if any collected). optimizerOptimizerInstance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENS",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:203651,Performance,perform,performance,203651,"n. evo_full_finalQobjThe evolution operator from t=0 to t=T based on the final amps. evo_full_initialQobjThe evolution operator from t=0 to t=T based on the initial amps. statsStatsObject contaning the stats for the run (if any collected). optimizerOptimizerInstance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propaga",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:204369,Performance,perform,performance,204369,"at is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_computerFidelityComputer (subclass instance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory s",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:205607,Performance,perform,perform,205607,"mputerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_computerFidelityComputer (subclass instance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_genboolIf True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_gradboolIf the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: boolIf True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: boolIf True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, o",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:205657,Performance,perform,perform,205657,"mputerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_computerFidelityComputer (subclass instance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_genboolIf True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_gradboolIf the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: boolIf True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: boolIf True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, o",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:206150,Performance,cache,cache,206150,"ng Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_genboolIf True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_gradboolIf the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: boolIf True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: boolIf True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, otherwise False. num_tslotsintegerNumber of timeslots (aka timeslices). num_ctrlsintegercalculate the of controls from the length of the control list. evo_timefloatTotal time for the evolution. tauarray[num_tslots] of floatDuration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots and evo_time are calculated from tau, otherwise; tau is generated from num_tslots and evo_time, that is; equ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:206403,Performance,cache,cached,206403,"d by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_genboolIf True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_gradboolIf the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: boolIf True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: boolIf True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, otherwise False. num_tslotsintegerNumber of timeslots (aka timeslices). num_ctrlsintegercalculate the of controls from the length of the control list. evo_timefloatTotal time for the evolution. tauarray[num_tslots] of floatDuration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots and evo_time are calculated from tau, otherwise; tau is generated from num_tslots and evo_time, that is; equal size time slices. timearray[num_tslots+1] of floatCumulative time for the evolution, that is the time at the start; of each time slice. drift_dyn_genQobj or list of QobjDrift or system dynamics generator (Hamiltonian); Matrix defining the underlying dynamics of the system; Can also be a list of Qobj (length num_tslo",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:223470,Performance,cache,cached,223470,"der). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:223913,Performance,cache,cached,223913,"litude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]¶; reset any config",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:226422,Performance,cache,cached,226422,"ance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:244261,Performance,optimiz,optimizer,244261,"; This is usually overridden in the subclass. dump_summaryboolIf True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sepstrdelimiter for the summary file.; default is a space. data_sepstrdelimiter for the data files (arrays saved to file).; default is a space. summary_filestrFile path for summary file.; Automatically generated. Can be set specifically. create_dump_dir()[source]¶; Checks dump directory exists, creates it if not. property level¶; The level of data dumping that will occur. SUMMARYA summary will be recorded. FULLAll possible dumping. CUSTOMSome customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes. dump_summaryboolWhen True summary items are appended to the iter_summary. iter_summarylist of optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. property dump_all¶; True if everything (ignoring the summary) is to be dumped. property dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:244773,Performance,optimiz,optimizer,244773," of data dumping that will occur. SUMMARYA summary will be recorded. FULLAll possible dumping. CUSTOMSome customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes. dump_summaryboolWhen True summary items are appended to the iter_summary. iter_summarylist of optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. property dump_all¶; True if everything (ignoring the summary) is to be dumped. property dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters. ffilename or filehandleIf specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]¶; A container for dumps of dynamics data. Mainly time evolution calculations. Attributes. dump_summaryboolIf True a summary is recorded. evo_summarylist of tslotcomp.Evo",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:10357,Safety,safe,safe,10357,"erator. Raises. TypeErrorQuantum operator is not square. extract_states(states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters. states_indslist of integerThe states that should be kept. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters. orderstr {‘C’, ‘F’}Return array in C (default) or Fortran ordering. squeezebool {False, True}Squeeze output array. Returns. dataarrayArray of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters. sparseboolUse sparse Eigensolver. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. inv(sparse=False)[source]¶; Matrix inverse of a quantum operator; Operator must be square. Returns. operqutip.QobjMatrix inverse of operator. Raises. TypeErrorQuantum object is not square. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwic",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:10736,Safety,safe,safebool,10736,"ably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters. orderstr {‘C’, ‘F’}Return array in C (default) or Fortran ordering. squeezebool {False, True}Squeeze output array. Returns. dataarrayArray of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters. sparseboolUse sparse Eigensolver. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. inv(sparse=False)[source]¶; Matrix inverse of a quantum operator; Operator must be square. Returns. operqutip.QobjMatrix inverse of operator. Raises. TypeErrorQuantum object is not square. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type ‘bra’ or ‘ket’. ketqutip.QobjQuantum object of type ‘ket’. Returns. elemcomplexComplex valued matrix element. Notes; It is slightly more computationally efficient to use a ket; vector for the ‘bra’ input. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:22867,Safety,safe,safePickleboolFlag,22867,"lue of the args dictionary passed into the; constructor. dynamics_argslistNames of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the args parameter. tlistarray_likeList of times at which the numpy-array coefficients are applied. compiledstrA string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevoCQobjCte or CQobjEvoTdCython version of the QobjEvo. coeff_getcallableObject called to obtain a list of all the coefficients at a particular; time. coeff_fileslistRuntime created files to delete with the instance. dummy_cteboolIs self.cte an empty Qobj. constboolIndicates if quantum object is constant. type{“cte”, “string”, “func”, “array”, “spline”, “mixed_callable”, “mixed_compilable”}Information about the type of coefficients used in the entire object. num_objintNumber of Qobj in the QobjEvo. use_cythonboolFlag to compile string to Cython or Python. safePickleboolFlag to not share pointers between thread. apply(function, *args, **kw_args)[source]¶; Apply the linear function function to every Qobj included in; this time-dependent object, and return a new QobjEvo with the; result.; Any additional arguments or keyword arguments will be appended to every; function call. apply_decorator(function, *args, str_mod=None, inplace_np=False, **kw_args)[source]¶; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result.; Any additional arguments and keyword arguments will be appended to the; function calls. Parameters. functioncallable(time_dependence, *args, **kwargs) -> time_dependence. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_modlistA 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string x will; become str_mod[0] + x",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:19821,Security,access,access,19821," The coeffients array must have the; same length as the tlist. The times of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; args = {""_step_func_coeff"": True}. Examples of array-format usage are:; tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; QobjEvo that contains different tlist values, however.; Passing arguments; args is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string.; There are some “magic” names that can be specified, whose objects will be; overwritten when used within sesolve, mesolve and; mcsolve. This allows access to the solvers’ internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. ""state"": the current state as a Qobj; ""state_vec"": the current state as a column-stacked 1D np.ndarray; ""state_mat"": the current state as a 2D np.ndarray; ""expect_op_<n>"": the current expectation value of the element; e_ops[n], which is an argument to the solvers. Replace <n> with; an integer literal, e.g. ""expect_op_0"". This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; ""collapse"": (mcsolve only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; (time: float, which: int), where time is the time this collapse; happened, and which is an integer indexing the c_ops argument to; mcsolve. Parameters. Q_objectlist, Qobj or QobjEvoThe time-dependent description of the quantum object. This is of the; same format as the first paramete",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:21421,Security,access,access,21421,"operator are both; Hermitian or not.; ""collapse"": (mcsolve only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; (time: float, which: int), where time is the time this collapse; happened, and which is an integer indexing the c_ops argument to; mcsolve. Parameters. Q_objectlist, Qobj or QobjEvoThe time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of [Qobj, time_dependence] pairs that are; summed to make the whole object. The time_dependence can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the Qobj instead; of the 2-element list. argsdict, optionalMapping of {str: object}, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the “magic”; names used to access solver internals. tlistarray_like, optionalList of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in Q_object is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes. cteQobjConstant part of the QobjEvo. opslist of EvoElementInternal representation of the time-dependence structure of the; elements. argsdictThe current value of the args dictionary passed into the; constructor. dynamics_argslistNames of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the args parameter. tlistarray_likeList of times at which the numpy-array coefficients are applied. compiledstrA string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevoCQobjCte or CQobjEvoTdCython version of the QobjEvo. coeff_getcallableObject called to obta",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:203246,Security,access,access,203246,"ededbooleanTrue if the wall time limit was reached. timearray[num_tslots+1] of floatTime are the start of each timeslot; with the final value being the total evolution time. initial_ampsarray[num_tslots, n_ctrls]The amplitudes at the start of the optimisation. final_ampsarray[num_tslots, n_ctrls]The amplitudes at the end of the optimisation. evo_full_finalQobjThe evolution operator from t=0 to t=T based on the final amps. evo_full_initialQobjThe evolution operator from t=0 to t=T based on the initial amps. statsStatsObject contaning the stats for the run (if any collected). optimizerOptimizerInstance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exis",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:18417,Testability,log,log,18417,"is; class is \(Q(t)\), then it is constructed from a set of constant; Qobj \(\{Q_k\}\) and time-dependent scalars \(f_k(t)\) by. \[Q(t) = \sum_k f_k(t) Q_k\]; If a scalar \(f_k(t)\) is not passed with a given Qobj, then; that term is assumed to be constant. The next section contains more detail; on the allowed forms of the constants, and gives several examples for how; to build instances of this class.; Time-dependence formats; There are three major formats for specifying a time-dependent scalar:. Python function; string; array. For function format, the function signature must be; f(t: float, args: dict) -> complex, for example; def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:; pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:; H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype np.float64 or; np.complex128. A list of times (np.float64) at which the; coeffients must be given as tlist. The coeffients array must have the; same length as the tlist. The times of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; args = {""_step_func_coeff"": True}. Examples of array-format usage are:; tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; QobjEvo that contains different tlist values, however.;",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:19236,Testability,log,logspace,19236,"1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:; pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:; H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype np.float64 or; np.complex128. A list of times (np.float64) at which the; coeffients must be given as tlist. The coeffients array must have the; same length as the tlist. The times of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; args = {""_step_func_coeff"": True}. Examples of array-format usage are:; tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; QobjEvo that contains different tlist values, however.; Passing arguments; args is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string.; There are some “magic” names that can be specified, whose objects will be; overwritten when used within sesolve, mesolve and; mcsolve. This allows access to the solvers’ internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. ""state"": the current state as a Qobj; ""state_vec"": the current state as a column-stacked 1D np.ndarray; ""state_mat"": the current state as a 2D np.ndarray; ""expect_op_<n>"": the current expectation value of the element; e_ops[n], which is an argument to the solvers.",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:187462,Testability,log,logger,187462," for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, array_like).; This pulses will implement the desired gate. Attributes. targets: list, optionalThe target qubits. controls: list, optionalThe control qubits. used_qubits: setUnion of the control and target qubits. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses. This class implements the fidelity,; gradient and interation callback functions. All subclass objects must be; initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the pulse optim algorithm alg. disp_conv_msgboolSet true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fi",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:192066,Testability,log,logs,192066,"setting a path. iter_summaryOptimIterSummarySummary of the most recent iteration.; Note this is only set if dummping is on. apply_method_params(params=None)[source]¶; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. property dumping¶; The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimise",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:192244,Testability,log,logs,192244,"all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. property dumping¶; The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:194601,Testability,test,tested,194601,"ource]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to t",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:203796,Testability,log,logger,203796," based on the initial amps. statsStatsObject contaning the stats for the run (if any collected). optimizerOptimizerInstance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_com",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:214567,Testability,log,logged,214567,"on assumes that the _apply_phase method has been; set to a custom function. Type; phase_application. property prop¶; List of propagators (Qobj) for each timeslot. property prop_grad¶; Array of propagator gradients (Qobj) for each timeslot, control. refresh_drift_attribs()[source]¶; Reset the dyn_shape, dyn_dims and time_depend_drift attribs. save_amps(file_name=None, times=None, amps=None, verbose=False)[source]¶; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters. file_namestringName of the file; If None given the def_amps_fname attribuite will be used. timesList type (or string)List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If ‘exclude’ then times will not be saved in the file, just; the amplitudes. ampsArray[num_tslots, num_ctrls]Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verboseBooleanIf True then an info message will be logged. unitarity_check()[source]¶; Checks whether all propagators are unitary. update_ctrl_amps(new_amps)[source]¶; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer. class DynamicsGenMat(optimconfig, params=None)[source]¶; This sub class can be used for any system where no additional; operator is applied to the dynamics generator before calculating; the propagator, e.g. classical dynamics, Lindbladian. class DynamicsUnitary(optimconfig, params=None)[source]¶; This is the subclass to use for systems with dynamics described by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes. drift_hamQobjThis is the drift Hamiltonian ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:217586,Testability,log,logger,217586,"his is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes. omegaarray[drift_dyn_gen.shape]matrix used in the calculation of propagators (time evolution); with symplectic systems. property dyn_gen_phase¶; The phasing operator for the symplectic group generators; usually refered to as Omega; By default this is applied as ‘postop’ dyn_gen*-Omega; If phase_application is ‘preop’ it is applied as Omega*dyn_gen. class PropagatorComputer(dynamics, params=None)[source]¶; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exactbooleanindicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:217633,Testability,log,logging,217633,"hape]matrix used in the calculation of propagators (time evolution); with symplectic systems. property dyn_gen_phase¶; The phasing operator for the symplectic group generators; usually refered to as Omega; By default this is applied as ‘postop’ dyn_gen*-Omega; If phase_application is ‘preop’ it is applied as Omega*dyn_gen. class PropagatorComputer(dynamics, params=None)[source]¶; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exactbooleanindicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:219761,Testability,log,logger,219761,"d; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; PropagatorComputer subclasses that may be more efficient. reset()[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_normfloatNormalisation constant. fid_norm_funcfunctionUsed to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_funcfunctionUsed to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evobooleanflag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evoboolean; flag to specify whether the onto_evo evolution operator(see Dynamics) is used by the FidelityComputer. fid_errfloatLast computed value of the fidelity error. fidelityfloatLast computed value of the ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:227653,Testability,log,logger,227653,"namics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. evo_comp_summaryEvoCompSummaryA summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dump_current()[source]¶; Store a copy of the current time evolution. class TSlotCompUpdateA",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:230943,Testability,log,logger,230943,"e if given). scalingfloatlinear scaling applied to the pulse; (copied from Dynamics.initial_ctrl_scaling if given). offsetfloatlinear offset applied to the pulse; (copied from Dynamics.initial_ctrl_offset if given). tauarray[num_tslots] of floatDuration of each timeslot; (copied from Dynamics if given). lboundfloatLower boundary for the pulse amplitudes; Note that the scaling and offset attributes can be used to fully; bound the pulse for all generators except some of the random ones; This bound (if set) may result in additional shifting / scaling; Default is -Inf. uboundfloatUpper boundary for the pulse amplitudes; Note that the scaling and offset attributes can be used to fully; bound the pulse for all generators except some of the random ones; This bound (if set) may result in additional shifting / scaling; Default is Inf. periodicbooleanTrue if the pulse generator produces periodic pulses. randombooleanTrue if the pulse generator produces random pulses. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value. gen_pulse()[source]¶; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass. init_pulse()[source]¶; Initialise the pulse parameters. reset()[source]¶; reset attributes to default values. class PulseGenRandom(dyn=None, params=None)[source]¶; Generates random pulses as simply random values for each timeslot. gen",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:245024,Testability,log,log,245024,"hat specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes. dump_summaryboolWhen True summary items are appended to the iter_summary. iter_summarylist of optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. property dump_all¶; True if everything (ignoring the summary) is to be dumped. property dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters. ffilename or filehandleIf specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]¶; A container for dumps of dynamics data. Mainly time evolution calculations. Attributes. dump_summaryboolIf True a summary is recorded. evo_summarylist of tslotcomp.EvoCompSummarySummary items are appended if dump_summary is True; at each recomputation of the evolution. dump_ampsboolIf True control amplitudes are dumped. dump_dyn_genboolIf True the dynamics generators (Hamiltonians) are dumped. d",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:245086,Testability,log,log,245086,"[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes. dump_summaryboolWhen True summary items are appended to the iter_summary. iter_summarylist of optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. property dump_all¶; True if everything (ignoring the summary) is to be dumped. property dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters. ffilename or filehandleIf specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]¶; A container for dumps of dynamics data. Mainly time evolution calculations. Attributes. dump_summaryboolIf True a summary is recorded. evo_summarylist of tslotcomp.EvoCompSummarySummary items are appended if dump_summary is True; at each recomputation of the evolution. dump_ampsboolIf True control amplitudes are dumped. dump_dyn_genboolIf True the dynamics generators (Hamiltonians) are dumped. dump_propboolIf True propagators are dumped. dump_prop_gradboolIf T",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:245163,Testability,log,log,245163,"g the pulse; optimisation. Attributes. dump_summaryboolWhen True summary items are appended to the iter_summary. iter_summarylist of optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. property dump_all¶; True if everything (ignoring the summary) is to be dumped. property dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters. ffilename or filehandleIf specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]¶; A container for dumps of dynamics data. Mainly time evolution calculations. Attributes. dump_summaryboolIf True a summary is recorded. evo_summarylist of tslotcomp.EvoCompSummarySummary items are appended if dump_summary is True; at each recomputation of the evolution. dump_ampsboolIf True control amplitudes are dumped. dump_dyn_genboolIf True the dynamics generators (Hamiltonians) are dumped. dump_propboolIf True propagators are dumped. dump_prop_gradboolIf True propagator gradients are dumped. dump_fwd_evoboolIf True forward e",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:245209,Testability,log,logs,245209," are appended to the iter_summary. iter_summarylist of optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. property dump_all¶; True if everything (ignoring the summary) is to be dumped. property dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters. ffilename or filehandleIf specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]¶; A container for dumps of dynamics data. Mainly time evolution calculations. Attributes. dump_summaryboolIf True a summary is recorded. evo_summarylist of tslotcomp.EvoCompSummarySummary items are appended if dump_summary is True; at each recomputation of the evolution. dump_ampsboolIf True control amplitudes are dumped. dump_dyn_genboolIf True the dynamics generators (Hamiltonians) are dumped. dump_propboolIf True propagators are dumped. dump_prop_gradboolIf True propagator gradients are dumped. dump_fwd_evoboolIf True forward evolution operators are dumped. dump_onwd_evoboolIf True onward evolution oper",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:16213,Usability,simpl,simply,16213,"oved. tr()[source]¶; Trace of a quantum object. Returns. tracefloatReturns the trace of the quantum object. trans()[source]¶; Transposed operator. Returns. operqutip.QobjTranspose of input operator. transform(inpt, inverse=False, sparse=True)[source]¶; Basis transform defined by input array.; Input array can be a matrix defining the transformation,; or a list of kets that defines the new basis. Parameters. inptarray_likeA matrix or list of kets defining the transformation. inverseboolWhether to return inverse transformation. sparseboolUse sparse matrices when possible. Can be slower. Returns. operqutip.QobjOperator in new basis. Notes; This function is still in development. trunc_neg(method='clip')[source]¶; Truncates negative eigenvalues and renormalizes.; Returns a new Qobj by removing the negative eigenvalues; of this instance, then renormalizing to obtain a valid density; operator. Parameters. methodstrAlgorithm to use to remove negative eigenvalues. “clip”; simply discards negative eigenvalues, then renormalizes.; “sgs” uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns. operqutip.QobjA valid density operator. unit(inplace=False, norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters. inplaceboolDo an in-place normalization. normstrRequested norm for states / operators. sparseboolUse sparse eigensolver for trace norm. Does not affect other norms. tolfloatTolerance used by sparse eigensolver. maxiterintNumber of maximum iterations performed by sparse eigensolver. Returns. operqutip.QobjNormalized quantum object if not in-place,; else None. QobjEvo¶. class QobjEvo(Q_object=[], args={}, copy=True, tlist=None, state0=None, e_ops=[])[source]¶; A class for representing time-dependent quantum objects, such as quantum; operators and states.; Basic math operations are defined:. +, - : QobjEvo, Qobj, scalars.; *: Qobj, C number;",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:18584,Usability,simpl,simple,18584,"If a scalar \(f_k(t)\) is not passed with a given Qobj, then; that term is assumed to be constant. The next section contains more detail; on the allowed forms of the constants, and gives several examples for how; to build instances of this class.; Time-dependence formats; There are three major formats for specifying a time-dependent scalar:. Python function; string; array. For function format, the function signature must be; f(t: float, args: dict) -> complex, for example; def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:; pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:; H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype np.float64 or; np.complex128. A list of times (np.float64) at which the; coeffients must be given as tlist. The coeffients array must have the; same length as the tlist. The times of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; args = {""_step_func_coeff"": True}. Examples of array-format usage are:; tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; QobjEvo that contains different tlist values, however.; Passing arguments; args is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; su",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:31751,Usability,clear,clear,31751,"it; state or a vector. Parameters. state_or_vectorQobj/array/list/tuplePosition for the annotaion.; Qobj of a qubit or a vector of 3 elements. textstrAnnotation text.; You can use LaTeX, but remember to use raw string; e.g. r”$langle x rangle$”; or escape backslashes; e.g. “$\langle x \rangle$”. kwargs :Options as for mplot3d.axes3d.text, including:; fontsize, color, horizontalalignment, verticalalignment. add_points(points, meth='s')[source]¶; Add a list of data points to bloch sphere. Parameters. pointsarray_likeCollection of data points. meth{‘s’, ‘m’, ‘l’}Type of points to plot, use ‘m’ for multicolored, ‘l’ for points; connected with a line. add_states(state, kind='vector')[source]¶; Add a state vector Qobj to Bloch sphere. Parameters. stateQobjInput state vector. kind{‘vector’, ‘point’}Type of object to plot. add_vectors(vectors)[source]¶; Add a list of vectors to Bloch sphere. Parameters. vectorsarray_likeArray with vectors of unit length or smaller. clear()[source]¶; Resets Bloch sphere data sets to empty. make_sphere()[source]¶; Plots Bloch sphere and data sets. render()[source]¶; Render the Bloch sphere and its data sets in on given figure and axes. save(name=None, format='png', dirc=None, dpin=None)[source]¶; Saves Bloch sphere to file of type format in directory dirc. Parameters. namestrName of saved image. Must include path and format as well.; i.e. ‘/Users/Paul/Desktop/bloch.png’; This overrides the ‘format’ and ‘dirc’ arguments. formatstrFormat of output image. dircstrDirectory for output images. Defaults to current working directory. dpinintResolution in dots per inch. Returns. File containing plot of Bloch sphere. set_label_convention(convention)[source]¶; Set x, y and z labels according to one of conventions. Parameters. conventionstringOne of the following:. “original”; “xyz”; “sx sy sz”; “01”; “polarization jones”; “polarization jones letters”; see also: http://en.wikipedia.org/wiki/Jones_calculus; “polarization stokes”; see also: http://en.wikip",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:33236,Usability,simpl,simplest,33236,"rguments. formatstrFormat of output image. dircstrDirectory for output images. Defaults to current working directory. dpinintResolution in dots per inch. Returns. File containing plot of Bloch sphere. set_label_convention(convention)[source]¶; Set x, y and z labels according to one of conventions. Parameters. conventionstringOne of the following:. “original”; “xyz”; “sx sy sz”; “01”; “polarization jones”; “polarization jones letters”; see also: http://en.wikipedia.org/wiki/Jones_calculus; “polarization stokes”; see also: http://en.wikipedia.org/wiki/Stokes_parameters. show()[source]¶; Display Bloch sphere and corresponding data sets.; Notes; When using inline plotting in Jupyter notebooks, any figure created; in a notebook cell is displayed after the cell executes. Thus if you; create a figure yourself and use it create a Bloch sphere with; b = Bloch(..., fig=fig) and then call b.show() in the same; cell, then the figure will be displayed twice. If you do create your; own figure, the simplest solution to this is to not call .show(); in the cell you create the figure in. vector_mutation¶; Sets the width of the vectors arrowhead. vector_style¶; Style of Bloch vectors, default = ‘-|>’ (or ‘simple’). vector_width¶; Width of Bloch vectors, default = 5. Distributions¶. class QFunc(xvec, yvec, g: float = 1.4142135623730951, memory: float = 1024)[source]¶; Class-based method of calculating the Husimi-Q function of many different; quantum states at fixed phase-space points 0.5*g* (xvec + i*yvec).; This class has slightly higher first-usage costs than qfunc, but; subsequent operations will be several times faster. However, it can require; quite a lot of memory. Call the created object as a function to retrieve; the Husimi-Q function. Parameters. xvec, yvecarray_likex- and y-coordinates at which to calculate the Husimi-Q function. gfloat, default sqrt(2)Scaling factor for a = 0.5 * g * (x + iy). The value of g is; related to the value of hbar in the commutation relation; \([x,",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:33443,Usability,simpl,simple,33443,"lot of Bloch sphere. set_label_convention(convention)[source]¶; Set x, y and z labels according to one of conventions. Parameters. conventionstringOne of the following:. “original”; “xyz”; “sx sy sz”; “01”; “polarization jones”; “polarization jones letters”; see also: http://en.wikipedia.org/wiki/Jones_calculus; “polarization stokes”; see also: http://en.wikipedia.org/wiki/Stokes_parameters. show()[source]¶; Display Bloch sphere and corresponding data sets.; Notes; When using inline plotting in Jupyter notebooks, any figure created; in a notebook cell is displayed after the cell executes. Thus if you; create a figure yourself and use it create a Bloch sphere with; b = Bloch(..., fig=fig) and then call b.show() in the same; cell, then the figure will be displayed twice. If you do create your; own figure, the simplest solution to this is to not call .show(); in the cell you create the figure in. vector_mutation¶; Sets the width of the vectors arrowhead. vector_style¶; Style of Bloch vectors, default = ‘-|>’ (or ‘simple’). vector_width¶; Width of Bloch vectors, default = 5. Distributions¶. class QFunc(xvec, yvec, g: float = 1.4142135623730951, memory: float = 1024)[source]¶; Class-based method of calculating the Husimi-Q function of many different; quantum states at fixed phase-space points 0.5*g* (xvec + i*yvec).; This class has slightly higher first-usage costs than qfunc, but; subsequent operations will be several times faster. However, it can require; quite a lot of memory. Call the created object as a function to retrieve; the Husimi-Q function. Parameters. xvec, yvecarray_likex- and y-coordinates at which to calculate the Husimi-Q function. gfloat, default sqrt(2)Scaling factor for a = 0.5 * g * (x + iy). The value of g is; related to the value of hbar in the commutation relation; \([x,\,y] = i\hbar\) via \(\hbar=2/g^2\), so the default; corresponds to \(\hbar=1\). memoryreal, default 1024Size in MB that may be used internally as workspace. This class will; raise",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:38732,Usability,progress bar,progress bar,38732," thereof, for; showing the progress of the simulation. statsqutip.solver.Statsoptional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:38779,Usability,progress bar,progress bar,38779," thereof, for; showing the progress of the simulation. statsqutip.solver.Statsoptional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:40968,Usability,feedback,feedback,40968,"pically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., l",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:41119,Usability,feedback,feedback,41119," configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Co",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:41254,Usability,feedback,feedback,41254,"x=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dag",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:41459,Usability,feedback,feedback,41459,"eset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_o",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:44872,Usability,learn,learningtimes,44872,"where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. : qutip.Qobjtime-propagator for computing field correlation function. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters. tfloatcurrent time. taufloattime-delay. notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; ——-; : :class:`qutip.Qobj`time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). tfloatcurrent time. taufloattime-delay. Returns. : qutip.Qobjdensity matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. Attributes. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. timesarray_likeList of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimesarray_likeList of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thresfloatThreshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. optionsqutip.solver.OptionsGeneric solver options. Solver Options and Results¶. class ExpectOps(e_ops=[], super_=False)[source]¶; Contain and compute expectation values. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_t_tol=1e-06, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:45273,Usability,learn,learning,45273," is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; ——-; : :class:`qutip.Qobj`time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). tfloatcurrent time. taufloattime-delay. Returns. : qutip.Qobjdensity matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. Attributes. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. timesarray_likeList of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimesarray_likeList of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thresfloatThreshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. optionsqutip.solver.OptionsGeneric solver options. Solver Options and Results¶. class ExpectOps(e_ops=[], super_=False)[source]¶; Contain and compute expectation values. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_t_tol=1e-06, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, steady_state_average=False, seeds=None, normalize_output=True, use_openmp=None, openmp_threads=None)[source]¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after cr",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:52166,Usability,clear,clear,52166,"h this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. section_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `class`_StatsSectionSection which to add the timing to.; If None given, the default (first) section will be used. clear()[source]¶; Clear counts, timings and messages from all sections. report(output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>)[source]¶; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters. outputstreamfile or console stream - anything that support write - where; the output will be written. set_total_time(value, section=None)[source]¶; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters. valuefloatTime in seconds to complete the solver section. sectionstring or classSection which to set the total_time for; If None given, the total_time for complete solve is set. class",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:57801,Usability,progress bar,progress bar,57801," instance returned by the solver. noiseint, or 1D array of int, or 4D array of float; int : seed of the noise; 1D array : length = ntraj, seeds for each trajectories.; 4D array : (ntraj, len(times), nsubsteps, len(sc_ops)*[1|2]).; Vector for the noise, the len of the last dimensions is doubled for; solvers of order 1.5. This corresponds to results.noise. noiseDepthintNumber of terms kept of the truncated series used to create the; noise used by taylor2.0 solver. normalizebool(default True for (photo)ssesolve, False for (photo)smesolve); Whether or not to normalize the wave function during the evolution.; Normalizing density matrices introduce numerical errors. optionsqutip.solver.OptionsGeneric solver options. Only options.average_states and; options.store_states are used. map_func: functionA map function or managing the calls to single-trajactory solvers. map_kwargs: dictionaryOptional keyword arguments to the map_func function function. progress_barqutip.ui.BaseProgressBarOptional progress bar class instance. Permutational Invariance¶. class Dicke(N, hamiltonian=None, emission=0.0, dephasing=0.0, pumping=0.0, collective_emission=0.0, collective_dephasing=0.0, collective_pumping=0.0)[source]¶; The Dicke class which builds the Lindbladian and Liouvillian matrix. Parameters. N: intThe number of two-level systems. hamiltonianqutip.QobjA Hamiltonian in the Dicke basis.; The matrix dimensions are (nds, nds),; with nds being the number of Dicke states.; The Hamiltonian can be built with the operators; given by the jspin functions. emission: floatIncoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: floatLocal dephasing coefficient.; default: 0.0. pumping: floatIncoherent pumping coefficient.; default: 0.0. collective_emission: floatCollective (superradiant) emmission coefficient.; default: 0.0. collective_pumping: floatCollective pumping coefficient.; default: 0.0. collective_dephasing: floatCollective dephasing coefficient.; default: 0.",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:63208,Usability,simpl,simple,63208,"lective (superradiant) emmission coefficient.; default: 0.0. collective_dephasing: floatCollective dephasing coefficient.; default: 0.0. collective_pumping: floatCollective pumping coefficient.; default: 0.0. M: dictA nested dictionary of the structure {row: {col: val}} which holds; non zero elements of the matrix M. calculate_j_m(dicke_row, dicke_col)[source]¶; Get the value of j and m for the particular Dicke space element. Parameters. dicke_row, dicke_col: intThe row and column from the Dicke space matrix. Returns. j, m: floatThe j and m values. calculate_k(dicke_row, dicke_col)[source]¶; Get k value from the current row and column element in the Dicke space. Parameters. dicke_row, dicke_col: intThe row and column from the Dicke space matrix. Returns; ——-; k: intThe row index for the matrix M for given Dicke space; element. coefficient_matrix()[source]¶; Generate the matrix M governing the dynamics for diagonal cases.; If the initial density matrix and the Hamiltonian is diagonal, the; evolution of the system is given by the simple ODE: dp/dt = Mp. isdicke(dicke_row, dicke_col)[source]¶; Check if an element in a matrix is a valid element in the Dicke space.; Dicke row: j value index. Dicke column: m value index.; The function returns True if the element exists in the Dicke space and; False otherwise. Parameters. dicke_row, dicke_colintIndex of the element in Dicke space which needs to be checked. solve(rho0, tlist, options=None)[source]¶; Solve the ODE for the evolution of diagonal states and Hamiltonians. tau1(j, m)[source]¶; Calculate coefficient matrix element relative to (j, m, m). tau2(j, m)[source]¶; Calculate coefficient matrix element relative to (j, m+1, m+1). tau3(j, m)[source]¶; Calculate coefficient matrix element relative to (j+1, m+1, m+1). tau4(j, m)[source]¶; Calculate coefficient matrix element relative to (j-1, m+1, m+1). tau5(j, m)[source]¶; Calculate coefficient matrix element relative to (j+1, m, m). tau6(j, m)[source]¶; Calculate coefficient ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:116964,Usability,simpl,simplicity,116964,"lass:`.QubitCircuit`, optionalA quantum circuit. If given, it first calls the load_circuit; and then calculate the evolution. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.ResultIf analytical is False, an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_params()[source]¶; Save the parameters in the attribute params and check the validity.; (Defined in subclasses); Notes; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)[source]¶; Transfer a parameter to an array. class SpinChain(N, correct_global_phase, sx, sz, sxsy, t1, t2)[source]¶; The processor based on the physical implementation of; a spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically.; It is a base class and should not be used directly, please; refer the the subclasses qutip.qip.device.LinearSpinChain and; qutip.qip.device.CircularSpinChain.; (Only additional attributes are documented here, for others please; refer to the parent class ModelProcessor). Parameters. N: intThe number of qubits in the system. correct_global_phase: floatSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or listThe delta for each of the qubits in the system. sz: int or listThe epsilon for",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:128336,Usability,simpl,simplicity,128336," the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class LinearSpinChain(N, correct_global_phase=True, sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None)[source]¶; A processor based on the physical implementation of; a linear spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically. Parameters. N: intThe number of qubits in the system. correct_global_phase: floatSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or listThe delta for each of the qubits in the system. sz: int or listThe epsilon for each of the qubits in the system. sxsy: int or listThe interaction strength for each of the qubit pair in the system. t1: list or float, optionalCharacterize the decoherence of amplitude damping for; each qubit. t2: list of float, optionalCharacterize the ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:138774,Usability,simpl,simplicity,138774,"ile. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz, sxsy)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class CircularSpinChain(N, correct_global_phase=True, sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None)[source]¶; A processor based on the physical implementation of; a circular spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically. Parameters. N: intThe number of qubits in the system. correct_global_phase: floatSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or listThe delta for each of the qubits in the system. sz: int or listThe epsilon for each of the qubits in the system. sxsy: int or listThe interaction strength for each of the qubit pair in the system. t1: list or float, optionalCharacterize the decoherence of amplitude damping for; each qubit. t2: list of float, optionalCharacterize ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:149216,Usability,simpl,simplicity,149216,"ile. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz, sxsy)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class DispersiveCavityQED(N, correct_global_phase=True, num_levels=10, deltamax=1.0, epsmax=9.5, w0=10.0, wq=None, eps=9.5, delta=0.0, g=0.01, t1=None, t2=None)[source]¶; The processor based on the physical implementation of; a dispersive cavity QED system.; The available Hamiltonian of the system is predefined.; For a given pulse amplitude matrix, the processor can; calculate the state evolution under the given control pulse,; either analytically or numerically.; (Only additional attributes are documented here, for others please; refer to the parent class ModelProcessor). Parameters. N: intThe number of qubits in the system. correct_global_phase: float, optionalSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. num_levels: int, optionalThe number of energy levels in the resonator. deltamax: int or list, optionalThe coefficients of",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:160823,Usability,simpl,simplicity,160823,"s. N: intThe number of qubits in the system. set_up_params(N, num_levels, deltamax, epsmax, w0, wq, eps, delta, g)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, “w0”, “eps”, “delta”; and “g”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “g”, list element i is the interaction; between qubits i and i+1. Parameters. N: intThe number of qubits in the system. num_levels: intThe number of energy levels in the resonator. deltamax: listThe coefficients of sigma-x for each of the qubits in the system. epsmax: listThe coefficients of sigma-z for each of the qubits in the system. wo: intThe base frequency of the resonator. wq: listThe frequency of the qubits. eps: listThe epsilon for each of the qubits in the system. delta: listThe delta for each of the qubits in the system. g: listThe interaction strength for each of the qubit with the resonator. Notes; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class Noise[source]¶; The base class representing noise in a processor.; The noise object can be added to Processor and; contributes to evolution. get_noisy_dynamics(dims, pulses, systematic_noise)[source]¶; Return a pulses list added with noise and; the pulse independent noise in a dummy Pulse object. Parameters. dims: list, optionalThe dimension of the components system, the default value is; [2,2…,2] for qubits system. pulses: list of :class:`.Pulse`The input pulses, on which the noise object is to be applied. systematic_noise: :class:`.Pulse`The dummy pulse with no ideal control element. Returns. noisy_pulses: list of PulseNoisy pulses. systematic_noise: PulseThe dummy pulse representing pulse independent noise. class DecoherenceNoise(c_ops, targets=None, coeff=None, tlist=None, all_qubits=False)[source]¶; The decoherence noise in a processor. It generates lindblad noise; according to the given",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:218658,Usability,simpl,simply,218658,"qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exactbooleanindicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; PropagatorComputer subclasses that may be more efficient. reset()[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynam",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:221661,Usability,clear,clear,221661,"ty error. fidelityfloatLast computed value of the normalised fidelity. fidelity_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of floatLast computed values for the fidelity error gradients wrt the; control in the timeslot. grad_normfloatLast computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it i",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:221679,Usability,clear,clear,221679,"ty error. fidelityfloatLast computed value of the normalised fidelity. fidelity_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of floatLast computed values for the fidelity error gradients wrt the; control in the timeslot. grad_normfloatLast computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it i",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:222198,Usability,clear,clear,222198," to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_c",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:222916,Usability,clear,clear,222916,"rmalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in t",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:222934,Usability,clear,clear,222934,"rmalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in t",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:224885,Usability,clear,clear,224885,"tion uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:226738,Usability,clear,clear,226738,"ated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:227334,Usability,clear,clear,227334,"ormalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. evo_comp_summaryEvoCompSummaryA summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:229143,Usability,simpl,simply,229143,"t to None if neither stats or dump are set. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dump_current()[source]¶; Store a copy of the current time evolution. class TSlotCompUpdateAll(dynamics, params=None)[source]¶; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated. compare_amps(new_amps)[source]¶; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed. get_timeslot_for_fidelity_calc()[source]¶; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot. recompute_evolution()[source]¶; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary. class PulseGen(dyn=None, params=None)[source]¶; Pulse generator; Base class for all Pulse generators; The object can optionally be instantiated with a Dynamics object,; in which case the timeslots and amplitude scaling and offset; are copied from that.; Otherwise the class can be used independently by setting:; tau (array of timeslot durations); or; num_tslots and pulse_time for equally spaced timeslots. Attributes. num_tslotsintegerNumber of timeslots, aka timeslices; (copied from Dynamics if given). pulse_timefloattotal duration of the pulse; (copied from Dynamics.evo_time if given). scalingfloatlinear scaling applied to the pulse; (copied from Dynamics.initial_ctrl_scaling if given). offsetfloatlinear offset applied to the pulse; (copied from Dynamics.initial_ctrl_offset if given). tauarray[num",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:231878,Usability,simpl,simply,231878,"e generator produces random pulses. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value. gen_pulse()[source]¶; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass. init_pulse()[source]¶; Initialise the pulse parameters. reset()[source]¶; reset attributes to default values. class PulseGenRandom(dyn=None, params=None)[source]¶; Generates random pulses as simply random values for each timeslot. gen_pulse()[source]¶; Generate a pulse of random values between 1 and -1; Values are scaled using the scaling property; and shifted using the offset property; Returns the pulse as an array of vales for each timeslot. reset()[source]¶; reset attributes to default values. class PulseGenZero(dyn=None, params=None)[source]¶; Generates a flat pulse. gen_pulse()[source]¶; Generate a pulse with the same value in every timeslot.; The value will be zero, unless the offset is not zero,; in which case it will be the offset. class PulseGenLinear(dyn=None, params=None)[source]¶; Generates linear pulses. Attributes. gradientfloatGradient of the line.; Note this is calculated from the start_val and end_val if these; are given. start_valfloatStart point of the line. That is the starting amplitude. end_valfloatEnd point of the line.; That is the amplitude at the start of the last timeslot. gen_pulse(gradient=None, start_val=None, end_val=None",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:239707,Usability,simpl,simply,239707,"ons. randomize_freqsboolIf True (default) the some random offset is applied to the frequencies. gen_pulse(coeffs=None)[source]¶; Generate a pulse using the Fourier basis with the freqs and; coeffs attributes. Parameters. coeffsfloat array[num_coeffs, num_basis_funcs]The basis coefficient values; If given this overides the default and sets the attribute; of the same name. init_freqs()[source]¶; Generate the frequencies; These are the Fourier harmonics with a uniformly distributed; random offset. init_pulse(num_coeffs=None)[source]¶; Set the initial freq and coefficient values. reset()[source]¶; reset attributes to default values. class Stats[source]¶; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes. dyn_gen_namestringText used in some report functions.; Makes sense to set it to ‘Hamiltonian’ when using unitary dynamics; Default is simply ‘dynamics generator’. num_iterintegerNumber of iterations of the optimisation algorithm. wall_time_optim_startfloatStart time for the optimisation. wall_time_optim_endfloatEnd time for the optimisation. wall_time_optimfloatTime elasped during the optimisation. wall_time_dyn_gen_computefloatTotal wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_computefloatTotal wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_computefloatTotal wall (elasped) time computing combined forward propagation,; that is the time evolution from the start to a specific timeslot.; Excludes calculating the propagators themselves. wall_time_onwd_prop_computefloatTotal wall (elasped) time computing combined onward propagation,; that is the time evolution from a specific",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/functions.html:3840,Availability,down,down,3840,": dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]; [0.]; [0.]; [0.]; [0.]]. bell_state(state='00')[source]¶; Returns the selected Bell state:. \[\begin{split}\begin{aligned}; \lvert B_{00}\rangle &=; \frac1{\sqrt2}(\lvert00\rangle+\lvert11\rangle)\\; \lvert B_{01}\rangle &=; \frac1{\sqrt2}(\lvert00\rangle-\lvert11\rangle)\\; \lvert B_{10}\rangle &=; \frac1{\sqrt2}(\lvert01\rangle+\lvert10\rangle)\\; \lvert B_{11}\rangle &=; \frac1{\sqrt2}(\lvert01\rangle-\lvert10\rangle)\\; \end{aligned}\end{split}\]. Returns. Bell_stateqobjBell state. bra(seq, dim=2)[source]¶; Produces a multiparticle bra state for a list or string,; where each element stands for state of the respective particle. Parameters. seqstr / list of ints or charactersEach element defines state of the respective particle.; (e.g. [1,1,0,1] or a string “1101”).; For qubits it is also possible to use the following conventions:. ‘g’/’e’ (ground and excited state); ‘u’/’d’ (spin up and down); ‘H’/’V’ (horizontal and vertical polarization). Note: for dimension > 9 you need to use a list. dimint (default: 2) / list of intsSpace dimension for each particle:; int if there are the same, list if they are different. Returns. braqobj. Examples; >>> bra(""10"") ; Quantum object: dims = [[1, 1], [2, 2]], shape = [1, 4], type = bra; Qobj data =; [[ 0. 0. 1. 0.]]. >>> bra(""Hue"") ; Quantum object: dims = [[1, 1, 1], [2, 2, 2]], shape = [1, 8], type = bra; Qobj data =; [[ 0. 1. 0. 0. 0. 0. 0. 0.]]. >>> bra(""12"", 3) ; Quantum object: dims = [[1, 1], [3, 3]], shape = [1, 9], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 1. 0. 0. 0.]]. >>> bra(""31"", [5, 2]) ; Quantum object: dims = [[1, 1], [5, 2]], shape = [1, 10], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]]. coherent(N, alpha, offset=0, method='operator')[source]¶; Generates a coherent state with eigenvalue alpha.; Constructed using displacement operator on vacuum state. Parameters. NintNumber of Fock states in Hilbert",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:12532,Availability,down,down,12532,"gth. offsetint or list of ints, optional (default 0 for all dimensions)The lowest number state that is included in the finite number state; representation of the state in the relevant dimension. Returns. dmqobjDensity matrix representation of Fock state. Examples; >>> fock_dm(3,1) ; Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 0.+0.j 0.+0.j]]. ghz_state(N=3)[source]¶; Returns the N-qubit GHZ-state. Parameters. Nint (default=3)Number of qubits in state. Returns. GqobjN-qubit GHZ-state. ket(seq, dim=2)[source]¶; Produces a multiparticle ket state for a list or string,; where each element stands for state of the respective particle. Parameters. seqstr / list of ints or charactersEach element defines state of the respective particle.; (e.g. [1,1,0,1] or a string “1101”).; For qubits it is also possible to use the following conventions:; - ‘g’/’e’ (ground and excited state); - ‘u’/’d’ (spin up and down); - ‘H’/’V’ (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dimint (default: 2) / list of intsSpace dimension for each particle:; int if there are the same, list if they are different. Returns. ketqobj. Examples; >>> ket(""10"") ; Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 1.]; [ 0.]]. >>> ket(""Hue"") ; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""12"", 3) ; Quantum object: dims = [[3, 3], [1, 1]], shape = [9, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""31"", [5, 2]) ; Quantum object: dims = [[5, 2], [1, 1]], shape = [10, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]. ket2dm(Q)[source]¶; Takes input ket or bra vector and returns density matrix; formed by outer ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:33348,Availability,toler,tolerance,33348,"class, for representing quantum states and; operators, and related functions. dag(A)[source]¶; Adjont operator (dagger) of a quantum object. Parameters. Aqutip.QobjInput quantum object. Returns. operqutip.QobjAdjoint of input operator. Notes; This function is for legacy compatibility only. It is recommended to use; the dag() Qobj method. dims(inpt)[source]¶; Returns the dims attribute of a quantum object. Parameters. inptqutip.QobjInput quantum object. Returns. dimslistA list of the quantum objects dimensions. Notes; This function is for legacy compatibility only. Using the Qobj.dims; attribute is recommended. isbra(Q)[source]¶; Determines if given quantum object is a bra-vector. Parameters. Qqutip.QobjQuantum object. Returns. isbraboolTrue if Qobj is bra-vector, False otherwise. Notes; This function is for legacy compatibility only. Using the Qobj.isbra; attribute is recommended.; Examples; >>> psi = basis(5,2); >>> isket(psi); False. isequal(A, B, tol=None)[source]¶; Determines if two qobj objects are equal to within given tolerance. Parameters. Aqutip.QobjQobj one. Bqutip.QobjQobj two. tolfloatTolerence for equality to be valid. Returns. isequalboolTrue if qobjs are equal, False otherwise. Notes; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. isherm(Q)[source]¶; Determines if given operator is Hermitian. Parameters. Qqutip.QobjQuantum object. Returns. ishermboolTrue if operator is Hermitian, False otherwise. Notes; This function is for legacy compatibility only. Using the Qobj.isherm; attribute is recommended.; Examples; >>> a = destroy(4); >>> isherm(a); False. isket(Q)[source]¶; Determines if given quantum object is a ket-vector. Parameters. Qqutip.QobjQuantum object. Returns. isketboolTrue if qobj is ket-vector, False otherwise. Notes; This function is for legacy compatibility only. Using the Qobj.isket; attribute is recommended.; Examples; >>> psi = basis(5,2); >>> is",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:37121,Availability,error,error,37121," a quantum object. Parameters. inptqutip.QobjInput quantum object. Returns. shapelistA list of the quantum objects shape. Notes; This function is for legacy compatibility only. Using the Qobj.shape; attribute is recommended. Random Operators and States¶; This module is a collection of random state and operator generators.; The sparsity of the ouput Qobj’s is controlled by varing the; density parameter. rand_dm(N, density=0.75, pure=False, dims=None, seed=None)[source]¶; Creates a random NxN density matrix. Parameters. Nint, ndarray, listIf int, then shape of output operator. If list/ndarray then eigenvalues; of generated density matrix. densityfloatDensity between [0,1] of output density matrix. dimslistDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. seedintSeed for the random number generator. Returns. operqobjNxN density matrix quantum operator. Notes; For small density matrices., choosing a low density will result in an error; as no diagonal elements will be generated such that \(Tr(\rho)=1\). rand_dm_ginibre(N=2, rank=None, dims=None, seed=None)[source]¶; Returns a Ginibre random density operator of dimension; dim and rank rank by using the algorithm of; [BCSZ08]. If rank is None, a full-rank; (Hilbert-Schmidt ensemble) random density operator will be; returned. Parameters. NintDimension of the density operator to be returned. dimslistDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. rankint or NoneRank of the sampled density operator. If None, a full-rank; density operator is generated. Returns. rhoQobjAn N × N density operator sampled from the Ginibre; or Hilbert-Schmidt distribution. rand_dm_hs(N=2, dims=None, seed=None)[source]¶; Returns a Hilbert-Schmidt random density operator of dimension; dim and rank rank by using the algorithm of; [BCSZ08]. Parameters. NintDimension of the density operator to be returned. dimslistDimensions of quantum object. Used for specifyin",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:50523,Availability,error,errors,50523,"senting a quantum map to a list of quantum objects,; each representing an operator in the Kraus decomposition of the given map. Parameters. q_operQobjSuperoperator to be converted to Kraus representation. If; q_oper is type=""oper"", then it is taken to act by conjugation,; such that to_kraus(A) == to_kraus(sprepost(A, A.dag())) == [A]. tolFloatOptional threshold parameter for eigenvalues/Kraus ops to be discarded.; The default is to=1e-9. Returns. kraus_opslist of QobjA list of quantum objects, each representing a Kraus operator in the; decomposition of q_oper. Raises. TypeError: if the given quantum object is not a map, or cannot bedecomposed into Kraus operators. to_stinespring(q_oper)[source]¶; Converts a Qobj representing a quantum map $Lambda$ to a pair of partial isometries; $A$ and $B$ such that $Lambda(X) = Tr_2(A X B^dagger)$ for all inputs $X$, where; the partial trace is taken over a a new index on the output dimensions of $A$ and $B$.; For completely positive inputs, $A$ will always equal $B$ up to precision errors. Parameters. q_operQobjSuperoperator to be converted to a Stinespring pair. Returns. A, BQobjQuantum objects representing each of the Stinespring matrices for the input Qobj. to_super(q_oper)[source]¶; Converts a Qobj representing a quantum map to the supermatrix (Liouville); representation. Parameters. q_operQobjSuperoperator to be converted to supermatrix representation. If; q_oper is type=""oper"", then it is taken to act by conjugation,; such that to_super(A) == sprepost(A, A.dag()). Returns. superopQobjA quantum object representing the same map as q_oper, such that; superop.superrep == ""super"". Raises. TypeErrorIf the given quantum object is not a map, or cannot be converted; to supermatrix representation. Operators and Superoperator Dimensions¶; Internal use module for manipulating dims specifications. collapse_dims_oper(dims)[source]¶; Given the dimensions specifications for a ket-, bra- or oper-type; Qobj, returns a dimensions specificatio",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:54809,Availability,down,down,54809,". Parameters. dimslistDimensions specification for a Qobj. Returns. permlistA list such that data[flatten(dims)[idx]] gives the; index of the tensor data corresponding to the idx``th; dimension of ``dims. dims_to_tensor_shape(dims)[source]¶; Given the dims of a Qobj instance, returns the shape of the; corresponding tensor. This helps, for instance, resolve the; column-stacking convention for superoperators. Parameters. dimslistDimensions specification for a Qobj. Returns. tensor_shapetupleNumPy shape of the corresponding tensor. enumerate_flat(l)[source]¶; Labels the indices at which scalars occur in a flattened list.; Given a list containing a mix of scalars and lists,; returns a list of the same structure, where each scalar; has been replaced by an index into the flattened list.; Examples; >>> print(enumerate_flat([[[10], [20, 30]], 40])) ; [[[0], [1, 2]], 3]. flatten(l)[source]¶; Flattens a list of lists to the first level.; Given a list containing a mix of scalars and lists,; flattens down to a list of the scalars within the original; list.; Examples; >>> flatten([[[0], 1], 2]) ; [0, 1, 2]. is_scalar(dims)[source]¶; Returns True if a dims specification is effectively; a scalar (has dimension 1). unflatten(l, idxs)[source]¶; Unflattens a list by a given structure.; Given a list of scalars and a deep list of indices; as produced by flatten, returns an “unflattened”; form of the list. This perfectly inverts flatten.; Examples; >>> l = [[[10, 20, 30], [40, 50, 60]], [[70, 80, 90], [100, 110, 120]]] ; >>> idxs = enumerate_flat(l) ; >>> unflatten(flatten(l), idxs) == l ; True. Functions acting on states and operators¶. Expectation Values¶. expect(oper, state)[source]¶; Calculates the expectation value for operator(s) and state(s). Parameters. operqobj/array-likeA single or a list or operators for expectation value. stateqobj/array-likeA single or a list of quantum states or density matrices. Returns. exptfloat/complex/array-likeExpectation value. real if oper is Hermi",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:58139,Availability,mask,mask,58139,"ct. tensor(*args)[source]¶; Calculates the tensor product of input operators. Parameters. argsarray_likelist or array of quantum objects for tensor product. Returns. objqobjA composite quantum object. Examples; >>> tensor([sigmax(), sigmax()]) ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; http://en.wikipedia.org/wiki/C",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:58231,Availability,mask,mask,58231,"ct. tensor(*args)[source]¶; Calculates the tensor product of input operators. Parameters. argsarray_likelist or array of quantum objects for tensor product. Returns. objqobjA composite quantum object. Examples; >>> tensor([sigmax(), sigmax()]) ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; http://en.wikipedia.org/wiki/C",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:58367,Availability,mask,mask,58367," objqobjA composite quantum object. Examples; >>> tensor([sigmax(), sigmax()]) ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:58464,Availability,mask,mask,58464,"shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters. rhoqobjDensity matrix of composite object. selBint/listSelected c",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:58626,Availability,mask,masklist,58626,"0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters. rhoqobjDensity matrix of composite object. selBint/listSelected components for density matrix B. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_condfloatValue of conditional entr",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:58644,Availability,mask,mask,58644,"0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters. rhoqobjDensity matrix of composite object. selBint/listSelected components for density matrix B. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_condfloatValue of conditional entr",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:71783,Availability,down,down,71783,"result of the; measurement is the corresponding eigenvalue. Parameters. stateQobjThe ket or density matrix specifying the state to measure. opQobjThe measurement operator. targetslist of ints, optionalSpecifies a list of target “qubit” indices on which to apply the; measurement using qutip.qip.gates.expand_operator to expand op; into full dimension. Returns. measured_valuefloatThe result of the measurement (one of the eigenvalues of op). stateQobjThe new state (a ket if a ket was given, otherwise a density matrix). Examples; Measure the z-component of the spin of the spin-up basis state:; >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase).; Measure the x-component of the spin of the spin-down basis state:; >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax.; One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:; >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix. measurement_statistics(state, ops, targets=None)[source]¶; A dispatch method that provides measurement statistics handling both; observable style measurements and projector style measurements(POVMs and; PVMs).; For return signatures, p",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:72290,Availability,down,down,72290,"was given, otherwise a density matrix). Examples; Measure the z-component of the spin of the spin-up basis state:; >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase).; Measure the x-component of the spin of the spin-down basis state:; >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax.; One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:; >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix. measurement_statistics(state, ops, targets=None)[source]¶; A dispatch method that provides measurement statistics handling both; observable style measurements and projector style measurements(POVMs and; PVMs).; For return signatures, please check:. measurement_statistics_observable for observable measurements.; measurement_statistics_povm for POVM measurements. Parameters. stateQobjThe ket or density matrix specifying the state to measure. opsQobj or list of Qobj; measurement observable (:class:.Qobj); or; list of measurement operators \(M_i\) or kets (list of; Qobj) Either:. specifying a POVM s.t. \(E_i = M_i^\dagger * M_i\); projection operators if ops correspond to projectors (s.t.; \(E_i = M_i^\dagger =",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:108270,Availability,avail,available,108270,"Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjState vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions.; Notes. Available solvers for ssesolve and smesolve; euler-maruyamaA simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting sc_ops. not tested. Order 0.5; Code: 'euler-maruyama', 'euler' or 0.5. milsteinAn order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]. Order strong 1.0; Code: 'milstein' or 1.0. milstein-impAn order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. Order strong 1.0; Code: 'milstein-imp'. predictor-correctorGeneralization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]. Order strong 0.5, weak 1.0; Codes to only correct t",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:113549,Availability,error,errors,113549,"qrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. g1, G1tupleThe normalized and unnormalized second-order coherence function. coherence_function_g2(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized second-order quantum coherence function:. \[ g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the elemen",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:115011,Availability,error,errors,115011,"agger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. argsdictDictionary of arguments to be passed to solver. solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. g2, G2tupleThe normalized and unnormalized second-order coherence function. correlation(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarr",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:116724,Availability,error,errors,116724,"; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reverseboolIf True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along one time axis using the quantum regression theorem and the evolution; solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:118425,Availability,error,errors,118425,"arameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reversebool {False, True}If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstr {‘me’, ‘mc’, ‘es’}choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionsSolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecndarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlatio",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:120214,Availability,error,errors,120214,"he initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reversebool {False, True}If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matndarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:121901,Availability,error,errors,121901," parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of time",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:123691,Availability,error,errors,123691,"ho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:125410,Availability,error,errors,125410,"t is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. d_opQobjoperator D. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. Note; Deprecated in QuTiP 3.1; Use correlation_3op_1t() instead. correlation_4op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-sta",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:127299,Availability,error,errors,127299,"or; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. d_opQobjoperator D. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_ss(H, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:. \[\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\]; along one time axis (given steady-state initial conditions) using the; quantum regression theorem and the evolution solver indicated by the; solver parameter. Parameters. HQobjsystem Hamiltonian. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators. a_opQobjoperator A. b_opQobjoperator B. reverseboolIf True, calculate; \(\lim_{t",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:128695,Availability,error,errors,128695,"ver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:. \[\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\]; along one time axis (given steady-state initial conditions) using the; quantum regression theorem and the evolution solver indicated by the; solver parameter. Parameters. HQobjsystem Hamiltonian. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators. a_opQobjoperator A. b_opQobjoperator B. reverseboolIf True, calculate; \(\lim_{t \to \infty} \left<A(t)B(t+\tau)\right>\) instead of; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by tlist. References; See, Gardiner, Quantum Noise, Section 5.2. spectrum(H, wlist, c_ops, a_op, b_op, solver='es', use_pinv=False)[source]¶; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\),; i.e., the Fourier transform of the correlation function:. \[S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using the solver indicated by the solver parameter. Note: this spectrum; is only defined for stationary statistics (uses steady state rho0). Parameters. Hqutip.qobjsystem Hamiltonian. wlistarray_likelist of frequencies for \(\omega\). c_opslistlist of collapse operators. a_opQobjoperator A. b_opQobjoperator B. solverstrchoice of solver (es for exponential series and; pi for psuedo-inverse). use_pinvboolFor use with the pi solver: if True use numpy’s p",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:135405,Availability,avail,availability,135405,"a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILUstr, optional, default = ‘smilu_2’Selects the incomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns. luobjectReturns a SuperLU object representing iLU preconditioner. infodict, optionalDictionary containing solver-specific information. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ system",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:137628,Availability,toler,tolerance,137628,"ominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint, default 10MKL ONLY. Max. number of iterative refinements to perform. scaling_vectorsboolMKL ONLY. Scale matrix to unit norm columns and rows. weighted_matchingboolMKL ONLY. Use weighted matching to better condition diagonal. x0ndarray, optionalITERATIVE ONLY. Initial guess for solution vector. maxiterint, default 1000ITERATIVE ONLY. Maximum number of iterations to perform. tolfloat, default 1e-12ITERATIVE ONLY. Tolerance used for terminating solver. mtolfloat, optionalITERATIVE ‘power’ methods ONLY. Tolerance for lu solve method. If None; given then max(0.1*tol, 1e-15) is used. matolfloat, default 1e-15ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_specstr, optionalITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ (default); and ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. use_precondbool, default FalseITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers. Speeds up; convergence time by orders of magnitude in many cases. M{sparse matrix, dense matrix, LinearOperator}, optionalITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and use_precond = True, then one; is generated automatically. fill_factorfloat, default 100ITERATIVE ONLY. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost o",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:142098,Availability,error,error,142098,"ystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). scattering_probability(H, psi0, n_emissions, c_ops, tlist, system_zero_state=None, construct_effective_hamiltonian=True)[source]¶; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters. H:class: qutip.Qobj or listSystem-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is cons",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:197937,Availability,error,error,197937,"al maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0qutip.QobjInitial density matrix or state vector (ket). timesarray_likelist of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced. e_opslist of qutip.Qobj / callback functionsingle operator or list of operators for which to evaluate; expectation values. learningtimesarray_likelist of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisat",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:198105,Availability,error,error,198105,"kelist of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced. e_opslist of qutip.Qobj / callback functionsingle operator or list of operators for which to evaluate; expectation values. learningtimesarray_likelist of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the v",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:198402,Availability,error,error,198402,"mes \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dyna",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:198649,Availability,error,error,198649,"TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:199322,Availability,error,error,199322,"hods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_ty",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:202341,Availability,error,error,202341,"can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are dervived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be u",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:202408,Availability,error,error,202408,"alQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are dervived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note th",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:203382,Availability,error,error,203382,"n the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:204954,Availability,error,error,204954," Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_paramsdictParameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. phase_optionstringDeprecated. Pass in fid_params instead. fid_err_scale_factorfloatDeprecated. Use scale_factor key in fid_params instead. tslot_typestringMethod for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_paramsdictParameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. amp_update_modestringDeprecated. Use tslot_type instead. init_pulse_typestringtype / shape of pulse(s) used to initialise the; the control amplitudes.; Options (GRAPE) include:. RN",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:204974,Availability,error,error,204974," Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_paramsdictParameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. phase_optionstringDeprecated. Pass in fid_params instead. fid_err_scale_factorfloatDeprecated. Use scale_factor key in fid_params instead. tslot_typestringMethod for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_paramsdictParameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. amp_update_modestringDeprecated. Use tslot_type instead. init_pulse_typestringtype / shape of pulse(s) used to initialise the; the control amplitudes.; Options (GRAPE) include:. RN",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:208808,Availability,error,error,208808,"Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. driftQobj or list of Qobjthe underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]a list of control dynamics generators. These are scaled by; the amplitu",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:209287,Availability,error,error,209287,"t_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. driftQobj or list of Qobjthe underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:209307,Availability,error,error,209307,"t_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. driftQobj or list of Qobjthe underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:210773,Availability,error,error,210773,"can be provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are dervived from it.; None implies that timeslot durations will be equal and calculated; as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set;",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:210840,Availability,error,error,210840,"lQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are dervived from it.; None implies that timeslot durations will be equal and calculated; as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencie",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:212485,Availability,error,error,212485,"e from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method. Note that where there is an attribute; of the Optimizer object or the termination_conditions matching; the key that attribute. Otherwise, and in some case also, they are; assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_typestringPropagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method.; Options are DEF, UNIT, TRACEDIFF, TD_APPROX. DEF will use the default; for the specific dyn_type. (See FidelityCo",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:213292,Availability,error,error,213292,"assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_typestringPropagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method.; Options are DEF, UNIT, TRACEDIFF, TD_APPROX. DEF will use the default; for the specific dyn_type. (See FidelityComputer classes for; details). fid_paramsdictParameters for the FidelityComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC UPDATE_ALL is the; only one that currently works. (See TimeslotComputer classes; for details). tslot_paramsdictParameters for the TimeslotComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. guess_pulse_typestring, default NoneType / shape of pulse(s) used modulate the control amplitudes.; Options include: RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN. guess_pulse_paramsdictParameters for the guess pulse generator object.",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:213312,Availability,error,error,213312,"assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_typestringPropagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method.; Options are DEF, UNIT, TRACEDIFF, TD_APPROX. DEF will use the default; for the specific dyn_type. (See FidelityComputer classes for; details). fid_paramsdictParameters for the FidelityComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC UPDATE_ALL is the; only one that currently works. (See TimeslotComputer classes; for details). tslot_paramsdictParameters for the TimeslotComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. guess_pulse_typestring, default NoneType / shape of pulse(s) used modulate the control amplitudes.; Options include: RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN. guess_pulse_paramsdictParameters for the guess pulse generator object.",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:216259,Availability,error,error,216259,"airs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse. Amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:217008,Availability,error,error,217008,"ill suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) th",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:217746,Availability,error,error,217746,"slot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array like imput can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:217766,Availability,error,error,217766,"lse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array like imput can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:219229,Availability,error,error,219229,"mput can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:219296,Availability,error,error,219296,"U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequenci",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:220942,Availability,error,error,220942," from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_paramsdictParameters for the FidelityComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC. UPDATE_ALL is; the only one that currently works. (See TimeslotComputer; classes for details). tslot_paramsdictParameters for the Tim",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:224231,Availability,error,error,224231,"airs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error. The dynamics of; the system in any given timeslot are governed by the combined dynamics; generator, i.e. the ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:225084,Availability,error,error,225084," for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error. The dynamics of; the system in any given timeslot are governed by the combined dynamics; generator, i.e. the sum of the drift + ctrl_amp[j]*ctrls[j].; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an initial (typically random) pulse, a multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. driftQobj or list of QobjThe underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time depen",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:225494,Availability,error,error,225494,"=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error. The dynamics of; the system in any given timeslot are governed by the combined dynamics; generator, i.e. the sum of the drift + ctrl_amp[j]*ctrls[j].; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an initial (typically random) pulse, a multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. driftQobj or list of QobjThe underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots w",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:225514,Availability,error,error,225514,"im_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error. The dynamics of; the system in any given timeslot are governed by the combined dynamics; generator, i.e. the sum of the drift + ctrl_amp[j]*ctrls[j].; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an initial (typically random) pulse, a multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. driftQobj or list of QobjThe underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; duratio",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:226980,Availability,error,error,226980," can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be us",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:227047,Availability,error,error,227047,"ialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error. Note tha",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:228020,Availability,error,error,228020,"r target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error. Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods. Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics; classes for details). dyn_paramsdictPara",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:229592,Availability,error,error,229592,"r the scipy.optimize.minimize; method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics; classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_typestringPropagator type i.e. the method used to calculate the propagators and; propagator gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT. DEF will use the default for the specific; dyn_type (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method.; Options are DEF, UNIT, TRACEDIFF, TD_APPROX. DEF will use the default; for the specific dyn_type (See FidelityComputer classes for; details). fid_paramsdictParameters for the FidelityComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. phase_optionstringDeprecated. Pass in fid_params instead. fid_err_scale_factorfloatDeprecated. Use scale_factor key in fid_params instead. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC. UPDATE_ALL is; the only one that currently works. (See TimeslotComputer; classes for details.). tslot_paramsdictParameters for the TimeslotComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. amp_update_modestringDeprecated. Use tslot_type instead. init_pulse_typestringType / shape of pulse(s)",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:229612,Availability,error,error,229612,"r the scipy.optimize.minimize; method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics; classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_typestringPropagator type i.e. the method used to calculate the propagators and; propagator gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT. DEF will use the default for the specific; dyn_type (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method.; Options are DEF, UNIT, TRACEDIFF, TD_APPROX. DEF will use the default; for the specific dyn_type (See FidelityComputer classes for; details). fid_paramsdictParameters for the FidelityComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. phase_optionstringDeprecated. Pass in fid_params instead. fid_err_scale_factorfloatDeprecated. Use scale_factor key in fid_params instead. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC. UPDATE_ALL is; the only one that currently works. (See TimeslotComputer; classes for details.). tslot_paramsdictParameters for the TimeslotComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. amp_update_modestringDeprecated. Use tslot_type instead. init_pulse_typestringType / shape of pulse(s)",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:232709,Availability,error,error,232709,"airs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:233483,Availability,error,error,233483,"atsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is 1 - fidelity. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provid",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:234148,Availability,error,error,234148,"thod_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is 1 - fidelity. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array-like input can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution.",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:234315,Availability,error,error,234315,"ffset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is 1 - fidelity. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array-like input can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_ts",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:235670,Availability,error,error,235670,"nput can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be us",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:235737,Availability,error,error,235737,"U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error Note that",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:236710,Availability,error,error,236710,"en the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying; DEF will given algorithm-dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:240782,Availability,error,error,240782," pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot. These are the other non-periodic options:. LIN - Linear, i.e. contant gradient over the time; ZERO - special case of",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:43267,Deployability,configurat,configuration,43267,"xp(-iH)\) where H is a randomly generated; Hermitian operator. Parameters. NintShape of output quantum operator. densityfloatDensity between [0,1] of output Unitary operator. dimslistDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. operqobjNxN Unitary quantum operator. rand_unitary_haar(N=2, dims=None, seed=None)[source]¶; Returns a Haar random unitary matrix of dimension; dim, using the algorithm of [Mez07]. Parameters. NintDimension of the unitary to be returned. dimslist of lists of int, or NoneDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. UQobjUnitary of dims [[dim], [dim]] drawn from the Haar; measure. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [1] . 1; Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns. statesarrayarray of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns. opsarrayarray of three level operators. Superoperators and Liouvillians¶. lindblad_dissipator(a, b=None, data_only=False, chi=None)[source]¶; Lindblad dissipator (generalized) for a single pair of collapse operators; (a, b), or",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:43356,Deployability,configurat,configurations,43356," object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. operqobjNxN Unitary quantum operator. rand_unitary_haar(N=2, dims=None, seed=None)[source]¶; Returns a Haar random unitary matrix of dimension; dim, using the algorithm of [Mez07]. Parameters. NintDimension of the unitary to be returned. dimslist of lists of int, or NoneDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. UQobjUnitary of dims [[dim], [dim]] drawn from the Haar; measure. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [1] . 1; Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns. statesarrayarray of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns. opsarrayarray of three level operators. Superoperators and Liouvillians¶. lindblad_dissipator(a, b=None, data_only=False, chi=None)[source]¶; Lindblad dissipator (generalized) for a single pair of collapse operators; (a, b), or for a single collapse operator (a) when b is not specified:. \[\mathcal{D}[a,b]\rho = a \rho b^\dagger -; \frac{1}{2}a^\dagger b\rho - \frac{1}{2}\rho a^\dagger b\]. Parameters. aQobj or QobjEvoLeft part",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:64969,Deployability,continuous,continuous,64969,"ctor. BqobjDensity matrix or state vector with same dimensions as A. Returns. distfloatHilbert-Schmidt distance between density matrices. Notes; See V. Vedral and M. B. Plenio, Phys. Rev. A 57, 1619 (1998). process_fidelity(U1, U2, normalize=True)[source]¶; Calculate the process fidelity given two process operators. tracedist(A, B, sparse=False, tol=0)[source]¶; Calculates the trace distance between two density matrices..; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. tolfloatTolerance used by sparse eigensolver, if used. (0=Machine precision). sparse{False, True}Use sparse eigensolver. Returns. tracedistfloatTrace distance between A and B. Examples; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(tracedist(x,y), 0.9705143161472971). Continuous Variables¶; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields. correlation_matrix(basis, rho=None)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the correlation; matrix:. \[C_{mn} = \langle a_m a_n \rangle\]. Parameters. basislistList of operators that defines the basis for the correlation matrix. rhoQobjDensity matrix for which to calculate the correlation matrix. If; rho is None, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns. corr_matndarrayA 2-dimensional array of correlation values or operators. correlation_matrix_field(a1, a2, rho=None)[source]¶; Calculates the correlation matrix for given field operators \(a_1\) and; \(a_2\). If a density matrix is given the expectation values are; calculated, otherwise a matrix with operators is returned. Parameters. a1QobjField operator for mode 1. a2QobjField operator for mode 2. rhoQobjDensity matrix for which to calculate the ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:74821,Deployability,integrat,integrating,74821,"slist of ints, optionalSpecifies a list of targets “qubit” indices on which to apply the; measurement using qutip.qip.gates.expand_operator to expand op; into full dimension. Returns. eigenvalues: list of floatThe list of eigenvalues of the measurement operator. eigenstates_or_projectors: list of QobjIf the state was a ket, return the eigenstates of the measurement; operator. Otherwise return the projectors onto the eigenstates. probabilities: list of floatThe probability of measuring the state as being in the corresponding; eigenstate (and the measurement result being the corresponding; eigenvalue). Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, psi0, tlist, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian.; Evolve the state vector (psi0) using a given Hamiltonian (H), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation.; The output is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters. HQobj, QobjEvo, list, or callableSystem Hamiltonian as a Qobj , list of :obj:`Qobj and; coefficient, QObjEvo, or a callback function for time-dependent; Hamiltonians. List format and options can be found in QobjEvo’s; description. psi0QobjInitial state vector (ket) or initial unitary operator psi0 = U. tlistarray_like of floatList of times for \(t\). e_opslist of Qobj or callback function, optionalSingle operator or list of ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:77089,Deployability,integrat,integrating,77089,"tions, optionalOptions for the ODE solver. progress_barBaseProgressBar, optionalOptional instance of BaseProgressBar, or a subclass thereof,; for showing the progress of the simulation. Returns. output: ResultAn instance of the class Result, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors corresponding to the times in tlist (if; e_ops is an empty list), or nothing if a callback function was; given inplace of operators for which to calculate the expectation; values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian or Liouvillian (H) and an optional set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form.; Time-dependent operators; For time-dependent problems, H and c_ops can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (qutip.qobj) at the first element and where; the sec",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:79423,Deployability,integrat,integration,79423,"the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:80062,Deployability,integrat,integrator,80062," (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opsNone / list of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opsNone / list of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. argsNone / dictionarydictionary of parameters for time-dependent Ha",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:80399,Deployability,integrat,integrator,80399,"solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opsNone / list of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opsNone / list of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. argsNone / dictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators. optionsNone / qutip.Optionswith options for the solver. progress_barNone / BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns. result: qutip.ResultAn instance of the class qutip.Result, which contains; either an array result.expect of expectatio",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:84840,Deployability,integrat,integration,84840,"lation. Set to None to disable the; progress bar. map_func: functionA map function for managing the calls to the single-trajactory solver. map_kwargs: dictionaryOptional keyword arguments to the map_func function. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. Note; It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds). Exponential Series¶. essolve(H, rho0, tlist, c_op_list, e_ops)[source]¶; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (tlist), or the; expectation values of the supplied operators (e_ops). Deprecated since version 4.6.0: essolev will be removed in QuTiP 5. Please use sesolve; or mesolve for general-purpose integration of the; Schroedinger/Lindblad master equation. This will likely be faster than; essolve for you. Parameters. Hqobj/function_typeSystem Hamiltonian. rho0qutip.qobjInitial state density matrix. tlistlist/arraylist of times for \(t\). c_op_listlist of qutip.qobjlist of qutip.qobj collapse operators. e_opslist of qutip.qobjlist of qutip.qobj operators for which to evaluate; expectation values. Returns. expt_arrayarrayExpectation values of wavefunctions/density matrices for the; times specified in tlist. Note; This solver does not support time-dependent Hamiltonians.; .. ode2es(L, rho0)[source]¶; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Deprecated since version 4.6.0: ode2es will be removed in QuTiP 5. Please use; Qobj.eigenstates to get the eigenstates and -values, and use; QobjEvo for general time-dependence. Parameters. LqobjLiouvillian of the system. rho0qob",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:142327,Deployability,configurat,configuration,142327,"enting the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). scattering_probability(H, psi0, n_emissions, c_ops, tlist, system_zero_state=None, construct_effective_hamiltonian=True)[source]¶; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters. H:class: qutip.Qobj or listSystem-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and; c_ops. psi0:class: qutip.QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). n_emissionsintNumber of photons emitted by the system (i",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:142707,Deployability,integrat,integrated,142707," a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). scattering_probability(H, psi0, n_emissions, c_ops, tlist, system_zero_state=None, construct_effective_hamiltonian=True)[source]¶; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters. H:class: qutip.Qobj or listSystem-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and; c_ops. psi0:class: qutip.QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). n_emissionsintNumber of photons emitted by the system (into any combination of; waveguides). c_opslistList of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; \(\sigma = \sqrt \gamma \cdot a\). tlistarray_likeList of times for \(\tau_i\). tlist should contain 0 and exceed; the pulse duration / temporal region of interest; tlist need not be; linearly spaced. system_zero_state:class: qutip.QobjState representing zero excitations in the syst",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:161593,Deployability,integrat,integrated,161593,"ions as working space when; dealing with density-matrix inputs. This is ignored for state-vector; inputs. The bound is not quite exact due to other, order-of-magnitude; smaller, intermediaries being necessary, but is a good approximation.; If you want to use the same iterative algorithm for density matrices; that is used for single kets, set precompute_memory=None. Returns. ndarrayValues representing the Husimi-Q function calculated over the specified; range [xvec, yvec]. See also. QFunca class-based version, more efficient if you want to calculate the Husimi-Q function for several states over the same coordinates. spin_q_function(rho, theta, phi)[source]¶; The Husimi Q function for spins is defined as Q(theta, phi) =; SCS.dag() * rho * SCS for the spin coherent state SCS = spin_coherent(; j, theta, phi) where j is the spin length.; The implementation here is more efficient as it doesn’t; generate all of the SCS at theta and phi (see references).; The spin Q function is normal when integrated over the surface of the; sphere. \[\frac{4 \pi}{2j + 1}\int_\phi \int_\theta; Q(\theta, \phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at which to calculate the Husimi-Q function. phiarray_likeAzimuthal angle at which to calculate the Husimi-Q function. Returns. Q, THETA, PHI2d-arrayValues representing the spin Husimi Q function at the values specified; by THETA and PHI. References; [1] Lee Loh, Y., & Kim, M. (2015). American J. of Phys., 83(1), 30–35.; https://doi.org/10.1119/1.4898595. spin_wigner(rho, theta, phi)[source]¶; Wigner function for a spin-j system.; The spin W function is normal when integrated over the surface of the; sphere. \[\sqrt{\frac{4 \pi}{2j + 1}}\int_\phi \int_\theta; W(\theta,\phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:162325,Deployability,integrat,integrated,162325,".dag() * rho * SCS for the spin coherent state SCS = spin_coherent(; j, theta, phi) where j is the spin length.; The implementation here is more efficient as it doesn’t; generate all of the SCS at theta and phi (see references).; The spin Q function is normal when integrated over the surface of the; sphere. \[\frac{4 \pi}{2j + 1}\int_\phi \int_\theta; Q(\theta, \phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at which to calculate the Husimi-Q function. phiarray_likeAzimuthal angle at which to calculate the Husimi-Q function. Returns. Q, THETA, PHI2d-arrayValues representing the spin Husimi Q function at the values specified; by THETA and PHI. References; [1] Lee Loh, Y., & Kim, M. (2015). American J. of Phys., 83(1), 30–35.; https://doi.org/10.1119/1.4898595. spin_wigner(rho, theta, phi)[source]¶; Wigner function for a spin-j system.; The spin W function is normal when integrated over the surface of the; sphere. \[\sqrt{\frac{4 \pi}{2j + 1}}\int_\phi \int_\theta; W(\theta,\phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at which to calculate the W function. phiarray_likeAzimuthal angle at which to calculate the W function. Returns. W, THETA, PHI2d-arrayValues representing the spin Wigner function at the values specified; by THETA and PHI. References; [1] Agarwal, G. S. (1981). Phys. Rev. A, 24(6), 2889–2896.; https://doi.org/10.1103/PhysRevA.24.2889; [2] Dowling, J. P., Agarwal, G. S., & Schleich, W. P. (1994).; Phys. Rev. A, 49(5), 4101–4109. https://doi.org/10.1103/PhysRevA.49.4101; [3] Conversion between Wigner 3-j symbol and Clebsch-Gordan coefficients; taken from Wikipedia (https://en.wikipedia.org/wiki/3-j_symbol). wigner(psi, xvec, yvec, method='clenshaw', g=1.4142135623730951, sparse=False, parfor=False)[source]¶; Wigner function for",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:197809,Deployability,configurat,configuration,197809,"source]¶; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0qutip.QobjInitial density matrix or state vector (ket). timesarray_likelist of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced. e_opslist of qutip.Qobj / callback functionsingle operator or list of operators for which to evaluate; expectation values. learningtimesarray_likelist of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The C",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:200807,Deployability,configurat,configuration,200807,"rco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses required for the pulse; optmisation based on the parameters given Note this method may be; preferable to calling optimize_pulse if more detailed configuration is; required before running the optmisation algorthim, or the algorithm will be; run many times, for instances when trying to finding global the optimum or; minimum time optimisation. Parameters. driftQobj or list of QobjThe underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:256951,Deployability,update,updated,256951,"n the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib. simdiag(ops, evals: bool = True, *, tol: float = 1e-14, safe_mode: bool = True)[source]¶; Simultaneous diagonalization of commuting Hermitian matrices. Parameters. opslist/arraylist or array of qobjs representing commuting Hermitian; operators. evalsbool [True]Whether to return the eigenvalues for each ops and eigenvectors or just; the eigenvectors. tolfloat [1e-14]Tolerance for detecting degenerate eigenstates. safe_modebool [True]Whether to check that all ops are Hermitian and commuting. If set to; False and operators are not commuting, the eigenvectors returned; will often be eigenvectors of only the first operator. Returns. eigstupleTuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:20363,Energy Efficiency,charge,charge,20363,"0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. triplet_states()[source]¶; Returns a list of the two particle triplet-states:. \[\lvert T_1\rangle = \lvert11\rangle; \lvert T_2\rangle = \frac1{\sqrt2}(\lvert01\rangle + \lvert10\rangle); \lvert T_3\rangle = \lvert00\rangle\]. Returns. trip_stateslist2 particle triplet states. w_state(N=3)[source]¶; Returns the N-qubit W-state. Parameters. Nint (default=3)Number of qubits in state. Returns. WqobjN-qubit W-state. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters. NintHilbert space dimensionality. dimslistOptional dimensions if ket corresponds to; a composite Hilbert space. Returns. zero_ketqobjZero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters. NmaxintMaximum charge state to consider. Nminint (default = -Nmax)Lowest charge state to consider. fracfloat (default = 1)Specify fractional charge if needed. Returns. CQobjCharge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters. NintDimension of Hilbert space. Returns. operqobjQobj for raising operator. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4) ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:20427,Energy Efficiency,charge,charge,20427,"0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. triplet_states()[source]¶; Returns a list of the two particle triplet-states:. \[\lvert T_1\rangle = \lvert11\rangle; \lvert T_2\rangle = \frac1{\sqrt2}(\lvert01\rangle + \lvert10\rangle); \lvert T_3\rangle = \lvert00\rangle\]. Returns. trip_stateslist2 particle triplet states. w_state(N=3)[source]¶; Returns the N-qubit W-state. Parameters. Nint (default=3)Number of qubits in state. Returns. WqobjN-qubit W-state. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters. NintHilbert space dimensionality. dimslistOptional dimensions if ket corresponds to; a composite Hilbert space. Returns. zero_ketqobjZero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters. NmaxintMaximum charge state to consider. Nminint (default = -Nmax)Lowest charge state to consider. fracfloat (default = 1)Specify fractional charge if needed. Returns. CQobjCharge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters. NintDimension of Hilbert space. Returns. operqobjQobj for raising operator. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4) ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:20448,Energy Efficiency,charge,charge,20448,"0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. triplet_states()[source]¶; Returns a list of the two particle triplet-states:. \[\lvert T_1\rangle = \lvert11\rangle; \lvert T_2\rangle = \frac1{\sqrt2}(\lvert01\rangle + \lvert10\rangle); \lvert T_3\rangle = \lvert00\rangle\]. Returns. trip_stateslist2 particle triplet states. w_state(N=3)[source]¶; Returns the N-qubit W-state. Parameters. Nint (default=3)Number of qubits in state. Returns. WqobjN-qubit W-state. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters. NintHilbert space dimensionality. dimslistOptional dimensions if ket corresponds to; a composite Hilbert space. Returns. zero_ketqobjZero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters. NmaxintMaximum charge state to consider. Nminint (default = -Nmax)Lowest charge state to consider. fracfloat (default = 1)Specify fractional charge if needed. Returns. CQobjCharge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters. NintDimension of Hilbert space. Returns. operqobjQobj for raising operator. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4) ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:20509,Energy Efficiency,charge,charge,20509,"0. 0. 0.03125]]. triplet_states()[source]¶; Returns a list of the two particle triplet-states:. \[\lvert T_1\rangle = \lvert11\rangle; \lvert T_2\rangle = \frac1{\sqrt2}(\lvert01\rangle + \lvert10\rangle); \lvert T_3\rangle = \lvert00\rangle\]. Returns. trip_stateslist2 particle triplet states. w_state(N=3)[source]¶; Returns the N-qubit W-state. Parameters. Nint (default=3)Number of qubits in state. Returns. WqobjN-qubit W-state. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters. NintHilbert space dimensionality. dimslistOptional dimensions if ket corresponds to; a composite Hilbert space. Returns. zero_ketqobjZero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters. NmaxintMaximum charge state to consider. Nminint (default = -Nmax)Lowest charge state to consider. fracfloat (default = 1)Specify fractional charge if needed. Returns. CQobjCharge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters. NintDimension of Hilbert space. Returns. operqobjQobj for raising operator. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4) ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. destroy(N, offset",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:20567,Energy Efficiency,charge,charge,20567,"s a list of the two particle triplet-states:. \[\lvert T_1\rangle = \lvert11\rangle; \lvert T_2\rangle = \frac1{\sqrt2}(\lvert01\rangle + \lvert10\rangle); \lvert T_3\rangle = \lvert00\rangle\]. Returns. trip_stateslist2 particle triplet states. w_state(N=3)[source]¶; Returns the N-qubit W-state. Parameters. Nint (default=3)Number of qubits in state. Returns. WqobjN-qubit W-state. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters. NintHilbert space dimensionality. dimslistOptional dimensions if ket corresponds to; a composite Hilbert space. Returns. zero_ketqobjZero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters. NmaxintMaximum charge state to consider. Nminint (default = -Nmax)Lowest charge state to consider. fracfloat (default = 1)Specify fractional charge if needed. Returns. CQobjCharge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters. NintDimension of Hilbert space. Returns. operqobjQobj for raising operator. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4) ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. destroy(N, offset=0)[source]¶; Destruction (lowering) operator. Pa",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:20635,Energy Efficiency,charge,charge,20635,"rangle = \lvert11\rangle; \lvert T_2\rangle = \frac1{\sqrt2}(\lvert01\rangle + \lvert10\rangle); \lvert T_3\rangle = \lvert00\rangle\]. Returns. trip_stateslist2 particle triplet states. w_state(N=3)[source]¶; Returns the N-qubit W-state. Parameters. Nint (default=3)Number of qubits in state. Returns. WqobjN-qubit W-state. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters. NintHilbert space dimensionality. dimslistOptional dimensions if ket corresponds to; a composite Hilbert space. Returns. zero_ketqobjZero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters. NmaxintMaximum charge state to consider. Nminint (default = -Nmax)Lowest charge state to consider. fracfloat (default = 1)Specify fractional charge if needed. Returns. CQobjCharge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters. NintDimension of Hilbert space. Returns. operqobjQobj for raising operator. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4) ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. destroy(N, offset=0)[source]¶; Destruction (lowering) operator. Parameters. NintDimension of Hilbert space. offsetint (defaul",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:91624,Energy Efficiency,power,power,91624,"uation¶. floquet_basis_transform(f_modes, f_energies, rho0)[source]¶; Make a basis transform that takes rho0 from the floquet basis to the; computational basis. floquet_markov_mesolve(R, ekets, rho0, tlist, e_ops, f_modes_table=None, options=None, floquet_basis=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T, args, J_cb, w_th, kmax=5, f_modes_table_t=None)[source]¶; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters. f_modes_0list of qutip.qobj (kets)A list of initial Floquet modes. f_energiesarrayThe Floquet energies. c_opqutip.qobjThe collapse operators describing the dissipation. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. J_cbcallback functionsA callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator c_op. w_thfloatThe temperature in units of frequency. k_maxintThe truncation of the number of sidebands (default 5). f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parame",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:98538,Energy Efficiency,power,power,98538,"me for which to evaluate the Floquet states. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. Returns. outputqutip.qobjThe wavefunction for the time \(t\). fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K ; >>> h = 6.626e-34 ; >>> kB = 1.38e-23 ; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 . optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times sp",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:98984,Energy Efficiency,energy,energy,98984,"loquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K ; >>> h = 6.626e-34 ; >>> kB = 1.38e-23 ; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 . optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters. Hqutip.qobj.QobjSystem Hamiltonian, time-dependent with period T. psi0qutip.qobjInitial state vector (ket). tlistlist / arraylist of times for \(t\). e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:129926,Energy Efficiency,power,power,129926,"op, b_op, solver='es', use_pinv=False)[source]¶; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\),; i.e., the Fourier transform of the correlation function:. \[S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using the solver indicated by the solver parameter. Note: this spectrum; is only defined for stationary statistics (uses steady state rho0). Parameters. Hqutip.qobjsystem Hamiltonian. wlistarray_likelist of frequencies for \(\omega\). c_opslistlist of collapse operators. a_opQobjoperator A. b_opQobjoperator B. solverstrchoice of solver (es for exponential series and; pi for psuedo-inverse). use_pinvboolFor use with the pi solver: if True use numpy’s pinv method,; otherwise use a generic solver. Returns. spectrumarrayAn array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_correlation_fft(tlist, y, inverse=False)[source]¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters. tlistarray_likelist/array of times \(t\) which the correlation function is given. yarray_likelist/array of correlations corresponding to time delays \(t\). inverse: booleanboolean parameter for using a positive exponent in the Fourier Transform instead. Default is False. Returns. w, StupleReturns an array of angular frequencies ‘w’ and the corresponding; two-sided power spectrum ‘S(w)’. spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False)[source]¶; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\),; i.e., the Fourier transform of the correlation function:. \[S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using a psuedo-inverse method. Note: this spectrum is only defined for; stationary statistics (uses steady state rho0). Parameters. Hqutip.qobjsystem Hamiltonian. wlistarray_like",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:130381,Energy Efficiency,power,power,130381,"tionary statistics (uses steady state rho0). Parameters. Hqutip.qobjsystem Hamiltonian. wlistarray_likelist of frequencies for \(\omega\). c_opslistlist of collapse operators. a_opQobjoperator A. b_opQobjoperator B. solverstrchoice of solver (es for exponential series and; pi for psuedo-inverse). use_pinvboolFor use with the pi solver: if True use numpy’s pinv method,; otherwise use a generic solver. Returns. spectrumarrayAn array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_correlation_fft(tlist, y, inverse=False)[source]¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters. tlistarray_likelist/array of times \(t\) which the correlation function is given. yarray_likelist/array of correlations corresponding to time delays \(t\). inverse: booleanboolean parameter for using a positive exponent in the Fourier Transform instead. Default is False. Returns. w, StupleReturns an array of angular frequencies ‘w’ and the corresponding; two-sided power spectrum ‘S(w)’. spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False)[source]¶; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\),; i.e., the Fourier transform of the correlation function:. \[S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using a psuedo-inverse method. Note: this spectrum is only defined for; stationary statistics (uses steady state rho0). Parameters. Hqutip.qobjsystem Hamiltonian. wlistarray_likelist of frequencies for \(\omega\). c_opslist of qutip.qobjlist of collapse operators. a_opqutip.qobjoperator A. b_opqutip.qobjoperator B. use_pinvboolIf True use numpy’s pinv method, otherwise use a generic solver. Returns. spectrumarrayAn array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_ss(H, wlist, c_ops, a_op, b_op)[source]¶; Calculate the spectrum of the correlation function; \(\l",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:133471,Energy Efficiency,power,power,133471,". AqobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. return_infobool, optional, default = FalseReturn a dictionary of solver-specific infomation about the; solution and how it was obtained. use_rcmbool, optional, default = FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbmbool, optional, default = FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. methodstr, default = ‘iterative’Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use ‘iterative’.; For power iterative methods use ‘power’. permc_specstr, optional, default=’COLAMD’Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. fill_factorfloat, optional, default = 100Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tolfloat, optional, default = 1e-4Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_threshfloat, optional, default = NoneSets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_M",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:133500,Energy Efficiency,power,power,133500,". AqobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. return_infobool, optional, default = FalseReturn a dictionary of solver-specific infomation about the; solution and how it was obtained. use_rcmbool, optional, default = FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbmbool, optional, default = FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. methodstr, default = ‘iterative’Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use ‘iterative’.; For power iterative methods use ‘power’. permc_specstr, optional, default=’COLAMD’Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. fill_factorfloat, optional, default = 100Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tolfloat, optional, default = 1e-4Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_threshfloat, optional, default = NoneSets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_M",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:134113,Energy Efficiency,reduce,reduced,134113,"ce condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. methodstr, default = ‘iterative’Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use ‘iterative’.; For power iterative methods use ‘power’. permc_specstr, optional, default=’COLAMD’Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. fill_factorfloat, optional, default = 100Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tolfloat, optional, default = 1e-4Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_threshfloat, optional, default = NoneSets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILUstr, optional, default = ‘smilu_2’Selects the incomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns. luobjectReturns a SuperLU object representing iLU preconditioner. infodict, optionalDictionary containing solver-specific information. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:135578,Energy Efficiency,power,power,135578,"n method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns. luobjectReturns a SuperLU object representing iLU preconditioner. infodict, optionalDictionary containing solver-specific information. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:135587,Energy Efficiency,power,power-gmres,135587,"n method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns. luobjectReturns a SuperLU object representing iLU preconditioner. infodict, optionalDictionary containing solver-specific information. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:135602,Energy Efficiency,power,power-lgmres,135602,"n method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns. luobjectReturns a SuperLU object representing iLU preconditioner. infodict, optionalDictionary containing solver-specific information. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:135618,Energy Efficiency,power,power-bicgstab,135618,"n method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns. luobjectReturns a SuperLU object representing iLU preconditioner. infodict, optionalDictionary containing solver-specific information. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:135926,Energy Efficiency,power,power,135926,"op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:135940,Energy Efficiency,power,power,135940,"op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:135962,Energy Efficiency,power,power,135962,"onian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint, default 10MKL ONLY.",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:135978,Energy Efficiency,power,power-gmres,135978,"onian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint, default 10MKL ONLY.",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:135993,Energy Efficiency,power,power-lgmres,135993,"onian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint, default 10MKL ONLY.",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:136009,Energy Efficiency,power,power-bicgstab,136009,"onian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint, default 10MKL ONLY.",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:137477,Energy Efficiency,power,power,137477,"inimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint, default 10MKL ONLY. Max. number of iterative refinements to perform. scaling_vectorsboolMKL ONLY. Scale matrix to unit norm columns and rows. weighted_matchingboolMKL ONLY. Use weighted matching to better condition diagonal. x0ndarray, optionalITERATIVE ONLY. Initial guess for solution vector. maxiterint, default 1000ITERATIVE ONLY. Maximum number of iterations to perform. tolfloat, default 1e-12ITERATIVE ONLY. Tolerance used for terminating solver. mtolfloat, optionalITERATIVE ‘power’ methods ONLY. Tolerance for lu solve method. If None; given then max(0.1*tol, 1e-15) is used. matolfloat, default 1e-15ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_specstr, optionalITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ (default); and ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. use_precondbool, default FalseITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers. Speeds up; convergence time by orders of magnitude in many cases. M{sparse matrix, dense matrix, LinearOperator}, optionalITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and use_precond = True, then one; is generated aut",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:138842,Energy Efficiency,reduce,reduced,138842,"xplicitly specified. use_precondbool, default FalseITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers. Speeds up; convergence time by orders of magnitude in many cases. M{sparse matrix, dense matrix, LinearOperator}, optionalITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and use_precond = True, then one; is generated automatically. fill_factorfloat, default 100ITERATIVE ONLY. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tolfloat, default 1e-4ITERATIVE ONLY. Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_threshfloat, optionalITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILUstr, default ‘smilu_2’ITERATIVE ONLY. Selects the incomplete LU decomposition method algoithm; used in creating the preconditoner. Should only be used by advanced; users. Returns. dmqobjSteady state density matrix. infodict, optionalDictionary containing solver-specific information about the solution. Notes; The SVD method works only for dense operators (i.e. small systems). Propagators¶. propagator(H, t, c_op_list=[], args={}, options=None, unitary_mode='batch', parallel=False, progress_bar=None, _safe_mode=True, **kwargs)[source]¶; Calculate the propagator U(t) for the density matrix or wave function such; that \(\psi(t) = U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:151745,Energy Efficiency,energy,energy,151745,"cks(rho)[source]¶; Create the list of blocks for block-diagonal density matrix in the Dicke basis. Parameters. rhoqutip.QobjA 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns. square_blocks: list of np.arrayGive back the blocks list. dicke_blocks_full(rho)[source]¶; Give the full (2^N-dimensional) list of blocks for a Dicke-basis matrix. Parameters. rhoqutip.QobjA 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns. full_blockslistThe list of blocks expanded in the 2^N space for N qubits. dicke_function_trace(f, rho)[source]¶; Calculate the trace of a function on a Dicke density matrix.; :param f: A Taylor-expandable function of rho.; :type f: function; :param rho: A density matrix in the Dicke basis.; :type rho: qutip.Qobj. Returns. resfloatTrace of a nonlinear function on rho. energy_degeneracy(N, m)[source]¶; Calculate the number of Dicke states with same energy.; The use of the Decimals class allows to explore N > 1000,; unlike the built-in function scipy.special.binom. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns. degeneracy: intThe energy degeneracy. entropy_vn_dicke(rho)[source]¶; Von Neumann Entropy of a Dicke-basis density matrix. Parameters. rhoqutip.QobjA 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns. entropy_dm: floatEntropy. Use degeneracy to multiply each block. excited(N, basis='dicke')[source]¶; Generate the density matrix for the excited state.; This state is given by (N/2, N/2) in the default Dicke basis. If the; argument basis is “uncoupled” then it generates the state in a; 2**N dim Hilbert space. Parameters. N: intThe number of two-level systems. basis: strThe basis to use. Either “dicke” or ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:151998,Energy Efficiency,energy,energy,151998,"list of np.arrayGive back the blocks list. dicke_blocks_full(rho)[source]¶; Give the full (2^N-dimensional) list of blocks for a Dicke-basis matrix. Parameters. rhoqutip.QobjA 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns. full_blockslistThe list of blocks expanded in the 2^N space for N qubits. dicke_function_trace(f, rho)[source]¶; Calculate the trace of a function on a Dicke density matrix.; :param f: A Taylor-expandable function of rho.; :type f: function; :param rho: A density matrix in the Dicke basis.; :type rho: qutip.Qobj. Returns. resfloatTrace of a nonlinear function on rho. energy_degeneracy(N, m)[source]¶; Calculate the number of Dicke states with same energy.; The use of the Decimals class allows to explore N > 1000,; unlike the built-in function scipy.special.binom. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns. degeneracy: intThe energy degeneracy. entropy_vn_dicke(rho)[source]¶; Von Neumann Entropy of a Dicke-basis density matrix. Parameters. rhoqutip.QobjA 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns. entropy_dm: floatEntropy. Use degeneracy to multiply each block. excited(N, basis='dicke')[source]¶; Generate the density matrix for the excited state.; This state is given by (N/2, N/2) in the default Dicke basis. If the; argument basis is “uncoupled” then it generates the state in a; 2**N dim Hilbert space. Parameters. N: intThe number of two-level systems. basis: strThe basis to use. Either “dicke” or “uncoupled”. Returns. state: :class: qutip.QobjThe excited state density matrix in the requested basis. ghz(N, basis='dicke')[source]¶; Generate the density matrix of the GHZ state.; If the argument basis is “uncoupled” then it generates the state; in a \(2^N\)-dimensional Hi",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:152034,Energy Efficiency,energy,energy,152034,"locks_full(rho)[source]¶; Give the full (2^N-dimensional) list of blocks for a Dicke-basis matrix. Parameters. rhoqutip.QobjA 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns. full_blockslistThe list of blocks expanded in the 2^N space for N qubits. dicke_function_trace(f, rho)[source]¶; Calculate the trace of a function on a Dicke density matrix.; :param f: A Taylor-expandable function of rho.; :type f: function; :param rho: A density matrix in the Dicke basis.; :type rho: qutip.Qobj. Returns. resfloatTrace of a nonlinear function on rho. energy_degeneracy(N, m)[source]¶; Calculate the number of Dicke states with same energy.; The use of the Decimals class allows to explore N > 1000,; unlike the built-in function scipy.special.binom. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns. degeneracy: intThe energy degeneracy. entropy_vn_dicke(rho)[source]¶; Von Neumann Entropy of a Dicke-basis density matrix. Parameters. rhoqutip.QobjA 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns. entropy_dm: floatEntropy. Use degeneracy to multiply each block. excited(N, basis='dicke')[source]¶; Generate the density matrix for the excited state.; This state is given by (N/2, N/2) in the default Dicke basis. If the; argument basis is “uncoupled” then it generates the state in a; 2**N dim Hilbert space. Parameters. N: intThe number of two-level systems. basis: strThe basis to use. Either “dicke” or “uncoupled”. Returns. state: :class: qutip.QobjThe excited state density matrix in the requested basis. ghz(N, basis='dicke')[source]¶; Generate the density matrix of the GHZ state.; If the argument basis is “uncoupled” then it generates the state; in a \(2^N\)-dimensional Hilbert space. Parameters. N: intThe number of two-",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:154877,Energy Efficiency,energy,energy,154877,"of two-level systems. Returns. identity: :class: qutip.QobjThe identity matrix. isdiagonal(mat)[source]¶; Check if the input matrix is diagonal. Parameters. mat: ndarray/QobjA 2D numpy array. Returns. diag: boolTrue/False depending on whether the input matrix is diagonal. jspin(N, op=None, basis='dicke')[source]¶; Calculate the list of collective operators of the total algebra.; The Dicke basis \(\lvert j,m\rangle\langle j,m'\rvert\) is used by; default. Otherwise with “uncoupled” the operators are in a; \(2^N\) space. Parameters. N: intNumber of two-level systems. op: strThe operator to return ‘x’,’y’,’z’,’+’,’-‘.; If no operator given, then output is the list of operators; for [‘x’,’y’,’z’]. basis: strThe basis of the operators - “dicke” or “uncoupled”; default: “dicke”. Returns. j_alg: list or :class: qutip.QobjA list of qutip.Qobj representing all the operators in; the “dicke” or “uncoupled” basis or a single operator requested. m_degeneracy(N, m)[source]¶; Calculate the number of Dicke states \(\lvert j, m\rangle\) with; same energy. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue (proportional to the total; energy). Returns. degeneracy: intThe m-degeneracy. num_dicke_ladders(N)[source]¶; Calculate the total number of ladders in the Dicke space.; For a collection of N two-level systems it counts how many different; “j” exist or the number of blocks in the block-diagonal matrix. Parameters. N: intThe number of two-level systems. Returns. Nj: intThe number of Dicke ladders. num_dicke_states(N)[source]¶; Calculate the number of Dicke states. Parameters. N: intThe number of two-level systems. Returns. nds: intThe number of Dicke states. num_tls(nds)[source]¶; Calculate the number of two-level systems. Parameters. nds: intThe number of Dicke states. Returns. N: intThe number of two-level systems. purity_dicke(rho)[source]¶; Calculate purity of a density matrix in the Dicke basis.; It accounts for the degenerate bloc",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:155012,Energy Efficiency,energy,energy,155012,"rameters. mat: ndarray/QobjA 2D numpy array. Returns. diag: boolTrue/False depending on whether the input matrix is diagonal. jspin(N, op=None, basis='dicke')[source]¶; Calculate the list of collective operators of the total algebra.; The Dicke basis \(\lvert j,m\rangle\langle j,m'\rvert\) is used by; default. Otherwise with “uncoupled” the operators are in a; \(2^N\) space. Parameters. N: intNumber of two-level systems. op: strThe operator to return ‘x’,’y’,’z’,’+’,’-‘.; If no operator given, then output is the list of operators; for [‘x’,’y’,’z’]. basis: strThe basis of the operators - “dicke” or “uncoupled”; default: “dicke”. Returns. j_alg: list or :class: qutip.QobjA list of qutip.Qobj representing all the operators in; the “dicke” or “uncoupled” basis or a single operator requested. m_degeneracy(N, m)[source]¶; Calculate the number of Dicke states \(\lvert j, m\rangle\) with; same energy. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue (proportional to the total; energy). Returns. degeneracy: intThe m-degeneracy. num_dicke_ladders(N)[source]¶; Calculate the total number of ladders in the Dicke space.; For a collection of N two-level systems it counts how many different; “j” exist or the number of blocks in the block-diagonal matrix. Parameters. N: intThe number of two-level systems. Returns. Nj: intThe number of Dicke ladders. num_dicke_states(N)[source]¶; Calculate the number of Dicke states. Parameters. N: intThe number of two-level systems. Returns. nds: intThe number of Dicke states. num_tls(nds)[source]¶; Calculate the number of two-level systems. Parameters. nds: intThe number of Dicke states. Returns. N: intThe number of two-level systems. purity_dicke(rho)[source]¶; Calculate purity of a density matrix in the Dicke basis.; It accounts for the degenerate blocks in the density matrix. Parameters. rhoqutip.QobjDensity matrix in the Dicke basis of qutip.piqs.jspin(N), for N spins. Returns. purityfloatThe pu",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:161116,Energy Efficiency,efficient,efficient,161116,"ix. This cannot have tensor-product; structure. xvec, yvecarray_likex- and y-coordinates at which to calculate the Husimi-Q function. gfloat, default sqrt(2)Scaling factor for a = 0.5 * g * (x + iy). The value of g is; related to the value of \(\hbar\) in the commutation relation; \([x,\,y] = i\hbar\) via \(\hbar=2/g^2\), so the default; corresponds to \(\hbar=1\). precompute_memoryreal, default 1024Size in MB that may be used during calculations as working space when; dealing with density-matrix inputs. This is ignored for state-vector; inputs. The bound is not quite exact due to other, order-of-magnitude; smaller, intermediaries being necessary, but is a good approximation.; If you want to use the same iterative algorithm for density matrices; that is used for single kets, set precompute_memory=None. Returns. ndarrayValues representing the Husimi-Q function calculated over the specified; range [xvec, yvec]. See also. QFunca class-based version, more efficient if you want to calculate the Husimi-Q function for several states over the same coordinates. spin_q_function(rho, theta, phi)[source]¶; The Husimi Q function for spins is defined as Q(theta, phi) =; SCS.dag() * rho * SCS for the spin coherent state SCS = spin_coherent(; j, theta, phi) where j is the spin length.; The implementation here is more efficient as it doesn’t; generate all of the SCS at theta and phi (see references).; The spin Q function is normal when integrated over the surface of the; sphere. \[\frac{4 \pi}{2j + 1}\int_\phi \int_\theta; Q(\theta, \phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at which to calculate the Husimi-Q function. phiarray_likeAzimuthal angle at which to calculate the Husimi-Q function. Returns. Q, THETA, PHI2d-arrayValues representing the spin Husimi Q function at the values specified; by THETA and PHI. References; [1] Lee Loh, Y., & Kim, M. (2015). American ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:161473,Energy Efficiency,efficient,efficient,161473,"onds to \(\hbar=1\). precompute_memoryreal, default 1024Size in MB that may be used during calculations as working space when; dealing with density-matrix inputs. This is ignored for state-vector; inputs. The bound is not quite exact due to other, order-of-magnitude; smaller, intermediaries being necessary, but is a good approximation.; If you want to use the same iterative algorithm for density matrices; that is used for single kets, set precompute_memory=None. Returns. ndarrayValues representing the Husimi-Q function calculated over the specified; range [xvec, yvec]. See also. QFunca class-based version, more efficient if you want to calculate the Husimi-Q function for several states over the same coordinates. spin_q_function(rho, theta, phi)[source]¶; The Husimi Q function for spins is defined as Q(theta, phi) =; SCS.dag() * rho * SCS for the spin coherent state SCS = spin_coherent(; j, theta, phi) where j is the spin length.; The implementation here is more efficient as it doesn’t; generate all of the SCS at theta and phi (see references).; The spin Q function is normal when integrated over the surface of the; sphere. \[\frac{4 \pi}{2j + 1}\int_\phi \int_\theta; Q(\theta, \phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at which to calculate the Husimi-Q function. phiarray_likeAzimuthal angle at which to calculate the Husimi-Q function. Returns. Q, THETA, PHI2d-arrayValues representing the spin Husimi Q function at the values specified; by THETA and PHI. References; [1] Lee Loh, Y., & Kim, M. (2015). American J. of Phys., 83(1), 30–35.; https://doi.org/10.1119/1.4898595. spin_wigner(rho, theta, phi)[source]¶; Wigner function for a spin-j system.; The spin W function is normal when integrated over the surface of the; sphere. \[\sqrt{\frac{4 \pi}{2j + 1}}\int_\phi \int_\theta; W(\theta,\phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:164327,Energy Efficiency,efficient,efficient,164327,"urce]¶; Wigner function for a state vector or density matrix at points; xvec + i * yvec. Parameters. stateqobjA state vector or density matrix. xvecarray_likex-coordinates at which to calculate the Wigner function. yvecarray_likey-coordinates at which to calculate the Wigner function. Does not; apply to the ‘fft’ method. gfloatScaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2).; The value of g is related to the value of hbar in the commutation; relation [x, y] = i * hbar via hbar=2/g^2 giving the default; value hbar=1. methodstring {‘clenshaw’, ‘iterative’, ‘laguerre’, ‘fft’}Select method ‘clenshaw’ ‘iterative’, ‘laguerre’, or ‘fft’, where ‘clenshaw’; and ‘iterative’ use an iterative method to evaluate the Wigner functions for density; matrices \(|m><n|\), while ‘laguerre’ uses the Laguerre polynomials; in scipy for the same task. The ‘fft’ method evaluates the Fourier; transform of the density matrix. The ‘iterative’ method is default, and; in general recommended, but the ‘laguerre’ method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The ‘clenshaw’ method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). ‘clenshaw’ is a fast and numerically stable method. sparsebool {False, True}Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance. parforbool {False, True}Flag for calculating the Laguerre polynomial based Wigner function; method=’laguerre’ in parallel using the parfor function. Returns. WarrayValues representing the Wigner function calculated over the specified; range [xvec,yvec]. yvexarrayFFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; The ‘fft’ method accepts only an xvec input for the x-coordinate.; The y-coordinates are calculated internally.; ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:168156,Energy Efficiency,energy,energy,168156,"ax=None, threshold=None)[source]¶; Draw a histogram for the amplitudes of matrix M, using the argument; of each element for coloring the bars, with the given x and y labels; and title. Parameters. MMatrix of QobjThe matrix to visualize. xlabelslist of stringslist of x labels. ylabelslist of stringslist of y labels. titlestringtitle of the plot (optional). limitslist/array with two float numbersThe z-axis limits [min, max] (optional). phase_limitslist/array with two float numbersThe phase-axis (colorbar) limits [min, max] (optional). axa matplotlib axes instanceThe axes context in which the plot will be drawn. threshold: float (None)Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters. H_listList of Qobj; A list of Hamiltonians. labelsList of stringA list of labels for each Hamiltonian. show_ylabelsBool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. NintThe number of energy levels to plot. figsizetuple (int,int)The size of the figure (width, height). figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_expectation_values(results, ylabels=[], title=None, show_legend=False, fig=None, ax",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:168223,Energy Efficiency,energy,energy,168223,"t; of each element for coloring the bars, with the given x and y labels; and title. Parameters. MMatrix of QobjThe matrix to visualize. xlabelslist of stringslist of x labels. ylabelslist of stringslist of y labels. titlestringtitle of the plot (optional). limitslist/array with two float numbersThe z-axis limits [min, max] (optional). phase_limitslist/array with two float numbersThe phase-axis (colorbar) limits [min, max] (optional). axa matplotlib axes instanceThe axes context in which the plot will be drawn. threshold: float (None)Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters. H_listList of Qobj; A list of Hamiltonians. labelsList of stringA list of labels for each Hamiltonian. show_ylabelsBool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. NintThe number of energy levels to plot. figsizetuple (int,int)The size of the figure (width, height). figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_expectation_values(results, ylabels=[], title=None, show_legend=False, fig=None, axes=None, figsize=(8, 4))[source]¶; Visualize the results (expectation values) for an evolution solver",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:168270,Energy Efficiency,energy,energy,168270,"Matrix of QobjThe matrix to visualize. xlabelslist of stringslist of x labels. ylabelslist of stringslist of y labels. titlestringtitle of the plot (optional). limitslist/array with two float numbersThe z-axis limits [min, max] (optional). phase_limitslist/array with two float numbersThe phase-axis (colorbar) limits [min, max] (optional). axa matplotlib axes instanceThe axes context in which the plot will be drawn. threshold: float (None)Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters. H_listList of Qobj; A list of Hamiltonians. labelsList of stringA list of labels for each Hamiltonian. show_ylabelsBool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. NintThe number of energy levels to plot. figsizetuple (int,int)The size of the figure (width, height). figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_expectation_values(results, ylabels=[], title=None, show_legend=False, fig=None, axes=None, figsize=(8, 4))[source]¶; Visualize the results (expectation values) for an evolution solver.; results is assumed to be an instance of Result, or a list of Result; instances. Parameters. res",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:168577,Energy Efficiency,energy,energy,168577,"itslist/array with two float numbersThe phase-axis (colorbar) limits [min, max] (optional). axa matplotlib axes instanceThe axes context in which the plot will be drawn. threshold: float (None)Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters. H_listList of Qobj; A list of Hamiltonians. labelsList of stringA list of labels for each Hamiltonian. show_ylabelsBool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. NintThe number of energy levels to plot. figsizetuple (int,int)The size of the figure (width, height). figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_expectation_values(results, ylabels=[], title=None, show_legend=False, fig=None, axes=None, figsize=(8, 4))[source]¶; Visualize the results (expectation values) for an evolution solver.; results is assumed to be an instance of Result, or a list of Result; instances. Parameters. results(list of) qutip.solver.ResultList of results objects returned by any of the QuTiP evolution solvers. ylabelslist of stringsThe y-axis labels. List should be of the same length as results. titlestringThe title of the figure. show_legendboolWheth",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:168638,Energy Efficiency,energy,energy,168638,"n, max] (optional). axa matplotlib axes instanceThe axes context in which the plot will be drawn. threshold: float (None)Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters. H_listList of Qobj; A list of Hamiltonians. labelsList of stringA list of labels for each Hamiltonian. show_ylabelsBool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. NintThe number of energy levels to plot. figsizetuple (int,int)The size of the figure (width, height). figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_expectation_values(results, ylabels=[], title=None, show_legend=False, fig=None, axes=None, figsize=(8, 4))[source]¶; Visualize the results (expectation values) for an evolution solver.; results is assumed to be an instance of Result, or a list of Result; instances. Parameters. results(list of) qutip.solver.ResultList of results objects returned by any of the QuTiP evolution solvers. ylabelslist of stringsThe y-axis labels. List should be of the same length as results. titlestringThe title of the figure. show_legendboolWhether or not to show the legend. figa matplotlib Figure instanceThe Figure c",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:198963,Energy Efficiency,reduce,reduces,198963,"tion in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:246964,Energy Efficiency,energy,energy,246964,"ith maximum; weight. Unlike other techniques[1]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method.; References; I. S. Duff and J. Koster, “The design and use of algorithms for permuting; large entries to the diagonal of sparse matrices”, SIAM J. Matrix Anal.; and Applics. 20, no. 4, 889 (1997). Utility Functions¶; This module contains utility functions that are commonly needed in other; qutip modules. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters. j1floatTotal angular momentum 1. j2floatTotal angular momentum 2. j3floatTotal angular momentum 3. m1floatz-component of angular momentum 1. m2floatz-component of angular momentum 2. m3floatz-component of angular momentum 3. Returns. cg_coefffloatRequested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters. valuefloat / arrayThe energy in the old unit. origstringThe name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). tostringThe name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns. value_new_unitfloat / arrayThe energy in the new unit. n_thermal(w, w_th)[source]¶; Return the number of photons in thermal equilibrium for an harmonic; oscillator mode with frequency ‘w’, at the temperature described by; ‘w_th’ where \(\omega_{\rm th} = k_BT/\hbar\). Parameters. wfloat or arrayFrequency of the oscillator. w_thfloatThe temperature in units of frequency (or the same units as w). Returns. n_avgfloat or arrayReturn the number of average photons in thermal equilibrium for a; an oscillator with the given frequency and temperature. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters. filenamestrName of file containing reqested data. sepstrSeperator ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:247032,Energy Efficiency,energy,energy,247032,"the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method.; References; I. S. Duff and J. Koster, “The design and use of algorithms for permuting; large entries to the diagonal of sparse matrices”, SIAM J. Matrix Anal.; and Applics. 20, no. 4, 889 (1997). Utility Functions¶; This module contains utility functions that are commonly needed in other; qutip modules. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters. j1floatTotal angular momentum 1. j2floatTotal angular momentum 2. j3floatTotal angular momentum 3. m1floatz-component of angular momentum 1. m2floatz-component of angular momentum 2. m3floatz-component of angular momentum 3. Returns. cg_coefffloatRequested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters. valuefloat / arrayThe energy in the old unit. origstringThe name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). tostringThe name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns. value_new_unitfloat / arrayThe energy in the new unit. n_thermal(w, w_th)[source]¶; Return the number of photons in thermal equilibrium for an harmonic; oscillator mode with frequency ‘w’, at the temperature described by; ‘w_th’ where \(\omega_{\rm th} = k_BT/\hbar\). Parameters. wfloat or arrayFrequency of the oscillator. w_thfloatThe temperature in units of frequency (or the same units as w). Returns. n_avgfloat or arrayReturn the number of average photons in thermal equilibrium for a; an oscillator with the given frequency and temperature. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters. filenamestrName of file containing reqested data. sepstrSeperator used to store data. Returns. dataarray_likeData from selected file. file_data_store",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:247235,Energy Efficiency,energy,energy,247235,"ithms for permuting; large entries to the diagonal of sparse matrices”, SIAM J. Matrix Anal.; and Applics. 20, no. 4, 889 (1997). Utility Functions¶; This module contains utility functions that are commonly needed in other; qutip modules. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters. j1floatTotal angular momentum 1. j2floatTotal angular momentum 2. j3floatTotal angular momentum 3. m1floatz-component of angular momentum 1. m2floatz-component of angular momentum 2. m3floatz-component of angular momentum 3. Returns. cg_coefffloatRequested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters. valuefloat / arrayThe energy in the old unit. origstringThe name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). tostringThe name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns. value_new_unitfloat / arrayThe energy in the new unit. n_thermal(w, w_th)[source]¶; Return the number of photons in thermal equilibrium for an harmonic; oscillator mode with frequency ‘w’, at the temperature described by; ‘w_th’ where \(\omega_{\rm th} = k_BT/\hbar\). Parameters. wfloat or arrayFrequency of the oscillator. w_thfloatThe temperature in units of frequency (or the same units as w). Returns. n_avgfloat or arrayReturn the number of average photons in thermal equilibrium for a; an oscillator with the given frequency and temperature. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters. filenamestrName of file containing reqested data. sepstrSeperator used to store data. Returns. dataarray_likeData from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=',')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters. filenamestrName of data file to be stored,",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:253094,Energy Efficiency,schedul,scheduling,253094,"ask_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. values: array / listThe list or array of values for which the task function is to be; evaluated. task_args: list / dictionaryThe optional additional argument to the task function. task_kwargs: list / dictionaryThe optional additional keyword argument to the task function. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar during the execution of the parfor; loop. Returns. resultlistThe result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced v",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:253439,Energy Efficiency,schedul,scheduled,253439,"t and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. values: array / listThe list or array of values for which the task function is to be; evaluated. task_args: list / dictionaryThe optional additional argument to the task function. task_kwargs: list / dictionaryThe optional additional keyword argument to the task function. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar during the execution of the parfor; loop. Returns. resultlistThe result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evalua",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:254696,Energy Efficiency,schedul,scheduling,254696,"rgs) for each; value in values. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evaluated. args: list / dictionaryThe optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:255041,Energy Efficiency,schedul,scheduled,255041,", args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evaluated. args: list / dictionaryThe optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib. simdiag(ops, evals: bool = True, *",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:937,Integrability,depend,dependent,937,". Functions — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Classes; Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Quantum Objects; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations; Operators and Superoperator Dimensions. Functions acting on states and operators; Expectation Values; Tensor; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continuous Variables. Measurement; Measurement of quantum states. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems; Scattering in Quantum Optical Systems; Permutational Invariance. Lattice; Lattice Properties; Topology. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms; Circuit. Non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utility Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; Semidefinite Programming; IPython Notebook Tools; Miscellaneous. Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; API documentation »; Functions. Functions¶. Manipulation and Creation of States and Operators¶. Quantum States¶. basis(dimensions, n=None, offset=None)[source]¶; Generates the vector representation of a Fock state. Parameters. dimensionsint or list of intsNumber of Fock states in Hilbert space. If a list, then the resultant; object will be a tensor product over spaces with those dimensions. nint or list of ints, optional (default 0 for all dimensions)I",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:24976,Integrability,depend,depending,24976,"ntity(dims, excitations)[source]¶; Generate the identity operator for the excitation-number restricted; state space defined by the dims and exciations arguments. See the; docstring for enr_fock for a more detailed description of these arguments. Parameters. dimslistA list of the dimensions of each subsystem of a composite quantum; system. excitationsintegerThe maximum number of excitations that are to be included in the; state space. statelist of integersThe state in the number basis representation. Returns. opQobjA Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by dims and; exciations. identity(dims)[source]¶; Identity operator. Alternative name to qeye. Parameters. dimensions(int) or (list of int) or (list of list of int)Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the dims property of; the new Qobj are set to this list. This can produce either oper or; super depending on the passed dimensions. Returns. operqobjIdentity operator Qobj. jmat(j, *args)[source]¶; Higher-order spin operators:. Parameters. jfloatSpin of operator. argsstrWhich operator to return ‘x’,’y’,’z’,’+’,’-‘.; If no args given, then output is [‘x’,’y’,’z’]. Returns. jmatqobj / ndarrayqobj for requested spin operator(s). Notes; If no ‘args’ input, then returns array of [‘x’,’y’,’z’] operators.; Examples; >>> jmat(1) ; [ Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0. 0.70710678 0. ]; [ 0.70710678 0. 0.70710678]; [ 0. 0.70710678 0. ]]; Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.-0.70710678j 0.+0.j ]; [ 0.+0.70710678j 0.+0.j 0.-0.70710678j]; [ 0.+0.j 0.+0.70710678j 0.+0.j ]]; Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 1. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. -1.]]]. momentum(N, offset=0)[source]¶; Momentum operator p=-1j/sq",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:28405,Integrability,depend,depending,28405,"_likeArray of elements to place along the selected diagonals. offsetssequence of ints; Sequence for diagonals to be set:; k=0 main diagonal; k>0 kth upper diagonal; k<0 kth lower diagonal. dimslist, optionalDimensions for operator. shapelist, tuple, optionalShape of operator. If omitted, a square operator large enough; to contain the diagonals is generated. See also. scipy.sparse.diagsfor usage information. Notes; This function requires SciPy 0.11+.; Examples; >>> qdiags(sqrt(range(1, 4)), 1) ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 0. 1. 0. 0. ]; [ 0. 0. 1.41421356 0. ]; [ 0. 0. 0. 1.73205081]; [ 0. 0. 0. 0. ]]. qeye(dimensions)[source]¶; Identity operator. Parameters. dimensions(int) or (list of int) or (list of list of int)Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the dims property of; the new Qobj are set to this list. This can produce either oper or; super depending on the passed dimensions. Returns. operqobjIdentity operator Qobj. Examples; >>> qeye(3) ; Quantum object: dims = [[3], [3]], shape = (3, 3), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0.]; [ 0. 1. 0.]; [ 0. 0. 1.]]; >>> qeye([2,2]) ; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[1. 0. 0. 0.]; [0. 1. 0. 0.]; [0. 0. 1. 0.]; [0. 0. 0. 1.]]. qutrit_ops()[source]¶; Operators for a three level system (qutrit). Returns. opers: arrayarray of qutrit operators. qzero(dimensions)[source]¶; Zero operator. Parameters. dimensions(int) or (list of int) or (list of list of int)Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the dims property of; the new Qobj are set to this list. This can produce either oper or; super depending on the passed dimensions. Returns. qzeroqobjZero operator Qobj. sigmam()[source]¶; Annihilation operator for Pauli spins.; Examples; >>> s",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:29255,Integrability,depend,depending,29255,", then the; dimension is the product over this list, but the dims property of; the new Qobj are set to this list. This can produce either oper or; super depending on the passed dimensions. Returns. operqobjIdentity operator Qobj. Examples; >>> qeye(3) ; Quantum object: dims = [[3], [3]], shape = (3, 3), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0.]; [ 0. 1. 0.]; [ 0. 0. 1.]]; >>> qeye([2,2]) ; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[1. 0. 0. 0.]; [0. 1. 0. 0.]; [0. 0. 1. 0.]; [0. 0. 0. 1.]]. qutrit_ops()[source]¶; Operators for a three level system (qutrit). Returns. opers: arrayarray of qutrit operators. qzero(dimensions)[source]¶; Zero operator. Parameters. dimensions(int) or (list of int) or (list of list of int)Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the dims property of; the new Qobj are set to this list. This can produce either oper or; super depending on the passed dimensions. Returns. qzeroqobjZero operator Qobj. sigmam()[source]¶; Annihilation operator for Pauli spins.; Examples; >>> sigmam() ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False; Qobj data =; [[ 0. 0.]; [ 1. 0.]]. sigmap()[source]¶; Creation operator for Pauli spins.; Examples; >>> sigmap() ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False; Qobj data =; [[ 0. 1.]; [ 0. 0.]]. sigmax()[source]¶; Pauli spin 1/2 sigma-x operator; Examples; >>> sigmax() ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False; Qobj data =; [[ 0. 1.]; [ 1. 0.]]. sigmay()[source]¶; Pauli spin 1/2 sigma-y operator.; Examples; >>> sigmay() ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.-1.j]; [ 0.+1.j 0.+0.j]]. sigmaz()[source]¶; Pauli spin 1/2 sigma-z operator.; Examples; >>> sigmaz() ; Quantum object: dims = [[2], [2]], shape = [2, 2], t",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:58003,Integrability,contract,contracted,58003,"ce]¶; Calculates the tensor product of input superoperators, by tensoring; together the underlying Hilbert spaces on which each vectorized operator; acts. Parameters. argsarray_likelist or array of quantum objects with type=""super"". Returns. objqobjA composite quantum object. tensor(*args)[source]¶; Calculates the tensor product of input operators. Parameters. argsarray_likelist or array of quantum objects for tensor product. Returns. objqobjA composite quantum object. Examples; >>> tensor([sigmax(), sigmax()]) ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transp",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:58078,Integrability,contract,contracted,58078,"t spaces on which each vectorized operator; acts. Parameters. argsarray_likelist or array of quantum objects with type=""super"". Returns. objqobjA composite quantum object. tensor(*args)[source]¶; Calculates the tensor product of input operators. Parameters. argsarray_likelist or array of quantum objects for tensor product. Returns. objqobjA composite quantum object. Examples; >>> tensor([sigmax(), sigmax()]) ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:74821,Integrability,integrat,integrating,74821,"slist of ints, optionalSpecifies a list of targets “qubit” indices on which to apply the; measurement using qutip.qip.gates.expand_operator to expand op; into full dimension. Returns. eigenvalues: list of floatThe list of eigenvalues of the measurement operator. eigenstates_or_projectors: list of QobjIf the state was a ket, return the eigenstates of the measurement; operator. Otherwise return the projectors onto the eigenstates. probabilities: list of floatThe probability of measuring the state as being in the corresponding; eigenstate (and the measurement result being the corresponding; eigenvalue). Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, psi0, tlist, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian.; Evolve the state vector (psi0) using a given Hamiltonian (H), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation.; The output is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters. HQobj, QobjEvo, list, or callableSystem Hamiltonian as a Qobj , list of :obj:`Qobj and; coefficient, QObjEvo, or a callback function for time-dependent; Hamiltonians. List format and options can be found in QobjEvo’s; description. psi0QobjInitial state vector (ket) or initial unitary operator psi0 = U. tlistarray_like of floatList of times for \(t\). e_opslist of Qobj or callback function, optionalSingle operator or list of ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:75541,Integrability,depend,dependent,75541,"ion¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, psi0, tlist, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian.; Evolve the state vector (psi0) using a given Hamiltonian (H), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation.; The output is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters. HQobj, QobjEvo, list, or callableSystem Hamiltonian as a Qobj , list of :obj:`Qobj and; coefficient, QObjEvo, or a callback function for time-dependent; Hamiltonians. List format and options can be found in QobjEvo’s; description. psi0QobjInitial state vector (ket) or initial unitary operator psi0 = U. tlistarray_like of floatList of times for \(t\). e_opslist of Qobj or callback function, optionalSingle operator or list of operators for which to evaluate expectation; values. For operator evolution, the overlap is computed:; (e_ops[i].dag() * op(t)).tr(). argsdict, optionalDictionary of scope parameters for time-dependent Hamiltonians. optionsOptions, optionalOptions for the ODE solver. progress_barBaseProgressBar, optionalOptional instance of BaseProgressBar, or a subclass thereof,; for showing the progress of the simulation. Returns. output: ResultAn instance of the class Result, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors corresponding to the times in tlist (if; e_ops is an empty list), or n",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:76019,Integrability,depend,dependent,76019,"either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters. HQobj, QobjEvo, list, or callableSystem Hamiltonian as a Qobj , list of :obj:`Qobj and; coefficient, QObjEvo, or a callback function for time-dependent; Hamiltonians. List format and options can be found in QobjEvo’s; description. psi0QobjInitial state vector (ket) or initial unitary operator psi0 = U. tlistarray_like of floatList of times for \(t\). e_opslist of Qobj or callback function, optionalSingle operator or list of operators for which to evaluate expectation; values. For operator evolution, the overlap is computed:; (e_ops[i].dag() * op(t)).tr(). argsdict, optionalDictionary of scope parameters for time-dependent Hamiltonians. optionsOptions, optionalOptions for the ODE solver. progress_barBaseProgressBar, optionalOptional instance of BaseProgressBar, or a subclass thereof,; for showing the progress of the simulation. Returns. output: ResultAn instance of the class Result, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors corresponding to the times in tlist (if; e_ops is an empty list), or nothing if a callback function was; given inplace of operators for which to calculate the expectation; values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:77089,Integrability,integrat,integrating,77089,"tions, optionalOptions for the ODE solver. progress_barBaseProgressBar, optionalOptional instance of BaseProgressBar, or a subclass thereof,; for showing the progress of the simulation. Returns. output: ResultAn instance of the class Result, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors corresponding to the times in tlist (if; e_ops is an empty list), or nothing if a callback function was; given inplace of operators for which to calculate the expectation; values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian or Liouvillian (H) and an optional set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form.; Time-dependent operators; For time-dependent problems, H and c_ops can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (qutip.qobj) at the first element and where; the sec",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:77817,Integrability,depend,dependent,77817,"operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian or Liouvillian (H) and an optional set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form.; Time-dependent operators; For time-dependent problems, H and c_ops can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (qutip.qobj) at the first element and where; the second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Alternatively, H (but not c_ops) can be a callback function with the; signature f(t, args) -> Qobj (callback format), which can return the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list s",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:77847,Integrability,depend,dependent,77847,"operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian or Liouvillian (H) and an optional set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form.; Time-dependent operators; For time-dependent problems, H and c_ops can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (qutip.qobj) at the first element and where; the second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Alternatively, H (but not c_ops) can be a callback function with the; signature f(t, args) -> Qobj (callback format), which can return the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list s",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:78177,Integrability,depend,dependent,78177,"apse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form.; Time-dependent operators; For time-dependent problems, H and c_ops can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (qutip.qobj) at the first element and where; the second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Alternatively, H (but not c_ops) can be a callback function with the; signature f(t, args) -> Qobj (callback format), which can return the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluatin",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:78653,Integrability,depend,dependence,78653,"eroperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form.; Time-dependent operators; For time-dependent problems, H and c_ops can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (qutip.qobj) at the first element and where; the second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Alternatively, H (but not c_ops) can be a callback function with the; signature f(t, args) -> Qobj (callback format), which can return the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an elemen",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:79108,Integrability,depend,dependent,79108,"rmat) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Alternatively, H (but not c_ops) can be a callback function with the; signature f(t, args) -> Qobj (callback format), which can return the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:79423,Integrability,integrat,integration,79423,"the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:80062,Integrability,integrat,integrator,80062," (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opsNone / list of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opsNone / list of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. argsNone / dictionarydictionary of parameters for time-dependent Ha",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:80399,Integrability,integrat,integrator,80399,"solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opsNone / list of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opsNone / list of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. argsNone / dictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators. optionsNone / qutip.Optionswith options for the solver. progress_barNone / BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns. result: qutip.ResultAn instance of the class qutip.Result, which contains; either an array result.expect of expectatio",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:80540,Integrability,depend,dependent,80540," even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opsNone / list of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opsNone / list of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. argsNone / dictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators. optionsNone / qutip.Optionswith options for the solver. progress_barNone / BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns. result: qutip.ResultAn instance of the class qutip.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the times in tlist [i",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:81027,Integrability,depend,dependent,81027,"rices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opsNone / list of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opsNone / list of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. argsNone / dictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators. optionsNone / qutip.Optionswith options for the solver. progress_barNone / BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns. result: qutip.ResultAn instance of the class qutip.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0, args={}, options=None, progress_bar=True, map_func=<function parallel_map>, map_kwargs={}, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; fo",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:82151,Integrability,depend,dependent,82151,"r a subclass thereof, for; showing the progress of the simulation. Returns. result: qutip.ResultAn instance of the class qutip.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0, args={}, options=None, progress_bar=True, map_func=<function parallel_map>, map_kwargs={}, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; opera",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:82257,Integrability,depend,dependent,82257,"r a subclass thereof, for; showing the progress of the simulation. Returns. result: qutip.ResultAn instance of the class qutip.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0, args={}, options=None, progress_bar=True, map_func=<function parallel_map>, map_kwargs={}, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; opera",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:82380,Integrability,depend,dependent,82380,"ate vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0, args={}, options=None, progress_bar=True, map_func=<function parallel_map>, map_kwargs={}, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters. Hqutip.Qobj, listSystem Hamiltonian. psi0qutip.QobjInitial state vector. tlistarray_likeTimes at which results are recorded. ntrajintNumber of trajectories to run. c_opsqutip.Qobj, listsingle collapse operator or a list of collapse operators. e_o",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:82466,Integrability,depend,dependent,82466,"ate vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0, args={}, options=None, progress_bar=True, map_func=<function parallel_map>, map_kwargs={}, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters. Hqutip.Qobj, listSystem Hamiltonian. psi0qutip.QobjInitial state vector. tlistarray_likeTimes at which results are recorded. ntrajintNumber of trajectories to run. c_opsqutip.Qobj, listsingle collapse operator or a list of collapse operators. e_o",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:82556,Integrability,depend,dependent,82556,"ate vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0, args={}, options=None, progress_bar=True, map_func=<function parallel_map>, map_kwargs={}, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters. Hqutip.Qobj, listSystem Hamiltonian. psi0qutip.QobjInitial state vector. tlistarray_likeTimes at which results are recorded. ntrajintNumber of trajectories to run. c_opsqutip.Qobj, listsingle collapse operator or a list of collapse operators. e_o",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:82684,Integrability,depend,dependent,82684," mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0, args={}, options=None, progress_bar=True, map_func=<function parallel_map>, map_kwargs={}, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters. Hqutip.Qobj, listSystem Hamiltonian. psi0qutip.QobjInitial state vector. tlistarray_likeTimes at which results are recorded. ntrajintNumber of trajectories to run. c_opsqutip.Qobj, listsingle collapse operator or a list of collapse operators. e_opsqutip.Qobj, listsingle operator as Qobj or list or equivalent of Qobj operators; for calculating expectation values. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver op",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:83619,Integrability,depend,dependent,83619," with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters. Hqutip.Qobj, listSystem Hamiltonian. psi0qutip.QobjInitial state vector. tlistarray_likeTimes at which results are recorded. ntrajintNumber of trajectories to run. c_opsqutip.Qobj, listsingle collapse operator or a list of collapse operators. e_opsqutip.Qobj, listsingle operator as Qobj or list or equivalent of Qobj operators; for calculating expectation values. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Set to None to disable the; progress bar. map_func: functionA map function for managing the calls to the single-trajactory solver. map_kwargs: dictionaryOptional keyword arguments to the map_func function. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. Note; It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds). Exponential Series¶. essolve(H, rho0, tlist, c_op_list, e_ops)[source]¶; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The output is either; the state vector at arbit",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:84840,Integrability,integrat,integration,84840,"lation. Set to None to disable the; progress bar. map_func: functionA map function for managing the calls to the single-trajactory solver. map_kwargs: dictionaryOptional keyword arguments to the map_func function. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. Note; It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds). Exponential Series¶. essolve(H, rho0, tlist, c_op_list, e_ops)[source]¶; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (tlist), or the; expectation values of the supplied operators (e_ops). Deprecated since version 4.6.0: essolev will be removed in QuTiP 5. Please use sesolve; or mesolve for general-purpose integration of the; Schroedinger/Lindblad master equation. This will likely be faster than; essolve for you. Parameters. Hqobj/function_typeSystem Hamiltonian. rho0qutip.qobjInitial state density matrix. tlistlist/arraylist of times for \(t\). c_op_listlist of qutip.qobjlist of qutip.qobj collapse operators. e_opslist of qutip.qobjlist of qutip.qobj operators for which to evaluate; expectation values. Returns. expt_arrayarrayExpectation values of wavefunctions/density matrices for the; times specified in tlist. Note; This solver does not support time-dependent Hamiltonians.; .. ode2es(L, rho0)[source]¶; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Deprecated since version 4.6.0: ode2es will be removed in QuTiP 5. Please use; Qobj.eigenstates to get the eigenstates and -values, and use; QobjEvo for general time-dependence. Parameters. LqobjLiouvillian of the system. rho0qob",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:85397,Integrability,depend,dependent,85397,"st, e_ops)[source]¶; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (tlist), or the; expectation values of the supplied operators (e_ops). Deprecated since version 4.6.0: essolev will be removed in QuTiP 5. Please use sesolve; or mesolve for general-purpose integration of the; Schroedinger/Lindblad master equation. This will likely be faster than; essolve for you. Parameters. Hqobj/function_typeSystem Hamiltonian. rho0qutip.qobjInitial state density matrix. tlistlist/arraylist of times for \(t\). c_op_listlist of qutip.qobjlist of qutip.qobj collapse operators. e_opslist of qutip.qobjlist of qutip.qobj operators for which to evaluate; expectation values. Returns. expt_arrayarrayExpectation values of wavefunctions/density matrices for the; times specified in tlist. Note; This solver does not support time-dependent Hamiltonians.; .. ode2es(L, rho0)[source]¶; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Deprecated since version 4.6.0: ode2es will be removed in QuTiP 5. Please use; Qobj.eigenstates to get the eigenstates and -values, and use; QobjEvo for general time-dependence. Parameters. LqobjLiouvillian of the system. rho0qobjInitial state vector or density matrix. Returns. eseriesqutip.eserieseseries represention of the system dynamics. Bloch-Redfield Master Equation¶. bloch_redfield_solve(R, ekets, rho0, tlist, e_ops=[], options=None, progress_bar=None)[source]¶; Evolve the ODEs defined by Bloch-Redfield master equation. The; Bloch-Redfield tensor can be calculated by the function; bloch_redfield_tensor. Parameters. Rqutip.qobjBloch-Redfield tensor. eketsarray of qutip.qobjArray of kets that make up a basis tranformation for the eigenbasis. rho0qutip.qobjIni",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:85780,Integrability,depend,dependence,85780,"n 4.6.0: essolev will be removed in QuTiP 5. Please use sesolve; or mesolve for general-purpose integration of the; Schroedinger/Lindblad master equation. This will likely be faster than; essolve for you. Parameters. Hqobj/function_typeSystem Hamiltonian. rho0qutip.qobjInitial state density matrix. tlistlist/arraylist of times for \(t\). c_op_listlist of qutip.qobjlist of qutip.qobj collapse operators. e_opslist of qutip.qobjlist of qutip.qobj operators for which to evaluate; expectation values. Returns. expt_arrayarrayExpectation values of wavefunctions/density matrices for the; times specified in tlist. Note; This solver does not support time-dependent Hamiltonians.; .. ode2es(L, rho0)[source]¶; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Deprecated since version 4.6.0: ode2es will be removed in QuTiP 5. Please use; Qobj.eigenstates to get the eigenstates and -values, and use; QobjEvo for general time-dependence. Parameters. LqobjLiouvillian of the system. rho0qobjInitial state vector or density matrix. Returns. eseriesqutip.eserieseseries represention of the system dynamics. Bloch-Redfield Master Equation¶. bloch_redfield_solve(R, ekets, rho0, tlist, e_ops=[], options=None, progress_bar=None)[source]¶; Evolve the ODEs defined by Bloch-Redfield master equation. The; Bloch-Redfield tensor can be calculated by the function; bloch_redfield_tensor. Parameters. Rqutip.qobjBloch-Redfield tensor. eketsarray of qutip.qobjArray of kets that make up a basis tranformation for the eigenbasis. rho0qutip.qobjInitial density matrix. tlistlist / arrayList of times for \(t\). e_opslist of qutip.qobj / callback functionList of operators for which to evaluate expectation values. optionsqutip.QdeoptionsOptions for the ODE solver. Returns. output: qutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times spec",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:88322,Integrability,depend,dependent,88322,"oat {qutip.settings.atol}Threshold for removing small parameters. Returns. R, kets: qutip.Qobj, list of qutip.QobjR is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:88455,Integrability,depend,dependent,88455,"oat {qutip.settings.atol}Threshold for removing small parameters. Returns. R, kets: qutip.Qobj, list of qutip.QobjR is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:88626,Integrability,depend,dependence,88626,"; Hamiltonian. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermi",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:88778,Integrability,depend,dependence,88778,"_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_opslistList of operators for which to evaluate expectation values. c_opsli",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:88991,Integrability,depend,dependence,88991,"functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_opslistList of operators for which to evaluate expectation values. c_opslistList of system collapse operators, or nested list in; string-based format. argsdictPlaceholder for future implementation, kept for API consistency. use_secularbool {True}Use secular approximation when e",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:89278,Integrability,depend,dependence,89278,"le.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_opslistList of operators for which to evaluate expectation values. c_opslistList of system collapse operators, or nested list in; string-based format. argsdictPlaceholder for future implementation, kept for API consistency. use_secularbool {True}Use secular approximation when evaluating bath-coupling terms. sec_cutofffloat {0.1}Cutoff for secular approximation. tolfloat {qutip.setttings.atol}Tolerance used for removing small values after; basis transformation. spectra_cblistDEPRECIATED. Do not use. optionsqutip.solver.OptionsOptions for the solver. progress_barBaseProg",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:91409,Integrability,depend,dependent,91409,"n instance of the class qutip.solver.Result, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by tlist. Floquet States and Floquet-Markov Master Equation¶. floquet_basis_transform(f_modes, f_energies, rho0)[source]¶; Make a basis transform that takes rho0 from the floquet basis to the; computational basis. floquet_markov_mesolve(R, ekets, rho0, tlist, e_ops, f_modes_table=None, options=None, floquet_basis=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T, args, J_cb, w_th, kmax=5, f_modes_table_t=None)[source]¶; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters. f_modes_0list of qutip.qobj (kets)A list of initial Floquet modes. f_energiesarrayThe Floquet energies. c_opqutip.qobjThe collapse operators describing the dissipation. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. J_cbcallback functionsA callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator c_op. w_thfloatThe temperature in units of frequency. k_maxintThe truncation of the number of sidebands (default 5). f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a d",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:91463,Integrability,depend,dependence,91463,"ns; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by tlist. Floquet States and Floquet-Markov Master Equation¶. floquet_basis_transform(f_modes, f_energies, rho0)[source]¶; Make a basis transform that takes rho0 from the floquet basis to the; computational basis. floquet_markov_mesolve(R, ekets, rho0, tlist, e_ops, f_modes_table=None, options=None, floquet_basis=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T, args, J_cb, w_th, kmax=5, f_modes_table_t=None)[source]¶; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters. f_modes_0list of qutip.qobj (kets)A list of initial Floquet modes. f_energiesarrayThe Floquet energies. c_opqutip.qobjThe collapse operators describing the dissipation. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. J_cbcallback functionsA callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator c_op. w_thfloatThe temperature in units of frequency. k_maxintThe truncation of the number of sidebands (default 5). f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qo",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:92767,Integrability,depend,dependent,92767,"axintThe truncation of the number of sidebands (default 5). f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. T",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:92885,Integrability,depend,dependence,92885," of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputlist of ketsThe Floquet modes as kets at time ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:93046,Integrability,depend,dependent,93046,"elta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputlist of ketsThe Floquet modes as kets at time \(t\). floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:93675,Integrability,depend,dependent,93675," be sorted in increasing quasienergies or not. Parameters. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputlist of ketsThe Floquet modes as kets at time \(t\). floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters. f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. tfloatThe time for which to evaluate the Floquet modes. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputnested listA list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:93793,Integrability,depend,dependence,93793,"rgsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputlist of ketsThe Floquet modes as kets at time \(t\). floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters. f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. tfloatThe time for which to evaluate the Floquet modes. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputnested listA list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\).",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:94060,Integrability,depend,dependence,94060,"le period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputlist of ketsThe Floquet modes as kets at time \(t\). floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters. f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. tfloatThe time for which to evaluate the Floquet modes. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputnested listA list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tlistarrayThe list of times at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. TfloatThe period of the ti",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:94310,Integrability,depend,dependence,94310,"odes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputlist of ketsThe Floquet modes as kets at time \(t\). floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters. f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. tfloatThe time for which to evaluate the Floquet modes. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputnested listA list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tlistarrayThe list of times at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionarydictionary with variables required to evaluate H. Returns. outputnested listA nested list of Floquet modes as kets for each time in tlist. floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompose the wavefunction psi (typically an initial state) in terms of; the ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:94930,Integrability,depend,dependent,94930,"e_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters. f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. tfloatThe time for which to evaluate the Floquet modes. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputnested listA list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tlistarrayThe list of times at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionarydictionary with variables required to evaluate H. Returns. outputnested listA nested list of Floquet modes as kets for each time in tlist. floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters. f_stateslist of qutip.qobj (kets)A list of Floquet modes. f_energiesarrayThe Floquet energies. psiqutip.qobjThe wavefunction to decompose in the Floquet state basis. Returns. outputarrayThe coefficients \(c_\alpha\) in the Floquet state decomposition. floquet_states(f_modes_t, f_energies, t)[source]¶; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters. f_modes_tlist of qutip.qobj (kets)A list of Floquet modes for time \(t\). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:94984,Integrability,depend,dependence,94984," the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters. f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. tfloatThe time for which to evaluate the Floquet modes. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputnested listA list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tlistarrayThe list of times at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionarydictionary with variables required to evaluate H. Returns. outputnested listA nested list of Floquet modes as kets for each time in tlist. floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters. f_stateslist of qutip.qobj (kets)A list of Floquet modes. f_energiesarrayThe Floquet energies. psiqutip.qobjThe wavefunction to decompose in the Floquet state basis. Returns. outputarrayThe coefficients \(c_\alpha\) in the Floquet state decomposition. floquet_states(f_modes_t, f_energies, t)[source]¶; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters. f_modes_tlist of qutip.qobj (kets)A list of Floquet modes for time \(t\). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the Floquet states. Returns. outputlistA list of Floquet st",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:96378,Integrability,depend,dependent,96378,"arameters. f_stateslist of qutip.qobj (kets)A list of Floquet modes. f_energiesarrayThe Floquet energies. psiqutip.qobjThe wavefunction to decompose in the Floquet state basis. Returns. outputarrayThe coefficients \(c_\alpha\) in the Floquet state decomposition. floquet_states(f_modes_t, f_energies, t)[source]¶; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters. f_modes_tlist of qutip.qobj (kets)A list of Floquet modes for time \(t\). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the Floquet states. Returns. outputlistA list of Floquet states for the time \(t\). floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the Floquet states. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. Returns. outputlistA list of Floquet states for the time \(t\). floquet_wavefunction(f_modes_t, f_energies, f_coeff, t)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time t. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Returns. outputqutip.qobjThe wavefunction for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:96432,Integrability,depend,dependence,96432,"quet modes. f_energiesarrayThe Floquet energies. psiqutip.qobjThe wavefunction to decompose in the Floquet state basis. Returns. outputarrayThe coefficients \(c_\alpha\) in the Floquet state decomposition. floquet_states(f_modes_t, f_energies, t)[source]¶; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters. f_modes_tlist of qutip.qobj (kets)A list of Floquet modes for time \(t\). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the Floquet states. Returns. outputlistA list of Floquet states for the time \(t\). floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the Floquet states. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. Returns. outputlistA list of Floquet states for the time \(t\). floquet_wavefunction(f_modes_t, f_energies, f_coeff, t)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time t. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Returns. outputqutip.qobjThe wavefunction for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet ene",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:97616,Integrability,depend,dependent,97616,"_modes_t, f_energies, f_coeff, t)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time t. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Returns. outputqutip.qobjThe wavefunction for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. Returns. outputqutip.qobjThe wavefunction for the time \(t\). fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_o",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:97670,Integrability,depend,dependence,97670,"wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time t. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Returns. outputqutip.qobjThe wavefunction for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. Returns. outputqutip.qobjThe wavefunction for the time \(t\). fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamil",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:98647,Integrability,depend,dependence,98647,"The period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. Returns. outputqutip.qobjThe wavefunction for the time \(t\). fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K ; >>> h = 6.626e-34 ; >>> kB = 1.38e-23 ; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 . optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schroding",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:98817,Integrability,depend,dependent,98817,"ime \(t\). fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K ; >>> h = 6.626e-34 ; >>> kB = 1.38e-23 ; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 . optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters. Hqutip.qobj.QobjSystem Hamiltonian, time-dependent with period T. psi0qutip.qobjInitial state vector (ket). tlistlis",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:99741,Integrability,depend,dependent,99741," single period of the driving. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K ; >>> h = 6.626e-34 ; >>> kB = 1.38e-23 ; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 . optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters. Hqutip.qobj.QobjSystem Hamiltonian, time-dependent with period T. psi0qutip.qobjInitial state vector (ket). tlistlist / arraylist of times for \(t\). e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. TstepsintegerThe number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶. general_stochastic(state0, times, d1, d2, e_ops=[], m_ops=[], _safe_mode=True, len_d2=1, args={}, **kwargs)[source]¶; Solve stochastic general equation. Dis",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:100096,Integrability,depend,dependence,100096,"; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K ; >>> h = 6.626e-34 ; >>> kB = 1.38e-23 ; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 . optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters. Hqutip.qobj.QobjSystem Hamiltonian, time-dependent with period T. psi0qutip.qobjInitial state vector (ket). tlistlist / arraylist of times for \(t\). e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. TstepsintegerThe number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶. general_stochastic(state0, times, d1, d2, e_ops=[], m_ops=[], _safe_mode=True, len_d2=1, args={}, **kwargs)[source]¶; Solve stochastic general equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. state0qutip.QobjInitial state vector (ket) or density matrix as a vector. timeslist / arrayList of times for \(t\). Must be uniformly spaced. d1function, callable classFunction representing the deterministic evolution of the system. def d1(time (double), state (a",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:100766,Integrability,depend,depending,100766,"objInitial state vector (ket). tlistlist / arraylist of times for \(t\). e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. TstepsintegerThe number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶. general_stochastic(state0, times, d1, d2, e_ops=[], m_ops=[], _safe_mode=True, len_d2=1, args={}, **kwargs)[source]¶; Solve stochastic general equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. state0qutip.QobjInitial state vector (ket) or density matrix as a vector. timeslist / arrayList of times for \(t\). Must be uniformly spaced. d1function, callable classFunction representing the deterministic evolution of the system. def d1(time (double), state (as a np.array vector)):return 1d np.array. d2function, callable classFunction representing the stochastic evolution of the system. def d2(time (double), state (as a np.array vector)):return 2d np.array (N_sc_ops, len(state0)). len_d2intNumber of output vector produced by d2. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values.; Must be a superoperator if the state vector is a density matrix. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:101924,Integrability,depend,dependent,101924,"ist of times for \(t\). Must be uniformly spaced. d1function, callable classFunction representing the deterministic evolution of the system. def d1(time (double), state (as a np.array vector)):return 1d np.array. d2function, callable classFunction representing the stochastic evolution of the system. def d2(time (double), state (as a np.array vector)):return 2d np.array (N_sc_ops, len(state0)). len_d2intNumber of output vector produced by d2. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values.; Must be a superoperator if the state vector is a density matrix. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns.",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:101966,Integrability,depend,depend,101966,"le classFunction representing the deterministic evolution of the system. def d1(time (double), state (as a np.array vector)):return 1d np.array. d2function, callable classFunction representing the stochastic evolution of the system. def d2(time (double), state (as a np.array vector)):return 2d np.array (N_sc_ops, len(state0)). len_d2intNumber of output vector produced by d2. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values.; Must be a superoperator if the state vector is a density matrix. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.R",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:102188,Integrability,depend,dependent,102188," stochastic evolution of the system. def d2(time (double), state (as a np.array vector)):return 2d np.array (N_sc_ops, len(state0)). len_d2intNumber of output vector produced by d2. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values.; Must be a superoperator if the state vector is a density matrix. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation using the photocurrent method. Parameters. Hqut",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:102310,Integrability,depend,depend,102310," of output vector produced by d2. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values.; Must be a superoperator if the state vector is a density matrix. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjInitial state ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:102405,Integrability,depend,dependent,102405,"tor or list of operators for which to evaluate; expectation values.; Must be a superoperator if the state vector is a density matrix. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be unifo",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:102636,Integrability,depend,depend,102636,"sultAn instance of the class qutip.solver.Result. photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 function",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:103206,Integrability,depend,dependent,103206,"erministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smepdpsolve(H, rho0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for density matrix; evolution. Parameters",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:103248,Integrability,depend,depend,103248,"Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smepdpsolve(H, rho0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for density matrix; evolution. Parameters. Hqutip.QobjSystem Hamiltonian. rho0qutip.QobjInitial density matr",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:103453,Integrability,depend,dependent,103453,"tors. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smepdpsolve(H, rho0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for density matrix; evolution. Parameters. Hqutip.QobjSystem Hamiltonian. rho0qutip.QobjInitial density matrix. timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:103684,Integrability,depend,depend,103684,"utip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smepdpsolve(H, rho0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for density matrix; evolution. Parameters. Hqutip.QobjSystem Hamiltonian. rho0qutip.QobjInitial density matrix. timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_opslist of qutip.QobjList of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_opsl",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:105174,Integrability,depend,depending,105174,"; evolution. Parameters. Hqutip.QobjSystem Hamiltonian. rho0qutip.QobjInitial density matrix. timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_opslist of qutip.QobjList of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See;",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:105262,Integrability,depend,dependent,105262,"density matrix. timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_opslist of qutip.QobjList of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.Resul",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:105304,Integrability,depend,depend,105304,"iformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_opslist of qutip.QobjList of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssepdpsolve(H, psi0,",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:105526,Integrability,depend,dependent,105526,"ators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use qutip.mcsolve instead for quantum; trajectory",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:105648,Integrability,depend,depend,105648,"nd d2 functions; are defined. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use qutip.mcsolve instead for quantum; trajectory simulations. Parameters. Hqutip.QobjSystem Hamiltonian. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:105743,Integrability,depend,dependent,105743,"tion singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use qutip.mcsolve instead for quantum; trajectory simulations. Parameters. Hqutip.QobjSystem Hamiltonian. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse oper",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:105974,Integrability,depend,depend,105974,"esult. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use qutip.mcsolve instead for quantum; trajectory simulations. Parameters. Hqutip.QobjSystem Hamiltonian. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; quti",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:107282,Integrability,depend,depending,107282,"ip.solver.Result. ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use qutip.mcsolve instead for quantum; trajectory simulations. Parameters. Hqutip.QobjSystem Hamiltonian. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjState vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic so",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:107370,Integrability,depend,dependent,107370,"; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use qutip.mcsolve instead for quantum; trajectory simulations. Parameters. Hqutip.QobjSystem Hamiltonian. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjState vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions.; Notes. Available solvers for ssesolve and",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:107412,Integrability,depend,depend,107412,"unction; evolution. For most purposes, use qutip.mcsolve instead for quantum; trajectory simulations. Parameters. Hqutip.QobjSystem Hamiltonian. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjState vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions.; Notes. Available solvers for ssesolve and smesolve; euler-maruyamaA simple generalization of the Euler metho",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:107609,Integrability,depend,dependent,107609,"e vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjState vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions.; Notes. Available solvers for ssesolve and smesolve; euler-maruyamaA simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting sc_ops. not tested. Order 0.5; Code: 'euler-maruya",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:107840,Integrability,depend,depend,107840,"esingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjState vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions.; Notes. Available solvers for ssesolve and smesolve; euler-maruyamaA simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting sc_ops. not tested. Order 0.5; Code: 'euler-maruyama', 'euler' or 0.5. milsteinAn order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]. Order strong 1.0; Code: 'milstein' or 1.0. milstein-impAn order 1.0 implicit ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:112787,Integrability,depend,dependent,112787,"r of; jumps at each timestep. Order 2.0; Code: 'pred-corr'. References. 1(1,2,3,4,5,6); Peter E. Kloeden and Exkhard Platen, Numerical Solution of; Stochastic Differential Equations. 2; H.-P. Breuer and F. Petruccione, The Theory of Open Quantum; Systems. 3; Pierre Rouchon and Jason F. Ralpha, Efficient Quantum Filtering for; Quantum Feedback Control, arXiv:1410.5345 [quant-ph], Phys. Rev. A 91, 012118,; (2015). 4; Howard M. Wiseman, Gerard J. Milburn, Quantum measurement and; control. Correlation Functions¶. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. g1, G1tupleThe normalized and unnormalized second-order coherence function. coherence_function_g2(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.so",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:113209,Integrability,depend,dependent,113209,"4; Howard M. Wiseman, Gerard J. Milburn, Quantum measurement and; control. Correlation Functions¶. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. g1, G1tupleThe normalized and unnormalized second-order coherence function. coherence_function_g2(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized second-order quantum coherence function:. \[ g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent fo",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
