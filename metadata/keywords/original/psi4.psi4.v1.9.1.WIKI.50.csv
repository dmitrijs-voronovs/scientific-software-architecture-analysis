id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://psicode.org/psi4manual/1.6.x/introduction.html:15749,Energy Efficiency,adapt,adapted,15749,"Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; (doi: 10.1063/1.3451077). F/I-SAPT. “Chemical Assignment of Symmetry-Adapted Perturbation Theory Interaction; Energy Components: The Functional-Group SAPT Partition,”; R. M. Parrish, T. M. Parker, and C. D. Sherrill,; J. Chem. Theory Comput. 10, 4417 (2014).; (doi: 10.1021/ct500724p).; “Communication: Practical Intramolecular Symmetry Adapted Perturbation Theory; via Hartree-Fock Embedding,”; R. M. Parrish, J. F. Gonthier, C. Corminboeuf, and C. D. Sherrill,; J. Chem. Phys. 143, 051103 (2015).; (doi: 10.1063/1.4927575). The derivation of the second-order exchange terms without the single-exchange; approximation are found in the following two works:. “Intermolecular exchange-induction energies without the overlap expansion,”; R. Schäffer and G. Jansen, Theor. Chem. Acc. 131, 1235 (2012).; (doi: 10.1007/s00214-012-1235-6); “Single-determinant-based symmetry-adapted perturbation theory without; single-exchange approximation,”; R. Schäffer and G. Jansen, Mol. Phys. 111, 2570 (2013).; (doi: 10.1080/00268976.2013.827253). Orbital-Optimized Post-Hartree–Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, J. Chem. Phys. 138, 184103 (2013).; (doi: 10.1063/1.4803662).; “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:16363,Energy Efficiency,energy,energy,16363,". The derivation of the second-order exchange terms without the single-exchange; approximation are found in the following two works:. “Intermolecular exchange-induction energies without the overlap expansion,”; R. Schäffer and G. Jansen, Theor. Chem. Acc. 131, 1235 (2012).; (doi: 10.1007/s00214-012-1235-6); “Single-determinant-based symmetry-adapted perturbation theory without; single-exchange approximation,”; R. Schäffer and G. Jansen, Mol. Phys. 111, 2570 (2013).; (doi: 10.1080/00268976.2013.827253). Orbital-Optimized Post-Hartree–Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, J. Chem. Phys. 138, 184103 (2013).; (doi: 10.1063/1.4803662).; “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q).; “Analytic energy gradients for the orbital-optimized",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:17363,Energy Efficiency,energy,energy,17363,"d second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, J. Chem. Phys. 138, 184103 (2013).; (doi: 10.1063/1.4803662).; “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q).; “Analytic energy gradients for the orbital-optimized third-order Møller–Plesset; Perturbation Theory,” U. Bozkaya,; J. Chem. Phys. 139, 104116 (2013).; (doi: 10.1063/1.4820877). Orbital-optimized linearized coupled-cluster doubles method (OLCCD). “Orbital-optimized coupled-electron pair theory and its analytic gradients:; Accurate equilibrium geometries, harmonic vibrational frequencies, and hydrogen transfer; reactions,” U. Bozkaya and C. D. Sherrill,; J. Chem. Phys. 139, 054104 (2013).; (doi: 10.1063/1.4816628). Orbital-optimized MP2.5 (OMP2.5). “Orbital-optimized MP2.5 and its analytic gradients: Approaching CCSD(T); quality for noncovalent interactions,” U. Bozkaya and C. D. Sherrill,; J. Chem. Phys. 141, 204105 (2014).; (doi: 10.1063/1.4902226). Extended Koopmans’ Theorem. “The extended Koopmans’ theorem for orbital-optimized methods: Accurate; computation of ionization potentials,” U. Bozkaya, J. Chem. Phys.; 139, 154105 (2013).; (doi: 10.1063/1.4825041).; “Accurate Electron Affinities from the Extended Koopmans’ Theorem Based on ",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:19614,Energy Efficiency,efficient,efficient,19614,"zed second-order perturbation theory (DF-OMP2). “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c).; “Analytic Energy Gradients and Spin Multiplicities for Orbital-Optimized; Second-Order Perturbation Theory with Density-Fitting Approximation: An; Efficient Implementation,” U. Bozkaya, J. Chem. Theory Comput. 10, 4389 (2014).; (doi: 10.1021/ct500634s). Density-Fitted and Cholesky-Decomposed Orbital-optimized MP3 and MP2.5 (DF-OMP3 and DF-OMP2.5). “Orbital-Optimized MP3 and MP2.5 with Density-Fitting; and Cholesky Decomposition Approximations,”; U. Bozkaya, J. Chem. Theory Comput. 12, 1179 (2016).; (doi: 10.1021/acs.jctc.5b01128). Density-Fitted and Cholesky-Decomposed Orbital-Optimized Linearized Coupled-Cluster Doubles Method (DF-OLCCD). “Orbital-optimized linearized coupled-cluster doubles with density-fitting; and Cholesky decomposition approximations: an efficient implementation,”; U. Bozkaya, Phys. Chem. Chem. Phys. 18, 11362 (2016).; (doi: 10.1039/c6cp00164e). Algebraic-Diagrammatic Construction methods (ADC)¶; General ADC theory. “Intermediate state representation approach to physical properties of; electronically excited molecules,”; J. Schirmer, and A. B. Trofimov, J. Chem. Phys. 120,; 11449-11464 (2004).; (doi: 10.1063/1.1752875). Implementation inside adcc,; the ADC backend used for most ADC methods available in PSI4. “adcc: A versatile toolkit for rapid development of; algebraic-diagrammatic construction methods,”; M. F. Herbst, M. Scheurer, T. Fransson, D. R. Rehn, and A. Dreuw.; WIREs Comput. Mol. Sci., (2020).; (DOI: 10.1002/wcms.1462, Preprint https://adc-connect.org/q/publications. “Partially-renormalized” CIS(D) and ADC(2) [PR-CIS(D) and PR-ADC(2)]; and the implementation for ADC(2) excitation energies within PSI4. “Excited State Calculation for Free-Base and Metalloporphyrins",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:20824,Energy Efficiency,adapt,adapted,20824,"ies of; electronically excited molecules,”; J. Schirmer, and A. B. Trofimov, J. Chem. Phys. 120,; 11449-11464 (2004).; (doi: 10.1063/1.1752875). Implementation inside adcc,; the ADC backend used for most ADC methods available in PSI4. “adcc: A versatile toolkit for rapid development of; algebraic-diagrammatic construction methods,”; M. F. Herbst, M. Scheurer, T. Fransson, D. R. Rehn, and A. Dreuw.; WIREs Comput. Mol. Sci., (2020).; (DOI: 10.1002/wcms.1462, Preprint https://adc-connect.org/q/publications. “Partially-renormalized” CIS(D) and ADC(2) [PR-CIS(D) and PR-ADC(2)]; and the implementation for ADC(2) excitation energies within PSI4. “Excited State Calculation for Free-Base and Metalloporphyrins with; the Partially Renormalized Polarization Propagator Approach,”; M. Saitow and Y. Mochizuki, Chem. Phys. Lett. 525, 144-149; (2012).; (doi: 10.1016/j.cplett.2011.12.063). Density Matrix Renormalization Group (DMRG)¶. “CheMPS2: a free open-source spin-adapted implementation of the density; matrix renormalization group for ab initio quantum chemistry,”; S. Wouters, W. Poelmans, P. W. Ayers and D. Van Neck,; Comput. Phys. Commun. 185 (6), 1501-1514 (2014).; (doi: 10.1016/j.cpc.2014.01.019).; “The density matrix renormalization group for ab initio quantum chemistry,”; S. Wouters and D. Van Neck, Eur. Phys. J. D 68 (9), 272 (2014).; (doi: 10.1140/epjd/e2014-50500-1). Scalar Relativistic Corrections¶; General theory for the exact two-component approach (X2C). “Analytic energy gradients for the spin-free exact two-component theory; using an exact block diagonalization for the one-electron Dirac; Hamiltonian,”; L. Cheng and J. Gauss, J. Chem. Phys. 135, 084114 (2011).; (doi: 10.1063/1.3624397). Implementation within Psi4. “Predicting Near Edge X-ray Absorption Spectra with the Spin-Free; Exact-Two-Component Hamiltonian and Orthogonality Constrained Density; Functional Theory,”; P. Verma, W. D. Derricotte and F. A. Evangelista,; J. Chem. Theory Comput. (2015).; (doi: 10.1021",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:21347,Energy Efficiency,energy,energy,21347,"R-CIS(D) and PR-ADC(2)]; and the implementation for ADC(2) excitation energies within PSI4. “Excited State Calculation for Free-Base and Metalloporphyrins with; the Partially Renormalized Polarization Propagator Approach,”; M. Saitow and Y. Mochizuki, Chem. Phys. Lett. 525, 144-149; (2012).; (doi: 10.1016/j.cplett.2011.12.063). Density Matrix Renormalization Group (DMRG)¶. “CheMPS2: a free open-source spin-adapted implementation of the density; matrix renormalization group for ab initio quantum chemistry,”; S. Wouters, W. Poelmans, P. W. Ayers and D. Van Neck,; Comput. Phys. Commun. 185 (6), 1501-1514 (2014).; (doi: 10.1016/j.cpc.2014.01.019).; “The density matrix renormalization group for ab initio quantum chemistry,”; S. Wouters and D. Van Neck, Eur. Phys. J. D 68 (9), 272 (2014).; (doi: 10.1140/epjd/e2014-50500-1). Scalar Relativistic Corrections¶; General theory for the exact two-component approach (X2C). “Analytic energy gradients for the spin-free exact two-component theory; using an exact block diagonalization for the one-electron Dirac; Hamiltonian,”; L. Cheng and J. Gauss, J. Chem. Phys. 135, 084114 (2011).; (doi: 10.1063/1.3624397). Implementation within Psi4. “Predicting Near Edge X-ray Absorption Spectra with the Spin-Free; Exact-Two-Component Hamiltonian and Orthogonality Constrained Density; Functional Theory,”; P. Verma, W. D. Derricotte and F. A. Evangelista,; J. Chem. Theory Comput. (2015).; (doi: 10.1021/acs.jctc.5b00817). Supported Systems¶. ArchitecturesThe majority of PSI4 was developed on Mac and Linux machines; in; principle, it should work on any Unix system. The latest version of the; PSI4 program package may be obtained at psicode.org.; The package is available as a binary (Installing from Binary) for Linux, macOS (not arm64), or Windows (both native and via Windows Subsystem for; Linux aka Bash on Ubuntu on Windows); or as source code (git repository or zipped archive from; https://github.com/psi4/psi4. CompilersPSI4 has been successfully ",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:26259,Energy Efficiency,energy,energy,26259," RHF; CONV; —; —; threaded 3. E. CI(n); RHF/ROHF; CONV; —; —; partially threaded. FCI; RHF/ROHF; CONV; —; —; partially threaded. Mk-MRPT2; RHF/ROHF/TCSCF; CONV; —; —; threaded 3. Mk-MRCCSD; RHF/ROHF/TCSCF; CONV; —; —; threaded 3. Mk-MRCCSD(T); RHF/ROHF/TCSCF; CONV; —; —; threaded 3. RAS-CI; RHF/ROHF; CONV; —; —; partially threaded. CASSCF, RASSCF; RHF/ROHF; CONV/DF; —; —; partially threaded. SAPT; RHF; CONV; —; —; threaded. ADC(1); RHF/UHF; CONV; —; —; threaded. ADC(2); RHF/UHF; CONV; —; —; threaded. ADC(2)-x; RHF/UHF; CONV; —; —; threaded. ADC(3); RHF/UHF; CONV; —; —; threaded. CVS-ADC(1); RHF/UHF; CONV; —; —; threaded. CVS-ADC(2); RHF/UHF; CONV; —; —; threaded. CVS-ADC(2)-x; RHF/UHF; CONV; —; —; threaded. CVS-ADC(3); RHF/UHF; CONV; —; —; threaded. EOM-CC2; RHF; CONV; —; —; threaded 3. EOM-CCSD; RHF/UHF/ROHF; CONV; RHF/UHF/ROHF; CONV; threaded 3. EOM-CC3; RHF/UHF/ROHF; CONV; —; —; threaded 3. DMRG-CI; Y; CONV; —; —. DMRG-SCF; Y; CONV; —; —. Geometry optimization can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is distributed for free and without any guarantee of; reliability, accuracy, or suitability for any particular purpose. No; obligation to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries on the forum or GitHub. For bug reports,; specific and detailed information, with example inputs, would be; appreciated.; Where-to-post summary:6. How do I? – ask the forum; I got this error, why? – ask the forum; I got this error and I’m sure it’s a bug – file a GitHub issue; Can I open a discussion on this bit of code? – file a GitHub issue; I have an idea/request and a plan – file a GitHub issue; I have an idea/request –",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:463,Integrability,rout,routine,463,"﻿. Introduction. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Introduction. Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; PSI4 is, in many ways, a whole new package compared to Psi3.; While some libraries and modules remain the same, the majority of the code has; been rewritten from scratch based on a powerful set of new libraries written; in C++. A totally new Python front-end makes PSI4 incredibly user-friendly; and automates many common tasks such as basis set extrapolation, composite; methods, running the same computation on every molecule in a test set, etc.; Density-functional theory, absent in Psi3, is quite efficient; in PSI4, with many functionals available. Density fitting is ubiquitous in; PSI4, leading to some of the most efficient MP2 and CCSD(T) code available.; PSI4 also introduces extensive,; powerful features for energy component analysis of non-covalent interactions; via symmetry-adapted perturbation theory. Orbital-optimized versions of; perturbation theory and coupled-cluster methods, and their analytic gradients,; have also been added. Through external libraries, PSI4 gains access to implicit; solvent (PCM) capabilities, density-matrix renormalization group CI, effective; fragment potentials, Grimme dispersion corrections, and high-order; coupled-cluster theory.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 inp",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:23229,Integrability,depend,dependencies,23229,"sh on Ubuntu on Windows); or as source code (git repository or zipped archive from; https://github.com/psi4/psi4. CompilersPSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. Compiler requirements are primarily; C++17 compliance (now GCC version 7.0 or above).; For some architectures, a precompiled binary is available. See Compiling and Installing for details. PythonPSI4 1.1 and 1.2 are supported on Python 2.7, 3.5,; and 3.6. After 1.2, only Python 3 will be supported; in accordance with other scientific software projects).; PSI4 1.3 supports Python 3.6 and 3.7.; PSI4 1.4 supports Python 3.6, 3.7, 3.8, and 3.9.; PSI4 1.5 supports Python 3.7, 3.8, and 3.9.; PSI4 1.6 supports Python 3.8, 3.9, and 3.10.; The future plan is to support the two or three latest Python versions.; The current master supports 3.8, 3.9, and 3.10. License¶; PSI4 is distributed under the GNU Lesser General Public License; version 3, LGPL-3.0. Its; required dependencies and add-ons have their own licenses, ranging from; BSD-2-Clause to GPL-2.0+. It is possible to build PSI4 without any; GPL dependencies. Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contracted Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Energy (CFOUR), Gradient,; Gradient (CFOUR), and Frequency. Summary of theoretical methods available in PSI4¶. Method; Energy; Gradient; Parallelism; Variants. Reference; Type; Reference; Type; OO 9; FNO 1; DLPNO. HF, HF-3c; RHF/UHF/ROHF; CONV/DF/CD; RHF/UHF/ROHF; CONV/DF; threaded. DFT, PBEh-3c; RKS/UKS; CONV/DF/CD 7; RKS/UKS; DF 4; threaded. EFP 5; RHF. —; —. DCT; RHF/UHF; CONV/DF; RHF/UHF; CONV; partially threaded. MP2 10; RHF/UHF/ROHF; CONV/DF/CD; RHF/UHF; CONV/DF",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:23365,Integrability,depend,dependencies,23365,"https://github.com/psi4/psi4. CompilersPSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. Compiler requirements are primarily; C++17 compliance (now GCC version 7.0 or above).; For some architectures, a precompiled binary is available. See Compiling and Installing for details. PythonPSI4 1.1 and 1.2 are supported on Python 2.7, 3.5,; and 3.6. After 1.2, only Python 3 will be supported; in accordance with other scientific software projects).; PSI4 1.3 supports Python 3.6 and 3.7.; PSI4 1.4 supports Python 3.6, 3.7, 3.8, and 3.9.; PSI4 1.5 supports Python 3.7, 3.8, and 3.9.; PSI4 1.6 supports Python 3.8, 3.9, and 3.10.; The future plan is to support the two or three latest Python versions.; The current master supports 3.8, 3.9, and 3.10. License¶; PSI4 is distributed under the GNU Lesser General Public License; version 3, LGPL-3.0. Its; required dependencies and add-ons have their own licenses, ranging from; BSD-2-Clause to GPL-2.0+. It is possible to build PSI4 without any; GPL dependencies. Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contracted Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Energy (CFOUR), Gradient,; Gradient (CFOUR), and Frequency. Summary of theoretical methods available in PSI4¶. Method; Energy; Gradient; Parallelism; Variants. Reference; Type; Reference; Type; OO 9; FNO 1; DLPNO. HF, HF-3c; RHF/UHF/ROHF; CONV/DF/CD; RHF/UHF/ROHF; CONV/DF; threaded. DFT, PBEh-3c; RKS/UKS; CONV/DF/CD 7; RKS/UKS; DF 4; threaded. EFP 5; RHF. —; —. DCT; RHF/UHF; CONV/DF; RHF/UHF; CONV; partially threaded. MP2 10; RHF/UHF/ROHF; CONV/DF/CD; RHF/UHF; CONV/DF; threaded 3; E/G. E. MP3 10; RHF/UHF; CONV/DF/CD; RHF/UHF; CONV/DF; threaded 3; E/",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:23459,Integrability,contract,contracted,23459,"rs. Compiler requirements are primarily; C++17 compliance (now GCC version 7.0 or above).; For some architectures, a precompiled binary is available. See Compiling and Installing for details. PythonPSI4 1.1 and 1.2 are supported on Python 2.7, 3.5,; and 3.6. After 1.2, only Python 3 will be supported; in accordance with other scientific software projects).; PSI4 1.3 supports Python 3.6 and 3.7.; PSI4 1.4 supports Python 3.6, 3.7, 3.8, and 3.9.; PSI4 1.5 supports Python 3.7, 3.8, and 3.9.; PSI4 1.6 supports Python 3.8, 3.9, and 3.10.; The future plan is to support the two or three latest Python versions.; The current master supports 3.8, 3.9, and 3.10. License¶; PSI4 is distributed under the GNU Lesser General Public License; version 3, LGPL-3.0. Its; required dependencies and add-ons have their own licenses, ranging from; BSD-2-Clause to GPL-2.0+. It is possible to build PSI4 without any; GPL dependencies. Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contracted Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Energy (CFOUR), Gradient,; Gradient (CFOUR), and Frequency. Summary of theoretical methods available in PSI4¶. Method; Energy; Gradient; Parallelism; Variants. Reference; Type; Reference; Type; OO 9; FNO 1; DLPNO. HF, HF-3c; RHF/UHF/ROHF; CONV/DF/CD; RHF/UHF/ROHF; CONV/DF; threaded. DFT, PBEh-3c; RKS/UKS; CONV/DF/CD 7; RKS/UKS; DF 4; threaded. EFP 5; RHF. —; —. DCT; RHF/UHF; CONV/DF; RHF/UHF; CONV; partially threaded. MP2 10; RHF/UHF/ROHF; CONV/DF/CD; RHF/UHF; CONV/DF; threaded 3; E/G. E. MP3 10; RHF/UHF; CONV/DF/CD; RHF/UHF; CONV/DF; threaded 3; E/G; E. MP2.5 10; RHF/UHF; CONV/DF/CD; RHF/UHF; CONV/DF; threaded 3; E/G. MP4 10; RHF; CONV; —; —; threaded 3. E. ",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:27766,Integrability,rout,routines,27766,"ed. As time; allows, the developers will attempt to answer inquiries on the forum or GitHub. For bug reports,; specific and detailed information, with example inputs, would be; appreciated.; Where-to-post summary:6. How do I? – ask the forum; I got this error, why? – ask the forum; I got this error and I’m sure it’s a bug – file a GitHub issue; Can I open a discussion on this bit of code? – file a GitHub issue; I have an idea/request and a plan – file a GitHub issue; I have an idea/request – ask the forum; Why do you? – ask the forum; When will you? – ask the forum; I have an experience that can improve the build documentation – inform the forum or add to the documentation itself; Anything you want to share privately – crawdad@vt.edu or sherrill@gatech.edu. Footnotes. 1; Frozen natural orbital variant available. In particular, RHF available as CONV. 2(1,2); Frozen natural orbital variant available. In particular, RHF available as CONV/DF. 3(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21); threading through BLAS routines only. 4; DFT gradients only implemented for SCF type DF. LRC-DFT gradients not implemented yet. DH-DFT gradients not implemented. 5; Both EFP/EFP and QM/EFP energies are available. 6; Adapted from here. 7; DH-DFT only available with DF-MP2. 8(1,2,3,4); Not all combinations of reference and algorithm available. In particular, non-RHF references only available as CONV. For CCSD(T), gradients are not available with frozen core. 9; Orbital-optimized variant available. In particular, all references available as CONV/DF. 10(1,2,3,4,5,6,7,8,9,10); Capabilities breakdown in great detail can be found here. table of contents. Introduction; Overview; Citing PSI4; Overall PSI4 Package; Density Cumulant Theory (DCT); Configuration Interaction (CI); Coupled Cluster (CC); Mukherjee State-Specific Multi-Reference Coupled Cluster (Mk-MRCC); Symmetry-Adapted Perturbation Theory (SAPT); Orbital-Optimized Post-Hartree–Fock Methods; Algebraic-Diagrammatic Construc",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:1331,Modifiability,adapt,adapted,1331,"memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; PSI4 is, in many ways, a whole new package compared to Psi3.; While some libraries and modules remain the same, the majority of the code has; been rewritten from scratch based on a powerful set of new libraries written; in C++. A totally new Python front-end makes PSI4 incredibly user-friendly; and automates many common tasks such as basis set extrapolation, composite; methods, running the same computation on every molecule in a test set, etc.; Density-functional theory, absent in Psi3, is quite efficient; in PSI4, with many functionals available. Density fitting is ubiquitous in; PSI4, leading to some of the most efficient MP2 and CCSD(T) code available.; PSI4 also introduces extensive,; powerful features for energy component analysis of non-covalent interactions; via symmetry-adapted perturbation theory. Orbital-optimized versions of; perturbation theory and coupled-cluster methods, and their analytic gradients,; have also been added. Through external libraries, PSI4 gains access to implicit; solvent (PCM) capabilities, density-matrix renormalization group CI, effective; fragment potentials, Grimme dispersion corrections, and high-order; coupled-cluster theory.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapol",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:5854,Modifiability,extend,extended,5854,"r modules used, the user may also wish to; cite some of the following references for theoretical, algorithmic,; or implementation contributions specific to PSI4 (in addition to; appropriate references for the underlying theory, which are not necessarily; included in the list below).; Regardless of the type of the calculation, an initial guess is; necessary. PSI4 features several initial guesses for the; molecular orbitals. The default guess is the superposition of atomic; densities (SAD), discussed in. “Principles for a direct SCF approach to LCAO-MO ab-initio; calculations”, J. Almlöf, K. Faegri, and K. Korsell,; J. Comput. Chem. 3, 385 (1982).; (doi: 10.1002/jcc.540030314).; “Starting SCF calculations by superposition of atomic; densities”, J. H. Van Lenthe, R. Zwaans, H. J. J. Van Dam,; and M. F. Guest, J. Comput. Chem. 27, 926 (2006).; (doi: 10.1002/jcc.20393). PSI4 also features a SAD natural orbital guess, an extended; Hückel guess that employs on-the-fly atomic calculations alike the SAD; guess, as well as a superposition of atomic potentials (SAP) guess; that is based on screening of atomic nuclei. The SAD natural orbitals,; Hückel and SAP guesses have been described in. “An assessment of initial guesses for self-consistent field; calculations. Superposition of Atomic Potentials: simple yet; efficient”, S. Lehtola, J. Chem. Theory Comput. 15,; 1593 (2019) (doi: 10.1021/acs.jctc.8b01089). Density Cumulant Theory (DCT)¶; PSI4 features several formulations of newly-developed density cumulant; theory (DCT), also known as density cumulant functional theory (DCFT).; The theory and benchmark of this theory are discussed in the following papers:; DC-06 (also known as DCT-06):. “Density Cumulant Functional Theory: First Implementation and; Benchmark Results for the DCFT-06 Model,” A. C. Simmonett,; J. J. Wilke, H. F. Schaefer, and W. Kutzelnigg, J. Chem. Phys.; 133, 174122 (2010).; (doi: 10.1063/1.3503657).; “Analytic gradients for density cumulant functional theory:",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:7840,Modifiability,config,configuration,7840,"1063/1.3503657).; “Analytic gradients for density cumulant functional theory: The; DCFT-06 model,” A. Yu. Sokolov, J. J. Wilke, A. C. Simmonett,; and H. F. Schaefer, J. Chem. Phys. 137, 054105 (2012).; (doi: 10.1063/1.4739423). DC-12:. “Density cumulant functional theory: The DC-12 method, an improved; description of the one-particle density matrix,” A. Yu. Sokolov,; A. C. Simmonett, and H. F. Schaefer, J. Chem. Phys. 138, 024107; (2013).; (doi: 10.1063/1.4773580). ODC-06 and ODC-12:. “Orbital-optimized density cumulant functional theory,” A. Yu. Sokolov, and; H. F. Schaefer, J. Chem. Phys. 139, 204110 (2013).; (doi: 10.1063/1.4833138). ODC-13:. “Density cumulant functional theory from a unitary transformation:; N-representability, three-particle correlation effects, and application; to O4+,” A. Yu. Sokolov, H. F. Schaefer, and W. Kutzelnigg,; J. Chem. Phys. 141, 074111 (2014).; (doi: 10.1063/1.4892946). Configuration Interaction (CI)¶; PSI has a highly optimized code for full configuration interaction; and highly correlated configuration interaction, as described in. “The Configuration Interaction Method: Advances in Highly; Correlated Approaches,” C. D. Sherrill and H. F. Schaefer, in; Adv. Quantum Chem., vol. 34, P.-O. Löwdin, Ed.; (Academic Press, New York, 1999), pp. 143-269.; (doi: 10.1016/S0065-3276(08)60532-8). Coupled Cluster (CC)¶; A general discussion of coupled cluster theory is given in. “An Introduction to Coupled Cluster Theory for Computational; Chemists,” T. D. Crawford and H. F. Schaefer, Rev. Comp. Chem.; 14, 33-136 (2000).; (doi: 10.1002/9780470125915.ch2). Implementation of frozen natural orbital (FNO) coupled cluster theory; in PSI and its performance for non-covalent interactions is discussed; in. “Accurate Noncovalent Interaction Energies Using Truncated Basis Sets; Based on Frozen Natural Orbitals,” A. E. DePrince and C. D. Sherrill,; J. Chem. Theory Comput. 9, 293-299 (2013).; (doi: 10.1021/ct300780u). Implementation of density-fitted (DF) a",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:7889,Modifiability,config,configuration,7889,"1063/1.3503657).; “Analytic gradients for density cumulant functional theory: The; DCFT-06 model,” A. Yu. Sokolov, J. J. Wilke, A. C. Simmonett,; and H. F. Schaefer, J. Chem. Phys. 137, 054105 (2012).; (doi: 10.1063/1.4739423). DC-12:. “Density cumulant functional theory: The DC-12 method, an improved; description of the one-particle density matrix,” A. Yu. Sokolov,; A. C. Simmonett, and H. F. Schaefer, J. Chem. Phys. 138, 024107; (2013).; (doi: 10.1063/1.4773580). ODC-06 and ODC-12:. “Orbital-optimized density cumulant functional theory,” A. Yu. Sokolov, and; H. F. Schaefer, J. Chem. Phys. 139, 204110 (2013).; (doi: 10.1063/1.4833138). ODC-13:. “Density cumulant functional theory from a unitary transformation:; N-representability, three-particle correlation effects, and application; to O4+,” A. Yu. Sokolov, H. F. Schaefer, and W. Kutzelnigg,; J. Chem. Phys. 141, 074111 (2014).; (doi: 10.1063/1.4892946). Configuration Interaction (CI)¶; PSI has a highly optimized code for full configuration interaction; and highly correlated configuration interaction, as described in. “The Configuration Interaction Method: Advances in Highly; Correlated Approaches,” C. D. Sherrill and H. F. Schaefer, in; Adv. Quantum Chem., vol. 34, P.-O. Löwdin, Ed.; (Academic Press, New York, 1999), pp. 143-269.; (doi: 10.1016/S0065-3276(08)60532-8). Coupled Cluster (CC)¶; A general discussion of coupled cluster theory is given in. “An Introduction to Coupled Cluster Theory for Computational; Chemists,” T. D. Crawford and H. F. Schaefer, Rev. Comp. Chem.; 14, 33-136 (2000).; (doi: 10.1002/9780470125915.ch2). Implementation of frozen natural orbital (FNO) coupled cluster theory; in PSI and its performance for non-covalent interactions is discussed; in. “Accurate Noncovalent Interaction Energies Using Truncated Basis Sets; Based on Frozen Natural Orbitals,” A. E. DePrince and C. D. Sherrill,; J. Chem. Theory Comput. 9, 293-299 (2013).; (doi: 10.1021/ct300780u). Implementation of density-fitted (DF) a",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:12796,Modifiability,adapt,adapted,12796,"APT). A good review article for this; method is as follows:. “Perturbation Theory Approach to Intermolecular Potential Energy; Surfaces of van der Waals Complexes,” B. Jeziorski, R. Moszynski,; and K. Szalewicz, Chem. Rev. 94, 1887-1930 (1994).; (doi: 10.1021/cr00031a008). PSI4 benefits enormously from the introduction of density fitting (DF); into SAPT. There are several SAPT truncations available in PSI4. For; guidance on which one to choose, see the SAPT section of the manual; and refer to the following systematic study:. “Levels of Symmetry Adapted Perturbation Theory (SAPT). I. Efficiency and; Performance for Interaction Energies,’’ T. M. Parker, L. A. Burns, R. M.; Parrish, A. G. Ryno, and C. D. Sherrill, J. Chem. Phys. 140,; 094106 (2014).; (doi: 10.1063/1.4867135). The theory and implementation of DF-SAPT is discussed; in the following papers for various levels of SAPT.; DF-SAPT0. “Large-scale Symmetry-adapted Perturbation Theory Computations via; Density Fitting and Laplace Transformation Techniques: Investigating the; Fundamental Forces of DNA-Intercalator Interactions,” E. G. Hohenstein,; R. M. Parrish, C. D. Sherrill, J. M. Turney, and H. F. Schaefer, J.; Chem. Phys. 135, 174017 (2011).; (doi: 10.1063/1.3656681).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of \(\pi - \pi\) Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010).; (doi: 10.1063/1.3426316). SAPT2. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; (doi: 10.1063/1.3451077). SAPT2+, SAPT2+(3), SAPT2+3. “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012).; (doi: 10.1002/wcms.84).; “Density Fitting of Intramonomer Correlation Effects in; S",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:15749,Modifiability,adapt,adapted,15749,"Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; (doi: 10.1063/1.3451077). F/I-SAPT. “Chemical Assignment of Symmetry-Adapted Perturbation Theory Interaction; Energy Components: The Functional-Group SAPT Partition,”; R. M. Parrish, T. M. Parker, and C. D. Sherrill,; J. Chem. Theory Comput. 10, 4417 (2014).; (doi: 10.1021/ct500724p).; “Communication: Practical Intramolecular Symmetry Adapted Perturbation Theory; via Hartree-Fock Embedding,”; R. M. Parrish, J. F. Gonthier, C. Corminboeuf, and C. D. Sherrill,; J. Chem. Phys. 143, 051103 (2015).; (doi: 10.1063/1.4927575). The derivation of the second-order exchange terms without the single-exchange; approximation are found in the following two works:. “Intermolecular exchange-induction energies without the overlap expansion,”; R. Schäffer and G. Jansen, Theor. Chem. Acc. 131, 1235 (2012).; (doi: 10.1007/s00214-012-1235-6); “Single-determinant-based symmetry-adapted perturbation theory without; single-exchange approximation,”; R. Schäffer and G. Jansen, Mol. Phys. 111, 2570 (2013).; (doi: 10.1080/00268976.2013.827253). Orbital-Optimized Post-Hartree–Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, J. Chem. Phys. 138, 184103 (2013).; (doi: 10.1063/1.4803662).; “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:18147,Modifiability,extend,extended,18147,"pposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q).; “Analytic energy gradients for the orbital-optimized third-order Møller–Plesset; Perturbation Theory,” U. Bozkaya,; J. Chem. Phys. 139, 104116 (2013).; (doi: 10.1063/1.4820877). Orbital-optimized linearized coupled-cluster doubles method (OLCCD). “Orbital-optimized coupled-electron pair theory and its analytic gradients:; Accurate equilibrium geometries, harmonic vibrational frequencies, and hydrogen transfer; reactions,” U. Bozkaya and C. D. Sherrill,; J. Chem. Phys. 139, 054104 (2013).; (doi: 10.1063/1.4816628). Orbital-optimized MP2.5 (OMP2.5). “Orbital-optimized MP2.5 and its analytic gradients: Approaching CCSD(T); quality for noncovalent interactions,” U. Bozkaya and C. D. Sherrill,; J. Chem. Phys. 141, 204105 (2014).; (doi: 10.1063/1.4902226). Extended Koopmans’ Theorem. “The extended Koopmans’ theorem for orbital-optimized methods: Accurate; computation of ionization potentials,” U. Bozkaya, J. Chem. Phys.; 139, 154105 (2013).; (doi: 10.1063/1.4825041).; “Accurate Electron Affinities from the Extended Koopmans’ Theorem Based on Orbital-Optimized Methods,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2041 (2014).; (doi: 10.1021/ct500186j). Density-Fitted and Cholesky-Decomposed Orbital-optimized second-order perturbation theory (DF-OMP2). “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c).; “Analytic Energy Gradients and Spin Multiplicities for Orbital-Optimized; Second-Order Perturbation Theory with Density-Fitting Approximation: An; Efficient Implementation,” U. Bozkaya, J. Chem. Theory Comput. 10, 4389 (2014).; (doi: 10.1021/ct500634s). Density-Fitted and Cholesky-Decomposed Orbital-optimized MP3 and MP2.5 (DF-OMP3 and DF-OMP2.5). “Orbi",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:20824,Modifiability,adapt,adapted,20824,"ies of; electronically excited molecules,”; J. Schirmer, and A. B. Trofimov, J. Chem. Phys. 120,; 11449-11464 (2004).; (doi: 10.1063/1.1752875). Implementation inside adcc,; the ADC backend used for most ADC methods available in PSI4. “adcc: A versatile toolkit for rapid development of; algebraic-diagrammatic construction methods,”; M. F. Herbst, M. Scheurer, T. Fransson, D. R. Rehn, and A. Dreuw.; WIREs Comput. Mol. Sci., (2020).; (DOI: 10.1002/wcms.1462, Preprint https://adc-connect.org/q/publications. “Partially-renormalized” CIS(D) and ADC(2) [PR-CIS(D) and PR-ADC(2)]; and the implementation for ADC(2) excitation energies within PSI4. “Excited State Calculation for Free-Base and Metalloporphyrins with; the Partially Renormalized Polarization Propagator Approach,”; M. Saitow and Y. Mochizuki, Chem. Phys. Lett. 525, 144-149; (2012).; (doi: 10.1016/j.cplett.2011.12.063). Density Matrix Renormalization Group (DMRG)¶. “CheMPS2: a free open-source spin-adapted implementation of the density; matrix renormalization group for ab initio quantum chemistry,”; S. Wouters, W. Poelmans, P. W. Ayers and D. Van Neck,; Comput. Phys. Commun. 185 (6), 1501-1514 (2014).; (doi: 10.1016/j.cpc.2014.01.019).; “The density matrix renormalization group for ab initio quantum chemistry,”; S. Wouters and D. Van Neck, Eur. Phys. J. D 68 (9), 272 (2014).; (doi: 10.1140/epjd/e2014-50500-1). Scalar Relativistic Corrections¶; General theory for the exact two-component approach (X2C). “Analytic energy gradients for the spin-free exact two-component theory; using an exact block diagonalization for the one-electron Dirac; Hamiltonian,”; L. Cheng and J. Gauss, J. Chem. Phys. 135, 084114 (2011).; (doi: 10.1063/1.3624397). Implementation within Psi4. “Predicting Near Edge X-ray Absorption Spectra with the Spin-Free; Exact-Two-Component Hamiltonian and Orthogonality Constrained Density; Functional Theory,”; P. Verma, W. D. Derricotte and F. A. Evangelista,; J. Chem. Theory Comput. (2015).; (doi: 10.1021",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:1368,Performance,optimiz,optimized,1368,"input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; PSI4 is, in many ways, a whole new package compared to Psi3.; While some libraries and modules remain the same, the majority of the code has; been rewritten from scratch based on a powerful set of new libraries written; in C++. A totally new Python front-end makes PSI4 incredibly user-friendly; and automates many common tasks such as basis set extrapolation, composite; methods, running the same computation on every molecule in a test set, etc.; Density-functional theory, absent in Psi3, is quite efficient; in PSI4, with many functionals available. Density fitting is ubiquitous in; PSI4, leading to some of the most efficient MP2 and CCSD(T) code available.; PSI4 also introduces extensive,; powerful features for energy component analysis of non-covalent interactions; via symmetry-adapted perturbation theory. Orbital-optimized versions of; perturbation theory and coupled-cluster methods, and their analytic gradients,; have also been added. Through external libraries, PSI4 gains access to implicit; solvent (PCM) capabilities, density-matrix renormalization group CI, effective; fragment potentials, Grimme dispersion corrections, and high-order; coupled-cluster theory.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations whi",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:2537,Performance,optimiz,optimization,2537,"PSI4 gains access to implicit; solvent (PCM) capabilities, density-matrix renormalization group CI, effective; fragment potentials, Grimme dispersion corrections, and high-order; coupled-cluster theory.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendices include a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶. Overall PSI4 Package¶; The following citation should be used in any publication utilizing the; PSI4 program package:. “Psi4 1.4: Open-Source Software for High-Throughput Quantum Chemistry”,; D. G. A. Smith, L. A. Burns, A. C. Simmonett, R. M. Parrish, M. C.; Schieber, R. Galvelis, P. Kraus, H. Kruse, R. Di Remigio, A. Alenaizan, A.; M. James, S. Lehtola, J. P. Misiewicz, M. Scheurer, R. A. Shaw, J. B.; Schriber, Y. Xie, Z. L. Glick, D. A. Sirianni, J. S. O’Brien, J. M.; Waldrop, A. Kumar, E. G. Hohenstein, B. P. Pritchard, ",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:7347,Performance,optimiz,optimized,7347,"y (DCT)¶; PSI4 features several formulations of newly-developed density cumulant; theory (DCT), also known as density cumulant functional theory (DCFT).; The theory and benchmark of this theory are discussed in the following papers:; DC-06 (also known as DCT-06):. “Density Cumulant Functional Theory: First Implementation and; Benchmark Results for the DCFT-06 Model,” A. C. Simmonett,; J. J. Wilke, H. F. Schaefer, and W. Kutzelnigg, J. Chem. Phys.; 133, 174122 (2010).; (doi: 10.1063/1.3503657).; “Analytic gradients for density cumulant functional theory: The; DCFT-06 model,” A. Yu. Sokolov, J. J. Wilke, A. C. Simmonett,; and H. F. Schaefer, J. Chem. Phys. 137, 054105 (2012).; (doi: 10.1063/1.4739423). DC-12:. “Density cumulant functional theory: The DC-12 method, an improved; description of the one-particle density matrix,” A. Yu. Sokolov,; A. C. Simmonett, and H. F. Schaefer, J. Chem. Phys. 138, 024107; (2013).; (doi: 10.1063/1.4773580). ODC-06 and ODC-12:. “Orbital-optimized density cumulant functional theory,” A. Yu. Sokolov, and; H. F. Schaefer, J. Chem. Phys. 139, 204110 (2013).; (doi: 10.1063/1.4833138). ODC-13:. “Density cumulant functional theory from a unitary transformation:; N-representability, three-particle correlation effects, and application; to O4+,” A. Yu. Sokolov, H. F. Schaefer, and W. Kutzelnigg,; J. Chem. Phys. 141, 074111 (2014).; (doi: 10.1063/1.4892946). Configuration Interaction (CI)¶; PSI has a highly optimized code for full configuration interaction; and highly correlated configuration interaction, as described in. “The Configuration Interaction Method: Advances in Highly; Correlated Approaches,” C. D. Sherrill and H. F. Schaefer, in; Adv. Quantum Chem., vol. 34, P.-O. Löwdin, Ed.; (Academic Press, New York, 1999), pp. 143-269.; (doi: 10.1016/S0065-3276(08)60532-8). Coupled Cluster (CC)¶; A general discussion of coupled cluster theory is given in. “An Introduction to Coupled Cluster Theory for Computational; Chemists,” T. D. Crawford and H. ",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:7816,Performance,optimiz,optimized,7816,"1063/1.3503657).; “Analytic gradients for density cumulant functional theory: The; DCFT-06 model,” A. Yu. Sokolov, J. J. Wilke, A. C. Simmonett,; and H. F. Schaefer, J. Chem. Phys. 137, 054105 (2012).; (doi: 10.1063/1.4739423). DC-12:. “Density cumulant functional theory: The DC-12 method, an improved; description of the one-particle density matrix,” A. Yu. Sokolov,; A. C. Simmonett, and H. F. Schaefer, J. Chem. Phys. 138, 024107; (2013).; (doi: 10.1063/1.4773580). ODC-06 and ODC-12:. “Orbital-optimized density cumulant functional theory,” A. Yu. Sokolov, and; H. F. Schaefer, J. Chem. Phys. 139, 204110 (2013).; (doi: 10.1063/1.4833138). ODC-13:. “Density cumulant functional theory from a unitary transformation:; N-representability, three-particle correlation effects, and application; to O4+,” A. Yu. Sokolov, H. F. Schaefer, and W. Kutzelnigg,; J. Chem. Phys. 141, 074111 (2014).; (doi: 10.1063/1.4892946). Configuration Interaction (CI)¶; PSI has a highly optimized code for full configuration interaction; and highly correlated configuration interaction, as described in. “The Configuration Interaction Method: Advances in Highly; Correlated Approaches,” C. D. Sherrill and H. F. Schaefer, in; Adv. Quantum Chem., vol. 34, P.-O. Löwdin, Ed.; (Academic Press, New York, 1999), pp. 143-269.; (doi: 10.1016/S0065-3276(08)60532-8). Coupled Cluster (CC)¶; A general discussion of coupled cluster theory is given in. “An Introduction to Coupled Cluster Theory for Computational; Chemists,” T. D. Crawford and H. F. Schaefer, Rev. Comp. Chem.; 14, 33-136 (2000).; (doi: 10.1002/9780470125915.ch2). Implementation of frozen natural orbital (FNO) coupled cluster theory; in PSI and its performance for non-covalent interactions is discussed; in. “Accurate Noncovalent Interaction Energies Using Truncated Basis Sets; Based on Frozen Natural Orbitals,” A. E. DePrince and C. D. Sherrill,; J. Chem. Theory Comput. 9, 293-299 (2013).; (doi: 10.1021/ct300780u). Implementation of density-fitted (DF) a",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:8538,Performance,perform,performance,8538,"tional theory from a unitary transformation:; N-representability, three-particle correlation effects, and application; to O4+,” A. Yu. Sokolov, H. F. Schaefer, and W. Kutzelnigg,; J. Chem. Phys. 141, 074111 (2014).; (doi: 10.1063/1.4892946). Configuration Interaction (CI)¶; PSI has a highly optimized code for full configuration interaction; and highly correlated configuration interaction, as described in. “The Configuration Interaction Method: Advances in Highly; Correlated Approaches,” C. D. Sherrill and H. F. Schaefer, in; Adv. Quantum Chem., vol. 34, P.-O. Löwdin, Ed.; (Academic Press, New York, 1999), pp. 143-269.; (doi: 10.1016/S0065-3276(08)60532-8). Coupled Cluster (CC)¶; A general discussion of coupled cluster theory is given in. “An Introduction to Coupled Cluster Theory for Computational; Chemists,” T. D. Crawford and H. F. Schaefer, Rev. Comp. Chem.; 14, 33-136 (2000).; (doi: 10.1002/9780470125915.ch2). Implementation of frozen natural orbital (FNO) coupled cluster theory; in PSI and its performance for non-covalent interactions is discussed; in. “Accurate Noncovalent Interaction Energies Using Truncated Basis Sets; Based on Frozen Natural Orbitals,” A. E. DePrince and C. D. Sherrill,; J. Chem. Theory Comput. 9, 293-299 (2013).; (doi: 10.1021/ct300780u). Implementation of density-fitted (DF) and Cholesky decomposition (CD); coupled cluster in PSI, and its performance for non-covalent interactions; and reaction energies, is discussed in. “Accuracy and Efficiency of Coupled-Cluster Theory Using; Density Fitting / Cholesky Decomposition, Frozen Natural Orbitals,; and a T1-Transformed Hamiltonian,” A. E. DePrince and C. D. Sherrill,; J. Chem. Theory Comput. 9, 2687-2696 (2013).; (doi: 10.1021/ct400250u). Implementation of the asymmetric triples correction for the density-fitted; and cholesky-decomposed coupled-cluster singles and doubles method. “A noniterative asymmetric triple excitation correction for the density-fitted; coupled-cluster singles and doubles",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:8913,Performance,perform,performance,8913," interaction, as described in. “The Configuration Interaction Method: Advances in Highly; Correlated Approaches,” C. D. Sherrill and H. F. Schaefer, in; Adv. Quantum Chem., vol. 34, P.-O. Löwdin, Ed.; (Academic Press, New York, 1999), pp. 143-269.; (doi: 10.1016/S0065-3276(08)60532-8). Coupled Cluster (CC)¶; A general discussion of coupled cluster theory is given in. “An Introduction to Coupled Cluster Theory for Computational; Chemists,” T. D. Crawford and H. F. Schaefer, Rev. Comp. Chem.; 14, 33-136 (2000).; (doi: 10.1002/9780470125915.ch2). Implementation of frozen natural orbital (FNO) coupled cluster theory; in PSI and its performance for non-covalent interactions is discussed; in. “Accurate Noncovalent Interaction Energies Using Truncated Basis Sets; Based on Frozen Natural Orbitals,” A. E. DePrince and C. D. Sherrill,; J. Chem. Theory Comput. 9, 293-299 (2013).; (doi: 10.1021/ct300780u). Implementation of density-fitted (DF) and Cholesky decomposition (CD); coupled cluster in PSI, and its performance for non-covalent interactions; and reaction energies, is discussed in. “Accuracy and Efficiency of Coupled-Cluster Theory Using; Density Fitting / Cholesky Decomposition, Frozen Natural Orbitals,; and a T1-Transformed Hamiltonian,” A. E. DePrince and C. D. Sherrill,; J. Chem. Theory Comput. 9, 2687-2696 (2013).; (doi: 10.1021/ct400250u). Implementation of the asymmetric triples correction for the density-fitted; and cholesky-decomposed coupled-cluster singles and doubles method. “A noniterative asymmetric triple excitation correction for the density-fitted; coupled-cluster singles and doubles method: Preliminary applications,”; U. Bozkaya, J. Chem. Phys. 144, 144108 (2016).; (doi: 10.1063/1.4945706). Implementation of analytic gradients for the density-fitted; coupled-cluster singles and doubles method. “Analytic energy gradients for the coupled-cluster singles and doubles method with; the density-fitting approximation,”; U. Bozkaya and C. D. Sherrill, J. Chem. P",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:11805,Performance,perform,perform,11805," F. A. Evangelista, W. D. Allen, and H. F. Schaefer,; J. Chem. Phys. 127, 024102 (2007).; (doi: 10.1063/1.2743014). Mk-MRCCSD(T). “Perturbative Triples Corrections in State-Specific Multireference; Coupled Cluster Theory,”; F. A. Evangelista, E. Prochnow, J. Gauss, and H. F. Schaefer,; J. Chem. Phys. 132, 074107 (2010).; (doi: 10.1063/1.3305335). Mk-MRCCSDT(-n). “Triple Excitations in State-Specific Multireference Coupled; Cluster Theory: Application of Mk-MRCCSDT and Mk-MRCCSDT-n Methods to; Model Systems,” F. A. Evangelista, A. C. Simmonett, W. D. Allen,; H. F. Schaefer, and J. Gauss, J. Chem. Phys. 128, 124104; (2008).; (doi: 10.1063/1.2834927). Mk-MRPT2. “A Companion Perturbation Theory for State-specific; Multireference Coupled Cluster Methods,”; F. A. Evangelista, A. C. Simmonett, H. F. Schaefer, D. Mukherjee, and; W. D. Allen,; Phys. Chem. Chem. Phys. 11, 4728-4741 (2009).; (doi: 10.1039/b822910d). Symmetry-Adapted Perturbation Theory (SAPT)¶; PSI4 features an extremely efficient code to perform wavefunction-based; Symmetry Adapted Perturbation Theory (SAPT). A good review article for this; method is as follows:. “Perturbation Theory Approach to Intermolecular Potential Energy; Surfaces of van der Waals Complexes,” B. Jeziorski, R. Moszynski,; and K. Szalewicz, Chem. Rev. 94, 1887-1930 (1994).; (doi: 10.1021/cr00031a008). PSI4 benefits enormously from the introduction of density fitting (DF); into SAPT. There are several SAPT truncations available in PSI4. For; guidance on which one to choose, see the SAPT section of the manual; and refer to the following systematic study:. “Levels of Symmetry Adapted Perturbation Theory (SAPT). I. Efficiency and; Performance for Interaction Energies,’’ T. M. Parker, L. A. Burns, R. M.; Parrish, A. G. Ryno, and C. D. Sherrill, J. Chem. Phys. 140,; 094106 (2014).; (doi: 10.1063/1.4867135). The theory and implementation of DF-SAPT is discussed; in the following papers for various levels of SAPT.; DF-SAPT0. “Large-scale Symmetry",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:15967,Performance,optimiz,optimized,15967,"bation Theory Interaction; Energy Components: The Functional-Group SAPT Partition,”; R. M. Parrish, T. M. Parker, and C. D. Sherrill,; J. Chem. Theory Comput. 10, 4417 (2014).; (doi: 10.1021/ct500724p).; “Communication: Practical Intramolecular Symmetry Adapted Perturbation Theory; via Hartree-Fock Embedding,”; R. M. Parrish, J. F. Gonthier, C. Corminboeuf, and C. D. Sherrill,; J. Chem. Phys. 143, 051103 (2015).; (doi: 10.1063/1.4927575). The derivation of the second-order exchange terms without the single-exchange; approximation are found in the following two works:. “Intermolecular exchange-induction energies without the overlap expansion,”; R. Schäffer and G. Jansen, Theor. Chem. Acc. 131, 1235 (2012).; (doi: 10.1007/s00214-012-1235-6); “Single-determinant-based symmetry-adapted perturbation theory without; single-exchange approximation,”; R. Schäffer and G. Jansen, Mol. Phys. 111, 2570 (2013).; (doi: 10.1080/00268976.2013.827253). Orbital-Optimized Post-Hartree–Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, J. Chem. Phys. 138, 184103 (2013).; (doi: 10.1063/1.4803662).; “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Ap",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:16066,Performance,optimiz,optimization,16066,"omput. 10, 4417 (2014).; (doi: 10.1021/ct500724p).; “Communication: Practical Intramolecular Symmetry Adapted Perturbation Theory; via Hartree-Fock Embedding,”; R. M. Parrish, J. F. Gonthier, C. Corminboeuf, and C. D. Sherrill,; J. Chem. Phys. 143, 051103 (2015).; (doi: 10.1063/1.4927575). The derivation of the second-order exchange terms without the single-exchange; approximation are found in the following two works:. “Intermolecular exchange-induction energies without the overlap expansion,”; R. Schäffer and G. Jansen, Theor. Chem. Acc. 131, 1235 (2012).; (doi: 10.1007/s00214-012-1235-6); “Single-determinant-based symmetry-adapted perturbation theory without; single-exchange approximation,”; R. Schäffer and G. Jansen, Mol. Phys. 111, 2570 (2013).; (doi: 10.1080/00268976.2013.827253). Orbital-Optimized Post-Hartree–Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, J. Chem. Phys. 138, 184103 (2013).; (doi: 10.1063/1.4803662).; “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:16095,Performance,optimiz,optimized,16095,"omput. 10, 4417 (2014).; (doi: 10.1021/ct500724p).; “Communication: Practical Intramolecular Symmetry Adapted Perturbation Theory; via Hartree-Fock Embedding,”; R. M. Parrish, J. F. Gonthier, C. Corminboeuf, and C. D. Sherrill,; J. Chem. Phys. 143, 051103 (2015).; (doi: 10.1063/1.4927575). The derivation of the second-order exchange terms without the single-exchange; approximation are found in the following two works:. “Intermolecular exchange-induction energies without the overlap expansion,”; R. Schäffer and G. Jansen, Theor. Chem. Acc. 131, 1235 (2012).; (doi: 10.1007/s00214-012-1235-6); “Single-determinant-based symmetry-adapted perturbation theory without; single-exchange approximation,”; R. Schäffer and G. Jansen, Mol. Phys. 111, 2570 (2013).; (doi: 10.1080/00268976.2013.827253). Orbital-Optimized Post-Hartree–Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, J. Chem. Phys. 138, 184103 (2013).; (doi: 10.1063/1.4803662).; “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:16151,Performance,optimiz,optimized,16151,"omput. 10, 4417 (2014).; (doi: 10.1021/ct500724p).; “Communication: Practical Intramolecular Symmetry Adapted Perturbation Theory; via Hartree-Fock Embedding,”; R. M. Parrish, J. F. Gonthier, C. Corminboeuf, and C. D. Sherrill,; J. Chem. Phys. 143, 051103 (2015).; (doi: 10.1063/1.4927575). The derivation of the second-order exchange terms without the single-exchange; approximation are found in the following two works:. “Intermolecular exchange-induction energies without the overlap expansion,”; R. Schäffer and G. Jansen, Theor. Chem. Acc. 131, 1235 (2012).; (doi: 10.1007/s00214-012-1235-6); “Single-determinant-based symmetry-adapted perturbation theory without; single-exchange approximation,”; R. Schäffer and G. Jansen, Mol. Phys. 111, 2570 (2013).; (doi: 10.1080/00268976.2013.827253). Orbital-Optimized Post-Hartree–Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, J. Chem. Phys. 138, 184103 (2013).; (doi: 10.1063/1.4803662).; “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:16396,Performance,optimiz,optimized,16396,". The derivation of the second-order exchange terms without the single-exchange; approximation are found in the following two works:. “Intermolecular exchange-induction energies without the overlap expansion,”; R. Schäffer and G. Jansen, Theor. Chem. Acc. 131, 1235 (2012).; (doi: 10.1007/s00214-012-1235-6); “Single-determinant-based symmetry-adapted perturbation theory without; single-exchange approximation,”; R. Schäffer and G. Jansen, Mol. Phys. 111, 2570 (2013).; (doi: 10.1080/00268976.2013.827253). Orbital-Optimized Post-Hartree–Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, J. Chem. Phys. 138, 184103 (2013).; (doi: 10.1063/1.4803662).; “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q).; “Analytic energy gradients for the orbital-optimized",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:16788,Performance,optimiz,optimized,16788,"imation,”; R. Schäffer and G. Jansen, Mol. Phys. 111, 2570 (2013).; (doi: 10.1080/00268976.2013.827253). Orbital-Optimized Post-Hartree–Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, J. Chem. Phys. 138, 184103 (2013).; (doi: 10.1063/1.4803662).; “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q).; “Analytic energy gradients for the orbital-optimized third-order Møller–Plesset; Perturbation Theory,” U. Bozkaya,; J. Chem. Phys. 139, 104116 (2013).; (doi: 10.1063/1.4820877). Orbital-optimized linearized coupled-cluster doubles method (OLCCD). “Orbital-optimized coupled-electron pair theory and its analytic gradients:; Accurate equilibrium geometries, harmonic vibrational frequencies, and hydrogen transfer; reactions,” U. Bozkaya and C. D. Sherrill",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:17396,Performance,optimiz,optimized,17396,"d second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, J. Chem. Phys. 138, 184103 (2013).; (doi: 10.1063/1.4803662).; “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q).; “Analytic energy gradients for the orbital-optimized third-order Møller–Plesset; Perturbation Theory,” U. Bozkaya,; J. Chem. Phys. 139, 104116 (2013).; (doi: 10.1063/1.4820877). Orbital-optimized linearized coupled-cluster doubles method (OLCCD). “Orbital-optimized coupled-electron pair theory and its analytic gradients:; Accurate equilibrium geometries, harmonic vibrational frequencies, and hydrogen transfer; reactions,” U. Bozkaya and C. D. Sherrill,; J. Chem. Phys. 139, 054104 (2013).; (doi: 10.1063/1.4816628). Orbital-optimized MP2.5 (OMP2.5). “Orbital-optimized MP2.5 and its analytic gradients: Approaching CCSD(T); quality for noncovalent interactions,” U. Bozkaya and C. D. Sherrill,; J. Chem. Phys. 141, 204105 (2014).; (doi: 10.1063/1.4902226). Extended Koopmans’ Theorem. “The extended Koopmans’ theorem for orbital-optimized methods: Accurate; computation of ionization potentials,” U. Bozkaya, J. Chem. Phys.; 139, 154105 (2013).; (doi: 10.1063/1.4825041).; “Accurate Electron Affinities from the Extended Koopmans’ Theorem Based on ",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:17539,Performance,optimiz,optimized,17539,"imized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q).; “Analytic energy gradients for the orbital-optimized third-order Møller–Plesset; Perturbation Theory,” U. Bozkaya,; J. Chem. Phys. 139, 104116 (2013).; (doi: 10.1063/1.4820877). Orbital-optimized linearized coupled-cluster doubles method (OLCCD). “Orbital-optimized coupled-electron pair theory and its analytic gradients:; Accurate equilibrium geometries, harmonic vibrational frequencies, and hydrogen transfer; reactions,” U. Bozkaya and C. D. Sherrill,; J. Chem. Phys. 139, 054104 (2013).; (doi: 10.1063/1.4816628). Orbital-optimized MP2.5 (OMP2.5). “Orbital-optimized MP2.5 and its analytic gradients: Approaching CCSD(T); quality for noncovalent interactions,” U. Bozkaya and C. D. Sherrill,; J. Chem. Phys. 141, 204105 (2014).; (doi: 10.1063/1.4902226). Extended Koopmans’ Theorem. “The extended Koopmans’ theorem for orbital-optimized methods: Accurate; computation of ionization potentials,” U. Bozkaya, J. Chem. Phys.; 139, 154105 (2013).; (doi: 10.1063/1.4825041).; “Accurate Electron Affinities from the Extended Koopmans’ Theorem Based on Orbital-Optimized Methods,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2041 (2014).; (doi: 10.1021/ct500186j). Density-Fitted and Cholesky-Decomposed Orbital-opti",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:17609,Performance,optimiz,optimized,17609,"tation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q).; “Analytic energy gradients for the orbital-optimized third-order Møller–Plesset; Perturbation Theory,” U. Bozkaya,; J. Chem. Phys. 139, 104116 (2013).; (doi: 10.1063/1.4820877). Orbital-optimized linearized coupled-cluster doubles method (OLCCD). “Orbital-optimized coupled-electron pair theory and its analytic gradients:; Accurate equilibrium geometries, harmonic vibrational frequencies, and hydrogen transfer; reactions,” U. Bozkaya and C. D. Sherrill,; J. Chem. Phys. 139, 054104 (2013).; (doi: 10.1063/1.4816628). Orbital-optimized MP2.5 (OMP2.5). “Orbital-optimized MP2.5 and its analytic gradients: Approaching CCSD(T); quality for noncovalent interactions,” U. Bozkaya and C. D. Sherrill,; J. Chem. Phys. 141, 204105 (2014).; (doi: 10.1063/1.4902226). Extended Koopmans’ Theorem. “The extended Koopmans’ theorem for orbital-optimized methods: Accurate; computation of ionization potentials,” U. Bozkaya, J. Chem. Phys.; 139, 154105 (2013).; (doi: 10.1063/1.4825041).; “Accurate Electron Affinities from the Extended Koopmans’ Theorem Based on Orbital-Optimized Methods,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2041 (2014).; (doi: 10.1021/ct500186j). Density-Fitted and Cholesky-Decomposed Orbital-optimized second-order perturbation theory (DF-OMP2). “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; a",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:17881,Performance,optimiz,optimized,17881," Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q).; “Analytic energy gradients for the orbital-optimized third-order Møller–Plesset; Perturbation Theory,” U. Bozkaya,; J. Chem. Phys. 139, 104116 (2013).; (doi: 10.1063/1.4820877). Orbital-optimized linearized coupled-cluster doubles method (OLCCD). “Orbital-optimized coupled-electron pair theory and its analytic gradients:; Accurate equilibrium geometries, harmonic vibrational frequencies, and hydrogen transfer; reactions,” U. Bozkaya and C. D. Sherrill,; J. Chem. Phys. 139, 054104 (2013).; (doi: 10.1063/1.4816628). Orbital-optimized MP2.5 (OMP2.5). “Orbital-optimized MP2.5 and its analytic gradients: Approaching CCSD(T); quality for noncovalent interactions,” U. Bozkaya and C. D. Sherrill,; J. Chem. Phys. 141, 204105 (2014).; (doi: 10.1063/1.4902226). Extended Koopmans’ Theorem. “The extended Koopmans’ theorem for orbital-optimized methods: Accurate; computation of ionization potentials,” U. Bozkaya, J. Chem. Phys.; 139, 154105 (2013).; (doi: 10.1063/1.4825041).; “Accurate Electron Affinities from the Extended Koopmans’ Theorem Based on Orbital-Optimized Methods,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2041 (2014).; (doi: 10.1021/ct500186j). Density-Fitted and Cholesky-Decomposed Orbital-optimized second-order perturbation theory (DF-OMP2). “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c).; “Analytic Energy Gradients and Spin Mult",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:17916,Performance,optimiz,optimized,17916,"Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q).; “Analytic energy gradients for the orbital-optimized third-order Møller–Plesset; Perturbation Theory,” U. Bozkaya,; J. Chem. Phys. 139, 104116 (2013).; (doi: 10.1063/1.4820877). Orbital-optimized linearized coupled-cluster doubles method (OLCCD). “Orbital-optimized coupled-electron pair theory and its analytic gradients:; Accurate equilibrium geometries, harmonic vibrational frequencies, and hydrogen transfer; reactions,” U. Bozkaya and C. D. Sherrill,; J. Chem. Phys. 139, 054104 (2013).; (doi: 10.1063/1.4816628). Orbital-optimized MP2.5 (OMP2.5). “Orbital-optimized MP2.5 and its analytic gradients: Approaching CCSD(T); quality for noncovalent interactions,” U. Bozkaya and C. D. Sherrill,; J. Chem. Phys. 141, 204105 (2014).; (doi: 10.1063/1.4902226). Extended Koopmans’ Theorem. “The extended Koopmans’ theorem for orbital-optimized methods: Accurate; computation of ionization potentials,” U. Bozkaya, J. Chem. Phys.; 139, 154105 (2013).; (doi: 10.1063/1.4825041).; “Accurate Electron Affinities from the Extended Koopmans’ Theorem Based on Orbital-Optimized Methods,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2041 (2014).; (doi: 10.1021/ct500186j). Density-Fitted and Cholesky-Decomposed Orbital-optimized second-order perturbation theory (DF-OMP2). “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c).; “Analytic Energy Gradients and Spin Multiplicities for Orbital-Optimized; ",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:18186,Performance,optimiz,optimized,18186,"pposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q).; “Analytic energy gradients for the orbital-optimized third-order Møller–Plesset; Perturbation Theory,” U. Bozkaya,; J. Chem. Phys. 139, 104116 (2013).; (doi: 10.1063/1.4820877). Orbital-optimized linearized coupled-cluster doubles method (OLCCD). “Orbital-optimized coupled-electron pair theory and its analytic gradients:; Accurate equilibrium geometries, harmonic vibrational frequencies, and hydrogen transfer; reactions,” U. Bozkaya and C. D. Sherrill,; J. Chem. Phys. 139, 054104 (2013).; (doi: 10.1063/1.4816628). Orbital-optimized MP2.5 (OMP2.5). “Orbital-optimized MP2.5 and its analytic gradients: Approaching CCSD(T); quality for noncovalent interactions,” U. Bozkaya and C. D. Sherrill,; J. Chem. Phys. 141, 204105 (2014).; (doi: 10.1063/1.4902226). Extended Koopmans’ Theorem. “The extended Koopmans’ theorem for orbital-optimized methods: Accurate; computation of ionization potentials,” U. Bozkaya, J. Chem. Phys.; 139, 154105 (2013).; (doi: 10.1063/1.4825041).; “Accurate Electron Affinities from the Extended Koopmans’ Theorem Based on Orbital-Optimized Methods,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2041 (2014).; (doi: 10.1021/ct500186j). Density-Fitted and Cholesky-Decomposed Orbital-optimized second-order perturbation theory (DF-OMP2). “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c).; “Analytic Energy Gradients and Spin Multiplicities for Orbital-Optimized; Second-Order Perturbation Theory with Density-Fitting Approximation: An; Efficient Implementation,” U. Bozkaya, J. Chem. Theory Comput. 10, 4389 (2014).; (doi: 10.1021/ct500634s). Density-Fitted and Cholesky-Decomposed Orbital-optimized MP3 and MP2.5 (DF-OMP3 and DF-OMP2.5). “Orbi",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:18561,Performance,optimiz,optimized,18561,"pled-cluster doubles method (OLCCD). “Orbital-optimized coupled-electron pair theory and its analytic gradients:; Accurate equilibrium geometries, harmonic vibrational frequencies, and hydrogen transfer; reactions,” U. Bozkaya and C. D. Sherrill,; J. Chem. Phys. 139, 054104 (2013).; (doi: 10.1063/1.4816628). Orbital-optimized MP2.5 (OMP2.5). “Orbital-optimized MP2.5 and its analytic gradients: Approaching CCSD(T); quality for noncovalent interactions,” U. Bozkaya and C. D. Sherrill,; J. Chem. Phys. 141, 204105 (2014).; (doi: 10.1063/1.4902226). Extended Koopmans’ Theorem. “The extended Koopmans’ theorem for orbital-optimized methods: Accurate; computation of ionization potentials,” U. Bozkaya, J. Chem. Phys.; 139, 154105 (2013).; (doi: 10.1063/1.4825041).; “Accurate Electron Affinities from the Extended Koopmans’ Theorem Based on Orbital-Optimized Methods,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2041 (2014).; (doi: 10.1021/ct500186j). Density-Fitted and Cholesky-Decomposed Orbital-optimized second-order perturbation theory (DF-OMP2). “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c).; “Analytic Energy Gradients and Spin Multiplicities for Orbital-Optimized; Second-Order Perturbation Theory with Density-Fitting Approximation: An; Efficient Implementation,” U. Bozkaya, J. Chem. Theory Comput. 10, 4389 (2014).; (doi: 10.1021/ct500634s). Density-Fitted and Cholesky-Decomposed Orbital-optimized MP3 and MP2.5 (DF-OMP3 and DF-OMP2.5). “Orbital-Optimized MP3 and MP2.5 with Density-Fitting; and Cholesky Decomposition Approximations,”; U. Bozkaya, J. Chem. Theory Comput. 12, 1179 (2016).; (doi: 10.1021/acs.jctc.5b01128). Density-Fitted and Cholesky-Decomposed Orbital-Optimized Linearized Coupled-Cluster Doubles Method (DF-OLCCD). “Orbital-optimized linearized coupled-cluster doubles with density-fitti",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:19145,Performance,optimiz,optimized,19145," Theorem. “The extended Koopmans’ theorem for orbital-optimized methods: Accurate; computation of ionization potentials,” U. Bozkaya, J. Chem. Phys.; 139, 154105 (2013).; (doi: 10.1063/1.4825041).; “Accurate Electron Affinities from the Extended Koopmans’ Theorem Based on Orbital-Optimized Methods,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2041 (2014).; (doi: 10.1021/ct500186j). Density-Fitted and Cholesky-Decomposed Orbital-optimized second-order perturbation theory (DF-OMP2). “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c).; “Analytic Energy Gradients and Spin Multiplicities for Orbital-Optimized; Second-Order Perturbation Theory with Density-Fitting Approximation: An; Efficient Implementation,” U. Bozkaya, J. Chem. Theory Comput. 10, 4389 (2014).; (doi: 10.1021/ct500634s). Density-Fitted and Cholesky-Decomposed Orbital-optimized MP3 and MP2.5 (DF-OMP3 and DF-OMP2.5). “Orbital-Optimized MP3 and MP2.5 with Density-Fitting; and Cholesky Decomposition Approximations,”; U. Bozkaya, J. Chem. Theory Comput. 12, 1179 (2016).; (doi: 10.1021/acs.jctc.5b01128). Density-Fitted and Cholesky-Decomposed Orbital-Optimized Linearized Coupled-Cluster Doubles Method (DF-OLCCD). “Orbital-optimized linearized coupled-cluster doubles with density-fitting; and Cholesky decomposition approximations: an efficient implementation,”; U. Bozkaya, Phys. Chem. Chem. Phys. 18, 11362 (2016).; (doi: 10.1039/c6cp00164e). Algebraic-Diagrammatic Construction methods (ADC)¶; General ADC theory. “Intermediate state representation approach to physical properties of; electronically excited molecules,”; J. Schirmer, and A. B. Trofimov, J. Chem. Phys. 120,; 11449-11464 (2004).; (doi: 10.1063/1.1752875). Implementation inside adcc,; the ADC backend used for most ADC methods available in PSI4. “adcc: A versatile toolkit for rapid d",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:19501,Performance,optimiz,optimized,19501,"zed second-order perturbation theory (DF-OMP2). “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c).; “Analytic Energy Gradients and Spin Multiplicities for Orbital-Optimized; Second-Order Perturbation Theory with Density-Fitting Approximation: An; Efficient Implementation,” U. Bozkaya, J. Chem. Theory Comput. 10, 4389 (2014).; (doi: 10.1021/ct500634s). Density-Fitted and Cholesky-Decomposed Orbital-optimized MP3 and MP2.5 (DF-OMP3 and DF-OMP2.5). “Orbital-Optimized MP3 and MP2.5 with Density-Fitting; and Cholesky Decomposition Approximations,”; U. Bozkaya, J. Chem. Theory Comput. 12, 1179 (2016).; (doi: 10.1021/acs.jctc.5b01128). Density-Fitted and Cholesky-Decomposed Orbital-Optimized Linearized Coupled-Cluster Doubles Method (DF-OLCCD). “Orbital-optimized linearized coupled-cluster doubles with density-fitting; and Cholesky decomposition approximations: an efficient implementation,”; U. Bozkaya, Phys. Chem. Chem. Phys. 18, 11362 (2016).; (doi: 10.1039/c6cp00164e). Algebraic-Diagrammatic Construction methods (ADC)¶; General ADC theory. “Intermediate state representation approach to physical properties of; electronically excited molecules,”; J. Schirmer, and A. B. Trofimov, J. Chem. Phys. 120,; 11449-11464 (2004).; (doi: 10.1063/1.1752875). Implementation inside adcc,; the ADC backend used for most ADC methods available in PSI4. “adcc: A versatile toolkit for rapid development of; algebraic-diagrammatic construction methods,”; M. F. Herbst, M. Scheurer, T. Fransson, D. R. Rehn, and A. Dreuw.; WIREs Comput. Mol. Sci., (2020).; (DOI: 10.1002/wcms.1462, Preprint https://adc-connect.org/q/publications. “Partially-renormalized” CIS(D) and ADC(2) [PR-CIS(D) and PR-ADC(2)]; and the implementation for ADC(2) excitation energies within PSI4. “Excited State Calculation for Free-Base and Metalloporphyrins",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:23403,Performance,perform,perform,23403,"rs. Compiler requirements are primarily; C++17 compliance (now GCC version 7.0 or above).; For some architectures, a precompiled binary is available. See Compiling and Installing for details. PythonPSI4 1.1 and 1.2 are supported on Python 2.7, 3.5,; and 3.6. After 1.2, only Python 3 will be supported; in accordance with other scientific software projects).; PSI4 1.3 supports Python 3.6 and 3.7.; PSI4 1.4 supports Python 3.6, 3.7, 3.8, and 3.9.; PSI4 1.5 supports Python 3.7, 3.8, and 3.9.; PSI4 1.6 supports Python 3.8, 3.9, and 3.10.; The future plan is to support the two or three latest Python versions.; The current master supports 3.8, 3.9, and 3.10. License¶; PSI4 is distributed under the GNU Lesser General Public License; version 3, LGPL-3.0. Its; required dependencies and add-ons have their own licenses, ranging from; BSD-2-Clause to GPL-2.0+. It is possible to build PSI4 without any; GPL dependencies. Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contracted Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Energy (CFOUR), Gradient,; Gradient (CFOUR), and Frequency. Summary of theoretical methods available in PSI4¶. Method; Energy; Gradient; Parallelism; Variants. Reference; Type; Reference; Type; OO 9; FNO 1; DLPNO. HF, HF-3c; RHF/UHF/ROHF; CONV/DF/CD; RHF/UHF/ROHF; CONV/DF; threaded. DFT, PBEh-3c; RKS/UKS; CONV/DF/CD 7; RKS/UKS; DF 4; threaded. EFP 5; RHF. —; —. DCT; RHF/UHF; CONV/DF; RHF/UHF; CONV; partially threaded. MP2 10; RHF/UHF/ROHF; CONV/DF/CD; RHF/UHF; CONV/DF; threaded 3; E/G. E. MP3 10; RHF/UHF; CONV/DF/CD; RHF/UHF; CONV/DF; threaded 3; E/G; E. MP2.5 10; RHF/UHF; CONV/DF/CD; RHF/UHF; CONV/DF; threaded 3; E/G. MP4 10; RHF; CONV; —; —; threaded 3. E. ",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:26193,Performance,optimiz,optimization,26193," RHF; CONV; —; —; threaded 3. E. CI(n); RHF/ROHF; CONV; —; —; partially threaded. FCI; RHF/ROHF; CONV; —; —; partially threaded. Mk-MRPT2; RHF/ROHF/TCSCF; CONV; —; —; threaded 3. Mk-MRCCSD; RHF/ROHF/TCSCF; CONV; —; —; threaded 3. Mk-MRCCSD(T); RHF/ROHF/TCSCF; CONV; —; —; threaded 3. RAS-CI; RHF/ROHF; CONV; —; —; partially threaded. CASSCF, RASSCF; RHF/ROHF; CONV/DF; —; —; partially threaded. SAPT; RHF; CONV; —; —; threaded. ADC(1); RHF/UHF; CONV; —; —; threaded. ADC(2); RHF/UHF; CONV; —; —; threaded. ADC(2)-x; RHF/UHF; CONV; —; —; threaded. ADC(3); RHF/UHF; CONV; —; —; threaded. CVS-ADC(1); RHF/UHF; CONV; —; —; threaded. CVS-ADC(2); RHF/UHF; CONV; —; —; threaded. CVS-ADC(2)-x; RHF/UHF; CONV; —; —; threaded. CVS-ADC(3); RHF/UHF; CONV; —; —; threaded. EOM-CC2; RHF; CONV; —; —; threaded 3. EOM-CCSD; RHF/UHF/ROHF; CONV; RHF/UHF/ROHF; CONV; threaded 3. EOM-CC3; RHF/UHF/ROHF; CONV; —; —; threaded 3. DMRG-CI; Y; CONV; —; —. DMRG-SCF; Y; CONV; —; —. Geometry optimization can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is distributed for free and without any guarantee of; reliability, accuracy, or suitability for any particular purpose. No; obligation to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries on the forum or GitHub. For bug reports,; specific and detailed information, with example inputs, would be; appreciated.; Where-to-post summary:6. How do I? – ask the forum; I got this error, why? – ask the forum; I got this error and I’m sure it’s a bug – file a GitHub issue; Can I open a discussion on this bit of code? – file a GitHub issue; I have an idea/request and a plan – file a GitHub issue; I have an idea/request –",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:26213,Performance,perform,performed,26213," RHF; CONV; —; —; threaded 3. E. CI(n); RHF/ROHF; CONV; —; —; partially threaded. FCI; RHF/ROHF; CONV; —; —; partially threaded. Mk-MRPT2; RHF/ROHF/TCSCF; CONV; —; —; threaded 3. Mk-MRCCSD; RHF/ROHF/TCSCF; CONV; —; —; threaded 3. Mk-MRCCSD(T); RHF/ROHF/TCSCF; CONV; —; —; threaded 3. RAS-CI; RHF/ROHF; CONV; —; —; partially threaded. CASSCF, RASSCF; RHF/ROHF; CONV/DF; —; —; partially threaded. SAPT; RHF; CONV; —; —; threaded. ADC(1); RHF/UHF; CONV; —; —; threaded. ADC(2); RHF/UHF; CONV; —; —; threaded. ADC(2)-x; RHF/UHF; CONV; —; —; threaded. ADC(3); RHF/UHF; CONV; —; —; threaded. CVS-ADC(1); RHF/UHF; CONV; —; —; threaded. CVS-ADC(2); RHF/UHF; CONV; —; —; threaded. CVS-ADC(2)-x; RHF/UHF; CONV; —; —; threaded. CVS-ADC(3); RHF/UHF; CONV; —; —; threaded. EOM-CC2; RHF; CONV; —; —; threaded 3. EOM-CCSD; RHF/UHF/ROHF; CONV; RHF/UHF/ROHF; CONV; threaded 3. EOM-CC3; RHF/UHF/ROHF; CONV; —; —; threaded 3. DMRG-CI; Y; CONV; —; —. DMRG-SCF; Y; CONV; —; —. Geometry optimization can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is distributed for free and without any guarantee of; reliability, accuracy, or suitability for any particular purpose. No; obligation to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries on the forum or GitHub. For bug reports,; specific and detailed information, with example inputs, would be; appreciated.; Where-to-post summary:6. How do I? – ask the forum; I got this error, why? – ask the forum; I got this error and I’m sure it’s a bug – file a GitHub issue; Can I open a discussion on this bit of code? – file a GitHub issue; I have an idea/request and a plan – file a GitHub issue; I have an idea/request –",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:28215,Performance,optimiz,optimized,28215," – file a GitHub issue; I have an idea/request and a plan – file a GitHub issue; I have an idea/request – ask the forum; Why do you? – ask the forum; When will you? – ask the forum; I have an experience that can improve the build documentation – inform the forum or add to the documentation itself; Anything you want to share privately – crawdad@vt.edu or sherrill@gatech.edu. Footnotes. 1; Frozen natural orbital variant available. In particular, RHF available as CONV. 2(1,2); Frozen natural orbital variant available. In particular, RHF available as CONV/DF. 3(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21); threading through BLAS routines only. 4; DFT gradients only implemented for SCF type DF. LRC-DFT gradients not implemented yet. DH-DFT gradients not implemented. 5; Both EFP/EFP and QM/EFP energies are available. 6; Adapted from here. 7; DH-DFT only available with DF-MP2. 8(1,2,3,4); Not all combinations of reference and algorithm available. In particular, non-RHF references only available as CONV. For CCSD(T), gradients are not available with frozen core. 9; Orbital-optimized variant available. In particular, all references available as CONV/DF. 10(1,2,3,4,5,6,7,8,9,10); Capabilities breakdown in great detail can be found here. table of contents. Introduction; Overview; Citing PSI4; Overall PSI4 Package; Density Cumulant Theory (DCT); Configuration Interaction (CI); Coupled Cluster (CC); Mukherjee State-Specific Multi-Reference Coupled Cluster (Mk-MRCC); Symmetry-Adapted Perturbation Theory (SAPT); Orbital-Optimized Post-Hartree–Fock Methods; Algebraic-Diagrammatic Construction methods (ADC); Density Matrix Renormalization Group (DMRG); Scalar Relativistic Corrections. Supported Systems; License; Capabilities; Technical Support. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Introduction. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:1532,Security,access,access,1532,"le some libraries and modules remain the same, the majority of the code has; been rewritten from scratch based on a powerful set of new libraries written; in C++. A totally new Python front-end makes PSI4 incredibly user-friendly; and automates many common tasks such as basis set extrapolation, composite; methods, running the same computation on every molecule in a test set, etc.; Density-functional theory, absent in Psi3, is quite efficient; in PSI4, with many functionals available. Density fitting is ubiquitous in; PSI4, leading to some of the most efficient MP2 and CCSD(T) code available.; PSI4 also introduces extensive,; powerful features for energy component analysis of non-covalent interactions; via symmetry-adapted perturbation theory. Orbital-optimized versions of; perturbation theory and coupled-cluster methods, and their analytic gradients,; have also been added. Through external libraries, PSI4 gains access to implicit; solvent (PCM) capabilities, density-matrix renormalization group CI, effective; fragment potentials, Grimme dispersion corrections, and high-order; coupled-cluster theory.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendices includ",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:975,Testability,test,test,975,"﻿. Introduction. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Introduction. Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; PSI4 is, in many ways, a whole new package compared to Psi3.; While some libraries and modules remain the same, the majority of the code has; been rewritten from scratch based on a powerful set of new libraries written; in C++. A totally new Python front-end makes PSI4 incredibly user-friendly; and automates many common tasks such as basis set extrapolation, composite; methods, running the same computation on every molecule in a test set, etc.; Density-functional theory, absent in Psi3, is quite efficient; in PSI4, with many functionals available. Density fitting is ubiquitous in; PSI4, leading to some of the most efficient MP2 and CCSD(T) code available.; PSI4 also introduces extensive,; powerful features for energy component analysis of non-covalent interactions; via symmetry-adapted perturbation theory. Orbital-optimized versions of; perturbation theory and coupled-cluster methods, and their analytic gradients,; have also been added. Through external libraries, PSI4 gains access to implicit; solvent (PCM) capabilities, density-matrix renormalization group CI, effective; fragment potentials, Grimme dispersion corrections, and high-order; coupled-cluster theory.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 inp",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:6535,Testability,benchmark,benchmark,6535,"82).; (doi: 10.1002/jcc.540030314).; “Starting SCF calculations by superposition of atomic; densities”, J. H. Van Lenthe, R. Zwaans, H. J. J. Van Dam,; and M. F. Guest, J. Comput. Chem. 27, 926 (2006).; (doi: 10.1002/jcc.20393). PSI4 also features a SAD natural orbital guess, an extended; Hückel guess that employs on-the-fly atomic calculations alike the SAD; guess, as well as a superposition of atomic potentials (SAP) guess; that is based on screening of atomic nuclei. The SAD natural orbitals,; Hückel and SAP guesses have been described in. “An assessment of initial guesses for self-consistent field; calculations. Superposition of Atomic Potentials: simple yet; efficient”, S. Lehtola, J. Chem. Theory Comput. 15,; 1593 (2019) (doi: 10.1021/acs.jctc.8b01089). Density Cumulant Theory (DCT)¶; PSI4 features several formulations of newly-developed density cumulant; theory (DCT), also known as density cumulant functional theory (DCFT).; The theory and benchmark of this theory are discussed in the following papers:; DC-06 (also known as DCT-06):. “Density Cumulant Functional Theory: First Implementation and; Benchmark Results for the DCFT-06 Model,” A. C. Simmonett,; J. J. Wilke, H. F. Schaefer, and W. Kutzelnigg, J. Chem. Phys.; 133, 174122 (2010).; (doi: 10.1063/1.3503657).; “Analytic gradients for density cumulant functional theory: The; DCFT-06 model,” A. Yu. Sokolov, J. J. Wilke, A. C. Simmonett,; and H. F. Schaefer, J. Chem. Phys. 137, 054105 (2012).; (doi: 10.1063/1.4739423). DC-12:. “Density cumulant functional theory: The DC-12 method, an improved; description of the one-particle density matrix,” A. Yu. Sokolov,; A. C. Simmonett, and H. F. Schaefer, J. Chem. Phys. 138, 024107; (2013).; (doi: 10.1063/1.4773580). ODC-06 and ODC-12:. “Orbital-optimized density cumulant functional theory,” A. Yu. Sokolov, and; H. F. Schaefer, J. Chem. Phys. 139, 204110 (2013).; (doi: 10.1063/1.4833138). ODC-13:. “Density cumulant functional theory from a unitary transformation:; N-re",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:446,Usability,simpl,simple,446,"﻿. Introduction. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Introduction. Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; PSI4 is, in many ways, a whole new package compared to Psi3.; While some libraries and modules remain the same, the majority of the code has; been rewritten from scratch based on a powerful set of new libraries written; in C++. A totally new Python front-end makes PSI4 incredibly user-friendly; and automates many common tasks such as basis set extrapolation, composite; methods, running the same computation on every molecule in a test set, etc.; Density-functional theory, absent in Psi3, is quite efficient; in PSI4, with many functionals available. Density fitting is ubiquitous in; PSI4, leading to some of the most efficient MP2 and CCSD(T) code available.; PSI4 also introduces extensive,; powerful features for energy component analysis of non-covalent interactions; via symmetry-adapted perturbation theory. Orbital-optimized versions of; perturbation theory and coupled-cluster methods, and their analytic gradients,; have also been added. Through external libraries, PSI4 gains access to implicit; solvent (PCM) capabilities, density-matrix renormalization group CI, effective; fragment potentials, Grimme dispersion corrections, and high-order; coupled-cluster theory.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 inp",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:823,Usability,user-friendly,user-friendly,823,"﻿. Introduction. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Introduction. Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; PSI4 is, in many ways, a whole new package compared to Psi3.; While some libraries and modules remain the same, the majority of the code has; been rewritten from scratch based on a powerful set of new libraries written; in C++. A totally new Python front-end makes PSI4 incredibly user-friendly; and automates many common tasks such as basis set extrapolation, composite; methods, running the same computation on every molecule in a test set, etc.; Density-functional theory, absent in Psi3, is quite efficient; in PSI4, with many functionals available. Density fitting is ubiquitous in; PSI4, leading to some of the most efficient MP2 and CCSD(T) code available.; PSI4 also introduces extensive,; powerful features for energy component analysis of non-covalent interactions; via symmetry-adapted perturbation theory. Orbital-optimized versions of; perturbation theory and coupled-cluster methods, and their analytic gradients,; have also been added. Through external libraries, PSI4 gains access to implicit; solvent (PCM) capabilities, density-matrix renormalization group CI, effective; fragment potentials, Grimme dispersion corrections, and high-order; coupled-cluster theory.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 inp",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:6234,Usability,simpl,simple,6234,"type of the calculation, an initial guess is; necessary. PSI4 features several initial guesses for the; molecular orbitals. The default guess is the superposition of atomic; densities (SAD), discussed in. “Principles for a direct SCF approach to LCAO-MO ab-initio; calculations”, J. Almlöf, K. Faegri, and K. Korsell,; J. Comput. Chem. 3, 385 (1982).; (doi: 10.1002/jcc.540030314).; “Starting SCF calculations by superposition of atomic; densities”, J. H. Van Lenthe, R. Zwaans, H. J. J. Van Dam,; and M. F. Guest, J. Comput. Chem. 27, 926 (2006).; (doi: 10.1002/jcc.20393). PSI4 also features a SAD natural orbital guess, an extended; Hückel guess that employs on-the-fly atomic calculations alike the SAD; guess, as well as a superposition of atomic potentials (SAP) guess; that is based on screening of atomic nuclei. The SAD natural orbitals,; Hückel and SAP guesses have been described in. “An assessment of initial guesses for self-consistent field; calculations. Superposition of Atomic Potentials: simple yet; efficient”, S. Lehtola, J. Chem. Theory Comput. 15,; 1593 (2019) (doi: 10.1021/acs.jctc.8b01089). Density Cumulant Theory (DCT)¶; PSI4 features several formulations of newly-developed density cumulant; theory (DCT), also known as density cumulant functional theory (DCFT).; The theory and benchmark of this theory are discussed in the following papers:; DC-06 (also known as DCT-06):. “Density Cumulant Functional Theory: First Implementation and; Benchmark Results for the DCFT-06 Model,” A. C. Simmonett,; J. J. Wilke, H. F. Schaefer, and W. Kutzelnigg, J. Chem. Phys.; 133, 174122 (2010).; (doi: 10.1063/1.3503657).; “Analytic gradients for density cumulant functional theory: The; DCFT-06 model,” A. Yu. Sokolov, J. J. Wilke, A. C. Simmonett,; and H. F. Schaefer, J. Chem. Phys. 137, 054105 (2012).; (doi: 10.1063/1.4739423). DC-12:. “Density cumulant functional theory: The DC-12 method, an improved; description of the one-particle density matrix,” A. Yu. Sokolov,; A. C. Simmo",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/introduction.html:12288,Usability,guid,guidance,12288,"t, W. D. Allen,; H. F. Schaefer, and J. Gauss, J. Chem. Phys. 128, 124104; (2008).; (doi: 10.1063/1.2834927). Mk-MRPT2. “A Companion Perturbation Theory for State-specific; Multireference Coupled Cluster Methods,”; F. A. Evangelista, A. C. Simmonett, H. F. Schaefer, D. Mukherjee, and; W. D. Allen,; Phys. Chem. Chem. Phys. 11, 4728-4741 (2009).; (doi: 10.1039/b822910d). Symmetry-Adapted Perturbation Theory (SAPT)¶; PSI4 features an extremely efficient code to perform wavefunction-based; Symmetry Adapted Perturbation Theory (SAPT). A good review article for this; method is as follows:. “Perturbation Theory Approach to Intermolecular Potential Energy; Surfaces of van der Waals Complexes,” B. Jeziorski, R. Moszynski,; and K. Szalewicz, Chem. Rev. 94, 1887-1930 (1994).; (doi: 10.1021/cr00031a008). PSI4 benefits enormously from the introduction of density fitting (DF); into SAPT. There are several SAPT truncations available in PSI4. For; guidance on which one to choose, see the SAPT section of the manual; and refer to the following systematic study:. “Levels of Symmetry Adapted Perturbation Theory (SAPT). I. Efficiency and; Performance for Interaction Energies,’’ T. M. Parker, L. A. Burns, R. M.; Parrish, A. G. Ryno, and C. D. Sherrill, J. Chem. Phys. 140,; 094106 (2014).; (doi: 10.1063/1.4867135). The theory and implementation of DF-SAPT is discussed; in the following papers for various levels of SAPT.; DF-SAPT0. “Large-scale Symmetry-adapted Perturbation Theory Computations via; Density Fitting and Laplace Transformation Techniques: Investigating the; Fundamental Forces of DNA-Intercalator Interactions,” E. G. Hohenstein,; R. M. Parrish, C. D. Sherrill, J. M. Turney, and H. F. Schaefer, J.; Chem. Phys. 135, 174017 (2011).; (doi: 10.1063/1.3656681).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of \(\pi - \pi\) Interactions in Linear Acenes,”; E. G. Hohenstein and ",MatchSource.WIKI,psi4manual/1.6.x/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html
https://psicode.org/psi4manual/1.6.x/libefp.html:529,Availability,down,downloads,529,"﻿. Interface to LIBEFP by I. Kaliman. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LIBEFP by I. Kaliman. Interface to LIBEFP by I. Kaliman¶; Code author: Andrew C. Simmonett, A. Eugene DePrince III, Rollin A. King, and Lori A. Burns; Section author: Lori A. Burns; Module: Keywords, PSI Variables, LIBEFP. PSI4 contains code to interface to the LIBEFP library developed; in L. Slipchenko’s group by I. Kaliman. LIBEFP; requires no additional licence,; downloads, or configuration. Since February 2017, libefp is not required to build; PSI4. Installation¶; Binary. libefp is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, libefp has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; libefp can be obtained through conda install libefp -c psi4.; Then enable it as a feature with ENABLE_libefp,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect libefp and activate dependent code. To remove a conda installation, conda remove libefp. Source. If using PSI4 built from source and you want libefp built from; from source also,; enable it as a feature with ENABLE_libefp,; and let the build system fetch and build it and activate dependent code. EFP Fragments¶; LIBEFP comes with a couple dozen ready-to-use fragments (water, benzene,; common solvents, etc.) listed here; with source https://github.com/libefp2/libefp/tree/master/fraglib. Any of these may be used directly in; a PSI4 input file as described here.; Creating new efp fragments requires the GAMESS quantum chemistry package.; Instructions on building new fragments are here.; Once your new fragment is ready, make it accessible to PSI4 by; including the directory in which the .efp file is located to the colon; separated environment variable PSIPATH. Fragments are",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:651,Availability,avail,available,651,"﻿. Interface to LIBEFP by I. Kaliman. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LIBEFP by I. Kaliman. Interface to LIBEFP by I. Kaliman¶; Code author: Andrew C. Simmonett, A. Eugene DePrince III, Rollin A. King, and Lori A. Burns; Section author: Lori A. Burns; Module: Keywords, PSI Variables, LIBEFP. PSI4 contains code to interface to the LIBEFP library developed; in L. Slipchenko’s group by I. Kaliman. LIBEFP; requires no additional licence,; downloads, or configuration. Since February 2017, libefp is not required to build; PSI4. Installation¶; Binary. libefp is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, libefp has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; libefp can be obtained through conda install libefp -c psi4.; Then enable it as a feature with ENABLE_libefp,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect libefp and activate dependent code. To remove a conda installation, conda remove libefp. Source. If using PSI4 built from source and you want libefp built from; from source also,; enable it as a feature with ENABLE_libefp,; and let the build system fetch and build it and activate dependent code. EFP Fragments¶; LIBEFP comes with a couple dozen ready-to-use fragments (water, benzene,; common solvents, etc.) listed here; with source https://github.com/libefp2/libefp/tree/master/fraglib. Any of these may be used directly in; a PSI4 input file as described here.; Creating new efp fragments requires the GAMESS quantum chemistry package.; Instructions on building new fragments are here.; Once your new fragment is ready, make it accessible to PSI4 by; including the directory in which the .efp file is located to the colon; separated environment variable PSIPATH. Fragments are",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:2156,Availability,error,error,2156,"ndent code. To remove a conda installation, conda remove libefp. Source. If using PSI4 built from source and you want libefp built from; from source also,; enable it as a feature with ENABLE_libefp,; and let the build system fetch and build it and activate dependent code. EFP Fragments¶; LIBEFP comes with a couple dozen ready-to-use fragments (water, benzene,; common solvents, etc.) listed here; with source https://github.com/libefp2/libefp/tree/master/fraglib. Any of these may be used directly in; a PSI4 input file as described here.; Creating new efp fragments requires the GAMESS quantum chemistry package.; Instructions on building new fragments are here.; Once your new fragment is ready, make it accessible to PSI4 by; including the directory in which the .efp file is located to the colon; separated environment variable PSIPATH. Fragments are searched; for first in the current directory, next in the paths of PSIPATH, and; finally in built-in library. If PSI4 is unable to find the; fragment, an error will be reported. Note; When constructing new fragment files, the name of the name of the; file should be lowercase and have extension .efp. The molecule name; within the file, e.g., $NH3 must correspond to the name of the; fragment file. Molecule Specification¶; EFP fragment geometries are specified alongside the quantum mechanical; (QM) molecule and make use of the -- fragment separation scheme; described here. Each EFP fragment has its own; fragment section that includes the label efp, the name of the file; fragname from which EFP parameters are to be read, and the position; specification for the fragment in one of two ways, XYZABC or POINTS. For; XYZABC, the fragment specification is all on one line: efp and; fragname are followed by two sets of three numbers: the coordinates; of the center of mass of the fragment and the three Euler angles that; specify orientation about the center of mass. This format is compact; but not readily generated from molecule viewing so",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:6910,Availability,error,error,6910,"FP is not so clean. In straightforward input files that involve; any number of [molecule block, energy/opt/etc, clean()] portions,; there should be no problem; the energy/opt computation will always; be run on the molecule defined in the preceding block. For advanced; users, unexpected difficulties may arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:6942,Availability,error,error,6942,"forward input files that involve; any number of [molecule block, energy/opt/etc, clean()] portions,; there should be no problem; the energy/opt computation will always; be run on the molecule defined in the preceding block. For advanced; users, unexpected difficulties may arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containi",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:7153,Availability,avail,available,7153,"n the preceding block. For advanced; users, unexpected difficulties may arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake v",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:543,Deployability,configurat,configuration,543,"﻿. Interface to LIBEFP by I. Kaliman. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LIBEFP by I. Kaliman. Interface to LIBEFP by I. Kaliman¶; Code author: Andrew C. Simmonett, A. Eugene DePrince III, Rollin A. King, and Lori A. Burns; Section author: Lori A. Burns; Module: Keywords, PSI Variables, LIBEFP. PSI4 contains code to interface to the LIBEFP library developed; in L. Slipchenko’s group by I. Kaliman. LIBEFP; requires no additional licence,; downloads, or configuration. Since February 2017, libefp is not required to build; PSI4. Installation¶; Binary. libefp is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, libefp has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; libefp can be obtained through conda install libefp -c psi4.; Then enable it as a feature with ENABLE_libefp,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect libefp and activate dependent code. To remove a conda installation, conda remove libefp. Source. If using PSI4 built from source and you want libefp built from; from source also,; enable it as a feature with ENABLE_libefp,; and let the build system fetch and build it and activate dependent code. EFP Fragments¶; LIBEFP comes with a couple dozen ready-to-use fragments (water, benzene,; common solvents, etc.) listed here; with source https://github.com/libefp2/libefp/tree/master/fraglib. Any of these may be used directly in; a PSI4 input file as described here.; Creating new efp fragments requires the GAMESS quantum chemistry package.; Instructions on building new fragments are here.; Once your new fragment is ready, make it accessible to PSI4 by; including the directory in which the .efp file is located to the colon; separated environment variable PSIPATH. Fragments are",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:792,Deployability,install,installed,792,"﻿. Interface to LIBEFP by I. Kaliman. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LIBEFP by I. Kaliman. Interface to LIBEFP by I. Kaliman¶; Code author: Andrew C. Simmonett, A. Eugene DePrince III, Rollin A. King, and Lori A. Burns; Section author: Lori A. Burns; Module: Keywords, PSI Variables, LIBEFP. PSI4 contains code to interface to the LIBEFP library developed; in L. Slipchenko’s group by I. Kaliman. LIBEFP; requires no additional licence,; downloads, or configuration. Since February 2017, libefp is not required to build; PSI4. Installation¶; Binary. libefp is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, libefp has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; libefp can be obtained through conda install libefp -c psi4.; Then enable it as a feature with ENABLE_libefp,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect libefp and activate dependent code. To remove a conda installation, conda remove libefp. Source. If using PSI4 built from source and you want libefp built from; from source also,; enable it as a feature with ENABLE_libefp,; and let the build system fetch and build it and activate dependent code. EFP Fragments¶; LIBEFP comes with a couple dozen ready-to-use fragments (water, benzene,; common solvents, etc.) listed here; with source https://github.com/libefp2/libefp/tree/master/fraglib. Any of these may be used directly in; a PSI4 input file as described here.; Creating new efp fragments requires the GAMESS quantum chemistry package.; Instructions on building new fragments are here.; Once your new fragment is ready, make it accessible to PSI4 by; including the directory in which the .efp file is located to the colon; separated environment variable PSIPATH. Fragments are",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:891,Deployability,install,installed,891,"﻿. Interface to LIBEFP by I. Kaliman. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LIBEFP by I. Kaliman. Interface to LIBEFP by I. Kaliman¶; Code author: Andrew C. Simmonett, A. Eugene DePrince III, Rollin A. King, and Lori A. Burns; Section author: Lori A. Burns; Module: Keywords, PSI Variables, LIBEFP. PSI4 contains code to interface to the LIBEFP library developed; in L. Slipchenko’s group by I. Kaliman. LIBEFP; requires no additional licence,; downloads, or configuration. Since February 2017, libefp is not required to build; PSI4. Installation¶; Binary. libefp is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, libefp has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; libefp can be obtained through conda install libefp -c psi4.; Then enable it as a feature with ENABLE_libefp,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect libefp and activate dependent code. To remove a conda installation, conda remove libefp. Source. If using PSI4 built from source and you want libefp built from; from source also,; enable it as a feature with ENABLE_libefp,; and let the build system fetch and build it and activate dependent code. EFP Fragments¶; LIBEFP comes with a couple dozen ready-to-use fragments (water, benzene,; common solvents, etc.) listed here; with source https://github.com/libefp2/libefp/tree/master/fraglib. Any of these may be used directly in; a PSI4 input file as described here.; Creating new efp fragments requires the GAMESS quantum chemistry package.; Instructions on building new fragments are here.; Once your new fragment is ready, make it accessible to PSI4 by; including the directory in which the .efp file is located to the colon; separated environment variable PSIPATH. Fragments are",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:977,Deployability,install,install,977,"﻿. Interface to LIBEFP by I. Kaliman. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LIBEFP by I. Kaliman. Interface to LIBEFP by I. Kaliman¶; Code author: Andrew C. Simmonett, A. Eugene DePrince III, Rollin A. King, and Lori A. Burns; Section author: Lori A. Burns; Module: Keywords, PSI Variables, LIBEFP. PSI4 contains code to interface to the LIBEFP library developed; in L. Slipchenko’s group by I. Kaliman. LIBEFP; requires no additional licence,; downloads, or configuration. Since February 2017, libefp is not required to build; PSI4. Installation¶; Binary. libefp is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, libefp has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; libefp can be obtained through conda install libefp -c psi4.; Then enable it as a feature with ENABLE_libefp,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect libefp and activate dependent code. To remove a conda installation, conda remove libefp. Source. If using PSI4 built from source and you want libefp built from; from source also,; enable it as a feature with ENABLE_libefp,; and let the build system fetch and build it and activate dependent code. EFP Fragments¶; LIBEFP comes with a couple dozen ready-to-use fragments (water, benzene,; common solvents, etc.) listed here; with source https://github.com/libefp2/libefp/tree/master/fraglib. Any of these may be used directly in; a PSI4 input file as described here.; Creating new efp fragments requires the GAMESS quantum chemistry package.; Instructions on building new fragments are here.; Once your new fragment is ready, make it accessible to PSI4 by; including the directory in which the .efp file is located to the colon; separated environment variable PSIPATH. Fragments are",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:1175,Deployability,install,installation,1175,"Interface to LIBEFP by I. Kaliman¶; Code author: Andrew C. Simmonett, A. Eugene DePrince III, Rollin A. King, and Lori A. Burns; Section author: Lori A. Burns; Module: Keywords, PSI Variables, LIBEFP. PSI4 contains code to interface to the LIBEFP library developed; in L. Slipchenko’s group by I. Kaliman. LIBEFP; requires no additional licence,; downloads, or configuration. Since February 2017, libefp is not required to build; PSI4. Installation¶; Binary. libefp is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, libefp has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; libefp can be obtained through conda install libefp -c psi4.; Then enable it as a feature with ENABLE_libefp,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect libefp and activate dependent code. To remove a conda installation, conda remove libefp. Source. If using PSI4 built from source and you want libefp built from; from source also,; enable it as a feature with ENABLE_libefp,; and let the build system fetch and build it and activate dependent code. EFP Fragments¶; LIBEFP comes with a couple dozen ready-to-use fragments (water, benzene,; common solvents, etc.) listed here; with source https://github.com/libefp2/libefp/tree/master/fraglib. Any of these may be used directly in; a PSI4 input file as described here.; Creating new efp fragments requires the GAMESS quantum chemistry package.; Instructions on building new fragments are here.; Once your new fragment is ready, make it accessible to PSI4 by; including the directory in which the .efp file is located to the colon; separated environment variable PSIPATH. Fragments are searched; for first in the current directory, next in the paths of PSIPATH, and; finally in built-in library. If PSI4 is unable to find the; fragment, an error will be reported. Not",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:7263,Deployability,configurat,configuration,7263,"e last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cm",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:7777,Deployability,install,installation,7777,"thod. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_libefp=ON. table of contents. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; R",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:7909,Deployability,install,installation,7909,"FP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_libefp=ON. table of contents. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    . ",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:9082,Deployability,update,updated,9082,"ilable from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_libefp=ON. table of contents. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LIBEFP by I. Kaliman. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:4926,Energy Efficiency,energy,energy,4926," format. Optimizations; are not allowed. Just as for QM, the center of mass; coordinates in the XYZABC format and all coordinates in the POINTS format are; taken to be in Angstroms by default or in Bohr if units au is present.; Charge and multiplicity specifications are encoded in the fragment file; and so are not read from input.; Any combination of EFP and QM fragments can be placed in a molecule; even; the oddity below is legitimate. Note that symmetry and reorientation are; automatically turned off when EFP fragments are present (symmetry c1; and no_com and no_reorient are implied).; molecule qmefp {; efp nh3 0.0 0.0 5.0 5 2 8; --; C 0.0 0.0 0.0; O 0.0 1.5 0.0; O 0.0 -1.5 0.0; --; efp h2o 5.0 0.0 0.0 5 2 8; --; He -3.0 4.0 4.0; He -4.0 5.0 4.0; --; efp ch3oh; 1.275 -2.447 -4.673; 0.709 -3.191 -3.592; 2.213 -1.978 -4.343; }. Running EFP¶; EFP can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the EFP interaction energy for benzene and two waters,; simply provide the following:; molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o 4.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. energy('efp'). This computation involves purely EFP/EFP fragment interactions and is; performed entirely by the LIBEFP library. PSI4 can also handle mixed; systems of quantum mechanical (QM) and EFP fragments through the native; SCF code augmented by calls to the LIBEFP library. For; example, turning one of the waters in the example above into a QM; fragment is shown below.; molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; O 4.0 0.0 0.0; H 4.7 0.7 0.0; H 3.3 -0.7 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. set basis 6-31g; energy('scf'). Whenever an EFP fragment is present in the active molecule, the SCF energy; will include EFP contributions. Warning; Although the EFP geometry is specified alongside the QM; geometry in a molecule name {...} block, internally the handling; of EFP is not so clean. In straightforw",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:5117,Energy Efficiency,energy,energy,5117,"by default or in Bohr if units au is present.; Charge and multiplicity specifications are encoded in the fragment file; and so are not read from input.; Any combination of EFP and QM fragments can be placed in a molecule; even; the oddity below is legitimate. Note that symmetry and reorientation are; automatically turned off when EFP fragments are present (symmetry c1; and no_com and no_reorient are implied).; molecule qmefp {; efp nh3 0.0 0.0 5.0 5 2 8; --; C 0.0 0.0 0.0; O 0.0 1.5 0.0; O 0.0 -1.5 0.0; --; efp h2o 5.0 0.0 0.0 5 2 8; --; He -3.0 4.0 4.0; He -4.0 5.0 4.0; --; efp ch3oh; 1.275 -2.447 -4.673; 0.709 -3.191 -3.592; 2.213 -1.978 -4.343; }. Running EFP¶; EFP can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the EFP interaction energy for benzene and two waters,; simply provide the following:; molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o 4.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. energy('efp'). This computation involves purely EFP/EFP fragment interactions and is; performed entirely by the LIBEFP library. PSI4 can also handle mixed; systems of quantum mechanical (QM) and EFP fragments through the native; SCF code augmented by calls to the LIBEFP library. For; example, turning one of the waters in the example above into a QM; fragment is shown below.; molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; O 4.0 0.0 0.0; H 4.7 0.7 0.0; H 3.3 -0.7 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. set basis 6-31g; energy('scf'). Whenever an EFP fragment is present in the active molecule, the SCF energy; will include EFP contributions. Warning; Although the EFP geometry is specified alongside the QM; geometry in a molecule name {...} block, internally the handling; of EFP is not so clean. In straightforward input files that involve; any number of [molecule block, energy/opt/etc, clean()] portions,; there should be no problem; the energy/opt computation will always; be run on the mo",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:5649,Energy Efficiency,energy,energy,5649," 0.0 0.0 5 2 8; --; He -3.0 4.0 4.0; He -4.0 5.0 4.0; --; efp ch3oh; 1.275 -2.447 -4.673; 0.709 -3.191 -3.592; 2.213 -1.978 -4.343; }. Running EFP¶; EFP can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the EFP interaction energy for benzene and two waters,; simply provide the following:; molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o 4.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. energy('efp'). This computation involves purely EFP/EFP fragment interactions and is; performed entirely by the LIBEFP library. PSI4 can also handle mixed; systems of quantum mechanical (QM) and EFP fragments through the native; SCF code augmented by calls to the LIBEFP library. For; example, turning one of the waters in the example above into a QM; fragment is shown below.; molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; O 4.0 0.0 0.0; H 4.7 0.7 0.0; H 3.3 -0.7 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. set basis 6-31g; energy('scf'). Whenever an EFP fragment is present in the active molecule, the SCF energy; will include EFP contributions. Warning; Although the EFP geometry is specified alongside the QM; geometry in a molecule name {...} block, internally the handling; of EFP is not so clean. In straightforward input files that involve; any number of [molecule block, energy/opt/etc, clean()] portions,; there should be no problem; the energy/opt computation will always; be run on the molecule defined in the preceding block. For advanced; users, unexpected difficulties may arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is onl",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:5732,Energy Efficiency,energy,energy,5732,".275 -2.447 -4.673; 0.709 -3.191 -3.592; 2.213 -1.978 -4.343; }. Running EFP¶; EFP can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the EFP interaction energy for benzene and two waters,; simply provide the following:; molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o 4.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. energy('efp'). This computation involves purely EFP/EFP fragment interactions and is; performed entirely by the LIBEFP library. PSI4 can also handle mixed; systems of quantum mechanical (QM) and EFP fragments through the native; SCF code augmented by calls to the LIBEFP library. For; example, turning one of the waters in the example above into a QM; fragment is shown below.; molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; O 4.0 0.0 0.0; H 4.7 0.7 0.0; H 3.3 -0.7 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. set basis 6-31g; energy('scf'). Whenever an EFP fragment is present in the active molecule, the SCF energy; will include EFP contributions. Warning; Although the EFP geometry is specified alongside the QM; geometry in a molecule name {...} block, internally the handling; of EFP is not so clean. In straightforward input files that involve; any number of [molecule block, energy/opt/etc, clean()] portions,; there should be no problem; the energy/opt computation will always; be run on the molecule defined in the preceding block. For advanced; users, unexpected difficulties may arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations a",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:6004,Energy Efficiency,energy,energy,6004,"fp h2o 4.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. energy('efp'). This computation involves purely EFP/EFP fragment interactions and is; performed entirely by the LIBEFP library. PSI4 can also handle mixed; systems of quantum mechanical (QM) and EFP fragments through the native; SCF code augmented by calls to the LIBEFP library. For; example, turning one of the waters in the example above into a QM; fragment is shown below.; molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; O 4.0 0.0 0.0; H 4.7 0.7 0.0; H 3.3 -0.7 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. set basis 6-31g; energy('scf'). Whenever an EFP fragment is present in the active molecule, the SCF energy; will include EFP contributions. Warning; Although the EFP geometry is specified alongside the QM; geometry in a molecule name {...} block, internally the handling; of EFP is not so clean. In straightforward input files that involve; any number of [molecule block, energy/opt/etc, clean()] portions,; there should be no problem; the energy/opt computation will always; be run on the molecule defined in the preceding block. For advanced; users, unexpected difficulties may arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM;",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:6072,Energy Efficiency,energy,energy,6072,"fp h2o 4.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. energy('efp'). This computation involves purely EFP/EFP fragment interactions and is; performed entirely by the LIBEFP library. PSI4 can also handle mixed; systems of quantum mechanical (QM) and EFP fragments through the native; SCF code augmented by calls to the LIBEFP library. For; example, turning one of the waters in the example above into a QM; fragment is shown below.; molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; O 4.0 0.0 0.0; H 4.7 0.7 0.0; H 3.3 -0.7 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. set basis 6-31g; energy('scf'). Whenever an EFP fragment is present in the active molecule, the SCF energy; will include EFP contributions. Warning; Although the EFP geometry is specified alongside the QM; geometry in a molecule name {...} block, internally the handling; of EFP is not so clean. In straightforward input files that involve; any number of [molecule block, energy/opt/etc, clean()] portions,; there should be no problem; the energy/opt computation will always; be run on the molecule defined in the preceding block. For advanced; users, unexpected difficulties may arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM;",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:6835,Energy Efficiency,energy,energy,6835,"QM; geometry in a molecule name {...} block, internally the handling; of EFP is not so clean. In straightforward input files that involve; any number of [molecule block, energy/opt/etc, clean()] portions,; there should be no problem; the energy/opt computation will always; be run on the molecule defined in the preceding block. For advanced; users, unexpected difficulties may arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_D",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:6967,Energy Efficiency,energy,energy,6967,"cule block, energy/opt/etc, clean()] portions,; there should be no problem; the energy/opt computation will always; be run on the molecule defined in the preceding block. For advanced; users, unexpected difficulties may arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISA",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:7050,Energy Efficiency,energy,energy,7050,"m; the energy/opt computation will always; be run on the molecule defined in the preceding block. For advanced; users, unexpected difficulties may arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libef",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:405,Integrability,interface,interface,405,"﻿. Interface to LIBEFP by I. Kaliman. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LIBEFP by I. Kaliman. Interface to LIBEFP by I. Kaliman¶; Code author: Andrew C. Simmonett, A. Eugene DePrince III, Rollin A. King, and Lori A. Burns; Section author: Lori A. Burns; Module: Keywords, PSI Variables, LIBEFP. PSI4 contains code to interface to the LIBEFP library developed; in L. Slipchenko’s group by I. Kaliman. LIBEFP; requires no additional licence,; downloads, or configuration. Since February 2017, libefp is not required to build; PSI4. Installation¶; Binary. libefp is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, libefp has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; libefp can be obtained through conda install libefp -c psi4.; Then enable it as a feature with ENABLE_libefp,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect libefp and activate dependent code. To remove a conda installation, conda remove libefp. Source. If using PSI4 built from source and you want libefp built from; from source also,; enable it as a feature with ENABLE_libefp,; and let the build system fetch and build it and activate dependent code. EFP Fragments¶; LIBEFP comes with a couple dozen ready-to-use fragments (water, benzene,; common solvents, etc.) listed here; with source https://github.com/libefp2/libefp/tree/master/fraglib. Any of these may be used directly in; a PSI4 input file as described here.; Creating new efp fragments requires the GAMESS quantum chemistry package.; Instructions on building new fragments are here.; Once your new fragment is ready, make it accessible to PSI4 by; including the directory in which the .efp file is located to the colon; separated environment variable PSIPATH. Fragments are",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:1141,Integrability,depend,dependent,1141,".    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LIBEFP by I. Kaliman. Interface to LIBEFP by I. Kaliman¶; Code author: Andrew C. Simmonett, A. Eugene DePrince III, Rollin A. King, and Lori A. Burns; Section author: Lori A. Burns; Module: Keywords, PSI Variables, LIBEFP. PSI4 contains code to interface to the LIBEFP library developed; in L. Slipchenko’s group by I. Kaliman. LIBEFP; requires no additional licence,; downloads, or configuration. Since February 2017, libefp is not required to build; PSI4. Installation¶; Binary. libefp is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, libefp has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; libefp can be obtained through conda install libefp -c psi4.; Then enable it as a feature with ENABLE_libefp,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect libefp and activate dependent code. To remove a conda installation, conda remove libefp. Source. If using PSI4 built from source and you want libefp built from; from source also,; enable it as a feature with ENABLE_libefp,; and let the build system fetch and build it and activate dependent code. EFP Fragments¶; LIBEFP comes with a couple dozen ready-to-use fragments (water, benzene,; common solvents, etc.) listed here; with source https://github.com/libefp2/libefp/tree/master/fraglib. Any of these may be used directly in; a PSI4 input file as described here.; Creating new efp fragments requires the GAMESS quantum chemistry package.; Instructions on building new fragments are here.; Once your new fragment is ready, make it accessible to PSI4 by; including the directory in which the .efp file is located to the colon; separated environment variable PSIPATH. Fragments are searched; for first in the current directory, next in the paths of PSIPATH, ",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:1402,Integrability,depend,dependent,1402,"n author: Lori A. Burns; Module: Keywords, PSI Variables, LIBEFP. PSI4 contains code to interface to the LIBEFP library developed; in L. Slipchenko’s group by I. Kaliman. LIBEFP; requires no additional licence,; downloads, or configuration. Since February 2017, libefp is not required to build; PSI4. Installation¶; Binary. libefp is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, libefp has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; libefp can be obtained through conda install libefp -c psi4.; Then enable it as a feature with ENABLE_libefp,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect libefp and activate dependent code. To remove a conda installation, conda remove libefp. Source. If using PSI4 built from source and you want libefp built from; from source also,; enable it as a feature with ENABLE_libefp,; and let the build system fetch and build it and activate dependent code. EFP Fragments¶; LIBEFP comes with a couple dozen ready-to-use fragments (water, benzene,; common solvents, etc.) listed here; with source https://github.com/libefp2/libefp/tree/master/fraglib. Any of these may be used directly in; a PSI4 input file as described here.; Creating new efp fragments requires the GAMESS quantum chemistry package.; Instructions on building new fragments are here.; Once your new fragment is ready, make it accessible to PSI4 by; including the directory in which the .efp file is located to the colon; separated environment variable PSIPATH. Fragments are searched; for first in the current directory, next in the paths of PSIPATH, and; finally in built-in library. If PSI4 is unable to find the; fragment, an error will be reported. Note; When constructing new fragment files, the name of the name of the; file should be lowercase and have extension .efp. The molecule n",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:7728,Integrability,depend,dependencies,7728,"efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_l",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:8623,Integrability,depend,dependencies,8623,"ilable from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_libefp=ON. table of contents. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LIBEFP by I. Kaliman. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:543,Modifiability,config,configuration,543,"﻿. Interface to LIBEFP by I. Kaliman. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LIBEFP by I. Kaliman. Interface to LIBEFP by I. Kaliman¶; Code author: Andrew C. Simmonett, A. Eugene DePrince III, Rollin A. King, and Lori A. Burns; Section author: Lori A. Burns; Module: Keywords, PSI Variables, LIBEFP. PSI4 contains code to interface to the LIBEFP library developed; in L. Slipchenko’s group by I. Kaliman. LIBEFP; requires no additional licence,; downloads, or configuration. Since February 2017, libefp is not required to build; PSI4. Installation¶; Binary. libefp is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, libefp has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; libefp can be obtained through conda install libefp -c psi4.; Then enable it as a feature with ENABLE_libefp,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect libefp and activate dependent code. To remove a conda installation, conda remove libefp. Source. If using PSI4 built from source and you want libefp built from; from source also,; enable it as a feature with ENABLE_libefp,; and let the build system fetch and build it and activate dependent code. EFP Fragments¶; LIBEFP comes with a couple dozen ready-to-use fragments (water, benzene,; common solvents, etc.) listed here; with source https://github.com/libefp2/libefp/tree/master/fraglib. Any of these may be used directly in; a PSI4 input file as described here.; Creating new efp fragments requires the GAMESS quantum chemistry package.; Instructions on building new fragments are here.; Once your new fragment is ready, make it accessible to PSI4 by; including the directory in which the .efp file is located to the colon; separated environment variable PSIPATH. Fragments are",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:1970,Modifiability,variab,variable,1970," be obtained through conda install libefp -c psi4.; Then enable it as a feature with ENABLE_libefp,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect libefp and activate dependent code. To remove a conda installation, conda remove libefp. Source. If using PSI4 built from source and you want libefp built from; from source also,; enable it as a feature with ENABLE_libefp,; and let the build system fetch and build it and activate dependent code. EFP Fragments¶; LIBEFP comes with a couple dozen ready-to-use fragments (water, benzene,; common solvents, etc.) listed here; with source https://github.com/libefp2/libefp/tree/master/fraglib. Any of these may be used directly in; a PSI4 input file as described here.; Creating new efp fragments requires the GAMESS quantum chemistry package.; Instructions on building new fragments are here.; Once your new fragment is ready, make it accessible to PSI4 by; including the directory in which the .efp file is located to the colon; separated environment variable PSIPATH. Fragments are searched; for first in the current directory, next in the paths of PSIPATH, and; finally in built-in library. If PSI4 is unable to find the; fragment, an error will be reported. Note; When constructing new fragment files, the name of the name of the; file should be lowercase and have extension .efp. The molecule name; within the file, e.g., $NH3 must correspond to the name of the; fragment file. Molecule Specification¶; EFP fragment geometries are specified alongside the quantum mechanical; (QM) molecule and make use of the -- fragment separation scheme; described here. Each EFP fragment has its own; fragment section that includes the label efp, the name of the file; fragname from which EFP parameters are to be read, and the position; specification for the fragment in one of two ways, XYZABC or POINTS. For; XYZABC, the fragment specification is all on one line: efp and; fragname are followed by two sets of three numbers: the coordinate",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:6988,Modifiability,coupling,coupling,6988,"cule block, energy/opt/etc, clean()] portions,; there should be no problem; the energy/opt computation will always; be run on the molecule defined in the preceding block. For advanced; users, unexpected difficulties may arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISA",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:7263,Modifiability,config,configuration,7263,"e last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cm",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:7285,Modifiability,config,configure,7285,"nd; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:7610,Modifiability,variab,variable,7610,"efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_l",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:7692,Modifiability,variab,variable,7692,"efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_l",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:7845,Modifiability,variab,variable,7845,"ixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_libefp=ON. table of contents. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. ",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:8024,Modifiability,variab,variable,8024,"ment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_libefp=ON. table of contents. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LIBEFP by I. Kaliman. © Copyright 2022, The Psi4 Project.; Last updated on Thursda",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:8140,Modifiability,variab,variable,8140,"ment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_libefp=ON. table of contents. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LIBEFP by I. Kaliman. © Copyright 2022, The Psi4 Project.; Last updated on Thursda",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:8466,Modifiability,config,configdir,8466,"ilable from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_libefp=ON. table of contents. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LIBEFP by I. Kaliman. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:8826,Modifiability,config,configure,8826,"ilable from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_libefp=ON. table of contents. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LIBEFP by I. Kaliman. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:5203,Performance,perform,performed,5203,"licity specifications are encoded in the fragment file; and so are not read from input.; Any combination of EFP and QM fragments can be placed in a molecule; even; the oddity below is legitimate. Note that symmetry and reorientation are; automatically turned off when EFP fragments are present (symmetry c1; and no_com and no_reorient are implied).; molecule qmefp {; efp nh3 0.0 0.0 5.0 5 2 8; --; C 0.0 0.0 0.0; O 0.0 1.5 0.0; O 0.0 -1.5 0.0; --; efp h2o 5.0 0.0 0.0 5 2 8; --; He -3.0 4.0 4.0; He -4.0 5.0 4.0; --; efp ch3oh; 1.275 -2.447 -4.673; 0.709 -3.191 -3.592; 2.213 -1.978 -4.343; }. Running EFP¶; EFP can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the EFP interaction energy for benzene and two waters,; simply provide the following:; molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o 4.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. energy('efp'). This computation involves purely EFP/EFP fragment interactions and is; performed entirely by the LIBEFP library. PSI4 can also handle mixed; systems of quantum mechanical (QM) and EFP fragments through the native; SCF code augmented by calls to the LIBEFP library. For; example, turning one of the waters in the example above into a QM; fragment is shown below.; molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; O 4.0 0.0 0.0; H 4.7 0.7 0.0; H 3.3 -0.7 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. set basis 6-31g; energy('scf'). Whenever an EFP fragment is present in the active molecule, the SCF energy; will include EFP contributions. Warning; Although the EFP geometry is specified alongside the QM; geometry in a molecule name {...} block, internally the handling; of EFP is not so clean. In straightforward input files that involve; any number of [molecule block, energy/opt/etc, clean()] portions,; there should be no problem; the energy/opt computation will always; be run on the molecule defined in the preceding block. For advanced; users, unex",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:6468,Performance,load,load,6468,"e native; SCF code augmented by calls to the LIBEFP library. For; example, turning one of the waters in the example above into a QM; fragment is shown below.; molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; O 4.0 0.0 0.0; H 4.7 0.7 0.0; H 3.3 -0.7 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. set basis 6-31g; energy('scf'). Whenever an EFP fragment is present in the active molecule, the SCF energy; will include EFP contributions. Warning; Although the EFP geometry is specified alongside the QM; geometry in a molecule name {...} block, internally the handling; of EFP is not so clean. In straightforward input files that involve; any number of [molecule block, energy/opt/etc, clean()] portions,; there should be no problem; the energy/opt computation will always; be run on the molecule defined in the preceding block. For advanced; users, unexpected difficulties may arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Depen",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:6657,Performance,perform,perform,6657,"nt is present in the active molecule, the SCF energy; will include EFP contributions. Warning; Although the EFP geometry is specified alongside the QM; geometry in a molecule name {...} block, internally the handling; of EFP is not so clean. In straightforward input files that involve; any number of [molecule block, energy/opt/etc, clean()] portions,; there should be no problem; the energy/opt computation will always; be run on the molecule defined in the preceding block. For advanced; users, unexpected difficulties may arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:6702,Performance,optimiz,optimizations,6702,"nt is present in the active molecule, the SCF energy; will include EFP contributions. Warning; Although the EFP geometry is specified alongside the QM; geometry in a molecule name {...} block, internally the handling; of EFP is not so clean. In straightforward input files that involve; any number of [molecule block, energy/opt/etc, clean()] portions,; there should be no problem; the energy/opt computation will always; be run on the molecule defined in the preceding block. For advanced; users, unexpected difficulties may arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:1114,Safety,detect,detect,1114,".    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LIBEFP by I. Kaliman. Interface to LIBEFP by I. Kaliman¶; Code author: Andrew C. Simmonett, A. Eugene DePrince III, Rollin A. King, and Lori A. Burns; Section author: Lori A. Burns; Module: Keywords, PSI Variables, LIBEFP. PSI4 contains code to interface to the LIBEFP library developed; in L. Slipchenko’s group by I. Kaliman. LIBEFP; requires no additional licence,; downloads, or configuration. Since February 2017, libefp is not required to build; PSI4. Installation¶; Binary. libefp is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, libefp has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; libefp can be obtained through conda install libefp -c psi4.; Then enable it as a feature with ENABLE_libefp,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect libefp and activate dependent code. To remove a conda installation, conda remove libefp. Source. If using PSI4 built from source and you want libefp built from; from source also,; enable it as a feature with ENABLE_libefp,; and let the build system fetch and build it and activate dependent code. EFP Fragments¶; LIBEFP comes with a couple dozen ready-to-use fragments (water, benzene,; common solvents, etc.) listed here; with source https://github.com/libefp2/libefp/tree/master/fraglib. Any of these may be used directly in; a PSI4 input file as described here.; Creating new efp fragments requires the GAMESS quantum chemistry package.; Instructions on building new fragments are here.; Once your new fragment is ready, make it accessible to PSI4 by; including the directory in which the .efp file is located to the colon; separated environment variable PSIPATH. Fragments are searched; for first in the current directory, next in the paths of PSIPATH, ",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:8078,Safety,detect,detecting,8078,"ment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_libefp=ON. table of contents. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LIBEFP by I. Kaliman. © Copyright 2022, The Psi4 Project.; Last updated on Thursda",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:8158,Safety,detect,detecting,8158,"ment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_libefp=ON. table of contents. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LIBEFP by I. Kaliman. © Copyright 2022, The Psi4 Project.; Last updated on Thursda",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:8515,Safety,detect,detectable,8515,"ilable from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_libefp=ON. table of contents. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LIBEFP by I. Kaliman. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:1853,Security,access,accessible,1853," miniconda has; already been installed (instructions at Quick Installation),; libefp can be obtained through conda install libefp -c psi4.; Then enable it as a feature with ENABLE_libefp,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect libefp and activate dependent code. To remove a conda installation, conda remove libefp. Source. If using PSI4 built from source and you want libefp built from; from source also,; enable it as a feature with ENABLE_libefp,; and let the build system fetch and build it and activate dependent code. EFP Fragments¶; LIBEFP comes with a couple dozen ready-to-use fragments (water, benzene,; common solvents, etc.) listed here; with source https://github.com/libefp2/libefp/tree/master/fraglib. Any of these may be used directly in; a PSI4 input file as described here.; Creating new efp fragments requires the GAMESS quantum chemistry package.; Instructions on building new fragments are here.; Once your new fragment is ready, make it accessible to PSI4 by; including the directory in which the .efp file is located to the colon; separated environment variable PSIPATH. Fragments are searched; for first in the current directory, next in the paths of PSIPATH, and; finally in built-in library. If PSI4 is unable to find the; fragment, an error will be reported. Note; When constructing new fragment files, the name of the name of the; file should be lowercase and have extension .efp. The molecule name; within the file, e.g., $NH3 must correspond to the name of the; fragment file. Molecule Specification¶; EFP fragment geometries are specified alongside the quantum mechanical; (QM) molecule and make use of the -- fragment separation scheme; described here. Each EFP fragment has its own; fragment section that includes the label efp, the name of the file; fragname from which EFP parameters are to be read, and the position; specification for the fragment in one of two ways, XYZABC or POINTS. For; XYZABC, the fragment specification is all",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:7207,Security,access,accessible,7207,"ay arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on i",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libefp.html:4962,Usability,simpl,simply,4962," format. Optimizations; are not allowed. Just as for QM, the center of mass; coordinates in the XYZABC format and all coordinates in the POINTS format are; taken to be in Angstroms by default or in Bohr if units au is present.; Charge and multiplicity specifications are encoded in the fragment file; and so are not read from input.; Any combination of EFP and QM fragments can be placed in a molecule; even; the oddity below is legitimate. Note that symmetry and reorientation are; automatically turned off when EFP fragments are present (symmetry c1; and no_com and no_reorient are implied).; molecule qmefp {; efp nh3 0.0 0.0 5.0 5 2 8; --; C 0.0 0.0 0.0; O 0.0 1.5 0.0; O 0.0 -1.5 0.0; --; efp h2o 5.0 0.0 0.0 5 2 8; --; He -3.0 4.0 4.0; He -4.0 5.0 4.0; --; efp ch3oh; 1.275 -2.447 -4.673; 0.709 -3.191 -3.592; 2.213 -1.978 -4.343; }. Running EFP¶; EFP can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the EFP interaction energy for benzene and two waters,; simply provide the following:; molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o 4.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. energy('efp'). This computation involves purely EFP/EFP fragment interactions and is; performed entirely by the LIBEFP library. PSI4 can also handle mixed; systems of quantum mechanical (QM) and EFP fragments through the native; SCF code augmented by calls to the LIBEFP library. For; example, turning one of the waters in the example above into a QM; fragment is shown below.; molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; O 4.0 0.0 0.0; H 4.7 0.7 0.0; H 3.3 -0.7 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. set basis 6-31g; energy('scf'). Whenever an EFP fragment is present in the active molecule, the SCF energy; will include EFP contributions. Warning; Although the EFP geometry is specified alongside the QM; geometry in a molecule name {...} block, internally the handling; of EFP is not so clean. In straightforw",MatchSource.WIKI,psi4manual/1.6.x/libefp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html
https://psicode.org/psi4manual/1.6.x/libint.html:462,Availability,down,downloads,462,"﻿. Interface to Libint by E. Valeev. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libint by E. Valeev. Interface to Libint by E. Valeev¶; Code author: Edward F. Valeev and Justin T. Fermann; Section author: Lori A. Burns. PSI4, particularly libmints utterly relies upon the Libint library; developed by E. Valeev from early roots by J. Fermann. Libint requires no; additional licence, downloads, or configuration. Conversely, PSI4; cannot build without Libint. Note; As of Nov 2020 or release v1.4, PSI4 uses Libint2, not Libint1.; Compared to many other open-source QC codes, PSI4 requires a separate; Libint compilation with a different integrals ordering. See notes at top of; psi4/external/upstream/libint2/CMakeLists.txt . Installation¶; Binary. Libint is available as a conda package for Linux and macOS and Windows.; If using the PSI4 binary, Libint has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; Libint can be obtained through conda install libint2 -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libint and activate dependent code. To remove a conda installation, conda remove libint2. Source. Note that PSI4 uses v2 and a modified branch. If using PSI4 built from source and you want Libint built from; from source also,; let the build system fetch and build it and activate dependent code.; Note that Libint2 has many more integral class enabling and AM knobs; than Libint1 and that the generation step (generator source to; library source) preceding the compilation step (library source to; built library) takes far longer than in Libint1 for production builds. How to configure Libint for building Psi4¶; Role and Dependencies. Role — In PSI4, Libint is a library that provides essential; two-body molecular integrals over Gaussian functions.; Downstream ",MatchSource.WIKI,psi4manual/1.6.x/libint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html
https://psicode.org/psi4manual/1.6.x/libint.html:838,Availability,avail,available,838,"﻿. Interface to Libint by E. Valeev. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libint by E. Valeev. Interface to Libint by E. Valeev¶; Code author: Edward F. Valeev and Justin T. Fermann; Section author: Lori A. Burns. PSI4, particularly libmints utterly relies upon the Libint library; developed by E. Valeev from early roots by J. Fermann. Libint requires no; additional licence, downloads, or configuration. Conversely, PSI4; cannot build without Libint. Note; As of Nov 2020 or release v1.4, PSI4 uses Libint2, not Libint1.; Compared to many other open-source QC codes, PSI4 requires a separate; Libint compilation with a different integrals ordering. See notes at top of; psi4/external/upstream/libint2/CMakeLists.txt . Installation¶; Binary. Libint is available as a conda package for Linux and macOS and Windows.; If using the PSI4 binary, Libint has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; Libint can be obtained through conda install libint2 -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libint and activate dependent code. To remove a conda installation, conda remove libint2. Source. Note that PSI4 uses v2 and a modified branch. If using PSI4 built from source and you want Libint built from; from source also,; let the build system fetch and build it and activate dependent code.; Note that Libint2 has many more integral class enabling and AM knobs; than Libint1 and that the generation step (generator source to; library source) preceding the compilation step (library source to; built library) takes far longer than in Libint1 for production builds. How to configure Libint for building Psi4¶; Role and Dependencies. Role — In PSI4, Libint is a library that provides essential; two-body molecular integrals over Gaussian functions.; Downstream ",MatchSource.WIKI,psi4manual/1.6.x/libint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html
https://psicode.org/psi4manual/1.6.x/libint.html:476,Deployability,configurat,configuration,476,"﻿. Interface to Libint by E. Valeev. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libint by E. Valeev. Interface to Libint by E. Valeev¶; Code author: Edward F. Valeev and Justin T. Fermann; Section author: Lori A. Burns. PSI4, particularly libmints utterly relies upon the Libint library; developed by E. Valeev from early roots by J. Fermann. Libint requires no; additional licence, downloads, or configuration. Conversely, PSI4; cannot build without Libint. Note; As of Nov 2020 or release v1.4, PSI4 uses Libint2, not Libint1.; Compared to many other open-source QC codes, PSI4 requires a separate; Libint compilation with a different integrals ordering. See notes at top of; psi4/external/upstream/libint2/CMakeLists.txt . Installation¶; Binary. Libint is available as a conda package for Linux and macOS and Windows.; If using the PSI4 binary, Libint has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; Libint can be obtained through conda install libint2 -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libint and activate dependent code. To remove a conda installation, conda remove libint2. Source. Note that PSI4 uses v2 and a modified branch. If using PSI4 built from source and you want Libint built from; from source also,; let the build system fetch and build it and activate dependent code.; Note that Libint2 has many more integral class enabling and AM knobs; than Libint1 and that the generation step (generator source to; library source) preceding the compilation step (library source to; built library) takes far longer than in Libint1 for production builds. How to configure Libint for building Psi4¶; Role and Dependencies. Role — In PSI4, Libint is a library that provides essential; two-body molecular integrals over Gaussian functions.; Downstream ",MatchSource.WIKI,psi4manual/1.6.x/libint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html
https://psicode.org/psi4manual/1.6.x/libint.html:562,Deployability,release,release,562,"﻿. Interface to Libint by E. Valeev. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libint by E. Valeev. Interface to Libint by E. Valeev¶; Code author: Edward F. Valeev and Justin T. Fermann; Section author: Lori A. Burns. PSI4, particularly libmints utterly relies upon the Libint library; developed by E. Valeev from early roots by J. Fermann. Libint requires no; additional licence, downloads, or configuration. Conversely, PSI4; cannot build without Libint. Note; As of Nov 2020 or release v1.4, PSI4 uses Libint2, not Libint1.; Compared to many other open-source QC codes, PSI4 requires a separate; Libint compilation with a different integrals ordering. See notes at top of; psi4/external/upstream/libint2/CMakeLists.txt . Installation¶; Binary. Libint is available as a conda package for Linux and macOS and Windows.; If using the PSI4 binary, Libint has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; Libint can be obtained through conda install libint2 -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libint and activate dependent code. To remove a conda installation, conda remove libint2. Source. Note that PSI4 uses v2 and a modified branch. If using PSI4 built from source and you want Libint built from; from source also,; let the build system fetch and build it and activate dependent code.; Note that Libint2 has many more integral class enabling and AM knobs; than Libint1 and that the generation step (generator source to; library source) preceding the compilation step (library source to; built library) takes far longer than in Libint1 for production builds. How to configure Libint for building Psi4¶; Role and Dependencies. Role — In PSI4, Libint is a library that provides essential; two-body molecular integrals over Gaussian functions.; Downstream ",MatchSource.WIKI,psi4manual/1.6.x/libint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html
https://psicode.org/psi4manual/1.6.x/libint.html:951,Deployability,install,installed,951,"﻿. Interface to Libint by E. Valeev. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libint by E. Valeev. Interface to Libint by E. Valeev¶; Code author: Edward F. Valeev and Justin T. Fermann; Section author: Lori A. Burns. PSI4, particularly libmints utterly relies upon the Libint library; developed by E. Valeev from early roots by J. Fermann. Libint requires no; additional licence, downloads, or configuration. Conversely, PSI4; cannot build without Libint. Note; As of Nov 2020 or release v1.4, PSI4 uses Libint2, not Libint1.; Compared to many other open-source QC codes, PSI4 requires a separate; Libint compilation with a different integrals ordering. See notes at top of; psi4/external/upstream/libint2/CMakeLists.txt . Installation¶; Binary. Libint is available as a conda package for Linux and macOS and Windows.; If using the PSI4 binary, Libint has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; Libint can be obtained through conda install libint2 -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libint and activate dependent code. To remove a conda installation, conda remove libint2. Source. Note that PSI4 uses v2 and a modified branch. If using PSI4 built from source and you want Libint built from; from source also,; let the build system fetch and build it and activate dependent code.; Note that Libint2 has many more integral class enabling and AM knobs; than Libint1 and that the generation step (generator source to; library source) preceding the compilation step (library source to; built library) takes far longer than in Libint1 for production builds. How to configure Libint for building Psi4¶; Role and Dependencies. Role — In PSI4, Libint is a library that provides essential; two-body molecular integrals over Gaussian functions.; Downstream ",MatchSource.WIKI,psi4manual/1.6.x/libint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html
https://psicode.org/psi4manual/1.6.x/libint.html:1050,Deployability,install,installed,1050,"  .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libint by E. Valeev. Interface to Libint by E. Valeev¶; Code author: Edward F. Valeev and Justin T. Fermann; Section author: Lori A. Burns. PSI4, particularly libmints utterly relies upon the Libint library; developed by E. Valeev from early roots by J. Fermann. Libint requires no; additional licence, downloads, or configuration. Conversely, PSI4; cannot build without Libint. Note; As of Nov 2020 or release v1.4, PSI4 uses Libint2, not Libint1.; Compared to many other open-source QC codes, PSI4 requires a separate; Libint compilation with a different integrals ordering. See notes at top of; psi4/external/upstream/libint2/CMakeLists.txt . Installation¶; Binary. Libint is available as a conda package for Linux and macOS and Windows.; If using the PSI4 binary, Libint has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; Libint can be obtained through conda install libint2 -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libint and activate dependent code. To remove a conda installation, conda remove libint2. Source. Note that PSI4 uses v2 and a modified branch. If using PSI4 built from source and you want Libint built from; from source also,; let the build system fetch and build it and activate dependent code.; Note that Libint2 has many more integral class enabling and AM knobs; than Libint1 and that the generation step (generator source to; library source) preceding the compilation step (library source to; built library) takes far longer than in Libint1 for production builds. How to configure Libint for building Psi4¶; Role and Dependencies. Role — In PSI4, Libint is a library that provides essential; two-body molecular integrals over Gaussian functions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies ",MatchSource.WIKI,psi4manual/1.6.x/libint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html
https://psicode.org/psi4manual/1.6.x/libint.html:1136,Deployability,install,install,1136,"  .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libint by E. Valeev. Interface to Libint by E. Valeev¶; Code author: Edward F. Valeev and Justin T. Fermann; Section author: Lori A. Burns. PSI4, particularly libmints utterly relies upon the Libint library; developed by E. Valeev from early roots by J. Fermann. Libint requires no; additional licence, downloads, or configuration. Conversely, PSI4; cannot build without Libint. Note; As of Nov 2020 or release v1.4, PSI4 uses Libint2, not Libint1.; Compared to many other open-source QC codes, PSI4 requires a separate; Libint compilation with a different integrals ordering. See notes at top of; psi4/external/upstream/libint2/CMakeLists.txt . Installation¶; Binary. Libint is available as a conda package for Linux and macOS and Windows.; If using the PSI4 binary, Libint has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; Libint can be obtained through conda install libint2 -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libint and activate dependent code. To remove a conda installation, conda remove libint2. Source. Note that PSI4 uses v2 and a modified branch. If using PSI4 built from source and you want Libint built from; from source also,; let the build system fetch and build it and activate dependent code.; Note that Libint2 has many more integral class enabling and AM knobs; than Libint1 and that the generation step (generator source to; library source) preceding the compilation step (library source to; built library) takes far longer than in Libint1 for production builds. How to configure Libint for building Psi4¶; Role and Dependencies. Role — In PSI4, Libint is a library that provides essential; two-body molecular integrals over Gaussian functions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies ",MatchSource.WIKI,psi4manual/1.6.x/libint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html
https://psicode.org/psi4manual/1.6.x/libint.html:1292,Deployability,install,installation,1292,"SI4, particularly libmints utterly relies upon the Libint library; developed by E. Valeev from early roots by J. Fermann. Libint requires no; additional licence, downloads, or configuration. Conversely, PSI4; cannot build without Libint. Note; As of Nov 2020 or release v1.4, PSI4 uses Libint2, not Libint1.; Compared to many other open-source QC codes, PSI4 requires a separate; Libint compilation with a different integrals ordering. See notes at top of; psi4/external/upstream/libint2/CMakeLists.txt . Installation¶; Binary. Libint is available as a conda package for Linux and macOS and Windows.; If using the PSI4 binary, Libint has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; Libint can be obtained through conda install libint2 -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libint and activate dependent code. To remove a conda installation, conda remove libint2. Source. Note that PSI4 uses v2 and a modified branch. If using PSI4 built from source and you want Libint built from; from source also,; let the build system fetch and build it and activate dependent code.; Note that Libint2 has many more integral class enabling and AM knobs; than Libint1 and that the generation step (generator source to; library source) preceding the compilation step (library source to; built library) takes far longer than in Libint1 for production builds. How to configure Libint for building Psi4¶; Role and Dependencies. Role — In PSI4, Libint is a library that provides essential; two-body molecular integrals over Gaussian functions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing include/libint2.h; Libint2_DIR — CMak",MatchSource.WIKI,psi4manual/1.6.x/libint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html
https://psicode.org/psi4manual/1.6.x/libint.html:2229,Deployability,install,installation,2229,"nt and activate dependent code. To remove a conda installation, conda remove libint2. Source. Note that PSI4 uses v2 and a modified branch. If using PSI4 built from source and you want Libint built from; from source also,; let the build system fetch and build it and activate dependent code.; Note that Libint2 has many more integral class enabling and AM knobs; than Libint1 and that the generation step (generator source to; library source) preceding the compilation step (library source to; built library) takes far longer than in Libint1 for production builds. How to configure Libint for building Psi4¶; Role and Dependencies. Role — In PSI4, Libint is a library that provides essential; two-body molecular integrals over Gaussian functions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing include/libint2.h; Libint2_DIR — CMake variable to specify where pre-built Libint can be found. Set to installation directory containing lib/cmake/libint2/libint2-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libint2 — CMake variable to force internal build of Libint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libint2 — CMake variable to force detecting pre-built Libint and not falling back on internal build; BUILD_Libint2_GENERATOR — CMake variable to allow internal build to start from generator source, not generated source; MAX_AM_ERI — CMake variable to specify minimum highest angular momentum built or detected. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libint/root. >>> cmake -DLibint_DIR2=/path/to/libint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON.",MatchSource.WIKI,psi4manual/1.6.x/libint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html
https://psicode.org/psi4manual/1.6.x/libint.html:2366,Deployability,install,installation,2366," built from source and you want Libint built from; from source also,; let the build system fetch and build it and activate dependent code.; Note that Libint2 has many more integral class enabling and AM knobs; than Libint1 and that the generation step (generator source to; library source) preceding the compilation step (library source to; built library) takes far longer than in Libint1 for production builds. How to configure Libint for building Psi4¶; Role and Dependencies. Role — In PSI4, Libint is a library that provides essential; two-body molecular integrals over Gaussian functions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing include/libint2.h; Libint2_DIR — CMake variable to specify where pre-built Libint can be found. Set to installation directory containing lib/cmake/libint2/libint2-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libint2 — CMake variable to force internal build of Libint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libint2 — CMake variable to force detecting pre-built Libint and not falling back on internal build; BUILD_Libint2_GENERATOR — CMake variable to allow internal build to start from generator source, not generated source; MAX_AM_ERI — CMake variable to specify minimum highest angular momentum built or detected. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libint/root. >>> cmake -DLibint_DIR2=/path/to/libint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. Build bundled shared library with up to AM=5. >>> cmake -DBUILD_SHARED_LIBS=ON. Build custom library from generator source. >>> # find the ""new-cmake-ha",MatchSource.WIKI,psi4manual/1.6.x/libint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html
https://psicode.org/psi4manual/1.6.x/libint.html:3925,Deployability,update,updated,3925,"m Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing include/libint2.h; Libint2_DIR — CMake variable to specify where pre-built Libint can be found. Set to installation directory containing lib/cmake/libint2/libint2-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libint2 — CMake variable to force internal build of Libint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libint2 — CMake variable to force detecting pre-built Libint and not falling back on internal build; BUILD_Libint2_GENERATOR — CMake variable to allow internal build to start from generator source, not generated source; MAX_AM_ERI — CMake variable to specify minimum highest angular momentum built or detected. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libint/root. >>> cmake -DLibint_DIR2=/path/to/libint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. Build bundled shared library with up to AM=5. >>> cmake -DBUILD_SHARED_LIBS=ON. Build custom library from generator source. >>> # find the ""new-cmake-harness-lab-rb1"" block at :source:`external/upstream/libint2/CMakeLists.txt`; >>> # edit the ""ENABLE"" and ""AM"" variables; >>> cmake -DBUILD_Libint2_GENERATOR=ON -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. table of contents. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libint by E. Valeev. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/libint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html
https://psicode.org/psi4manual/1.6.x/libint.html:1258,Integrability,depend,dependent,1258,"ode author: Edward F. Valeev and Justin T. Fermann; Section author: Lori A. Burns. PSI4, particularly libmints utterly relies upon the Libint library; developed by E. Valeev from early roots by J. Fermann. Libint requires no; additional licence, downloads, or configuration. Conversely, PSI4; cannot build without Libint. Note; As of Nov 2020 or release v1.4, PSI4 uses Libint2, not Libint1.; Compared to many other open-source QC codes, PSI4 requires a separate; Libint compilation with a different integrals ordering. See notes at top of; psi4/external/upstream/libint2/CMakeLists.txt . Installation¶; Binary. Libint is available as a conda package for Linux and macOS and Windows.; If using the PSI4 binary, Libint has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; Libint can be obtained through conda install libint2 -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libint and activate dependent code. To remove a conda installation, conda remove libint2. Source. Note that PSI4 uses v2 and a modified branch. If using PSI4 built from source and you want Libint built from; from source also,; let the build system fetch and build it and activate dependent code.; Note that Libint2 has many more integral class enabling and AM knobs; than Libint1 and that the generation step (generator source to; library source) preceding the compilation step (library source to; built library) takes far longer than in Libint1 for production builds. How to configure Libint for building Psi4¶; Role and Dependencies. Role — In PSI4, Libint is a library that provides essential; two-body molecular integrals over Gaussian functions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint",MatchSource.WIKI,psi4manual/1.6.x/libint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html
https://psicode.org/psi4manual/1.6.x/libint.html:1518,Integrability,depend,dependent,1518,"nce, downloads, or configuration. Conversely, PSI4; cannot build without Libint. Note; As of Nov 2020 or release v1.4, PSI4 uses Libint2, not Libint1.; Compared to many other open-source QC codes, PSI4 requires a separate; Libint compilation with a different integrals ordering. See notes at top of; psi4/external/upstream/libint2/CMakeLists.txt . Installation¶; Binary. Libint is available as a conda package for Linux and macOS and Windows.; If using the PSI4 binary, Libint has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; Libint can be obtained through conda install libint2 -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libint and activate dependent code. To remove a conda installation, conda remove libint2. Source. Note that PSI4 uses v2 and a modified branch. If using PSI4 built from source and you want Libint built from; from source also,; let the build system fetch and build it and activate dependent code.; Note that Libint2 has many more integral class enabling and AM knobs; than Libint1 and that the generation step (generator source to; library source) preceding the compilation step (library source to; built library) takes far longer than in Libint1 for production builds. How to configure Libint for building Psi4¶; Role and Dependencies. Role — In PSI4, Libint is a library that provides essential; two-body molecular integrals over Gaussian functions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing include/libint2.h; Libint2_DIR — CMake variable to specify where pre-built Libint can be found. Set to installation directory containing lib/cmake/libint2/libint2-config.cmake; CMAKE_DISABLE_FIN",MatchSource.WIKI,psi4manual/1.6.x/libint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html
https://psicode.org/psi4manual/1.6.x/libint.html:2180,Integrability,depend,dependencies,2180,".; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libint and activate dependent code. To remove a conda installation, conda remove libint2. Source. Note that PSI4 uses v2 and a modified branch. If using PSI4 built from source and you want Libint built from; from source also,; let the build system fetch and build it and activate dependent code.; Note that Libint2 has many more integral class enabling and AM knobs; than Libint1 and that the generation step (generator source to; library source) preceding the compilation step (library source to; built library) takes far longer than in Libint1 for production builds. How to configure Libint for building Psi4¶; Role and Dependencies. Role — In PSI4, Libint is a library that provides essential; two-body molecular integrals over Gaussian functions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing include/libint2.h; Libint2_DIR — CMake variable to specify where pre-built Libint can be found. Set to installation directory containing lib/cmake/libint2/libint2-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libint2 — CMake variable to force internal build of Libint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libint2 — CMake variable to force detecting pre-built Libint and not falling back on internal build; BUILD_Libint2_GENERATOR — CMake variable to allow internal build to start from generator source, not generated source; MAX_AM_ERI — CMake variable to specify minimum highest angular momentum built or detected. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libint/root. >>> cmake -DLibint_DIR2=/path/to/libint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/lib",MatchSource.WIKI,psi4manual/1.6.x/libint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html
https://psicode.org/psi4manual/1.6.x/libint.html:3185,Integrability,depend,dependencies,3185,"m Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing include/libint2.h; Libint2_DIR — CMake variable to specify where pre-built Libint can be found. Set to installation directory containing lib/cmake/libint2/libint2-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libint2 — CMake variable to force internal build of Libint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libint2 — CMake variable to force detecting pre-built Libint and not falling back on internal build; BUILD_Libint2_GENERATOR — CMake variable to allow internal build to start from generator source, not generated source; MAX_AM_ERI — CMake variable to specify minimum highest angular momentum built or detected. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libint/root. >>> cmake -DLibint_DIR2=/path/to/libint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. Build bundled shared library with up to AM=5. >>> cmake -DBUILD_SHARED_LIBS=ON. Build custom library from generator source. >>> # find the ""new-cmake-harness-lab-rb1"" block at :source:`external/upstream/libint2/CMakeLists.txt`; >>> # edit the ""ENABLE"" and ""AM"" variables; >>> cmake -DBUILD_Libint2_GENERATOR=ON -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. table of contents. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libint by E. Valeev. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/libint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html
https://psicode.org/psi4manual/1.6.x/libint.html:476,Modifiability,config,configuration,476,"﻿. Interface to Libint by E. Valeev. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libint by E. Valeev. Interface to Libint by E. Valeev¶; Code author: Edward F. Valeev and Justin T. Fermann; Section author: Lori A. Burns. PSI4, particularly libmints utterly relies upon the Libint library; developed by E. Valeev from early roots by J. Fermann. Libint requires no; additional licence, downloads, or configuration. Conversely, PSI4; cannot build without Libint. Note; As of Nov 2020 or release v1.4, PSI4 uses Libint2, not Libint1.; Compared to many other open-source QC codes, PSI4 requires a separate; Libint compilation with a different integrals ordering. See notes at top of; psi4/external/upstream/libint2/CMakeLists.txt . Installation¶; Binary. Libint is available as a conda package for Linux and macOS and Windows.; If using the PSI4 binary, Libint has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; Libint can be obtained through conda install libint2 -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libint and activate dependent code. To remove a conda installation, conda remove libint2. Source. Note that PSI4 uses v2 and a modified branch. If using PSI4 built from source and you want Libint built from; from source also,; let the build system fetch and build it and activate dependent code.; Note that Libint2 has many more integral class enabling and AM knobs; than Libint1 and that the generation step (generator source to; library source) preceding the compilation step (library source to; built library) takes far longer than in Libint1 for production builds. How to configure Libint for building Psi4¶; Role and Dependencies. Role — In PSI4, Libint is a library that provides essential; two-body molecular integrals over Gaussian functions.; Downstream ",MatchSource.WIKI,psi4manual/1.6.x/libint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html
https://psicode.org/psi4manual/1.6.x/libint.html:1814,Modifiability,config,configure,1814,"vailable as a conda package for Linux and macOS and Windows.; If using the PSI4 binary, Libint has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; Libint can be obtained through conda install libint2 -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libint and activate dependent code. To remove a conda installation, conda remove libint2. Source. Note that PSI4 uses v2 and a modified branch. If using PSI4 built from source and you want Libint built from; from source also,; let the build system fetch and build it and activate dependent code.; Note that Libint2 has many more integral class enabling and AM knobs; than Libint1 and that the generation step (generator source to; library source) preceding the compilation step (library source to; built library) takes far longer than in Libint1 for production builds. How to configure Libint for building Psi4¶; Role and Dependencies. Role — In PSI4, Libint is a library that provides essential; two-body molecular integrals over Gaussian functions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing include/libint2.h; Libint2_DIR — CMake variable to specify where pre-built Libint can be found. Set to installation directory containing lib/cmake/libint2/libint2-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libint2 — CMake variable to force internal build of Libint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libint2 — CMake variable to force detecting pre-built Libint and not falling back on internal build; BUILD_Libint2_GENERATOR — CMake variable to allow internal build to start from generator source, not generated source; MAX_AM_ERI — CMake variable to speci",MatchSource.WIKI,psi4manual/1.6.x/libint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html
https://psicode.org/psi4manual/1.6.x/libint.html:2144,Modifiability,variab,variable,2144,".; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libint and activate dependent code. To remove a conda installation, conda remove libint2. Source. Note that PSI4 uses v2 and a modified branch. If using PSI4 built from source and you want Libint built from; from source also,; let the build system fetch and build it and activate dependent code.; Note that Libint2 has many more integral class enabling and AM knobs; than Libint1 and that the generation step (generator source to; library source) preceding the compilation step (library source to; built library) takes far longer than in Libint1 for production builds. How to configure Libint for building Psi4¶; Role and Dependencies. Role — In PSI4, Libint is a library that provides essential; two-body molecular integrals over Gaussian functions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing include/libint2.h; Libint2_DIR — CMake variable to specify where pre-built Libint can be found. Set to installation directory containing lib/cmake/libint2/libint2-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libint2 — CMake variable to force internal build of Libint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libint2 — CMake variable to force detecting pre-built Libint and not falling back on internal build; BUILD_Libint2_GENERATOR — CMake variable to allow internal build to start from generator source, not generated source; MAX_AM_ERI — CMake variable to specify minimum highest angular momentum built or detected. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libint/root. >>> cmake -DLibint_DIR2=/path/to/libint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/lib",MatchSource.WIKI,psi4manual/1.6.x/libint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html
https://psicode.org/psi4manual/1.6.x/libint.html:2302,Modifiability,variab,variable,2302," libint2. Source. Note that PSI4 uses v2 and a modified branch. If using PSI4 built from source and you want Libint built from; from source also,; let the build system fetch and build it and activate dependent code.; Note that Libint2 has many more integral class enabling and AM knobs; than Libint1 and that the generation step (generator source to; library source) preceding the compilation step (library source to; built library) takes far longer than in Libint1 for production builds. How to configure Libint for building Psi4¶; Role and Dependencies. Role — In PSI4, Libint is a library that provides essential; two-body molecular integrals over Gaussian functions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing include/libint2.h; Libint2_DIR — CMake variable to specify where pre-built Libint can be found. Set to installation directory containing lib/cmake/libint2/libint2-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libint2 — CMake variable to force internal build of Libint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libint2 — CMake variable to force detecting pre-built Libint and not falling back on internal build; BUILD_Libint2_GENERATOR — CMake variable to allow internal build to start from generator source, not generated source; MAX_AM_ERI — CMake variable to specify minimum highest angular momentum built or detected. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libint/root. >>> cmake -DLibint_DIR2=/path/to/libint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. Build bundled shared library with up to AM=5. >>> cmake -DBUILD_SHARED_LIBS",MatchSource.WIKI,psi4manual/1.6.x/libint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html
https://psicode.org/psi4manual/1.6.x/libint.html:2426,Modifiability,config,config,2426," built from source and you want Libint built from; from source also,; let the build system fetch and build it and activate dependent code.; Note that Libint2 has many more integral class enabling and AM knobs; than Libint1 and that the generation step (generator source to; library source) preceding the compilation step (library source to; built library) takes far longer than in Libint1 for production builds. How to configure Libint for building Psi4¶; Role and Dependencies. Role — In PSI4, Libint is a library that provides essential; two-body molecular integrals over Gaussian functions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing include/libint2.h; Libint2_DIR — CMake variable to specify where pre-built Libint can be found. Set to installation directory containing lib/cmake/libint2/libint2-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libint2 — CMake variable to force internal build of Libint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libint2 — CMake variable to force detecting pre-built Libint and not falling back on internal build; BUILD_Libint2_GENERATOR — CMake variable to allow internal build to start from generator source, not generated source; MAX_AM_ERI — CMake variable to specify minimum highest angular momentum built or detected. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libint/root. >>> cmake -DLibint_DIR2=/path/to/libint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. Build bundled shared library with up to AM=5. >>> cmake -DBUILD_SHARED_LIBS=ON. Build custom library from generator source. >>> # find the ""new-cmake-ha",MatchSource.WIKI,psi4manual/1.6.x/libint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html
https://psicode.org/psi4manual/1.6.x/libint.html:2483,Modifiability,variab,variable,2483,"e to; library source) preceding the compilation step (library source to; built library) takes far longer than in Libint1 for production builds. How to configure Libint for building Psi4¶; Role and Dependencies. Role — In PSI4, Libint is a library that provides essential; two-body molecular integrals over Gaussian functions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing include/libint2.h; Libint2_DIR — CMake variable to specify where pre-built Libint can be found. Set to installation directory containing lib/cmake/libint2/libint2-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libint2 — CMake variable to force internal build of Libint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libint2 — CMake variable to force detecting pre-built Libint and not falling back on internal build; BUILD_Libint2_GENERATOR — CMake variable to allow internal build to start from generator source, not generated source; MAX_AM_ERI — CMake variable to specify minimum highest angular momentum built or detected. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libint/root. >>> cmake -DLibint_DIR2=/path/to/libint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. Build bundled shared library with up to AM=5. >>> cmake -DBUILD_SHARED_LIBS=ON. Build custom library from generator source. >>> # find the ""new-cmake-harness-lab-rb1"" block at :source:`external/upstream/libint2/CMakeLists.txt`; >>> # edit the ""ENABLE"" and ""AM"" variables; >>> cmake -DBUILD_Libint2_GENERATOR=ON -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. table of contents. Interface to Libint by E. Valeev; Installation; H",MatchSource.WIKI,psi4manual/1.6.x/libint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html
https://psicode.org/psi4manual/1.6.x/libint.html:2600,Modifiability,variab,variable,2600,"e to; library source) preceding the compilation step (library source to; built library) takes far longer than in Libint1 for production builds. How to configure Libint for building Psi4¶; Role and Dependencies. Role — In PSI4, Libint is a library that provides essential; two-body molecular integrals over Gaussian functions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing include/libint2.h; Libint2_DIR — CMake variable to specify where pre-built Libint can be found. Set to installation directory containing lib/cmake/libint2/libint2-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libint2 — CMake variable to force internal build of Libint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libint2 — CMake variable to force detecting pre-built Libint and not falling back on internal build; BUILD_Libint2_GENERATOR — CMake variable to allow internal build to start from generator source, not generated source; MAX_AM_ERI — CMake variable to specify minimum highest angular momentum built or detected. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libint/root. >>> cmake -DLibint_DIR2=/path/to/libint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. Build bundled shared library with up to AM=5. >>> cmake -DBUILD_SHARED_LIBS=ON. Build custom library from generator source. >>> # find the ""new-cmake-harness-lab-rb1"" block at :source:`external/upstream/libint2/CMakeLists.txt`; >>> # edit the ""ENABLE"" and ""AM"" variables; >>> cmake -DBUILD_Libint2_GENERATOR=ON -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. table of contents. Interface to Libint by E. Valeev; Installation; H",MatchSource.WIKI,psi4manual/1.6.x/libint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html
https://psicode.org/psi4manual/1.6.x/libint.html:2717,Modifiability,variab,variable,2717,"e to; library source) preceding the compilation step (library source to; built library) takes far longer than in Libint1 for production builds. How to configure Libint for building Psi4¶; Role and Dependencies. Role — In PSI4, Libint is a library that provides essential; two-body molecular integrals over Gaussian functions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing include/libint2.h; Libint2_DIR — CMake variable to specify where pre-built Libint can be found. Set to installation directory containing lib/cmake/libint2/libint2-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libint2 — CMake variable to force internal build of Libint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libint2 — CMake variable to force detecting pre-built Libint and not falling back on internal build; BUILD_Libint2_GENERATOR — CMake variable to allow internal build to start from generator source, not generated source; MAX_AM_ERI — CMake variable to specify minimum highest angular momentum built or detected. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libint/root. >>> cmake -DLibint_DIR2=/path/to/libint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. Build bundled shared library with up to AM=5. >>> cmake -DBUILD_SHARED_LIBS=ON. Build custom library from generator source. >>> # find the ""new-cmake-harness-lab-rb1"" block at :source:`external/upstream/libint2/CMakeLists.txt`; >>> # edit the ""ENABLE"" and ""AM"" variables; >>> cmake -DBUILD_Libint2_GENERATOR=ON -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. table of contents. Interface to Libint by E. Valeev; Installation; H",MatchSource.WIKI,psi4manual/1.6.x/libint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html
https://psicode.org/psi4manual/1.6.x/libint.html:2823,Modifiability,variab,variable,2823,"e to; library source) preceding the compilation step (library source to; built library) takes far longer than in Libint1 for production builds. How to configure Libint for building Psi4¶; Role and Dependencies. Role — In PSI4, Libint is a library that provides essential; two-body molecular integrals over Gaussian functions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing include/libint2.h; Libint2_DIR — CMake variable to specify where pre-built Libint can be found. Set to installation directory containing lib/cmake/libint2/libint2-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libint2 — CMake variable to force internal build of Libint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libint2 — CMake variable to force detecting pre-built Libint and not falling back on internal build; BUILD_Libint2_GENERATOR — CMake variable to allow internal build to start from generator source, not generated source; MAX_AM_ERI — CMake variable to specify minimum highest angular momentum built or detected. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libint/root. >>> cmake -DLibint_DIR2=/path/to/libint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. Build bundled shared library with up to AM=5. >>> cmake -DBUILD_SHARED_LIBS=ON. Build custom library from generator source. >>> # find the ""new-cmake-harness-lab-rb1"" block at :source:`external/upstream/libint2/CMakeLists.txt`; >>> # edit the ""ENABLE"" and ""AM"" variables; >>> cmake -DBUILD_Libint2_GENERATOR=ON -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. table of contents. Interface to Libint by E. Valeev; Installation; H",MatchSource.WIKI,psi4manual/1.6.x/libint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html
https://psicode.org/psi4manual/1.6.x/libint.html:3047,Modifiability,config,configdir,3047,"m Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing include/libint2.h; Libint2_DIR — CMake variable to specify where pre-built Libint can be found. Set to installation directory containing lib/cmake/libint2/libint2-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libint2 — CMake variable to force internal build of Libint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libint2 — CMake variable to force detecting pre-built Libint and not falling back on internal build; BUILD_Libint2_GENERATOR — CMake variable to allow internal build to start from generator source, not generated source; MAX_AM_ERI — CMake variable to specify minimum highest angular momentum built or detected. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libint/root. >>> cmake -DLibint_DIR2=/path/to/libint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. Build bundled shared library with up to AM=5. >>> cmake -DBUILD_SHARED_LIBS=ON. Build custom library from generator source. >>> # find the ""new-cmake-harness-lab-rb1"" block at :source:`external/upstream/libint2/CMakeLists.txt`; >>> # edit the ""ENABLE"" and ""AM"" variables; >>> cmake -DBUILD_Libint2_GENERATOR=ON -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. table of contents. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libint by E. Valeev. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/libint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html
https://psicode.org/psi4manual/1.6.x/libint.html:3505,Modifiability,variab,variables,3505,"m Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing include/libint2.h; Libint2_DIR — CMake variable to specify where pre-built Libint can be found. Set to installation directory containing lib/cmake/libint2/libint2-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libint2 — CMake variable to force internal build of Libint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libint2 — CMake variable to force detecting pre-built Libint and not falling back on internal build; BUILD_Libint2_GENERATOR — CMake variable to allow internal build to start from generator source, not generated source; MAX_AM_ERI — CMake variable to specify minimum highest angular momentum built or detected. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libint/root. >>> cmake -DLibint_DIR2=/path/to/libint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. Build bundled shared library with up to AM=5. >>> cmake -DBUILD_SHARED_LIBS=ON. Build custom library from generator source. >>> # find the ""new-cmake-harness-lab-rb1"" block at :source:`external/upstream/libint2/CMakeLists.txt`; >>> # edit the ""ENABLE"" and ""AM"" variables; >>> cmake -DBUILD_Libint2_GENERATOR=ON -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. table of contents. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libint by E. Valeev. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/libint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html
https://psicode.org/psi4manual/1.6.x/libint.html:3670,Modifiability,config,configure,3670,"m Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing include/libint2.h; Libint2_DIR — CMake variable to specify where pre-built Libint can be found. Set to installation directory containing lib/cmake/libint2/libint2-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libint2 — CMake variable to force internal build of Libint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libint2 — CMake variable to force detecting pre-built Libint and not falling back on internal build; BUILD_Libint2_GENERATOR — CMake variable to allow internal build to start from generator source, not generated source; MAX_AM_ERI — CMake variable to specify minimum highest angular momentum built or detected. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libint/root. >>> cmake -DLibint_DIR2=/path/to/libint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. Build bundled shared library with up to AM=5. >>> cmake -DBUILD_SHARED_LIBS=ON. Build custom library from generator source. >>> # find the ""new-cmake-harness-lab-rb1"" block at :source:`external/upstream/libint2/CMakeLists.txt`; >>> # edit the ""ENABLE"" and ""AM"" variables; >>> cmake -DBUILD_Libint2_GENERATOR=ON -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. table of contents. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libint by E. Valeev. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/libint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html
https://psicode.org/psi4manual/1.6.x/libint.html:1231,Safety,detect,detect,1231,"ode author: Edward F. Valeev and Justin T. Fermann; Section author: Lori A. Burns. PSI4, particularly libmints utterly relies upon the Libint library; developed by E. Valeev from early roots by J. Fermann. Libint requires no; additional licence, downloads, or configuration. Conversely, PSI4; cannot build without Libint. Note; As of Nov 2020 or release v1.4, PSI4 uses Libint2, not Libint1.; Compared to many other open-source QC codes, PSI4 requires a separate; Libint compilation with a different integrals ordering. See notes at top of; psi4/external/upstream/libint2/CMakeLists.txt . Installation¶; Binary. Libint is available as a conda package for Linux and macOS and Windows.; If using the PSI4 binary, Libint has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; Libint can be obtained through conda install libint2 -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libint and activate dependent code. To remove a conda installation, conda remove libint2. Source. Note that PSI4 uses v2 and a modified branch. If using PSI4 built from source and you want Libint built from; from source also,; let the build system fetch and build it and activate dependent code.; Note that Libint2 has many more integral class enabling and AM knobs; than Libint1 and that the generation step (generator source to; library source) preceding the compilation step (library source to; built library) takes far longer than in Libint1 for production builds. How to configure Libint for building Psi4¶; Role and Dependencies. Role — In PSI4, Libint is a library that provides essential; two-body molecular integrals over Gaussian functions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint",MatchSource.WIKI,psi4manual/1.6.x/libint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html
https://psicode.org/psi4manual/1.6.x/libint.html:2537,Safety,detect,detecting,2537,"e to; library source) preceding the compilation step (library source to; built library) takes far longer than in Libint1 for production builds. How to configure Libint for building Psi4¶; Role and Dependencies. Role — In PSI4, Libint is a library that provides essential; two-body molecular integrals over Gaussian functions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing include/libint2.h; Libint2_DIR — CMake variable to specify where pre-built Libint can be found. Set to installation directory containing lib/cmake/libint2/libint2-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libint2 — CMake variable to force internal build of Libint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libint2 — CMake variable to force detecting pre-built Libint and not falling back on internal build; BUILD_Libint2_GENERATOR — CMake variable to allow internal build to start from generator source, not generated source; MAX_AM_ERI — CMake variable to specify minimum highest angular momentum built or detected. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libint/root. >>> cmake -DLibint_DIR2=/path/to/libint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. Build bundled shared library with up to AM=5. >>> cmake -DBUILD_SHARED_LIBS=ON. Build custom library from generator source. >>> # find the ""new-cmake-harness-lab-rb1"" block at :source:`external/upstream/libint2/CMakeLists.txt`; >>> # edit the ""ENABLE"" and ""AM"" variables; >>> cmake -DBUILD_Libint2_GENERATOR=ON -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. table of contents. Interface to Libint by E. Valeev; Installation; H",MatchSource.WIKI,psi4manual/1.6.x/libint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html
https://psicode.org/psi4manual/1.6.x/libint.html:2618,Safety,detect,detecting,2618,"e to; library source) preceding the compilation step (library source to; built library) takes far longer than in Libint1 for production builds. How to configure Libint for building Psi4¶; Role and Dependencies. Role — In PSI4, Libint is a library that provides essential; two-body molecular integrals over Gaussian functions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing include/libint2.h; Libint2_DIR — CMake variable to specify where pre-built Libint can be found. Set to installation directory containing lib/cmake/libint2/libint2-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libint2 — CMake variable to force internal build of Libint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libint2 — CMake variable to force detecting pre-built Libint and not falling back on internal build; BUILD_Libint2_GENERATOR — CMake variable to allow internal build to start from generator source, not generated source; MAX_AM_ERI — CMake variable to specify minimum highest angular momentum built or detected. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libint/root. >>> cmake -DLibint_DIR2=/path/to/libint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. Build bundled shared library with up to AM=5. >>> cmake -DBUILD_SHARED_LIBS=ON. Build custom library from generator source. >>> # find the ""new-cmake-harness-lab-rb1"" block at :source:`external/upstream/libint2/CMakeLists.txt`; >>> # edit the ""ENABLE"" and ""AM"" variables; >>> cmake -DBUILD_Libint2_GENERATOR=ON -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. table of contents. Interface to Libint by E. Valeev; Installation; H",MatchSource.WIKI,psi4manual/1.6.x/libint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html
https://psicode.org/psi4manual/1.6.x/libint.html:2885,Safety,detect,detected,2885,"e to; library source) preceding the compilation step (library source to; built library) takes far longer than in Libint1 for production builds. How to configure Libint for building Psi4¶; Role and Dependencies. Role — In PSI4, Libint is a library that provides essential; two-body molecular integrals over Gaussian functions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing include/libint2.h; Libint2_DIR — CMake variable to specify where pre-built Libint can be found. Set to installation directory containing lib/cmake/libint2/libint2-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libint2 — CMake variable to force internal build of Libint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libint2 — CMake variable to force detecting pre-built Libint and not falling back on internal build; BUILD_Libint2_GENERATOR — CMake variable to allow internal build to start from generator source, not generated source; MAX_AM_ERI — CMake variable to specify minimum highest angular momentum built or detected. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libint/root. >>> cmake -DLibint_DIR2=/path/to/libint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. Build bundled shared library with up to AM=5. >>> cmake -DBUILD_SHARED_LIBS=ON. Build custom library from generator source. >>> # find the ""new-cmake-harness-lab-rb1"" block at :source:`external/upstream/libint2/CMakeLists.txt`; >>> # edit the ""ENABLE"" and ""AM"" variables; >>> cmake -DBUILD_Libint2_GENERATOR=ON -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. table of contents. Interface to Libint by E. Valeev; Installation; H",MatchSource.WIKI,psi4manual/1.6.x/libint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html
https://psicode.org/psi4manual/1.6.x/libint.html:3096,Safety,detect,detectable,3096,"m Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing include/libint2.h; Libint2_DIR — CMake variable to specify where pre-built Libint can be found. Set to installation directory containing lib/cmake/libint2/libint2-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libint2 — CMake variable to force internal build of Libint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libint2 — CMake variable to force detecting pre-built Libint and not falling back on internal build; BUILD_Libint2_GENERATOR — CMake variable to allow internal build to start from generator source, not generated source; MAX_AM_ERI — CMake variable to specify minimum highest angular momentum built or detected. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libint/root. >>> cmake -DLibint_DIR2=/path/to/libint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. Build bundled shared library with up to AM=5. >>> cmake -DBUILD_SHARED_LIBS=ON. Build custom library from generator source. >>> # find the ""new-cmake-harness-lab-rb1"" block at :source:`external/upstream/libint2/CMakeLists.txt`; >>> # edit the ""ENABLE"" and ""AM"" variables; >>> cmake -DBUILD_Libint2_GENERATOR=ON -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. table of contents. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libint by E. Valeev. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/libint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html
https://psicode.org/psi4manual/1.6.x/libxc.html:416,Availability,down,downloads,416,"﻿. Interface to Libxc by M. A. L. Marques. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libxc by M. A. L. Marques. Interface to Libxc by M. A. L. Marques¶; Code author: M. A. L. Marques and Micael Oliveira; Section author: Lori A. Burns. PSI4, relies upon the Libxc library for density functionals. Libxc; requires no; additional licence, downloads, or configuration. Conversely, PSI4; cannot build without Libxc. Installation¶; Binary. Libxc is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, Libxc has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; Libxc can be obtained through conda install libxc -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force intern",MatchSource.WIKI,psi4manual/1.6.x/libxc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libxc.html
https://psicode.org/psi4manual/1.6.x/libxc.html:523,Availability,avail,available,523,"﻿. Interface to Libxc by M. A. L. Marques. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libxc by M. A. L. Marques. Interface to Libxc by M. A. L. Marques¶; Code author: M. A. L. Marques and Micael Oliveira; Section author: Lori A. Burns. PSI4, relies upon the Libxc library for density functionals. Libxc; requires no; additional licence, downloads, or configuration. Conversely, PSI4; cannot build without Libxc. Installation¶; Binary. Libxc is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, Libxc has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; Libxc can be obtained through conda install libxc -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force intern",MatchSource.WIKI,psi4manual/1.6.x/libxc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libxc.html
https://psicode.org/psi4manual/1.6.x/libxc.html:430,Deployability,configurat,configuration,430,"﻿. Interface to Libxc by M. A. L. Marques. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libxc by M. A. L. Marques. Interface to Libxc by M. A. L. Marques¶; Code author: M. A. L. Marques and Micael Oliveira; Section author: Lori A. Burns. PSI4, relies upon the Libxc library for density functionals. Libxc; requires no; additional licence, downloads, or configuration. Conversely, PSI4; cannot build without Libxc. Installation¶; Binary. Libxc is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, Libxc has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; Libxc can be obtained through conda install libxc -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force intern",MatchSource.WIKI,psi4manual/1.6.x/libxc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libxc.html
https://psicode.org/psi4manual/1.6.x/libxc.html:663,Deployability,install,installed,663,"﻿. Interface to Libxc by M. A. L. Marques. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libxc by M. A. L. Marques. Interface to Libxc by M. A. L. Marques¶; Code author: M. A. L. Marques and Micael Oliveira; Section author: Lori A. Burns. PSI4, relies upon the Libxc library for density functionals. Libxc; requires no; additional licence, downloads, or configuration. Conversely, PSI4; cannot build without Libxc. Installation¶; Binary. Libxc is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, Libxc has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; Libxc can be obtained through conda install libxc -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force intern",MatchSource.WIKI,psi4manual/1.6.x/libxc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libxc.html
https://psicode.org/psi4manual/1.6.x/libxc.html:762,Deployability,install,installed,762,"﻿. Interface to Libxc by M. A. L. Marques. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libxc by M. A. L. Marques. Interface to Libxc by M. A. L. Marques¶; Code author: M. A. L. Marques and Micael Oliveira; Section author: Lori A. Burns. PSI4, relies upon the Libxc library for density functionals. Libxc; requires no; additional licence, downloads, or configuration. Conversely, PSI4; cannot build without Libxc. Installation¶; Binary. Libxc is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, Libxc has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; Libxc can be obtained through conda install libxc -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force intern",MatchSource.WIKI,psi4manual/1.6.x/libxc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libxc.html
https://psicode.org/psi4manual/1.6.x/libxc.html:847,Deployability,install,install,847,"﻿. Interface to Libxc by M. A. L. Marques. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libxc by M. A. L. Marques. Interface to Libxc by M. A. L. Marques¶; Code author: M. A. L. Marques and Micael Oliveira; Section author: Lori A. Burns. PSI4, relies upon the Libxc library for density functionals. Libxc; requires no; additional licence, downloads, or configuration. Conversely, PSI4; cannot build without Libxc. Installation¶; Binary. Libxc is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, Libxc has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; Libxc can be obtained through conda install libxc -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force intern",MatchSource.WIKI,psi4manual/1.6.x/libxc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libxc.html
https://psicode.org/psi4manual/1.6.x/libxc.html:1000,Deployability,install,installation,1000,"rface to Libxc by M. A. L. Marques. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libxc by M. A. L. Marques. Interface to Libxc by M. A. L. Marques¶; Code author: M. A. L. Marques and Micael Oliveira; Section author: Lori A. Burns. PSI4, relies upon the Libxc library for density functionals. Libxc; requires no; additional licence, downloads, or configuration. Conversely, PSI4; cannot build without Libxc. Installation¶; Binary. Libxc is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, Libxc has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; Libxc can be obtained through conda install libxc -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force internal bui",MatchSource.WIKI,psi4manual/1.6.x/libxc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libxc.html
https://psicode.org/psi4manual/1.6.x/libxc.html:1730,Deployability,install,installation,1730,"has; already been installed (instructions at Quick Installation),; Libxc can be obtained through conda install libxc -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force internal build of Libxc instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libxc — CMake variable to force detecting pre-built Libxc and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libxc/root. >>> cmake -DLibxc_DIR=/path/to/libxc/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libxc/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libxc=ON. table of contents. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces:",MatchSource.WIKI,psi4manual/1.6.x/libxc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libxc.html
https://psicode.org/psi4manual/1.6.x/libxc.html:1865,Deployability,install,installation,1865,"n with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force internal build of Libxc instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libxc — CMake variable to force detecting pre-built Libxc and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libxc/root. >>> cmake -DLibxc_DIR=/path/to/libxc/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libxc/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libxc=ON. table of contents. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libxc by M. A. L. Marques. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:",MatchSource.WIKI,psi4manual/1.6.x/libxc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libxc.html
https://psicode.org/psi4manual/1.6.x/libxc.html:2857,Deployability,update,updated,2857," PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force internal build of Libxc instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libxc — CMake variable to force detecting pre-built Libxc and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libxc/root. >>> cmake -DLibxc_DIR=/path/to/libxc/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libxc/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libxc=ON. table of contents. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libxc by M. A. L. Marques. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/libxc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libxc.html
https://psicode.org/psi4manual/1.6.x/libxc.html:966,Integrability,depend,dependent,966,"﻿. Interface to Libxc by M. A. L. Marques. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libxc by M. A. L. Marques. Interface to Libxc by M. A. L. Marques¶; Code author: M. A. L. Marques and Micael Oliveira; Section author: Lori A. Burns. PSI4, relies upon the Libxc library for density functionals. Libxc; requires no; additional licence, downloads, or configuration. Conversely, PSI4; cannot build without Libxc. Installation¶; Binary. Libxc is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, Libxc has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; Libxc can be obtained through conda install libxc -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force intern",MatchSource.WIKI,psi4manual/1.6.x/libxc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libxc.html
https://psicode.org/psi4manual/1.6.x/libxc.html:1302,Integrability,depend,dependent,1302,"hor: M. A. L. Marques and Micael Oliveira; Section author: Lori A. Burns. PSI4, relies upon the Libxc library for density functionals. Libxc; requires no; additional licence, downloads, or configuration. Conversely, PSI4; cannot build without Libxc. Installation¶; Binary. Libxc is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, Libxc has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; Libxc can be obtained through conda install libxc -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force internal build of Libxc instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libxc — CMake variable to force detecting pre-built Libxc and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cma",MatchSource.WIKI,psi4manual/1.6.x/libxc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libxc.html
https://psicode.org/psi4manual/1.6.x/libxc.html:1682,Integrability,depend,dependencies,1682,"n installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; Libxc can be obtained through conda install libxc -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force internal build of Libxc instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libxc — CMake variable to force detecting pre-built Libxc and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libxc/root. >>> cmake -DLibxc_DIR=/path/to/libxc/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libxc/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libxc=ON. table of contents. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; ",MatchSource.WIKI,psi4manual/1.6.x/libxc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libxc.html
https://psicode.org/psi4manual/1.6.x/libxc.html:2460,Integrability,depend,dependencies,2460," PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force internal build of Libxc instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libxc — CMake variable to force detecting pre-built Libxc and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libxc/root. >>> cmake -DLibxc_DIR=/path/to/libxc/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libxc/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libxc=ON. table of contents. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libxc by M. A. L. Marques. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/libxc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libxc.html
https://psicode.org/psi4manual/1.6.x/libxc.html:430,Modifiability,config,configuration,430,"﻿. Interface to Libxc by M. A. L. Marques. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libxc by M. A. L. Marques. Interface to Libxc by M. A. L. Marques¶; Code author: M. A. L. Marques and Micael Oliveira; Section author: Lori A. Burns. PSI4, relies upon the Libxc library for density functionals. Libxc; requires no; additional licence, downloads, or configuration. Conversely, PSI4; cannot build without Libxc. Installation¶; Binary. Libxc is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, Libxc has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; Libxc can be obtained through conda install libxc -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force intern",MatchSource.WIKI,psi4manual/1.6.x/libxc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libxc.html
https://psicode.org/psi4manual/1.6.x/libxc.html:1325,Modifiability,config,configure,1325," for density functionals. Libxc; requires no; additional licence, downloads, or configuration. Conversely, PSI4; cannot build without Libxc. Installation¶; Binary. Libxc is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, Libxc has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; Libxc can be obtained through conda install libxc -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force internal build of Libxc instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libxc — CMake variable to force detecting pre-built Libxc and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libxc/root. >>> cmake -DLibxc_DIR=/path/to/libxc/configdir. Build bundled de",MatchSource.WIKI,psi4manual/1.6.x/libxc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libxc.html
https://psicode.org/psi4manual/1.6.x/libxc.html:1646,Modifiability,variab,variable,1646,"n installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; Libxc can be obtained through conda install libxc -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force internal build of Libxc instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libxc — CMake variable to force detecting pre-built Libxc and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libxc/root. >>> cmake -DLibxc_DIR=/path/to/libxc/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libxc/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libxc=ON. table of contents. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; ",MatchSource.WIKI,psi4manual/1.6.x/libxc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libxc.html
https://psicode.org/psi4manual/1.6.x/libxc.html:1802,Modifiability,variab,variable,1802,"n be obtained through conda install libxc -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force internal build of Libxc instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libxc — CMake variable to force detecting pre-built Libxc and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libxc/root. >>> cmake -DLibxc_DIR=/path/to/libxc/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libxc/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libxc=ON. table of contents. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libxc by M. A. L. Marques. © Co",MatchSource.WIKI,psi4manual/1.6.x/libxc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libxc.html
https://psicode.org/psi4manual/1.6.x/libxc.html:1977,Modifiability,variab,variable,1977," PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force internal build of Libxc instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libxc — CMake variable to force detecting pre-built Libxc and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libxc/root. >>> cmake -DLibxc_DIR=/path/to/libxc/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libxc/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libxc=ON. table of contents. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libxc by M. A. L. Marques. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/libxc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libxc.html
https://psicode.org/psi4manual/1.6.x/libxc.html:2091,Modifiability,variab,variable,2091," PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force internal build of Libxc instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libxc — CMake variable to force detecting pre-built Libxc and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libxc/root. >>> cmake -DLibxc_DIR=/path/to/libxc/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libxc/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libxc=ON. table of contents. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libxc by M. A. L. Marques. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/libxc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libxc.html
https://psicode.org/psi4manual/1.6.x/libxc.html:2323,Modifiability,config,configdir,2323," PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force internal build of Libxc instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libxc — CMake variable to force detecting pre-built Libxc and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libxc/root. >>> cmake -DLibxc_DIR=/path/to/libxc/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libxc/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libxc=ON. table of contents. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libxc by M. A. L. Marques. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/libxc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libxc.html
https://psicode.org/psi4manual/1.6.x/libxc.html:2597,Modifiability,config,configure,2597," PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force internal build of Libxc instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libxc — CMake variable to force detecting pre-built Libxc and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libxc/root. >>> cmake -DLibxc_DIR=/path/to/libxc/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libxc/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libxc=ON. table of contents. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libxc by M. A. L. Marques. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/libxc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libxc.html
https://psicode.org/psi4manual/1.6.x/libxc.html:940,Safety,detect,detect,940,"﻿. Interface to Libxc by M. A. L. Marques. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libxc by M. A. L. Marques. Interface to Libxc by M. A. L. Marques¶; Code author: M. A. L. Marques and Micael Oliveira; Section author: Lori A. Burns. PSI4, relies upon the Libxc library for density functionals. Libxc; requires no; additional licence, downloads, or configuration. Conversely, PSI4; cannot build without Libxc. Installation¶; Binary. Libxc is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, Libxc has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; Libxc can be obtained through conda install libxc -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force intern",MatchSource.WIKI,psi4manual/1.6.x/libxc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libxc.html
https://psicode.org/psi4manual/1.6.x/libxc.html:2030,Safety,detect,detecting,2030," PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force internal build of Libxc instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libxc — CMake variable to force detecting pre-built Libxc and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libxc/root. >>> cmake -DLibxc_DIR=/path/to/libxc/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libxc/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libxc=ON. table of contents. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libxc by M. A. L. Marques. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/libxc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libxc.html
https://psicode.org/psi4manual/1.6.x/libxc.html:2109,Safety,detect,detecting,2109," PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force internal build of Libxc instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libxc — CMake variable to force detecting pre-built Libxc and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libxc/root. >>> cmake -DLibxc_DIR=/path/to/libxc/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libxc/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libxc=ON. table of contents. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libxc by M. A. L. Marques. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/libxc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libxc.html
https://psicode.org/psi4manual/1.6.x/libxc.html:2372,Safety,detect,detectable,2372," PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force internal build of Libxc instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libxc — CMake variable to force detecting pre-built Libxc and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libxc/root. >>> cmake -DLibxc_DIR=/path/to/libxc/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libxc/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libxc=ON. table of contents. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libxc by M. A. L. Marques. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/libxc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libxc.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:2956,Availability,error,errors,2956,"me. After all,; that’s what PSI4 does. How to integrate an Add-On into build, testing, and docs¶. In all cases, put Add-Ons in alphabetic order, ignoring any “lib” in the name.; psi4/CMakeLists.txt. Add the ENABLE_AddOn_name line; Add the external_addon_name dependency to the psi4-core external project; Add the AddOn_name_DIR variable passing to the psi4-core external project. psi4/psi4/CMakeLists.txt. Add a block imitating Libint if Add-On required or CheMPS2 if not; required; If there are shared resources to the external that need; to be found by PSI4 in PSIDATADIR, follow the efpfrag; pattern of libefp to symlink them in. psi4/psi4/src/CMakeLists.txt. No changes should be required unless both (1) code in export_*; or core.cc needs the USING_AddOn_name definition or; AddOn header includes and (2) no binary PSI4 module (as; opposed to library PSI4 module with the AddOn target linked; is itself a direct dependency of target core. Basically,; try to leave this file alone, but if there are compile errors,; add the definitions/headers as needed. psi4/psi4/src/psi4/. If a module is needed to interface the AddOn to PSI4, try to; put “interface” in the name. Follow the pattern of CheMPS2 or gdma.; If non-required, be sure to conditionalize it with if(TARGET; AddOn::addon) in CMake files or #ifdef USING_AddOn in; source files.; If a separate module is not required, follow the patter of dkh; or simint with respect to libmints. Again, conditionalize as in; preceding bullet. psi4/external/upstream/. Add a CMakeLists.txt that imitates another AddOn of similar; language and dependencies. Try to keep the format, messaging,; and variables passed as similar as possible so that differences; mean something. If BLAS/LAPACK or other common dependencies in; psi4/external/common are needed, be sure to add them to the; DEPENDS argument.; The usual practice to to get everything cohesive between; the CMake for the AddOn repository and PSI4 and then as a; last step, mint a tag in the former ",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:6107,Availability,down,download,6107,"ecipes. PSI4 and Add-On Projects Working Together. Obligations of the External Project owners are to:. allow us to contribute some CMake files to your build system; so that compile flags and dependencies (e.g., BLAS/LAPACK) can be; consistent with the PSI4 build and so the installed project can; be readily detected by PSI4 or any interested party (through a; CMake imported target).; provide us a tag at a tested commit/version number so their; development may be ongoing.; communicate with us when they’ve made improvements and minted; a new tag. In return, for Add-Ons the PSI4 project will:. leave control of their code under your purview.; maintain any interfacing code needed.; regularly run integration tests between PSI4 and your code.; build a mostly statically linked conda package so that any; of your users can obtain a pre-built binary distribution through; conda install addon --channel psi4.; provide a development sandbox for your code through PSI4 plugins.; provide conda download counts independent of PSI4. How to name keywords in psi4/src/read_options.cc¶; A few guidelines for standardizing option names among modules. TRIPLES (not trip), TRIPLETS (not trip), SINGLES (not sing),; SINGLETS (not sing); CONVERGENCE (not conv, not converge) and TOLERANCE (not tol); Convergence of a method should be governed by an E_CONVERGENCE for; energy and either a D_CONVERGENCE for density or a R_CONVERGENCE; for residual/amplitudes. All of these should be doubles- let the input; parser handle the flexible input format.; Diis should have a boolean DIIS (not do_diis, not use_diis) to turn; on/off diis extrapolation, a DIIS_MIN_VECS and DIIS_MAX_VECS for; minimum and maximum number of diis vectors to use, and a DIIS_START; which is the iteration at which to start saving vectors for diis. Not all; modules conform to all these at present, but they’re as standardized as; they can be without changing code.; AMPS (not amplitude, not amp) for amplitudes; NUM_ (not n) for number (e.g., N",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:8429,Availability,toler,tolerance,8429," perturbation; Use PRINT options to indicate printing to output file. Use WRITE; options to indicate printing to another file. This probably isn’t; entirely valid now but should be observed in future. The complement to; WRITE is READ. PRINT, READ, and WRITE will usually; be the last words in an option name.; Use FOLLOW_ROOT for the state to be followed in geometry optimizations; WFN (not wavefunction); You’re welcome to use WFN and DERTYPE as internal options, but; plan to have these set by the python driver and mark them as !expert; options. Really avoid using JOBTYPE.; You’re not welcome to add CHARGE or MULTP options. Plan to get; these quantities from the molecule object. Since we frequently use subsets; of systems (with their own charge and multiplicity), this is safer.; Conform. Just grep 'add' psi4/src/read_options.cc to get a list of; all the option names in PSI4 and try to match any conventions you; find.; If you have a quantity you’d like to call a cutoff, a threshold, a; tolerance, or a convergence, consider the following guidelines in naming; it. If its value is typically greater than ~0.001, give it a name with CUTOFF.; If its value is typically less than ~0.001 and quantities being tested; against the option are more valuable with larger values (e.g.,; integrals, occupations, eigenvectors), give it a name with TOLERANCE.; If its value is typically less than ~0.001 and quantities being tested; against the option are more valuable with smaller values (e.g., energy; changes, residual errors, gradients), give it a name with; CONVERGENCE. In deciding how to arrange words in an option name, place the context; first (e.g., MP2_AMPS_PRINT, TRIPLES_DIIS). This means PRINT; will generally be at the end of an option name.; Use INTS_TOLERANCE (not schwarz_cutoff); H in an option name is reserved for Hamiltonian (or hydrogen).; Hessian should be HESS.; All option names should be all caps and separated by underscores.; If you have an option that instructs your module",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:8952,Availability,error,errors,8952,"expert; options. Really avoid using JOBTYPE.; You’re not welcome to add CHARGE or MULTP options. Plan to get; these quantities from the molecule object. Since we frequently use subsets; of systems (with their own charge and multiplicity), this is safer.; Conform. Just grep 'add' psi4/src/read_options.cc to get a list of; all the option names in PSI4 and try to match any conventions you; find.; If you have a quantity you’d like to call a cutoff, a threshold, a; tolerance, or a convergence, consider the following guidelines in naming; it. If its value is typically greater than ~0.001, give it a name with CUTOFF.; If its value is typically less than ~0.001 and quantities being tested; against the option are more valuable with larger values (e.g.,; integrals, occupations, eigenvectors), give it a name with TOLERANCE.; If its value is typically less than ~0.001 and quantities being tested; against the option are more valuable with smaller values (e.g., energy; changes, residual errors, gradients), give it a name with; CONVERGENCE. In deciding how to arrange words in an option name, place the context; first (e.g., MP2_AMPS_PRINT, TRIPLES_DIIS). This means PRINT; will generally be at the end of an option name.; Use INTS_TOLERANCE (not schwarz_cutoff); H in an option name is reserved for Hamiltonian (or hydrogen).; Hessian should be HESS.; All option names should be all caps and separated by underscores.; If you have an option that instructs your module to do something not too; computationally intensive and then quit, append _EXIT to the option; name.; Scaling terms (like for scs) should follow the pattern MP2_SS_SCALE; and SAPT_OS_SCALE.; FRAG for fragment.; AVG for average.; For level-shifting, let’s try to have it governed by (double); LEVEL_SHIFT only and not a boolean/double combo since the procedure; can be turned on (role of boolean) if the value (role of double) has; changed.; For Tikhonow regularization, use TIKONOW_OMEGA, not regularizer.; SYM for symmetry.; OCC fo",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:1991,Deployability,integrat,integrate,1991," PCMSolver_LIBRARIES, USING_v2rdm_casscf.; The CMake target(s) formed use the full add-on name as the namespace,; AddOn_name::lib_name_without_lib.lower(). For example:; libefp::efp, CheMPS2::chemps2, PCMSolver::pcm,; v2rdm_casscf::v2rdm_casscf.; Following the CMake project name (though not restricted to it –; PSI4 managment could change the pattern), the user flag to enable; an add-on is ENABLE_AddOn_name. Note that runtime-only; add-ons don’t go through this enabling process.; Internally, the ExternalProject_Add and dummy libraries as well as any; tests/ and external/ subdirectories should all be lowercase,; addon_name.; The conda package and internal to; PSI4 (that is, the ExternalProject_Add, dummy libraries, and any; tests/ and external/ subdirectories) should all be lowercase,; addon_name.; Alternatively, you can do everything mentioned here lowercase and just; have a different capitalization for an advertising name. After all,; that’s what PSI4 does. How to integrate an Add-On into build, testing, and docs¶. In all cases, put Add-Ons in alphabetic order, ignoring any “lib” in the name.; psi4/CMakeLists.txt. Add the ENABLE_AddOn_name line; Add the external_addon_name dependency to the psi4-core external project; Add the AddOn_name_DIR variable passing to the psi4-core external project. psi4/psi4/CMakeLists.txt. Add a block imitating Libint if Add-On required or CheMPS2 if not; required; If there are shared resources to the external that need; to be found by PSI4 in PSIDATADIR, follow the efpfrag; pattern of libefp to symlink them in. psi4/psi4/src/CMakeLists.txt. No changes should be required unless both (1) code in export_*; or core.cc needs the USING_AddOn_name definition or; AddOn header includes and (2) no binary PSI4 module (as; opposed to library PSI4 module with the AddOn target linked; is itself a direct dependency of target core. Basically,; try to leave this file alone, but if there are compile errors,; add the definitions/headers as needed. psi4/psi4",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:5391,Deployability,install,installed,5391," test name in the; CMakeLists but not in the test dir name. Make sure the tests get the; addon CTest label and that at least one of them gets the smoke label. psi4/doc/sphinxman/. Create a new .rst page, copying one of the Add-Ons with similar; language and dependency requirements. Edit it; as appropriate. Add this page to the list in; psi4/doc/sphinxman/source/interfacing.rst.; Add a bullet to psi4/doc/sphinxman/source/build_planning.rst; Add the new page to the long list in; psi4/doc/sphinxman/CMakeLists.txt. If there are any files or; images referred to, add them to the file, too, following precedent. else¶. Build conda packages. Recipes in https://github.com/psi4/psi4meta/tree/master/conda-recipes. PSI4 and Add-On Projects Working Together. Obligations of the External Project owners are to:. allow us to contribute some CMake files to your build system; so that compile flags and dependencies (e.g., BLAS/LAPACK) can be; consistent with the PSI4 build and so the installed project can; be readily detected by PSI4 or any interested party (through a; CMake imported target).; provide us a tag at a tested commit/version number so their; development may be ongoing.; communicate with us when they’ve made improvements and minted; a new tag. In return, for Add-Ons the PSI4 project will:. leave control of their code under your purview.; maintain any interfacing code needed.; regularly run integration tests between PSI4 and your code.; build a mostly statically linked conda package so that any; of your users can obtain a pre-built binary distribution through; conda install addon --channel psi4.; provide a development sandbox for your code through PSI4 plugins.; provide conda download counts independent of PSI4. How to name keywords in psi4/src/read_options.cc¶; A few guidelines for standardizing option names among modules. TRIPLES (not trip), TRIPLETS (not trip), SINGLES (not sing),; SINGLETS (not sing); CONVERGENCE (not conv, not converge) and TOLERANCE (not tol); Convergence",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:5816,Deployability,integrat,integration,5816,"source/build_planning.rst; Add the new page to the long list in; psi4/doc/sphinxman/CMakeLists.txt. If there are any files or; images referred to, add them to the file, too, following precedent. else¶. Build conda packages. Recipes in https://github.com/psi4/psi4meta/tree/master/conda-recipes. PSI4 and Add-On Projects Working Together. Obligations of the External Project owners are to:. allow us to contribute some CMake files to your build system; so that compile flags and dependencies (e.g., BLAS/LAPACK) can be; consistent with the PSI4 build and so the installed project can; be readily detected by PSI4 or any interested party (through a; CMake imported target).; provide us a tag at a tested commit/version number so their; development may be ongoing.; communicate with us when they’ve made improvements and minted; a new tag. In return, for Add-Ons the PSI4 project will:. leave control of their code under your purview.; maintain any interfacing code needed.; regularly run integration tests between PSI4 and your code.; build a mostly statically linked conda package so that any; of your users can obtain a pre-built binary distribution through; conda install addon --channel psi4.; provide a development sandbox for your code through PSI4 plugins.; provide conda download counts independent of PSI4. How to name keywords in psi4/src/read_options.cc¶; A few guidelines for standardizing option names among modules. TRIPLES (not trip), TRIPLETS (not trip), SINGLES (not sing),; SINGLETS (not sing); CONVERGENCE (not conv, not converge) and TOLERANCE (not tol); Convergence of a method should be governed by an E_CONVERGENCE for; energy and either a D_CONVERGENCE for density or a R_CONVERGENCE; for residual/amplitudes. All of these should be doubles- let the input; parser handle the flexible input format.; Diis should have a boolean DIIS (not do_diis, not use_diis) to turn; on/off diis extrapolation, a DIIS_MIN_VECS and DIIS_MAX_VECS for; minimum and maximum number of diis vectors to",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:5995,Deployability,install,install,5995," any files or; images referred to, add them to the file, too, following precedent. else¶. Build conda packages. Recipes in https://github.com/psi4/psi4meta/tree/master/conda-recipes. PSI4 and Add-On Projects Working Together. Obligations of the External Project owners are to:. allow us to contribute some CMake files to your build system; so that compile flags and dependencies (e.g., BLAS/LAPACK) can be; consistent with the PSI4 build and so the installed project can; be readily detected by PSI4 or any interested party (through a; CMake imported target).; provide us a tag at a tested commit/version number so their; development may be ongoing.; communicate with us when they’ve made improvements and minted; a new tag. In return, for Add-Ons the PSI4 project will:. leave control of their code under your purview.; maintain any interfacing code needed.; regularly run integration tests between PSI4 and your code.; build a mostly statically linked conda package so that any; of your users can obtain a pre-built binary distribution through; conda install addon --channel psi4.; provide a development sandbox for your code through PSI4 plugins.; provide conda download counts independent of PSI4. How to name keywords in psi4/src/read_options.cc¶; A few guidelines for standardizing option names among modules. TRIPLES (not trip), TRIPLETS (not trip), SINGLES (not sing),; SINGLETS (not sing); CONVERGENCE (not conv, not converge) and TOLERANCE (not tol); Convergence of a method should be governed by an E_CONVERGENCE for; energy and either a D_CONVERGENCE for density or a R_CONVERGENCE; for residual/amplitudes. All of these should be doubles- let the input; parser handle the flexible input format.; Diis should have a boolean DIIS (not do_diis, not use_diis) to turn; on/off diis extrapolation, a DIIS_MIN_VECS and DIIS_MAX_VECS for; minimum and maximum number of diis vectors to use, and a DIIS_START; which is the iteration at which to start saving vectors for diis. Not all; modules confo",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:11454,Deployability,integrat,integrate,11454,"alue (role of double) has; changed.; For Tikhonow regularization, use TIKONOW_OMEGA, not regularizer.; SYM for symmetry.; OCC for occupied/occupation (e.g., DOCC, LOCK_OCC, OCC_TOLERANCE).; COND for condition and CONDITIONER for conditioner.; LOCAL (not localize).; Use AO and MO for atomic and molecular orbitals. When ‘O’ for; orbitals is too obsure or would make for too short a keyword, as in; “bool NO” for “Do use natural orbitals”, use ORBS for orbitals. So; natural orbitals are NAT_ORBS and Brueckner orbitals are; BRUECKNER_ORBS.; LEVEL (not LVL, not LEV).; EX for excitation.; VAL for valence.; GEOM (not geo, not geometry).; SYM (not symm, not symmetry).; FILE (unless truly multiple FILES).; WRITE/READ for info transfer across jobs. SAVE/RESTART; for same in context of restart.; Damping should interface through option (double) DAMPING_PERCENTAGE,; where a value of 0.0 indicates no damping.; Try to avoid COMPUTE or CALC in an option name. If it’s a; boolean like “opdm_compute” for “Do compute the one-particle density; matrix”, just use OPDM.; Properties should be governed by a PROPERTIES array for the root of; interest or by a PROPERTIES_ALL array for all roots in a multi-root; calc. Since no module conforms to this right now, use PROPERTY; alone and PROP in multi-part option as PROP_ROOT, PROP_ALL,; PROP_SYM to conform.; Use DF (not ri) for density-fitting and resolution-of-the-identity; option names. Only the basis sets are staying as -RI since that’s what; EMSL uses. table of contents. Adding Add-Ons; How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs; else; How to name keywords in psi4/src/read_options.cc. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that; Adding Add-Ons. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:11763,Deployability,update,updated,11763,"alue (role of double) has; changed.; For Tikhonow regularization, use TIKONOW_OMEGA, not regularizer.; SYM for symmetry.; OCC for occupied/occupation (e.g., DOCC, LOCK_OCC, OCC_TOLERANCE).; COND for condition and CONDITIONER for conditioner.; LOCAL (not localize).; Use AO and MO for atomic and molecular orbitals. When ‘O’ for; orbitals is too obsure or would make for too short a keyword, as in; “bool NO” for “Do use natural orbitals”, use ORBS for orbitals. So; natural orbitals are NAT_ORBS and Brueckner orbitals are; BRUECKNER_ORBS.; LEVEL (not LVL, not LEV).; EX for excitation.; VAL for valence.; GEOM (not geo, not geometry).; SYM (not symm, not symmetry).; FILE (unless truly multiple FILES).; WRITE/READ for info transfer across jobs. SAVE/RESTART; for same in context of restart.; Damping should interface through option (double) DAMPING_PERCENTAGE,; where a value of 0.0 indicates no damping.; Try to avoid COMPUTE or CALC in an option name. If it’s a; boolean like “opdm_compute” for “Do compute the one-particle density; matrix”, just use OPDM.; Properties should be governed by a PROPERTIES array for the root of; interest or by a PROPERTIES_ALL array for all roots in a multi-root; calc. Since no module conforms to this right now, use PROPERTY; alone and PROP in multi-part option as PROP_ROOT, PROP_ALL,; PROP_SYM to conform.; Use DF (not ri) for density-fitting and resolution-of-the-identity; option names. Only the basis sets are staying as -RI since that’s what; EMSL uses. table of contents. Adding Add-Ons; How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs; else; How to name keywords in psi4/src/read_options.cc. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that; Adding Add-Ons. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:6471,Energy Efficiency,energy,energy,6471,"can; be readily detected by PSI4 or any interested party (through a; CMake imported target).; provide us a tag at a tested commit/version number so their; development may be ongoing.; communicate with us when they’ve made improvements and minted; a new tag. In return, for Add-Ons the PSI4 project will:. leave control of their code under your purview.; maintain any interfacing code needed.; regularly run integration tests between PSI4 and your code.; build a mostly statically linked conda package so that any; of your users can obtain a pre-built binary distribution through; conda install addon --channel psi4.; provide a development sandbox for your code through PSI4 plugins.; provide conda download counts independent of PSI4. How to name keywords in psi4/src/read_options.cc¶; A few guidelines for standardizing option names among modules. TRIPLES (not trip), TRIPLETS (not trip), SINGLES (not sing),; SINGLETS (not sing); CONVERGENCE (not conv, not converge) and TOLERANCE (not tol); Convergence of a method should be governed by an E_CONVERGENCE for; energy and either a D_CONVERGENCE for density or a R_CONVERGENCE; for residual/amplitudes. All of these should be doubles- let the input; parser handle the flexible input format.; Diis should have a boolean DIIS (not do_diis, not use_diis) to turn; on/off diis extrapolation, a DIIS_MIN_VECS and DIIS_MAX_VECS for; minimum and maximum number of diis vectors to use, and a DIIS_START; which is the iteration at which to start saving vectors for diis. Not all; modules conform to all these at present, but they’re as standardized as; they can be without changing code.; AMPS (not amplitude, not amp) for amplitudes; NUM_ (not n) for number (e.g., NUM_AMPS_PRINT, MAX_NUM_VECS,; NUM_THREADS); Some names that could be split into multiple words are staying as one.; Use MAXITER, CACHELEVEL, PUREAM, DERTYPE.; INTS (not integrals), also OEI (not oe_integrals) for; one-electron integrals and TEI (not te_integrals) for two-electron; integrals;",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:8177,Energy Efficiency,charge,charge,8177,"names that could be split into multiple words are staying as one.; Use MAXITER, CACHELEVEL, PUREAM, DERTYPE.; INTS (not integrals), also OEI (not oe_integrals) for; one-electron integrals and TEI (not te_integrals) for two-electron; integrals; PERTURB (not pert) for perturbation; Use PRINT options to indicate printing to output file. Use WRITE; options to indicate printing to another file. This probably isn’t; entirely valid now but should be observed in future. The complement to; WRITE is READ. PRINT, READ, and WRITE will usually; be the last words in an option name.; Use FOLLOW_ROOT for the state to be followed in geometry optimizations; WFN (not wavefunction); You’re welcome to use WFN and DERTYPE as internal options, but; plan to have these set by the python driver and mark them as !expert; options. Really avoid using JOBTYPE.; You’re not welcome to add CHARGE or MULTP options. Plan to get; these quantities from the molecule object. Since we frequently use subsets; of systems (with their own charge and multiplicity), this is safer.; Conform. Just grep 'add' psi4/src/read_options.cc to get a list of; all the option names in PSI4 and try to match any conventions you; find.; If you have a quantity you’d like to call a cutoff, a threshold, a; tolerance, or a convergence, consider the following guidelines in naming; it. If its value is typically greater than ~0.001, give it a name with CUTOFF.; If its value is typically less than ~0.001 and quantities being tested; against the option are more valuable with larger values (e.g.,; integrals, occupations, eigenvectors), give it a name with TOLERANCE.; If its value is typically less than ~0.001 and quantities being tested; against the option are more valuable with smaller values (e.g., energy; changes, residual errors, gradients), give it a name with; CONVERGENCE. In deciding how to arrange words in an option name, place the context; first (e.g., MP2_AMPS_PRINT, TRIPLES_DIIS). This means PRINT; will generally be at the end",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:8926,Energy Efficiency,energy,energy,8926,"expert; options. Really avoid using JOBTYPE.; You’re not welcome to add CHARGE or MULTP options. Plan to get; these quantities from the molecule object. Since we frequently use subsets; of systems (with their own charge and multiplicity), this is safer.; Conform. Just grep 'add' psi4/src/read_options.cc to get a list of; all the option names in PSI4 and try to match any conventions you; find.; If you have a quantity you’d like to call a cutoff, a threshold, a; tolerance, or a convergence, consider the following guidelines in naming; it. If its value is typically greater than ~0.001, give it a name with CUTOFF.; If its value is typically less than ~0.001 and quantities being tested; against the option are more valuable with larger values (e.g.,; integrals, occupations, eigenvectors), give it a name with TOLERANCE.; If its value is typically less than ~0.001 and quantities being tested; against the option are more valuable with smaller values (e.g., energy; changes, residual errors, gradients), give it a name with; CONVERGENCE. In deciding how to arrange words in an option name, place the context; first (e.g., MP2_AMPS_PRINT, TRIPLES_DIIS). This means PRINT; will generally be at the end of an option name.; Use INTS_TOLERANCE (not schwarz_cutoff); H in an option name is reserved for Hamiltonian (or hydrogen).; Hessian should be HESS.; All option names should be all caps and separated by underscores.; If you have an option that instructs your module to do something not too; computationally intensive and then quit, append _EXIT to the option; name.; Scaling terms (like for scs) should follow the pattern MP2_SS_SCALE; and SAPT_OS_SCALE.; FRAG for fragment.; AVG for average.; For level-shifting, let’s try to have it governed by (double); LEVEL_SHIFT only and not a boolean/double combo since the procedure; can be turned on (role of boolean) if the value (role of double) has; changed.; For Tikhonow regularization, use TIKONOW_OMEGA, not regularizer.; SYM for symmetry.; OCC fo",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:1991,Integrability,integrat,integrate,1991," PCMSolver_LIBRARIES, USING_v2rdm_casscf.; The CMake target(s) formed use the full add-on name as the namespace,; AddOn_name::lib_name_without_lib.lower(). For example:; libefp::efp, CheMPS2::chemps2, PCMSolver::pcm,; v2rdm_casscf::v2rdm_casscf.; Following the CMake project name (though not restricted to it –; PSI4 managment could change the pattern), the user flag to enable; an add-on is ENABLE_AddOn_name. Note that runtime-only; add-ons don’t go through this enabling process.; Internally, the ExternalProject_Add and dummy libraries as well as any; tests/ and external/ subdirectories should all be lowercase,; addon_name.; The conda package and internal to; PSI4 (that is, the ExternalProject_Add, dummy libraries, and any; tests/ and external/ subdirectories) should all be lowercase,; addon_name.; Alternatively, you can do everything mentioned here lowercase and just; have a different capitalization for an advertising name. After all,; that’s what PSI4 does. How to integrate an Add-On into build, testing, and docs¶. In all cases, put Add-Ons in alphabetic order, ignoring any “lib” in the name.; psi4/CMakeLists.txt. Add the ENABLE_AddOn_name line; Add the external_addon_name dependency to the psi4-core external project; Add the AddOn_name_DIR variable passing to the psi4-core external project. psi4/psi4/CMakeLists.txt. Add a block imitating Libint if Add-On required or CheMPS2 if not; required; If there are shared resources to the external that need; to be found by PSI4 in PSIDATADIR, follow the efpfrag; pattern of libefp to symlink them in. psi4/psi4/src/CMakeLists.txt. No changes should be required unless both (1) code in export_*; or core.cc needs the USING_AddOn_name definition or; AddOn header includes and (2) no binary PSI4 module (as; opposed to library PSI4 module with the AddOn target linked; is itself a direct dependency of target core. Basically,; try to leave this file alone, but if there are compile errors,; add the definitions/headers as needed. psi4/psi4",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:2204,Integrability,depend,dependency,2204,"dm_casscf::v2rdm_casscf.; Following the CMake project name (though not restricted to it –; PSI4 managment could change the pattern), the user flag to enable; an add-on is ENABLE_AddOn_name. Note that runtime-only; add-ons don’t go through this enabling process.; Internally, the ExternalProject_Add and dummy libraries as well as any; tests/ and external/ subdirectories should all be lowercase,; addon_name.; The conda package and internal to; PSI4 (that is, the ExternalProject_Add, dummy libraries, and any; tests/ and external/ subdirectories) should all be lowercase,; addon_name.; Alternatively, you can do everything mentioned here lowercase and just; have a different capitalization for an advertising name. After all,; that’s what PSI4 does. How to integrate an Add-On into build, testing, and docs¶. In all cases, put Add-Ons in alphabetic order, ignoring any “lib” in the name.; psi4/CMakeLists.txt. Add the ENABLE_AddOn_name line; Add the external_addon_name dependency to the psi4-core external project; Add the AddOn_name_DIR variable passing to the psi4-core external project. psi4/psi4/CMakeLists.txt. Add a block imitating Libint if Add-On required or CheMPS2 if not; required; If there are shared resources to the external that need; to be found by PSI4 in PSIDATADIR, follow the efpfrag; pattern of libefp to symlink them in. psi4/psi4/src/CMakeLists.txt. No changes should be required unless both (1) code in export_*; or core.cc needs the USING_AddOn_name definition or; AddOn header includes and (2) no binary PSI4 module (as; opposed to library PSI4 module with the AddOn target linked; is itself a direct dependency of target core. Basically,; try to leave this file alone, but if there are compile errors,; add the definitions/headers as needed. psi4/psi4/src/psi4/. If a module is needed to interface the AddOn to PSI4, try to; put “interface” in the name. Follow the pattern of CheMPS2 or gdma.; If non-required, be sure to conditionalize it with if(TARGET; AddOn::addon) in",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:2862,Integrability,depend,dependency,2862,"uld all be lowercase,; addon_name.; Alternatively, you can do everything mentioned here lowercase and just; have a different capitalization for an advertising name. After all,; that’s what PSI4 does. How to integrate an Add-On into build, testing, and docs¶. In all cases, put Add-Ons in alphabetic order, ignoring any “lib” in the name.; psi4/CMakeLists.txt. Add the ENABLE_AddOn_name line; Add the external_addon_name dependency to the psi4-core external project; Add the AddOn_name_DIR variable passing to the psi4-core external project. psi4/psi4/CMakeLists.txt. Add a block imitating Libint if Add-On required or CheMPS2 if not; required; If there are shared resources to the external that need; to be found by PSI4 in PSIDATADIR, follow the efpfrag; pattern of libefp to symlink them in. psi4/psi4/src/CMakeLists.txt. No changes should be required unless both (1) code in export_*; or core.cc needs the USING_AddOn_name definition or; AddOn header includes and (2) no binary PSI4 module (as; opposed to library PSI4 module with the AddOn target linked; is itself a direct dependency of target core. Basically,; try to leave this file alone, but if there are compile errors,; add the definitions/headers as needed. psi4/psi4/src/psi4/. If a module is needed to interface the AddOn to PSI4, try to; put “interface” in the name. Follow the pattern of CheMPS2 or gdma.; If non-required, be sure to conditionalize it with if(TARGET; AddOn::addon) in CMake files or #ifdef USING_AddOn in; source files.; If a separate module is not required, follow the patter of dkh; or simint with respect to libmints. Again, conditionalize as in; preceding bullet. psi4/external/upstream/. Add a CMakeLists.txt that imitates another AddOn of similar; language and dependencies. Try to keep the format, messaging,; and variables passed as similar as possible so that differences; mean something. If BLAS/LAPACK or other common dependencies in; psi4/external/common are needed, be sure to add them to the; DEPENDS ar",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:3050,Integrability,interface,interface,3050,"in alphabetic order, ignoring any “lib” in the name.; psi4/CMakeLists.txt. Add the ENABLE_AddOn_name line; Add the external_addon_name dependency to the psi4-core external project; Add the AddOn_name_DIR variable passing to the psi4-core external project. psi4/psi4/CMakeLists.txt. Add a block imitating Libint if Add-On required or CheMPS2 if not; required; If there are shared resources to the external that need; to be found by PSI4 in PSIDATADIR, follow the efpfrag; pattern of libefp to symlink them in. psi4/psi4/src/CMakeLists.txt. No changes should be required unless both (1) code in export_*; or core.cc needs the USING_AddOn_name definition or; AddOn header includes and (2) no binary PSI4 module (as; opposed to library PSI4 module with the AddOn target linked; is itself a direct dependency of target core. Basically,; try to leave this file alone, but if there are compile errors,; add the definitions/headers as needed. psi4/psi4/src/psi4/. If a module is needed to interface the AddOn to PSI4, try to; put “interface” in the name. Follow the pattern of CheMPS2 or gdma.; If non-required, be sure to conditionalize it with if(TARGET; AddOn::addon) in CMake files or #ifdef USING_AddOn in; source files.; If a separate module is not required, follow the patter of dkh; or simint with respect to libmints. Again, conditionalize as in; preceding bullet. psi4/external/upstream/. Add a CMakeLists.txt that imitates another AddOn of similar; language and dependencies. Try to keep the format, messaging,; and variables passed as similar as possible so that differences; mean something. If BLAS/LAPACK or other common dependencies in; psi4/external/common are needed, be sure to add them to the; DEPENDS argument.; The usual practice to to get everything cohesive between; the CMake for the AddOn repository and PSI4 and then as a; last step, mint a tag in the former and add it to two places in; external/upstream/addon_name/CMakeLists.txt and one; place in psi4/psi4/CMakeLists.txt so that ",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:3092,Integrability,interface,interface,3092,"in alphabetic order, ignoring any “lib” in the name.; psi4/CMakeLists.txt. Add the ENABLE_AddOn_name line; Add the external_addon_name dependency to the psi4-core external project; Add the AddOn_name_DIR variable passing to the psi4-core external project. psi4/psi4/CMakeLists.txt. Add a block imitating Libint if Add-On required or CheMPS2 if not; required; If there are shared resources to the external that need; to be found by PSI4 in PSIDATADIR, follow the efpfrag; pattern of libefp to symlink them in. psi4/psi4/src/CMakeLists.txt. No changes should be required unless both (1) code in export_*; or core.cc needs the USING_AddOn_name definition or; AddOn header includes and (2) no binary PSI4 module (as; opposed to library PSI4 module with the AddOn target linked; is itself a direct dependency of target core. Basically,; try to leave this file alone, but if there are compile errors,; add the definitions/headers as needed. psi4/psi4/src/psi4/. If a module is needed to interface the AddOn to PSI4, try to; put “interface” in the name. Follow the pattern of CheMPS2 or gdma.; If non-required, be sure to conditionalize it with if(TARGET; AddOn::addon) in CMake files or #ifdef USING_AddOn in; source files.; If a separate module is not required, follow the patter of dkh; or simint with respect to libmints. Again, conditionalize as in; preceding bullet. psi4/external/upstream/. Add a CMakeLists.txt that imitates another AddOn of similar; language and dependencies. Try to keep the format, messaging,; and variables passed as similar as possible so that differences; mean something. If BLAS/LAPACK or other common dependencies in; psi4/external/common are needed, be sure to add them to the; DEPENDS argument.; The usual practice to to get everything cohesive between; the CMake for the AddOn repository and PSI4 and then as a; last step, mint a tag in the former and add it to two places in; external/upstream/addon_name/CMakeLists.txt and one; place in psi4/psi4/CMakeLists.txt so that ",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:3534,Integrability,depend,dependencies,3534,"ATADIR, follow the efpfrag; pattern of libefp to symlink them in. psi4/psi4/src/CMakeLists.txt. No changes should be required unless both (1) code in export_*; or core.cc needs the USING_AddOn_name definition or; AddOn header includes and (2) no binary PSI4 module (as; opposed to library PSI4 module with the AddOn target linked; is itself a direct dependency of target core. Basically,; try to leave this file alone, but if there are compile errors,; add the definitions/headers as needed. psi4/psi4/src/psi4/. If a module is needed to interface the AddOn to PSI4, try to; put “interface” in the name. Follow the pattern of CheMPS2 or gdma.; If non-required, be sure to conditionalize it with if(TARGET; AddOn::addon) in CMake files or #ifdef USING_AddOn in; source files.; If a separate module is not required, follow the patter of dkh; or simint with respect to libmints. Again, conditionalize as in; preceding bullet. psi4/external/upstream/. Add a CMakeLists.txt that imitates another AddOn of similar; language and dependencies. Try to keep the format, messaging,; and variables passed as similar as possible so that differences; mean something. If BLAS/LAPACK or other common dependencies in; psi4/external/common are needed, be sure to add them to the; DEPENDS argument.; The usual practice to to get everything cohesive between; the CMake for the AddOn repository and PSI4 and then as a; last step, mint a tag in the former and add it to two places in; external/upstream/addon_name/CMakeLists.txt and one; place in psi4/psi4/CMakeLists.txt so that only that version; and later are acceptable to PSI4 for detecting pre-built. psi4/tests/. In psi4/tests/CMakeLists.txt, add a block adding a tests subdirectory if Add-On enabled; Create new subdirectory tests/addon_name with a; CMakeLists.txt. In that add a few tests. Imitate the pattern in; other subdirs of including the addon prefix to the test name in the; CMakeLists but not in the test dir name. Make sure the tests get the; addon CTes",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:3696,Integrability,depend,dependencies,3696,"dOn header includes and (2) no binary PSI4 module (as; opposed to library PSI4 module with the AddOn target linked; is itself a direct dependency of target core. Basically,; try to leave this file alone, but if there are compile errors,; add the definitions/headers as needed. psi4/psi4/src/psi4/. If a module is needed to interface the AddOn to PSI4, try to; put “interface” in the name. Follow the pattern of CheMPS2 or gdma.; If non-required, be sure to conditionalize it with if(TARGET; AddOn::addon) in CMake files or #ifdef USING_AddOn in; source files.; If a separate module is not required, follow the patter of dkh; or simint with respect to libmints. Again, conditionalize as in; preceding bullet. psi4/external/upstream/. Add a CMakeLists.txt that imitates another AddOn of similar; language and dependencies. Try to keep the format, messaging,; and variables passed as similar as possible so that differences; mean something. If BLAS/LAPACK or other common dependencies in; psi4/external/common are needed, be sure to add them to the; DEPENDS argument.; The usual practice to to get everything cohesive between; the CMake for the AddOn repository and PSI4 and then as a; last step, mint a tag in the former and add it to two places in; external/upstream/addon_name/CMakeLists.txt and one; place in psi4/psi4/CMakeLists.txt so that only that version; and later are acceptable to PSI4 for detecting pre-built. psi4/tests/. In psi4/tests/CMakeLists.txt, add a block adding a tests subdirectory if Add-On enabled; Create new subdirectory tests/addon_name with a; CMakeLists.txt. In that add a few tests. Imitate the pattern in; other subdirs of including the addon prefix to the test name in the; CMakeLists but not in the test dir name. Make sure the tests get the; addon CTest label and that at least one of them gets the smoke label. psi4/doc/sphinxman/. Create a new .rst page, copying one of the Add-Ons with similar; language and dependency requirements. Edit it; as appropriate. Add thi",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:4671,Integrability,depend,dependency,4671,"an something. If BLAS/LAPACK or other common dependencies in; psi4/external/common are needed, be sure to add them to the; DEPENDS argument.; The usual practice to to get everything cohesive between; the CMake for the AddOn repository and PSI4 and then as a; last step, mint a tag in the former and add it to two places in; external/upstream/addon_name/CMakeLists.txt and one; place in psi4/psi4/CMakeLists.txt so that only that version; and later are acceptable to PSI4 for detecting pre-built. psi4/tests/. In psi4/tests/CMakeLists.txt, add a block adding a tests subdirectory if Add-On enabled; Create new subdirectory tests/addon_name with a; CMakeLists.txt. In that add a few tests. Imitate the pattern in; other subdirs of including the addon prefix to the test name in the; CMakeLists but not in the test dir name. Make sure the tests get the; addon CTest label and that at least one of them gets the smoke label. psi4/doc/sphinxman/. Create a new .rst page, copying one of the Add-Ons with similar; language and dependency requirements. Edit it; as appropriate. Add this page to the list in; psi4/doc/sphinxman/source/interfacing.rst.; Add a bullet to psi4/doc/sphinxman/source/build_planning.rst; Add the new page to the long list in; psi4/doc/sphinxman/CMakeLists.txt. If there are any files or; images referred to, add them to the file, too, following precedent. else¶. Build conda packages. Recipes in https://github.com/psi4/psi4meta/tree/master/conda-recipes. PSI4 and Add-On Projects Working Together. Obligations of the External Project owners are to:. allow us to contribute some CMake files to your build system; so that compile flags and dependencies (e.g., BLAS/LAPACK) can be; consistent with the PSI4 build and so the installed project can; be readily detected by PSI4 or any interested party (through a; CMake imported target).; provide us a tag at a tested commit/version number so their; development may be ongoing.; communicate with us when they’ve made improvements and min",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:5308,Integrability,depend,dependencies,5308,"y tests/addon_name with a; CMakeLists.txt. In that add a few tests. Imitate the pattern in; other subdirs of including the addon prefix to the test name in the; CMakeLists but not in the test dir name. Make sure the tests get the; addon CTest label and that at least one of them gets the smoke label. psi4/doc/sphinxman/. Create a new .rst page, copying one of the Add-Ons with similar; language and dependency requirements. Edit it; as appropriate. Add this page to the list in; psi4/doc/sphinxman/source/interfacing.rst.; Add a bullet to psi4/doc/sphinxman/source/build_planning.rst; Add the new page to the long list in; psi4/doc/sphinxman/CMakeLists.txt. If there are any files or; images referred to, add them to the file, too, following precedent. else¶. Build conda packages. Recipes in https://github.com/psi4/psi4meta/tree/master/conda-recipes. PSI4 and Add-On Projects Working Together. Obligations of the External Project owners are to:. allow us to contribute some CMake files to your build system; so that compile flags and dependencies (e.g., BLAS/LAPACK) can be; consistent with the PSI4 build and so the installed project can; be readily detected by PSI4 or any interested party (through a; CMake imported target).; provide us a tag at a tested commit/version number so their; development may be ongoing.; communicate with us when they’ve made improvements and minted; a new tag. In return, for Add-Ons the PSI4 project will:. leave control of their code under your purview.; maintain any interfacing code needed.; regularly run integration tests between PSI4 and your code.; build a mostly statically linked conda package so that any; of your users can obtain a pre-built binary distribution through; conda install addon --channel psi4.; provide a development sandbox for your code through PSI4 plugins.; provide conda download counts independent of PSI4. How to name keywords in psi4/src/read_options.cc¶; A few guidelines for standardizing option names among modules. TRIPLES (not t",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:5816,Integrability,integrat,integration,5816,"source/build_planning.rst; Add the new page to the long list in; psi4/doc/sphinxman/CMakeLists.txt. If there are any files or; images referred to, add them to the file, too, following precedent. else¶. Build conda packages. Recipes in https://github.com/psi4/psi4meta/tree/master/conda-recipes. PSI4 and Add-On Projects Working Together. Obligations of the External Project owners are to:. allow us to contribute some CMake files to your build system; so that compile flags and dependencies (e.g., BLAS/LAPACK) can be; consistent with the PSI4 build and so the installed project can; be readily detected by PSI4 or any interested party (through a; CMake imported target).; provide us a tag at a tested commit/version number so their; development may be ongoing.; communicate with us when they’ve made improvements and minted; a new tag. In return, for Add-Ons the PSI4 project will:. leave control of their code under your purview.; maintain any interfacing code needed.; regularly run integration tests between PSI4 and your code.; build a mostly statically linked conda package so that any; of your users can obtain a pre-built binary distribution through; conda install addon --channel psi4.; provide a development sandbox for your code through PSI4 plugins.; provide conda download counts independent of PSI4. How to name keywords in psi4/src/read_options.cc¶; A few guidelines for standardizing option names among modules. TRIPLES (not trip), TRIPLETS (not trip), SINGLES (not sing),; SINGLETS (not sing); CONVERGENCE (not conv, not converge) and TOLERANCE (not tol); Convergence of a method should be governed by an E_CONVERGENCE for; energy and either a D_CONVERGENCE for density or a R_CONVERGENCE; for residual/amplitudes. All of these should be doubles- let the input; parser handle the flexible input format.; Diis should have a boolean DIIS (not do_diis, not use_diis) to turn; on/off diis extrapolation, a DIIS_MIN_VECS and DIIS_MAX_VECS for; minimum and maximum number of diis vectors to",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:10646,Integrability,interface,interface,10646,"ifting, let’s try to have it governed by (double); LEVEL_SHIFT only and not a boolean/double combo since the procedure; can be turned on (role of boolean) if the value (role of double) has; changed.; For Tikhonow regularization, use TIKONOW_OMEGA, not regularizer.; SYM for symmetry.; OCC for occupied/occupation (e.g., DOCC, LOCK_OCC, OCC_TOLERANCE).; COND for condition and CONDITIONER for conditioner.; LOCAL (not localize).; Use AO and MO for atomic and molecular orbitals. When ‘O’ for; orbitals is too obsure or would make for too short a keyword, as in; “bool NO” for “Do use natural orbitals”, use ORBS for orbitals. So; natural orbitals are NAT_ORBS and Brueckner orbitals are; BRUECKNER_ORBS.; LEVEL (not LVL, not LEV).; EX for excitation.; VAL for valence.; GEOM (not geo, not geometry).; SYM (not symm, not symmetry).; FILE (unless truly multiple FILES).; WRITE/READ for info transfer across jobs. SAVE/RESTART; for same in context of restart.; Damping should interface through option (double) DAMPING_PERCENTAGE,; where a value of 0.0 indicates no damping.; Try to avoid COMPUTE or CALC in an option name. If it’s a; boolean like “opdm_compute” for “Do compute the one-particle density; matrix”, just use OPDM.; Properties should be governed by a PROPERTIES array for the root of; interest or by a PROPERTIES_ALL array for all roots in a multi-root; calc. Since no module conforms to this right now, use PROPERTY; alone and PROP in multi-part option as PROP_ROOT, PROP_ALL,; PROP_SYM to conform.; Use DF (not ri) for density-fitting and resolution-of-the-identity; option names. Only the basis sets are staying as -RI since that’s what; EMSL uses. table of contents. Adding Add-Ons; How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs; else; How to name keywords in psi4/src/read_options.cc. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Gi",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:11454,Integrability,integrat,integrate,11454,"alue (role of double) has; changed.; For Tikhonow regularization, use TIKONOW_OMEGA, not regularizer.; SYM for symmetry.; OCC for occupied/occupation (e.g., DOCC, LOCK_OCC, OCC_TOLERANCE).; COND for condition and CONDITIONER for conditioner.; LOCAL (not localize).; Use AO and MO for atomic and molecular orbitals. When ‘O’ for; orbitals is too obsure or would make for too short a keyword, as in; “bool NO” for “Do use natural orbitals”, use ORBS for orbitals. So; natural orbitals are NAT_ORBS and Brueckner orbitals are; BRUECKNER_ORBS.; LEVEL (not LVL, not LEV).; EX for excitation.; VAL for valence.; GEOM (not geo, not geometry).; SYM (not symm, not symmetry).; FILE (unless truly multiple FILES).; WRITE/READ for info transfer across jobs. SAVE/RESTART; for same in context of restart.; Damping should interface through option (double) DAMPING_PERCENTAGE,; where a value of 0.0 indicates no damping.; Try to avoid COMPUTE or CALC in an option name. If it’s a; boolean like “opdm_compute” for “Do compute the one-particle density; matrix”, just use OPDM.; Properties should be governed by a PROPERTIES array for the root of; interest or by a PROPERTIES_ALL array for all roots in a multi-root; calc. Since no module conforms to this right now, use PROPERTY; alone and PROP in multi-part option as PROP_ROOT, PROP_ALL,; PROP_SYM to conform.; Use DF (not ri) for density-fitting and resolution-of-the-identity; option names. Only the basis sets are staying as -RI since that’s what; EMSL uses. table of contents. Adding Add-Ons; How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs; else; How to name keywords in psi4/src/read_options.cc. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that; Adding Add-Ons. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:892,Modifiability,variab,variables,892,"﻿. Adding Add-Ons. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that; Adding Add-Ons. Adding Add-Ons¶. How to use an Add-On’s name in directory structure, build, and distribution¶. Select a name. May be mixed case with numerals and underscores; (e.g., CheMPS2, libefp, PCMSolver, v2rdm_casscf). Shouldn’t start with a; numeral. Needn’t start with “lib”, even if a library.; GitHub repository name should be AddOn_name or; AddOn_name.lower() (hereafter, addon_name. For example: CheMPS2, libefp, pcmsolver,; v2rdm_casscf.; CMake project name should be AddOn_name. For example:; project(libefp), project(CheMPS2), project(PCMSolver),; project(v2rdm_casscf). Namespacing in the directory structure used; to detect the addon should have this name (e.g.,; share/cmake/CheMPS2).; Restricted by the CMake project name, add-ons return CMake variables; and compile definitions of FOUND_AddOn_name and; USING_AddOn_name. For example: FOUND_libefp,; USING_CheMPS2, PCMSolver_LIBRARIES, USING_v2rdm_casscf.; The CMake target(s) formed use the full add-on name as the namespace,; AddOn_name::lib_name_without_lib.lower(). For example:; libefp::efp, CheMPS2::chemps2, PCMSolver::pcm,; v2rdm_casscf::v2rdm_casscf.; Following the CMake project name (though not restricted to it –; PSI4 managment could change the pattern), the user flag to enable; an add-on is ENABLE_AddOn_name. Note that runtime-only; add-ons don’t go through this enabling process.; Internally, the ExternalProject_Add and dummy libraries as well as any; tests/ and external/ subdirectories should all be lowercase,; addon_name.; The conda package and internal to; PSI4 (that is, the ExternalProject_Add, dummy libraries, and any; tests/ and external/ subdirectories) should all be lowercase,; addon_name.; Alternatively, you can do everything mentioned here lowercase and just; have a different capitalization for an advertising name. After all,; that’s what PSI4 does. How to integrate ",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:2273,Modifiability,variab,variable,2273,"dm_casscf::v2rdm_casscf.; Following the CMake project name (though not restricted to it –; PSI4 managment could change the pattern), the user flag to enable; an add-on is ENABLE_AddOn_name. Note that runtime-only; add-ons don’t go through this enabling process.; Internally, the ExternalProject_Add and dummy libraries as well as any; tests/ and external/ subdirectories should all be lowercase,; addon_name.; The conda package and internal to; PSI4 (that is, the ExternalProject_Add, dummy libraries, and any; tests/ and external/ subdirectories) should all be lowercase,; addon_name.; Alternatively, you can do everything mentioned here lowercase and just; have a different capitalization for an advertising name. After all,; that’s what PSI4 does. How to integrate an Add-On into build, testing, and docs¶. In all cases, put Add-Ons in alphabetic order, ignoring any “lib” in the name.; psi4/CMakeLists.txt. Add the ENABLE_AddOn_name line; Add the external_addon_name dependency to the psi4-core external project; Add the AddOn_name_DIR variable passing to the psi4-core external project. psi4/psi4/CMakeLists.txt. Add a block imitating Libint if Add-On required or CheMPS2 if not; required; If there are shared resources to the external that need; to be found by PSI4 in PSIDATADIR, follow the efpfrag; pattern of libefp to symlink them in. psi4/psi4/src/CMakeLists.txt. No changes should be required unless both (1) code in export_*; or core.cc needs the USING_AddOn_name definition or; AddOn header includes and (2) no binary PSI4 module (as; opposed to library PSI4 module with the AddOn target linked; is itself a direct dependency of target core. Basically,; try to leave this file alone, but if there are compile errors,; add the definitions/headers as needed. psi4/psi4/src/psi4/. If a module is needed to interface the AddOn to PSI4, try to; put “interface” in the name. Follow the pattern of CheMPS2 or gdma.; If non-required, be sure to conditionalize it with if(TARGET; AddOn::addon) in",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:3588,Modifiability,variab,variables,3588,"t. No changes should be required unless both (1) code in export_*; or core.cc needs the USING_AddOn_name definition or; AddOn header includes and (2) no binary PSI4 module (as; opposed to library PSI4 module with the AddOn target linked; is itself a direct dependency of target core. Basically,; try to leave this file alone, but if there are compile errors,; add the definitions/headers as needed. psi4/psi4/src/psi4/. If a module is needed to interface the AddOn to PSI4, try to; put “interface” in the name. Follow the pattern of CheMPS2 or gdma.; If non-required, be sure to conditionalize it with if(TARGET; AddOn::addon) in CMake files or #ifdef USING_AddOn in; source files.; If a separate module is not required, follow the patter of dkh; or simint with respect to libmints. Again, conditionalize as in; preceding bullet. psi4/external/upstream/. Add a CMakeLists.txt that imitates another AddOn of similar; language and dependencies. Try to keep the format, messaging,; and variables passed as similar as possible so that differences; mean something. If BLAS/LAPACK or other common dependencies in; psi4/external/common are needed, be sure to add them to the; DEPENDS argument.; The usual practice to to get everything cohesive between; the CMake for the AddOn repository and PSI4 and then as a; last step, mint a tag in the former and add it to two places in; external/upstream/addon_name/CMakeLists.txt and one; place in psi4/psi4/CMakeLists.txt so that only that version; and later are acceptable to PSI4 for detecting pre-built. psi4/tests/. In psi4/tests/CMakeLists.txt, add a block adding a tests subdirectory if Add-On enabled; Create new subdirectory tests/addon_name with a; CMakeLists.txt. In that add a few tests. Imitate the pattern in; other subdirs of including the addon prefix to the test name in the; CMakeLists but not in the test dir name. Make sure the tests get the; addon CTest label and that at least one of them gets the smoke label. psi4/doc/sphinxman/. Create a new ",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:6048,Modifiability,sandbox,sandbox,6048,"ipes in https://github.com/psi4/psi4meta/tree/master/conda-recipes. PSI4 and Add-On Projects Working Together. Obligations of the External Project owners are to:. allow us to contribute some CMake files to your build system; so that compile flags and dependencies (e.g., BLAS/LAPACK) can be; consistent with the PSI4 build and so the installed project can; be readily detected by PSI4 or any interested party (through a; CMake imported target).; provide us a tag at a tested commit/version number so their; development may be ongoing.; communicate with us when they’ve made improvements and minted; a new tag. In return, for Add-Ons the PSI4 project will:. leave control of their code under your purview.; maintain any interfacing code needed.; regularly run integration tests between PSI4 and your code.; build a mostly statically linked conda package so that any; of your users can obtain a pre-built binary distribution through; conda install addon --channel psi4.; provide a development sandbox for your code through PSI4 plugins.; provide conda download counts independent of PSI4. How to name keywords in psi4/src/read_options.cc¶; A few guidelines for standardizing option names among modules. TRIPLES (not trip), TRIPLETS (not trip), SINGLES (not sing),; SINGLETS (not sing); CONVERGENCE (not conv, not converge) and TOLERANCE (not tol); Convergence of a method should be governed by an E_CONVERGENCE for; energy and either a D_CONVERGENCE for density or a R_CONVERGENCE; for residual/amplitudes. All of these should be doubles- let the input; parser handle the flexible input format.; Diis should have a boolean DIIS (not do_diis, not use_diis) to turn; on/off diis extrapolation, a DIIS_MIN_VECS and DIIS_MAX_VECS for; minimum and maximum number of diis vectors to use, and a DIIS_START; which is the iteration at which to start saving vectors for diis. Not all; modules conform to all these at present, but they’re as standardized as; they can be without changing code.; AMPS (not amplitude",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:6083,Modifiability,plugin,plugins,6083,"ipes in https://github.com/psi4/psi4meta/tree/master/conda-recipes. PSI4 and Add-On Projects Working Together. Obligations of the External Project owners are to:. allow us to contribute some CMake files to your build system; so that compile flags and dependencies (e.g., BLAS/LAPACK) can be; consistent with the PSI4 build and so the installed project can; be readily detected by PSI4 or any interested party (through a; CMake imported target).; provide us a tag at a tested commit/version number so their; development may be ongoing.; communicate with us when they’ve made improvements and minted; a new tag. In return, for Add-Ons the PSI4 project will:. leave control of their code under your purview.; maintain any interfacing code needed.; regularly run integration tests between PSI4 and your code.; build a mostly statically linked conda package so that any; of your users can obtain a pre-built binary distribution through; conda install addon --channel psi4.; provide a development sandbox for your code through PSI4 plugins.; provide conda download counts independent of PSI4. How to name keywords in psi4/src/read_options.cc¶; A few guidelines for standardizing option names among modules. TRIPLES (not trip), TRIPLETS (not trip), SINGLES (not sing),; SINGLETS (not sing); CONVERGENCE (not conv, not converge) and TOLERANCE (not tol); Convergence of a method should be governed by an E_CONVERGENCE for; energy and either a D_CONVERGENCE for density or a R_CONVERGENCE; for residual/amplitudes. All of these should be doubles- let the input; parser handle the flexible input format.; Diis should have a boolean DIIS (not do_diis, not use_diis) to turn; on/off diis extrapolation, a DIIS_MIN_VECS and DIIS_MAX_VECS for; minimum and maximum number of diis vectors to use, and a DIIS_START; which is the iteration at which to start saving vectors for diis. Not all; modules conform to all these at present, but they’re as standardized as; they can be without changing code.; AMPS (not amplitude",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:6627,Modifiability,flexible,flexible,6627,"with us when they’ve made improvements and minted; a new tag. In return, for Add-Ons the PSI4 project will:. leave control of their code under your purview.; maintain any interfacing code needed.; regularly run integration tests between PSI4 and your code.; build a mostly statically linked conda package so that any; of your users can obtain a pre-built binary distribution through; conda install addon --channel psi4.; provide a development sandbox for your code through PSI4 plugins.; provide conda download counts independent of PSI4. How to name keywords in psi4/src/read_options.cc¶; A few guidelines for standardizing option names among modules. TRIPLES (not trip), TRIPLETS (not trip), SINGLES (not sing),; SINGLETS (not sing); CONVERGENCE (not conv, not converge) and TOLERANCE (not tol); Convergence of a method should be governed by an E_CONVERGENCE for; energy and either a D_CONVERGENCE for density or a R_CONVERGENCE; for residual/amplitudes. All of these should be doubles- let the input; parser handle the flexible input format.; Diis should have a boolean DIIS (not do_diis, not use_diis) to turn; on/off diis extrapolation, a DIIS_MIN_VECS and DIIS_MAX_VECS for; minimum and maximum number of diis vectors to use, and a DIIS_START; which is the iteration at which to start saving vectors for diis. Not all; modules conform to all these at present, but they’re as standardized as; they can be without changing code.; AMPS (not amplitude, not amp) for amplitudes; NUM_ (not n) for number (e.g., NUM_AMPS_PRINT, MAX_NUM_VECS,; NUM_THREADS); Some names that could be split into multiple words are staying as one.; Use MAXITER, CACHELEVEL, PUREAM, DERTYPE.; INTS (not integrals), also OEI (not oe_integrals) for; one-electron integrals and TEI (not te_integrals) for two-electron; integrals; PERTURB (not pert) for perturbation; Use PRINT options to indicate printing to output file. Use WRITE; options to indicate printing to another file. This probably isn’t; entirely valid now but sh",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:7799,Performance,optimiz,optimizations,7799," is the iteration at which to start saving vectors for diis. Not all; modules conform to all these at present, but they’re as standardized as; they can be without changing code.; AMPS (not amplitude, not amp) for amplitudes; NUM_ (not n) for number (e.g., NUM_AMPS_PRINT, MAX_NUM_VECS,; NUM_THREADS); Some names that could be split into multiple words are staying as one.; Use MAXITER, CACHELEVEL, PUREAM, DERTYPE.; INTS (not integrals), also OEI (not oe_integrals) for; one-electron integrals and TEI (not te_integrals) for two-electron; integrals; PERTURB (not pert) for perturbation; Use PRINT options to indicate printing to output file. Use WRITE; options to indicate printing to another file. This probably isn’t; entirely valid now but should be observed in future. The complement to; WRITE is READ. PRINT, READ, and WRITE will usually; be the last words in an option name.; Use FOLLOW_ROOT for the state to be followed in geometry optimizations; WFN (not wavefunction); You’re welcome to use WFN and DERTYPE as internal options, but; plan to have these set by the python driver and mark them as !expert; options. Really avoid using JOBTYPE.; You’re not welcome to add CHARGE or MULTP options. Plan to get; these quantities from the molecule object. Since we frequently use subsets; of systems (with their own charge and multiplicity), this is safer.; Conform. Just grep 'add' psi4/src/read_options.cc to get a list of; all the option names in PSI4 and try to match any conventions you; find.; If you have a quantity you’d like to call a cutoff, a threshold, a; tolerance, or a convergence, consider the following guidelines in naming; it. If its value is typically greater than ~0.001, give it a name with CUTOFF.; If its value is typically less than ~0.001 and quantities being tested; against the option are more valuable with larger values (e.g.,; integrals, occupations, eigenvectors), give it a name with TOLERANCE.; If its value is typically less than ~0.001 and quantities being tested",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:763,Safety,detect,detect,763,"﻿. Adding Add-Ons. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that; Adding Add-Ons. Adding Add-Ons¶. How to use an Add-On’s name in directory structure, build, and distribution¶. Select a name. May be mixed case with numerals and underscores; (e.g., CheMPS2, libefp, PCMSolver, v2rdm_casscf). Shouldn’t start with a; numeral. Needn’t start with “lib”, even if a library.; GitHub repository name should be AddOn_name or; AddOn_name.lower() (hereafter, addon_name. For example: CheMPS2, libefp, pcmsolver,; v2rdm_casscf.; CMake project name should be AddOn_name. For example:; project(libefp), project(CheMPS2), project(PCMSolver),; project(v2rdm_casscf). Namespacing in the directory structure used; to detect the addon should have this name (e.g.,; share/cmake/CheMPS2).; Restricted by the CMake project name, add-ons return CMake variables; and compile definitions of FOUND_AddOn_name and; USING_AddOn_name. For example: FOUND_libefp,; USING_CheMPS2, PCMSolver_LIBRARIES, USING_v2rdm_casscf.; The CMake target(s) formed use the full add-on name as the namespace,; AddOn_name::lib_name_without_lib.lower(). For example:; libefp::efp, CheMPS2::chemps2, PCMSolver::pcm,; v2rdm_casscf::v2rdm_casscf.; Following the CMake project name (though not restricted to it –; PSI4 managment could change the pattern), the user flag to enable; an add-on is ENABLE_AddOn_name. Note that runtime-only; add-ons don’t go through this enabling process.; Internally, the ExternalProject_Add and dummy libraries as well as any; tests/ and external/ subdirectories should all be lowercase,; addon_name.; The conda package and internal to; PSI4 (that is, the ExternalProject_Add, dummy libraries, and any; tests/ and external/ subdirectories) should all be lowercase,; addon_name.; Alternatively, you can do everything mentioned here lowercase and just; have a different capitalization for an advertising name. After all,; that’s what PSI4 does. How to integrate ",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:4126,Safety,detect,detecting,4126," in the name. Follow the pattern of CheMPS2 or gdma.; If non-required, be sure to conditionalize it with if(TARGET; AddOn::addon) in CMake files or #ifdef USING_AddOn in; source files.; If a separate module is not required, follow the patter of dkh; or simint with respect to libmints. Again, conditionalize as in; preceding bullet. psi4/external/upstream/. Add a CMakeLists.txt that imitates another AddOn of similar; language and dependencies. Try to keep the format, messaging,; and variables passed as similar as possible so that differences; mean something. If BLAS/LAPACK or other common dependencies in; psi4/external/common are needed, be sure to add them to the; DEPENDS argument.; The usual practice to to get everything cohesive between; the CMake for the AddOn repository and PSI4 and then as a; last step, mint a tag in the former and add it to two places in; external/upstream/addon_name/CMakeLists.txt and one; place in psi4/psi4/CMakeLists.txt so that only that version; and later are acceptable to PSI4 for detecting pre-built. psi4/tests/. In psi4/tests/CMakeLists.txt, add a block adding a tests subdirectory if Add-On enabled; Create new subdirectory tests/addon_name with a; CMakeLists.txt. In that add a few tests. Imitate the pattern in; other subdirs of including the addon prefix to the test name in the; CMakeLists but not in the test dir name. Make sure the tests get the; addon CTest label and that at least one of them gets the smoke label. psi4/doc/sphinxman/. Create a new .rst page, copying one of the Add-Ons with similar; language and dependency requirements. Edit it; as appropriate. Add this page to the list in; psi4/doc/sphinxman/source/interfacing.rst.; Add a bullet to psi4/doc/sphinxman/source/build_planning.rst; Add the new page to the long list in; psi4/doc/sphinxman/CMakeLists.txt. If there are any files or; images referred to, add them to the file, too, following precedent. else¶. Build conda packages. Recipes in https://github.com/psi4/psi4meta/tree",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:5425,Safety,detect,detected,5425," test name in the; CMakeLists but not in the test dir name. Make sure the tests get the; addon CTest label and that at least one of them gets the smoke label. psi4/doc/sphinxman/. Create a new .rst page, copying one of the Add-Ons with similar; language and dependency requirements. Edit it; as appropriate. Add this page to the list in; psi4/doc/sphinxman/source/interfacing.rst.; Add a bullet to psi4/doc/sphinxman/source/build_planning.rst; Add the new page to the long list in; psi4/doc/sphinxman/CMakeLists.txt. If there are any files or; images referred to, add them to the file, too, following precedent. else¶. Build conda packages. Recipes in https://github.com/psi4/psi4meta/tree/master/conda-recipes. PSI4 and Add-On Projects Working Together. Obligations of the External Project owners are to:. allow us to contribute some CMake files to your build system; so that compile flags and dependencies (e.g., BLAS/LAPACK) can be; consistent with the PSI4 build and so the installed project can; be readily detected by PSI4 or any interested party (through a; CMake imported target).; provide us a tag at a tested commit/version number so their; development may be ongoing.; communicate with us when they’ve made improvements and minted; a new tag. In return, for Add-Ons the PSI4 project will:. leave control of their code under your purview.; maintain any interfacing code needed.; regularly run integration tests between PSI4 and your code.; build a mostly statically linked conda package so that any; of your users can obtain a pre-built binary distribution through; conda install addon --channel psi4.; provide a development sandbox for your code through PSI4 plugins.; provide conda download counts independent of PSI4. How to name keywords in psi4/src/read_options.cc¶; A few guidelines for standardizing option names among modules. TRIPLES (not trip), TRIPLETS (not trip), SINGLES (not sing),; SINGLETS (not sing); CONVERGENCE (not conv, not converge) and TOLERANCE (not tol); Convergence",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:7988,Safety,avoid,avoid,7988,"ized as; they can be without changing code.; AMPS (not amplitude, not amp) for amplitudes; NUM_ (not n) for number (e.g., NUM_AMPS_PRINT, MAX_NUM_VECS,; NUM_THREADS); Some names that could be split into multiple words are staying as one.; Use MAXITER, CACHELEVEL, PUREAM, DERTYPE.; INTS (not integrals), also OEI (not oe_integrals) for; one-electron integrals and TEI (not te_integrals) for two-electron; integrals; PERTURB (not pert) for perturbation; Use PRINT options to indicate printing to output file. Use WRITE; options to indicate printing to another file. This probably isn’t; entirely valid now but should be observed in future. The complement to; WRITE is READ. PRINT, READ, and WRITE will usually; be the last words in an option name.; Use FOLLOW_ROOT for the state to be followed in geometry optimizations; WFN (not wavefunction); You’re welcome to use WFN and DERTYPE as internal options, but; plan to have these set by the python driver and mark them as !expert; options. Really avoid using JOBTYPE.; You’re not welcome to add CHARGE or MULTP options. Plan to get; these quantities from the molecule object. Since we frequently use subsets; of systems (with their own charge and multiplicity), this is safer.; Conform. Just grep 'add' psi4/src/read_options.cc to get a list of; all the option names in PSI4 and try to match any conventions you; find.; If you have a quantity you’d like to call a cutoff, a threshold, a; tolerance, or a convergence, consider the following guidelines in naming; it. If its value is typically greater than ~0.001, give it a name with CUTOFF.; If its value is typically less than ~0.001 and quantities being tested; against the option are more valuable with larger values (e.g.,; integrals, occupations, eigenvectors), give it a name with TOLERANCE.; If its value is typically less than ~0.001 and quantities being tested; against the option are more valuable with smaller values (e.g., energy; changes, residual errors, gradients), give it a name with; C",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:8211,Safety,safe,safer,8211,"names that could be split into multiple words are staying as one.; Use MAXITER, CACHELEVEL, PUREAM, DERTYPE.; INTS (not integrals), also OEI (not oe_integrals) for; one-electron integrals and TEI (not te_integrals) for two-electron; integrals; PERTURB (not pert) for perturbation; Use PRINT options to indicate printing to output file. Use WRITE; options to indicate printing to another file. This probably isn’t; entirely valid now but should be observed in future. The complement to; WRITE is READ. PRINT, READ, and WRITE will usually; be the last words in an option name.; Use FOLLOW_ROOT for the state to be followed in geometry optimizations; WFN (not wavefunction); You’re welcome to use WFN and DERTYPE as internal options, but; plan to have these set by the python driver and mark them as !expert; options. Really avoid using JOBTYPE.; You’re not welcome to add CHARGE or MULTP options. Plan to get; these quantities from the molecule object. Since we frequently use subsets; of systems (with their own charge and multiplicity), this is safer.; Conform. Just grep 'add' psi4/src/read_options.cc to get a list of; all the option names in PSI4 and try to match any conventions you; find.; If you have a quantity you’d like to call a cutoff, a threshold, a; tolerance, or a convergence, consider the following guidelines in naming; it. If its value is typically greater than ~0.001, give it a name with CUTOFF.; If its value is typically less than ~0.001 and quantities being tested; against the option are more valuable with larger values (e.g.,; integrals, occupations, eigenvectors), give it a name with TOLERANCE.; If its value is typically less than ~0.001 and quantities being tested; against the option are more valuable with smaller values (e.g., energy; changes, residual errors, gradients), give it a name with; CONVERGENCE. In deciding how to arrange words in an option name, place the context; first (e.g., MP2_AMPS_PRINT, TRIPLES_DIIS). This means PRINT; will generally be at the end",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:10752,Safety,avoid,avoid,10752,"combo since the procedure; can be turned on (role of boolean) if the value (role of double) has; changed.; For Tikhonow regularization, use TIKONOW_OMEGA, not regularizer.; SYM for symmetry.; OCC for occupied/occupation (e.g., DOCC, LOCK_OCC, OCC_TOLERANCE).; COND for condition and CONDITIONER for conditioner.; LOCAL (not localize).; Use AO and MO for atomic and molecular orbitals. When ‘O’ for; orbitals is too obsure or would make for too short a keyword, as in; “bool NO” for “Do use natural orbitals”, use ORBS for orbitals. So; natural orbitals are NAT_ORBS and Brueckner orbitals are; BRUECKNER_ORBS.; LEVEL (not LVL, not LEV).; EX for excitation.; VAL for valence.; GEOM (not geo, not geometry).; SYM (not symm, not symmetry).; FILE (unless truly multiple FILES).; WRITE/READ for info transfer across jobs. SAVE/RESTART; for same in context of restart.; Damping should interface through option (double) DAMPING_PERCENTAGE,; where a value of 0.0 indicates no damping.; Try to avoid COMPUTE or CALC in an option name. If it’s a; boolean like “opdm_compute” for “Do compute the one-particle density; matrix”, just use OPDM.; Properties should be governed by a PROPERTIES array for the root of; interest or by a PROPERTIES_ALL array for all roots in a multi-root; calc. Since no module conforms to this right now, use PROPERTY; alone and PROP in multi-part option as PROP_ROOT, PROP_ALL,; PROP_SYM to conform.; Use DF (not ri) for density-fitting and resolution-of-the-identity; option names. Only the basis sets are staying as -RI since that’s what; EMSL uses. table of contents. Adding Add-Ons; How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs; else; How to name keywords in psi4/src/read_options.cc. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that; Adding Add-Ons. © Copyright 2022, The Psi4 Project.; Last updat",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:1568,Testability,test,tests,1568,"2rdm_casscf.; CMake project name should be AddOn_name. For example:; project(libefp), project(CheMPS2), project(PCMSolver),; project(v2rdm_casscf). Namespacing in the directory structure used; to detect the addon should have this name (e.g.,; share/cmake/CheMPS2).; Restricted by the CMake project name, add-ons return CMake variables; and compile definitions of FOUND_AddOn_name and; USING_AddOn_name. For example: FOUND_libefp,; USING_CheMPS2, PCMSolver_LIBRARIES, USING_v2rdm_casscf.; The CMake target(s) formed use the full add-on name as the namespace,; AddOn_name::lib_name_without_lib.lower(). For example:; libefp::efp, CheMPS2::chemps2, PCMSolver::pcm,; v2rdm_casscf::v2rdm_casscf.; Following the CMake project name (though not restricted to it –; PSI4 managment could change the pattern), the user flag to enable; an add-on is ENABLE_AddOn_name. Note that runtime-only; add-ons don’t go through this enabling process.; Internally, the ExternalProject_Add and dummy libraries as well as any; tests/ and external/ subdirectories should all be lowercase,; addon_name.; The conda package and internal to; PSI4 (that is, the ExternalProject_Add, dummy libraries, and any; tests/ and external/ subdirectories) should all be lowercase,; addon_name.; Alternatively, you can do everything mentioned here lowercase and just; have a different capitalization for an advertising name. After all,; that’s what PSI4 does. How to integrate an Add-On into build, testing, and docs¶. In all cases, put Add-Ons in alphabetic order, ignoring any “lib” in the name.; psi4/CMakeLists.txt. Add the ENABLE_AddOn_name line; Add the external_addon_name dependency to the psi4-core external project; Add the AddOn_name_DIR variable passing to the psi4-core external project. psi4/psi4/CMakeLists.txt. Add a block imitating Libint if Add-On required or CheMPS2 if not; required; If there are shared resources to the external that need; to be found by PSI4 in PSIDATADIR, follow the efpfrag; pattern of libefp to symlink",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:1744,Testability,test,tests,1744," the directory structure used; to detect the addon should have this name (e.g.,; share/cmake/CheMPS2).; Restricted by the CMake project name, add-ons return CMake variables; and compile definitions of FOUND_AddOn_name and; USING_AddOn_name. For example: FOUND_libefp,; USING_CheMPS2, PCMSolver_LIBRARIES, USING_v2rdm_casscf.; The CMake target(s) formed use the full add-on name as the namespace,; AddOn_name::lib_name_without_lib.lower(). For example:; libefp::efp, CheMPS2::chemps2, PCMSolver::pcm,; v2rdm_casscf::v2rdm_casscf.; Following the CMake project name (though not restricted to it –; PSI4 managment could change the pattern), the user flag to enable; an add-on is ENABLE_AddOn_name. Note that runtime-only; add-ons don’t go through this enabling process.; Internally, the ExternalProject_Add and dummy libraries as well as any; tests/ and external/ subdirectories should all be lowercase,; addon_name.; The conda package and internal to; PSI4 (that is, the ExternalProject_Add, dummy libraries, and any; tests/ and external/ subdirectories) should all be lowercase,; addon_name.; Alternatively, you can do everything mentioned here lowercase and just; have a different capitalization for an advertising name. After all,; that’s what PSI4 does. How to integrate an Add-On into build, testing, and docs¶. In all cases, put Add-Ons in alphabetic order, ignoring any “lib” in the name.; psi4/CMakeLists.txt. Add the ENABLE_AddOn_name line; Add the external_addon_name dependency to the psi4-core external project; Add the AddOn_name_DIR variable passing to the psi4-core external project. psi4/psi4/CMakeLists.txt. Add a block imitating Libint if Add-On required or CheMPS2 if not; required; If there are shared resources to the external that need; to be found by PSI4 in PSIDATADIR, follow the efpfrag; pattern of libefp to symlink them in. psi4/psi4/src/CMakeLists.txt. No changes should be required unless both (1) code in export_*; or core.cc needs the USING_AddOn_name definition or; AddOn",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:2023,Testability,test,testing,2023," PCMSolver_LIBRARIES, USING_v2rdm_casscf.; The CMake target(s) formed use the full add-on name as the namespace,; AddOn_name::lib_name_without_lib.lower(). For example:; libefp::efp, CheMPS2::chemps2, PCMSolver::pcm,; v2rdm_casscf::v2rdm_casscf.; Following the CMake project name (though not restricted to it –; PSI4 managment could change the pattern), the user flag to enable; an add-on is ENABLE_AddOn_name. Note that runtime-only; add-ons don’t go through this enabling process.; Internally, the ExternalProject_Add and dummy libraries as well as any; tests/ and external/ subdirectories should all be lowercase,; addon_name.; The conda package and internal to; PSI4 (that is, the ExternalProject_Add, dummy libraries, and any; tests/ and external/ subdirectories) should all be lowercase,; addon_name.; Alternatively, you can do everything mentioned here lowercase and just; have a different capitalization for an advertising name. After all,; that’s what PSI4 does. How to integrate an Add-On into build, testing, and docs¶. In all cases, put Add-Ons in alphabetic order, ignoring any “lib” in the name.; psi4/CMakeLists.txt. Add the ENABLE_AddOn_name line; Add the external_addon_name dependency to the psi4-core external project; Add the AddOn_name_DIR variable passing to the psi4-core external project. psi4/psi4/CMakeLists.txt. Add a block imitating Libint if Add-On required or CheMPS2 if not; required; If there are shared resources to the external that need; to be found by PSI4 in PSIDATADIR, follow the efpfrag; pattern of libefp to symlink them in. psi4/psi4/src/CMakeLists.txt. No changes should be required unless both (1) code in export_*; or core.cc needs the USING_AddOn_name definition or; AddOn header includes and (2) no binary PSI4 module (as; opposed to library PSI4 module with the AddOn target linked; is itself a direct dependency of target core. Basically,; try to leave this file alone, but if there are compile errors,; add the definitions/headers as needed. psi4/psi4",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:4152,Testability,test,tests,4152,"a.; If non-required, be sure to conditionalize it with if(TARGET; AddOn::addon) in CMake files or #ifdef USING_AddOn in; source files.; If a separate module is not required, follow the patter of dkh; or simint with respect to libmints. Again, conditionalize as in; preceding bullet. psi4/external/upstream/. Add a CMakeLists.txt that imitates another AddOn of similar; language and dependencies. Try to keep the format, messaging,; and variables passed as similar as possible so that differences; mean something. If BLAS/LAPACK or other common dependencies in; psi4/external/common are needed, be sure to add them to the; DEPENDS argument.; The usual practice to to get everything cohesive between; the CMake for the AddOn repository and PSI4 and then as a; last step, mint a tag in the former and add it to two places in; external/upstream/addon_name/CMakeLists.txt and one; place in psi4/psi4/CMakeLists.txt so that only that version; and later are acceptable to PSI4 for detecting pre-built. psi4/tests/. In psi4/tests/CMakeLists.txt, add a block adding a tests subdirectory if Add-On enabled; Create new subdirectory tests/addon_name with a; CMakeLists.txt. In that add a few tests. Imitate the pattern in; other subdirs of including the addon prefix to the test name in the; CMakeLists but not in the test dir name. Make sure the tests get the; addon CTest label and that at least one of them gets the smoke label. psi4/doc/sphinxman/. Create a new .rst page, copying one of the Add-Ons with similar; language and dependency requirements. Edit it; as appropriate. Add this page to the list in; psi4/doc/sphinxman/source/interfacing.rst.; Add a bullet to psi4/doc/sphinxman/source/build_planning.rst; Add the new page to the long list in; psi4/doc/sphinxman/CMakeLists.txt. If there are any files or; images referred to, add them to the file, too, following precedent. else¶. Build conda packages. Recipes in https://github.com/psi4/psi4meta/tree/master/conda-recipes. PSI4 and Add-On Projects Wor",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:4168,Testability,test,tests,4168," be sure to conditionalize it with if(TARGET; AddOn::addon) in CMake files or #ifdef USING_AddOn in; source files.; If a separate module is not required, follow the patter of dkh; or simint with respect to libmints. Again, conditionalize as in; preceding bullet. psi4/external/upstream/. Add a CMakeLists.txt that imitates another AddOn of similar; language and dependencies. Try to keep the format, messaging,; and variables passed as similar as possible so that differences; mean something. If BLAS/LAPACK or other common dependencies in; psi4/external/common are needed, be sure to add them to the; DEPENDS argument.; The usual practice to to get everything cohesive between; the CMake for the AddOn repository and PSI4 and then as a; last step, mint a tag in the former and add it to two places in; external/upstream/addon_name/CMakeLists.txt and one; place in psi4/psi4/CMakeLists.txt so that only that version; and later are acceptable to PSI4 for detecting pre-built. psi4/tests/. In psi4/tests/CMakeLists.txt, add a block adding a tests subdirectory if Add-On enabled; Create new subdirectory tests/addon_name with a; CMakeLists.txt. In that add a few tests. Imitate the pattern in; other subdirs of including the addon prefix to the test name in the; CMakeLists but not in the test dir name. Make sure the tests get the; addon CTest label and that at least one of them gets the smoke label. psi4/doc/sphinxman/. Create a new .rst page, copying one of the Add-Ons with similar; language and dependency requirements. Edit it; as appropriate. Add this page to the list in; psi4/doc/sphinxman/source/interfacing.rst.; Add a bullet to psi4/doc/sphinxman/source/build_planning.rst; Add the new page to the long list in; psi4/doc/sphinxman/CMakeLists.txt. If there are any files or; images referred to, add them to the file, too, following precedent. else¶. Build conda packages. Recipes in https://github.com/psi4/psi4meta/tree/master/conda-recipes. PSI4 and Add-On Projects Working Together. Obli",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:4211,Testability,test,tests,4211,"or #ifdef USING_AddOn in; source files.; If a separate module is not required, follow the patter of dkh; or simint with respect to libmints. Again, conditionalize as in; preceding bullet. psi4/external/upstream/. Add a CMakeLists.txt that imitates another AddOn of similar; language and dependencies. Try to keep the format, messaging,; and variables passed as similar as possible so that differences; mean something. If BLAS/LAPACK or other common dependencies in; psi4/external/common are needed, be sure to add them to the; DEPENDS argument.; The usual practice to to get everything cohesive between; the CMake for the AddOn repository and PSI4 and then as a; last step, mint a tag in the former and add it to two places in; external/upstream/addon_name/CMakeLists.txt and one; place in psi4/psi4/CMakeLists.txt so that only that version; and later are acceptable to PSI4 for detecting pre-built. psi4/tests/. In psi4/tests/CMakeLists.txt, add a block adding a tests subdirectory if Add-On enabled; Create new subdirectory tests/addon_name with a; CMakeLists.txt. In that add a few tests. Imitate the pattern in; other subdirs of including the addon prefix to the test name in the; CMakeLists but not in the test dir name. Make sure the tests get the; addon CTest label and that at least one of them gets the smoke label. psi4/doc/sphinxman/. Create a new .rst page, copying one of the Add-Ons with similar; language and dependency requirements. Edit it; as appropriate. Add this page to the list in; psi4/doc/sphinxman/source/interfacing.rst.; Add a bullet to psi4/doc/sphinxman/source/build_planning.rst; Add the new page to the long list in; psi4/doc/sphinxman/CMakeLists.txt. If there are any files or; images referred to, add them to the file, too, following precedent. else¶. Build conda packages. Recipes in https://github.com/psi4/psi4meta/tree/master/conda-recipes. PSI4 and Add-On Projects Working Together. Obligations of the External Project owners are to:. allow us to contribute some",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:4273,Testability,test,tests,4273,"or #ifdef USING_AddOn in; source files.; If a separate module is not required, follow the patter of dkh; or simint with respect to libmints. Again, conditionalize as in; preceding bullet. psi4/external/upstream/. Add a CMakeLists.txt that imitates another AddOn of similar; language and dependencies. Try to keep the format, messaging,; and variables passed as similar as possible so that differences; mean something. If BLAS/LAPACK or other common dependencies in; psi4/external/common are needed, be sure to add them to the; DEPENDS argument.; The usual practice to to get everything cohesive between; the CMake for the AddOn repository and PSI4 and then as a; last step, mint a tag in the former and add it to two places in; external/upstream/addon_name/CMakeLists.txt and one; place in psi4/psi4/CMakeLists.txt so that only that version; and later are acceptable to PSI4 for detecting pre-built. psi4/tests/. In psi4/tests/CMakeLists.txt, add a block adding a tests subdirectory if Add-On enabled; Create new subdirectory tests/addon_name with a; CMakeLists.txt. In that add a few tests. Imitate the pattern in; other subdirs of including the addon prefix to the test name in the; CMakeLists but not in the test dir name. Make sure the tests get the; addon CTest label and that at least one of them gets the smoke label. psi4/doc/sphinxman/. Create a new .rst page, copying one of the Add-Ons with similar; language and dependency requirements. Edit it; as appropriate. Add this page to the list in; psi4/doc/sphinxman/source/interfacing.rst.; Add a bullet to psi4/doc/sphinxman/source/build_planning.rst; Add the new page to the long list in; psi4/doc/sphinxman/CMakeLists.txt. If there are any files or; images referred to, add them to the file, too, following precedent. else¶. Build conda packages. Recipes in https://github.com/psi4/psi4meta/tree/master/conda-recipes. PSI4 and Add-On Projects Working Together. Obligations of the External Project owners are to:. allow us to contribute some",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:4332,Testability,test,tests,4332," follow the patter of dkh; or simint with respect to libmints. Again, conditionalize as in; preceding bullet. psi4/external/upstream/. Add a CMakeLists.txt that imitates another AddOn of similar; language and dependencies. Try to keep the format, messaging,; and variables passed as similar as possible so that differences; mean something. If BLAS/LAPACK or other common dependencies in; psi4/external/common are needed, be sure to add them to the; DEPENDS argument.; The usual practice to to get everything cohesive between; the CMake for the AddOn repository and PSI4 and then as a; last step, mint a tag in the former and add it to two places in; external/upstream/addon_name/CMakeLists.txt and one; place in psi4/psi4/CMakeLists.txt so that only that version; and later are acceptable to PSI4 for detecting pre-built. psi4/tests/. In psi4/tests/CMakeLists.txt, add a block adding a tests subdirectory if Add-On enabled; Create new subdirectory tests/addon_name with a; CMakeLists.txt. In that add a few tests. Imitate the pattern in; other subdirs of including the addon prefix to the test name in the; CMakeLists but not in the test dir name. Make sure the tests get the; addon CTest label and that at least one of them gets the smoke label. psi4/doc/sphinxman/. Create a new .rst page, copying one of the Add-Ons with similar; language and dependency requirements. Edit it; as appropriate. Add this page to the list in; psi4/doc/sphinxman/source/interfacing.rst.; Add a bullet to psi4/doc/sphinxman/source/build_planning.rst; Add the new page to the long list in; psi4/doc/sphinxman/CMakeLists.txt. If there are any files or; images referred to, add them to the file, too, following precedent. else¶. Build conda packages. Recipes in https://github.com/psi4/psi4meta/tree/master/conda-recipes. PSI4 and Add-On Projects Working Together. Obligations of the External Project owners are to:. allow us to contribute some CMake files to your build system; so that compile flags and dependencies (e.g.",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:4414,Testability,test,test,4414,"lize as in; preceding bullet. psi4/external/upstream/. Add a CMakeLists.txt that imitates another AddOn of similar; language and dependencies. Try to keep the format, messaging,; and variables passed as similar as possible so that differences; mean something. If BLAS/LAPACK or other common dependencies in; psi4/external/common are needed, be sure to add them to the; DEPENDS argument.; The usual practice to to get everything cohesive between; the CMake for the AddOn repository and PSI4 and then as a; last step, mint a tag in the former and add it to two places in; external/upstream/addon_name/CMakeLists.txt and one; place in psi4/psi4/CMakeLists.txt so that only that version; and later are acceptable to PSI4 for detecting pre-built. psi4/tests/. In psi4/tests/CMakeLists.txt, add a block adding a tests subdirectory if Add-On enabled; Create new subdirectory tests/addon_name with a; CMakeLists.txt. In that add a few tests. Imitate the pattern in; other subdirs of including the addon prefix to the test name in the; CMakeLists but not in the test dir name. Make sure the tests get the; addon CTest label and that at least one of them gets the smoke label. psi4/doc/sphinxman/. Create a new .rst page, copying one of the Add-Ons with similar; language and dependency requirements. Edit it; as appropriate. Add this page to the list in; psi4/doc/sphinxman/source/interfacing.rst.; Add a bullet to psi4/doc/sphinxman/source/build_planning.rst; Add the new page to the long list in; psi4/doc/sphinxman/CMakeLists.txt. If there are any files or; images referred to, add them to the file, too, following precedent. else¶. Build conda packages. Recipes in https://github.com/psi4/psi4meta/tree/master/conda-recipes. PSI4 and Add-On Projects Working Together. Obligations of the External Project owners are to:. allow us to contribute some CMake files to your build system; so that compile flags and dependencies (e.g., BLAS/LAPACK) can be; consistent with the PSI4 build and so the installed proj",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:4458,Testability,test,test,4458,"lize as in; preceding bullet. psi4/external/upstream/. Add a CMakeLists.txt that imitates another AddOn of similar; language and dependencies. Try to keep the format, messaging,; and variables passed as similar as possible so that differences; mean something. If BLAS/LAPACK or other common dependencies in; psi4/external/common are needed, be sure to add them to the; DEPENDS argument.; The usual practice to to get everything cohesive between; the CMake for the AddOn repository and PSI4 and then as a; last step, mint a tag in the former and add it to two places in; external/upstream/addon_name/CMakeLists.txt and one; place in psi4/psi4/CMakeLists.txt so that only that version; and later are acceptable to PSI4 for detecting pre-built. psi4/tests/. In psi4/tests/CMakeLists.txt, add a block adding a tests subdirectory if Add-On enabled; Create new subdirectory tests/addon_name with a; CMakeLists.txt. In that add a few tests. Imitate the pattern in; other subdirs of including the addon prefix to the test name in the; CMakeLists but not in the test dir name. Make sure the tests get the; addon CTest label and that at least one of them gets the smoke label. psi4/doc/sphinxman/. Create a new .rst page, copying one of the Add-Ons with similar; language and dependency requirements. Edit it; as appropriate. Add this page to the list in; psi4/doc/sphinxman/source/interfacing.rst.; Add a bullet to psi4/doc/sphinxman/source/build_planning.rst; Add the new page to the long list in; psi4/doc/sphinxman/CMakeLists.txt. If there are any files or; images referred to, add them to the file, too, following precedent. else¶. Build conda packages. Recipes in https://github.com/psi4/psi4meta/tree/master/conda-recipes. PSI4 and Add-On Projects Working Together. Obligations of the External Project owners are to:. allow us to contribute some CMake files to your build system; so that compile flags and dependencies (e.g., BLAS/LAPACK) can be; consistent with the PSI4 build and so the installed proj",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:4487,Testability,test,tests,4487,"language and dependencies. Try to keep the format, messaging,; and variables passed as similar as possible so that differences; mean something. If BLAS/LAPACK or other common dependencies in; psi4/external/common are needed, be sure to add them to the; DEPENDS argument.; The usual practice to to get everything cohesive between; the CMake for the AddOn repository and PSI4 and then as a; last step, mint a tag in the former and add it to two places in; external/upstream/addon_name/CMakeLists.txt and one; place in psi4/psi4/CMakeLists.txt so that only that version; and later are acceptable to PSI4 for detecting pre-built. psi4/tests/. In psi4/tests/CMakeLists.txt, add a block adding a tests subdirectory if Add-On enabled; Create new subdirectory tests/addon_name with a; CMakeLists.txt. In that add a few tests. Imitate the pattern in; other subdirs of including the addon prefix to the test name in the; CMakeLists but not in the test dir name. Make sure the tests get the; addon CTest label and that at least one of them gets the smoke label. psi4/doc/sphinxman/. Create a new .rst page, copying one of the Add-Ons with similar; language and dependency requirements. Edit it; as appropriate. Add this page to the list in; psi4/doc/sphinxman/source/interfacing.rst.; Add a bullet to psi4/doc/sphinxman/source/build_planning.rst; Add the new page to the long list in; psi4/doc/sphinxman/CMakeLists.txt. If there are any files or; images referred to, add them to the file, too, following precedent. else¶. Build conda packages. Recipes in https://github.com/psi4/psi4meta/tree/master/conda-recipes. PSI4 and Add-On Projects Working Together. Obligations of the External Project owners are to:. allow us to contribute some CMake files to your build system; so that compile flags and dependencies (e.g., BLAS/LAPACK) can be; consistent with the PSI4 build and so the installed project can; be readily detected by PSI4 or any interested party (through a; CMake imported target).; provide us a tag at",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:5525,Testability,test,tested,5525,"hem gets the smoke label. psi4/doc/sphinxman/. Create a new .rst page, copying one of the Add-Ons with similar; language and dependency requirements. Edit it; as appropriate. Add this page to the list in; psi4/doc/sphinxman/source/interfacing.rst.; Add a bullet to psi4/doc/sphinxman/source/build_planning.rst; Add the new page to the long list in; psi4/doc/sphinxman/CMakeLists.txt. If there are any files or; images referred to, add them to the file, too, following precedent. else¶. Build conda packages. Recipes in https://github.com/psi4/psi4meta/tree/master/conda-recipes. PSI4 and Add-On Projects Working Together. Obligations of the External Project owners are to:. allow us to contribute some CMake files to your build system; so that compile flags and dependencies (e.g., BLAS/LAPACK) can be; consistent with the PSI4 build and so the installed project can; be readily detected by PSI4 or any interested party (through a; CMake imported target).; provide us a tag at a tested commit/version number so their; development may be ongoing.; communicate with us when they’ve made improvements and minted; a new tag. In return, for Add-Ons the PSI4 project will:. leave control of their code under your purview.; maintain any interfacing code needed.; regularly run integration tests between PSI4 and your code.; build a mostly statically linked conda package so that any; of your users can obtain a pre-built binary distribution through; conda install addon --channel psi4.; provide a development sandbox for your code through PSI4 plugins.; provide conda download counts independent of PSI4. How to name keywords in psi4/src/read_options.cc¶; A few guidelines for standardizing option names among modules. TRIPLES (not trip), TRIPLETS (not trip), SINGLES (not sing),; SINGLETS (not sing); CONVERGENCE (not conv, not converge) and TOLERANCE (not tol); Convergence of a method should be governed by an E_CONVERGENCE for; energy and either a D_CONVERGENCE for density or a R_CONVERGENCE; for resid",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:5828,Testability,test,tests,5828,"source/build_planning.rst; Add the new page to the long list in; psi4/doc/sphinxman/CMakeLists.txt. If there are any files or; images referred to, add them to the file, too, following precedent. else¶. Build conda packages. Recipes in https://github.com/psi4/psi4meta/tree/master/conda-recipes. PSI4 and Add-On Projects Working Together. Obligations of the External Project owners are to:. allow us to contribute some CMake files to your build system; so that compile flags and dependencies (e.g., BLAS/LAPACK) can be; consistent with the PSI4 build and so the installed project can; be readily detected by PSI4 or any interested party (through a; CMake imported target).; provide us a tag at a tested commit/version number so their; development may be ongoing.; communicate with us when they’ve made improvements and minted; a new tag. In return, for Add-Ons the PSI4 project will:. leave control of their code under your purview.; maintain any interfacing code needed.; regularly run integration tests between PSI4 and your code.; build a mostly statically linked conda package so that any; of your users can obtain a pre-built binary distribution through; conda install addon --channel psi4.; provide a development sandbox for your code through PSI4 plugins.; provide conda download counts independent of PSI4. How to name keywords in psi4/src/read_options.cc¶; A few guidelines for standardizing option names among modules. TRIPLES (not trip), TRIPLETS (not trip), SINGLES (not sing),; SINGLETS (not sing); CONVERGENCE (not conv, not converge) and TOLERANCE (not tol); Convergence of a method should be governed by an E_CONVERGENCE for; energy and either a D_CONVERGENCE for density or a R_CONVERGENCE; for residual/amplitudes. All of these should be doubles- let the input; parser handle the flexible input format.; Diis should have a boolean DIIS (not do_diis, not use_diis) to turn; on/off diis extrapolation, a DIIS_MIN_VECS and DIIS_MAX_VECS for; minimum and maximum number of diis vectors to",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:6048,Testability,sandbox,sandbox,6048,"ipes in https://github.com/psi4/psi4meta/tree/master/conda-recipes. PSI4 and Add-On Projects Working Together. Obligations of the External Project owners are to:. allow us to contribute some CMake files to your build system; so that compile flags and dependencies (e.g., BLAS/LAPACK) can be; consistent with the PSI4 build and so the installed project can; be readily detected by PSI4 or any interested party (through a; CMake imported target).; provide us a tag at a tested commit/version number so their; development may be ongoing.; communicate with us when they’ve made improvements and minted; a new tag. In return, for Add-Ons the PSI4 project will:. leave control of their code under your purview.; maintain any interfacing code needed.; regularly run integration tests between PSI4 and your code.; build a mostly statically linked conda package so that any; of your users can obtain a pre-built binary distribution through; conda install addon --channel psi4.; provide a development sandbox for your code through PSI4 plugins.; provide conda download counts independent of PSI4. How to name keywords in psi4/src/read_options.cc¶; A few guidelines for standardizing option names among modules. TRIPLES (not trip), TRIPLETS (not trip), SINGLES (not sing),; SINGLETS (not sing); CONVERGENCE (not conv, not converge) and TOLERANCE (not tol); Convergence of a method should be governed by an E_CONVERGENCE for; energy and either a D_CONVERGENCE for density or a R_CONVERGENCE; for residual/amplitudes. All of these should be doubles- let the input; parser handle the flexible input format.; Diis should have a boolean DIIS (not do_diis, not use_diis) to turn; on/off diis extrapolation, a DIIS_MIN_VECS and DIIS_MAX_VECS for; minimum and maximum number of diis vectors to use, and a DIIS_START; which is the iteration at which to start saving vectors for diis. Not all; modules conform to all these at present, but they’re as standardized as; they can be without changing code.; AMPS (not amplitude",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:8647,Testability,test,tested,8647,"RINT, READ, and WRITE will usually; be the last words in an option name.; Use FOLLOW_ROOT for the state to be followed in geometry optimizations; WFN (not wavefunction); You’re welcome to use WFN and DERTYPE as internal options, but; plan to have these set by the python driver and mark them as !expert; options. Really avoid using JOBTYPE.; You’re not welcome to add CHARGE or MULTP options. Plan to get; these quantities from the molecule object. Since we frequently use subsets; of systems (with their own charge and multiplicity), this is safer.; Conform. Just grep 'add' psi4/src/read_options.cc to get a list of; all the option names in PSI4 and try to match any conventions you; find.; If you have a quantity you’d like to call a cutoff, a threshold, a; tolerance, or a convergence, consider the following guidelines in naming; it. If its value is typically greater than ~0.001, give it a name with CUTOFF.; If its value is typically less than ~0.001 and quantities being tested; against the option are more valuable with larger values (e.g.,; integrals, occupations, eigenvectors), give it a name with TOLERANCE.; If its value is typically less than ~0.001 and quantities being tested; against the option are more valuable with smaller values (e.g., energy; changes, residual errors, gradients), give it a name with; CONVERGENCE. In deciding how to arrange words in an option name, place the context; first (e.g., MP2_AMPS_PRINT, TRIPLES_DIIS). This means PRINT; will generally be at the end of an option name.; Use INTS_TOLERANCE (not schwarz_cutoff); H in an option name is reserved for Hamiltonian (or hydrogen).; Hessian should be HESS.; All option names should be all caps and separated by underscores.; If you have an option that instructs your module to do something not too; computationally intensive and then quit, append _EXIT to the option; name.; Scaling terms (like for scs) should follow the pattern MP2_SS_SCALE; and SAPT_OS_SCALE.; FRAG for fragment.; AVG for average.; For le",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:8854,Testability,test,tested,8854," as internal options, but; plan to have these set by the python driver and mark them as !expert; options. Really avoid using JOBTYPE.; You’re not welcome to add CHARGE or MULTP options. Plan to get; these quantities from the molecule object. Since we frequently use subsets; of systems (with their own charge and multiplicity), this is safer.; Conform. Just grep 'add' psi4/src/read_options.cc to get a list of; all the option names in PSI4 and try to match any conventions you; find.; If you have a quantity you’d like to call a cutoff, a threshold, a; tolerance, or a convergence, consider the following guidelines in naming; it. If its value is typically greater than ~0.001, give it a name with CUTOFF.; If its value is typically less than ~0.001 and quantities being tested; against the option are more valuable with larger values (e.g.,; integrals, occupations, eigenvectors), give it a name with TOLERANCE.; If its value is typically less than ~0.001 and quantities being tested; against the option are more valuable with smaller values (e.g., energy; changes, residual errors, gradients), give it a name with; CONVERGENCE. In deciding how to arrange words in an option name, place the context; first (e.g., MP2_AMPS_PRINT, TRIPLES_DIIS). This means PRINT; will generally be at the end of an option name.; Use INTS_TOLERANCE (not schwarz_cutoff); H in an option name is reserved for Hamiltonian (or hydrogen).; Hessian should be HESS.; All option names should be all caps and separated by underscores.; If you have an option that instructs your module to do something not too; computationally intensive and then quit, append _EXIT to the option; name.; Scaling terms (like for scs) should follow the pattern MP2_SS_SCALE; and SAPT_OS_SCALE.; FRAG for fragment.; AVG for average.; For level-shifting, let’s try to have it governed by (double); LEVEL_SHIFT only and not a boolean/double combo since the procedure; can be turned on (role of boolean) if the value (role of double) has; changed.; Fo",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:11486,Testability,test,testing,11486,"alue (role of double) has; changed.; For Tikhonow regularization, use TIKONOW_OMEGA, not regularizer.; SYM for symmetry.; OCC for occupied/occupation (e.g., DOCC, LOCK_OCC, OCC_TOLERANCE).; COND for condition and CONDITIONER for conditioner.; LOCAL (not localize).; Use AO and MO for atomic and molecular orbitals. When ‘O’ for; orbitals is too obsure or would make for too short a keyword, as in; “bool NO” for “Do use natural orbitals”, use ORBS for orbitals. So; natural orbitals are NAT_ORBS and Brueckner orbitals are; BRUECKNER_ORBS.; LEVEL (not LVL, not LEV).; EX for excitation.; VAL for valence.; GEOM (not geo, not geometry).; SYM (not symm, not symmetry).; FILE (unless truly multiple FILES).; WRITE/READ for info transfer across jobs. SAVE/RESTART; for same in context of restart.; Damping should interface through option (double) DAMPING_PERCENTAGE,; where a value of 0.0 indicates no damping.; Try to avoid COMPUTE or CALC in an option name. If it’s a; boolean like “opdm_compute” for “Do compute the one-particle density; matrix”, just use OPDM.; Properties should be governed by a PROPERTIES array for the root of; interest or by a PROPERTIES_ALL array for all roots in a multi-root; calc. Since no module conforms to this right now, use PROPERTY; alone and PROP in multi-part option as PROP_ROOT, PROP_ALL,; PROP_SYM to conform.; Use DF (not ri) for density-fitting and resolution-of-the-identity; option names. Only the basis sets are staying as -RI since that’s what; EMSL uses. table of contents. Adding Add-Ons; How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs; else; How to name keywords in psi4/src/read_options.cc. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that; Adding Add-Ons. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:6201,Usability,guid,guidelines,6201,"ow us to contribute some CMake files to your build system; so that compile flags and dependencies (e.g., BLAS/LAPACK) can be; consistent with the PSI4 build and so the installed project can; be readily detected by PSI4 or any interested party (through a; CMake imported target).; provide us a tag at a tested commit/version number so their; development may be ongoing.; communicate with us when they’ve made improvements and minted; a new tag. In return, for Add-Ons the PSI4 project will:. leave control of their code under your purview.; maintain any interfacing code needed.; regularly run integration tests between PSI4 and your code.; build a mostly statically linked conda package so that any; of your users can obtain a pre-built binary distribution through; conda install addon --channel psi4.; provide a development sandbox for your code through PSI4 plugins.; provide conda download counts independent of PSI4. How to name keywords in psi4/src/read_options.cc¶; A few guidelines for standardizing option names among modules. TRIPLES (not trip), TRIPLETS (not trip), SINGLES (not sing),; SINGLETS (not sing); CONVERGENCE (not conv, not converge) and TOLERANCE (not tol); Convergence of a method should be governed by an E_CONVERGENCE for; energy and either a D_CONVERGENCE for density or a R_CONVERGENCE; for residual/amplitudes. All of these should be doubles- let the input; parser handle the flexible input format.; Diis should have a boolean DIIS (not do_diis, not use_diis) to turn; on/off diis extrapolation, a DIIS_MIN_VECS and DIIS_MAX_VECS for; minimum and maximum number of diis vectors to use, and a DIIS_START; which is the iteration at which to start saving vectors for diis. Not all; modules conform to all these at present, but they’re as standardized as; they can be without changing code.; AMPS (not amplitude, not amp) for amplitudes; NUM_ (not n) for number (e.g., NUM_AMPS_PRINT, MAX_NUM_VECS,; NUM_THREADS); Some names that could be split into multiple words are staying ",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_addon.html:8481,Usability,guid,guidelines,8481," perturbation; Use PRINT options to indicate printing to output file. Use WRITE; options to indicate printing to another file. This probably isn’t; entirely valid now but should be observed in future. The complement to; WRITE is READ. PRINT, READ, and WRITE will usually; be the last words in an option name.; Use FOLLOW_ROOT for the state to be followed in geometry optimizations; WFN (not wavefunction); You’re welcome to use WFN and DERTYPE as internal options, but; plan to have these set by the python driver and mark them as !expert; options. Really avoid using JOBTYPE.; You’re not welcome to add CHARGE or MULTP options. Plan to get; these quantities from the molecule object. Since we frequently use subsets; of systems (with their own charge and multiplicity), this is safer.; Conform. Just grep 'add' psi4/src/read_options.cc to get a list of; all the option names in PSI4 and try to match any conventions you; find.; If you have a quantity you’d like to call a cutoff, a threshold, a; tolerance, or a convergence, consider the following guidelines in naming; it. If its value is typically greater than ~0.001, give it a name with CUTOFF.; If its value is typically less than ~0.001 and quantities being tested; against the option are more valuable with larger values (e.g.,; integrals, occupations, eigenvectors), give it a name with TOLERANCE.; If its value is typically less than ~0.001 and quantities being tested; against the option are more valuable with smaller values (e.g., energy; changes, residual errors, gradients), give it a name with; CONVERGENCE. In deciding how to arrange words in an option name, place the context; first (e.g., MP2_AMPS_PRINT, TRIPLES_DIIS). This means PRINT; will generally be at the end of an option name.; Use INTS_TOLERANCE (not schwarz_cutoff); H in an option name is reserved for Hamiltonian (or hydrogen).; Hessian should be HESS.; All option names should be all caps and separated by underscores.; If you have an option that instructs your module",MatchSource.WIKI,psi4manual/1.6.x/manage_addon.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_addon.html
https://psicode.org/psi4manual/1.6.x/manage_git.html:6421,Availability,error,errors,6421,"irty. R. M. Parrish, L. A. Burns, D. G. A. Smith, A. C. Simmonett,; A. E. DePrince III, E. G. Hohenstein, U. Bozkaya, A. Yu. Sokolov,; R. Di Remigio, R. M. Richard, J. F. Gonthier, A. M. James,; H. R. McAlexander, A. Kumar, M. Saitow, X. Wang, B. P. Pritchard,; P. Verma, H. F. Schaefer III, K. Patkowski, R. A. King, E. F. Valeev,; F. A. Evangelista, J. M. Turney, T. D. Crawford, and C. D. Sherrill,; submitted. -----------------------------------------------------------------------. Psi4 started on: Friday, 28 April 2017 07:31PM. Process ID: 95107; PSIDATADIR: /Users/johndoe/psi4/objdir8/stage/usr/local/psi4/share/psi4; Memory: 500.0 MiB; Threads: 1. >>> psi4.version_formatter(); '1.1rc2.dev17'; >>> psi4.version_formatter('all'); '1.1rc2.dev17 {condadoc} c852257 1.0.0.999 dirty 1.0 <-- 1.1rc2.dev17+c852257'; >>> psi4.version_formatter(""""""{{{branch}}} {versionlong}""""""); '{condadoc} 1.1rc2.dev17+c852257'. How to locate non-ascii characters in the codebase¶; Neither the Python interpreter nor Sphinx like non-ASCII characters one; bit, though the errors may be intermittant. Output files are usually ok,; so Jerome can live, for now. To aid in tracking down offenders, here’s; the vi and grep search strings. In the docs, you want to use; the substitutions in psi4/doc/sphinxman/source/abbr_accents.rst; instead of the actual characters.; # vim; :/[^\x00-\x7F]. # bash; grep -r --color='auto' -P -n ""[^\x00-\x7F]"" psi4/. How to fix “Psi4 undefined” version¶; When in a git repo, the versioner uses git describe and psi4/metadata.py; to compute the version. If you don’t have all the latest tags, this mechanism; can’t work. To solve, pull tags and remake.; # upstream in `git remote -v` points to github.com/psi4/psi4.git; >>> git fetch upstream 'refs/tags/*:refs/tags/*'; >>> make; # version healed. How to fix “cannot import name ‘core’ from {top-level-psi4-dir}¶; First, what’s happening? sys.path (where modules can be imported from in python) starts with ''. If you export PYTHONPATH=",MatchSource.WIKI,psi4manual/1.6.x/manage_git.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_git.html
https://psicode.org/psi4manual/1.6.x/manage_git.html:6527,Availability,down,down,6527,"A. M. James,; H. R. McAlexander, A. Kumar, M. Saitow, X. Wang, B. P. Pritchard,; P. Verma, H. F. Schaefer III, K. Patkowski, R. A. King, E. F. Valeev,; F. A. Evangelista, J. M. Turney, T. D. Crawford, and C. D. Sherrill,; submitted. -----------------------------------------------------------------------. Psi4 started on: Friday, 28 April 2017 07:31PM. Process ID: 95107; PSIDATADIR: /Users/johndoe/psi4/objdir8/stage/usr/local/psi4/share/psi4; Memory: 500.0 MiB; Threads: 1. >>> psi4.version_formatter(); '1.1rc2.dev17'; >>> psi4.version_formatter('all'); '1.1rc2.dev17 {condadoc} c852257 1.0.0.999 dirty 1.0 <-- 1.1rc2.dev17+c852257'; >>> psi4.version_formatter(""""""{{{branch}}} {versionlong}""""""); '{condadoc} 1.1rc2.dev17+c852257'. How to locate non-ascii characters in the codebase¶; Neither the Python interpreter nor Sphinx like non-ASCII characters one; bit, though the errors may be intermittant. Output files are usually ok,; so Jerome can live, for now. To aid in tracking down offenders, here’s; the vi and grep search strings. In the docs, you want to use; the substitutions in psi4/doc/sphinxman/source/abbr_accents.rst; instead of the actual characters.; # vim; :/[^\x00-\x7F]. # bash; grep -r --color='auto' -P -n ""[^\x00-\x7F]"" psi4/. How to fix “Psi4 undefined” version¶; When in a git repo, the versioner uses git describe and psi4/metadata.py; to compute the version. If you don’t have all the latest tags, this mechanism; can’t work. To solve, pull tags and remake.; # upstream in `git remote -v` points to github.com/psi4/psi4.git; >>> git fetch upstream 'refs/tags/*:refs/tags/*'; >>> make; # version healed. How to fix “cannot import name ‘core’ from {top-level-psi4-dir}¶; First, what’s happening? sys.path (where modules can be imported from in python) starts with ''. If you export PYTHONPATH={objdir}/stage/{prefix}/lib/{pymod_lib_dir}:$PYTHONPATH to make PsiAPI easy, that inserts starting in pos’n 1 (0-indexed), so '' still at the head of sys.path. Now, if you try to run",MatchSource.WIKI,psi4manual/1.6.x/manage_git.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_git.html
https://psicode.org/psi4manual/1.6.x/manage_git.html:9026,Availability,mainten,maintenance,9026,"uld add its own; output.ref. When that doesn’t happen, this command helps.; find tests/ -mindepth 1 -maxdepth 1 -type d '!' -exec test -e ""{}/output.ref"" "";"" -print. How to do GitHub issue management and code review¶. Anyone, core-dev or not, is encouraged to review PRs. It’s actually good practice for interacting with other open-source projects, where you don’t have the advantage of knowing or working with the contributors. Before venturing into projects on GitHub where you don’t know the maintainers, it doesn’t hurt to read https://snarky.ca/setting-expectations-for-open-source-participation/ .; Psi4 is a learning tool for all involved, so partial reviews in areas of confidence and questions and comments on PRs in general are encouraged.; Approving before CI completes is fine, though it can be mildly personally embarrassing when CI catches something you didn’t.; All main branches (master and 1.N.x maintenance) are protected by GitHub, including administrators, so even with write access, no one can accidentally push (master) or rewrite the history (master and maintenance).; PR owners who also have maintainer status can merge their PRs as GitHub enforces three external reviews.; Unless there’s been a lot of discussion on core-dev about merge order, generally the 3rd positive reviewer merges the PR. Also fine to add review and leave merge for later.; Presently only Travis-CI is set up as a required-to-merge service. Incomplete Azure won’t block merging, but we do usually let it complete before merging unless it’s a trivial PR.; We don’t enforce branches to be up to date before merging since that’d be a lot of extra CI time and coordination when merging several PRs in a day. So, if a PR hasn’t been updated in a while, and a reviewer is nervous about PR interference, fine to ask submitter to rebase. For this reason, we try to merge newer contributors first so the rebase falls on more experienced contributors.; Ideally a PR consists of atomic, compilable commits. When th",MatchSource.WIKI,psi4manual/1.6.x/manage_git.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_git.html
https://psicode.org/psi4manual/1.6.x/manage_git.html:9190,Availability,mainten,maintenance,9190,"uld add its own; output.ref. When that doesn’t happen, this command helps.; find tests/ -mindepth 1 -maxdepth 1 -type d '!' -exec test -e ""{}/output.ref"" "";"" -print. How to do GitHub issue management and code review¶. Anyone, core-dev or not, is encouraged to review PRs. It’s actually good practice for interacting with other open-source projects, where you don’t have the advantage of knowing or working with the contributors. Before venturing into projects on GitHub where you don’t know the maintainers, it doesn’t hurt to read https://snarky.ca/setting-expectations-for-open-source-participation/ .; Psi4 is a learning tool for all involved, so partial reviews in areas of confidence and questions and comments on PRs in general are encouraged.; Approving before CI completes is fine, though it can be mildly personally embarrassing when CI catches something you didn’t.; All main branches (master and 1.N.x maintenance) are protected by GitHub, including administrators, so even with write access, no one can accidentally push (master) or rewrite the history (master and maintenance).; PR owners who also have maintainer status can merge their PRs as GitHub enforces three external reviews.; Unless there’s been a lot of discussion on core-dev about merge order, generally the 3rd positive reviewer merges the PR. Also fine to add review and leave merge for later.; Presently only Travis-CI is set up as a required-to-merge service. Incomplete Azure won’t block merging, but we do usually let it complete before merging unless it’s a trivial PR.; We don’t enforce branches to be up to date before merging since that’d be a lot of extra CI time and coordination when merging several PRs in a day. So, if a PR hasn’t been updated in a while, and a reviewer is nervous about PR interference, fine to ask submitter to rebase. For this reason, we try to merge newer contributors first so the rebase falls on more experienced contributors.; Ideally a PR consists of atomic, compilable commits. When th",MatchSource.WIKI,psi4manual/1.6.x/manage_git.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_git.html
https://psicode.org/psi4manual/1.6.x/manage_git.html:426,Deployability,release,releases,426,"﻿. Git, Versioning. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that; Git, Versioning. Git, Versioning¶. How to bump a version¶. ACT to check everything in; OBSERVE current versioning state. Be on master of (i) a direct clone or (ii) clone-of-fork with master; up-to-date with upstream (including tags!!!) and with upstream as; remote.; https://github.com/psi4/psi4/releases says v1.1a1 & 007a9b6. >>> git tag; v1.0; v1.1a1. >>> cat psi4/metadata.py; __version__ = '1.1a1'; __version_long = '1.1a1+007a9b6'; __version_upcoming_annotated_v_tag = '1.1a2'. >>> git describe --abbrev=7 --long --always HEAD; v1.1a1-417-gcbee32b. >>> git describe --abbrev=7 --long --dirty; v1.1a1-417-gcbee32b. >>> ./psi4/versioner.py; Defining development snapshot version: 1.1a2.dev417+cbee32b (computed); 1.1a2.dev417 {master} cbee32b 1.0.0.999 1.0 <-- 1.1a2.dev417+cbee32b. >>> git diff. Observe that current latest tag matches metadata scipt and git; describe, that GitHub releases matches metadata script, that upcoming in; metadata script matches current versioner version.; Note that current tag is v1.1a1. Decide on imminent tag, say v1.1rc1. ACT to bump tag in code. Edit current & prospective tag in psi4/psi4/metadata.py. Use your; decided-upon tag v1.1rc1 and a speculative next tag, say v1.1rc2,; and use 7 “z”s for the part you can’t predict. >>> vi psi4/metadata.py. >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; index 5d87b55..6cbc05e 100644; --- a/psi4/metadata.py; +++ b/psi4/metadata.py; @@ -1,6 +1,6 @@; -__version__ = '1.1a1'; -__version_long = '1.1a1+007a9b6'; -__version_upcoming_annotated_v_tag = '1.1a2'; +__version__ = '1.1rc1'; +__version_long = '1.1rc1+zzzzzzz'; +__version_upcoming_annotated_v_tag = '1.1rc2'. >>> git add psi4/metadata.py. >>> git commit -m ""v1.1rc1"". OBSERVE undefined version state. >>> git describe --abbrev=7 --long --always HEAD; v1.1a1-418-g6100822. >>> git describe --abbrev=7 --long --dirt",MatchSource.WIKI,psi4manual/1.6.x/manage_git.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_git.html
https://psicode.org/psi4manual/1.6.x/manage_git.html:1017,Deployability,release,releases,1017,"gation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that; Git, Versioning. Git, Versioning¶. How to bump a version¶. ACT to check everything in; OBSERVE current versioning state. Be on master of (i) a direct clone or (ii) clone-of-fork with master; up-to-date with upstream (including tags!!!) and with upstream as; remote.; https://github.com/psi4/psi4/releases says v1.1a1 & 007a9b6. >>> git tag; v1.0; v1.1a1. >>> cat psi4/metadata.py; __version__ = '1.1a1'; __version_long = '1.1a1+007a9b6'; __version_upcoming_annotated_v_tag = '1.1a2'. >>> git describe --abbrev=7 --long --always HEAD; v1.1a1-417-gcbee32b. >>> git describe --abbrev=7 --long --dirty; v1.1a1-417-gcbee32b. >>> ./psi4/versioner.py; Defining development snapshot version: 1.1a2.dev417+cbee32b (computed); 1.1a2.dev417 {master} cbee32b 1.0.0.999 1.0 <-- 1.1a2.dev417+cbee32b. >>> git diff. Observe that current latest tag matches metadata scipt and git; describe, that GitHub releases matches metadata script, that upcoming in; metadata script matches current versioner version.; Note that current tag is v1.1a1. Decide on imminent tag, say v1.1rc1. ACT to bump tag in code. Edit current & prospective tag in psi4/psi4/metadata.py. Use your; decided-upon tag v1.1rc1 and a speculative next tag, say v1.1rc2,; and use 7 “z”s for the part you can’t predict. >>> vi psi4/metadata.py. >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; index 5d87b55..6cbc05e 100644; --- a/psi4/metadata.py; +++ b/psi4/metadata.py; @@ -1,6 +1,6 @@; -__version__ = '1.1a1'; -__version_long = '1.1a1+007a9b6'; -__version_upcoming_annotated_v_tag = '1.1a2'; +__version__ = '1.1rc1'; +__version_long = '1.1rc1+zzzzzzz'; +__version_upcoming_annotated_v_tag = '1.1rc2'. >>> git add psi4/metadata.py. >>> git commit -m ""v1.1rc1"". OBSERVE undefined version state. >>> git describe --abbrev=7 --long --always HEAD; v1.1a1-418-g6100822. >>> git describe --abbrev=7 --long --dirty; v1.1a1-418-g6100822. ",MatchSource.WIKI,psi4manual/1.6.x/manage_git.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_git.html
https://psicode.org/psi4manual/1.6.x/manage_git.html:4233,Deployability,release,releases,4233,".1rc2.dev1 {master} 4e0596e 1.0.0.999 1.0 <-- 1.1rc2.dev1+4e0596e. >>> git describe --abbrev=7 --long --always HEAD; v1.1rc1-1-g4e0596e. >>> git describe --abbrev=7 --long --dirty; v1.1rc1-1-g4e0596e. >>> git tag; v1.0; v1.1a1; v1.1rc1. >>> cat psi4/metadata.py; __version__ = '1.1rc1'; __version_long = '1.1rc1+6100822'; __version_upcoming_annotated_v_tag = '1.1rc2'. >>> cat metadata.out.py | head -8; __version__ = '1.1rc2.dev1'; __version_branch_name = 'master'; __version_cmake = '1.0.0.999'; __version_is_clean = 'True'; __version_last_release = '1.0'; __version_long = '1.1rc2.dev1+4e0596e'; __version_prerelease = 'False'; __version_release = 'False'. >>> git log --oneline; 4e0596e Records tag for v1.1rc1; 6100822 v1.1rc1; cbee32b Fixes pcmsolver/scf for py3. Moves source for libefp upstream. ACT to inform remote of bump. Temporarily disengage “Include administrators” on protected master branch. >>> git push origin master; >>> git push origin v1.1rc1. Now https://github.com/psi4/psi4/releases says v1.1rc1 & 6100822. How to create and remove an annotated Git tag on a remote¶; PSI4 versioning only works with annotated tags, not lightweight; tags as are created with the GitHub interface. Create annotated tag:; >>> git tag -a v1.1a1 <git hash if not current> -m ""v1.1a1""; >>> git push origin v1.1a1. Delete tag:; >>> git tag -d v1.1a1; >>> git push origin :refs/tags/v1.1a1. Pull tags:; >>> git fetch <remote> 'refs/tags/*:refs/tags/*'. What Psi4 version is running¶. Psithon / from the executable:; >>> psi4 --version; 1.1rc2.dev17. PsiAPI / from the library:; >>> python -c ""import psi4; print(psi4.__version__)""; 1.1rc2.dev17. Output file header gives info like the print_header() below.; Function print_header() returns a summary of citation, version, and; git information about PSI4. Function version_formatter() can; return version and git information in any desired format string.; >>> import psi4; >>> psi4.print_header(). ------------------------------------------------------",MatchSource.WIKI,psi4manual/1.6.x/manage_git.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_git.html
https://psicode.org/psi4manual/1.6.x/manage_git.html:9839,Deployability,update,updated,9839,"ore CI completes is fine, though it can be mildly personally embarrassing when CI catches something you didn’t.; All main branches (master and 1.N.x maintenance) are protected by GitHub, including administrators, so even with write access, no one can accidentally push (master) or rewrite the history (master and maintenance).; PR owners who also have maintainer status can merge their PRs as GitHub enforces three external reviews.; Unless there’s been a lot of discussion on core-dev about merge order, generally the 3rd positive reviewer merges the PR. Also fine to add review and leave merge for later.; Presently only Travis-CI is set up as a required-to-merge service. Incomplete Azure won’t block merging, but we do usually let it complete before merging unless it’s a trivial PR.; We don’t enforce branches to be up to date before merging since that’d be a lot of extra CI time and coordination when merging several PRs in a day. So, if a PR hasn’t been updated in a while, and a reviewer is nervous about PR interference, fine to ask submitter to rebase. For this reason, we try to merge newer contributors first so the rebase falls on more experienced contributors.; Ideally a PR consists of atomic, compilable commits. When the PR instead is many successive small changes toward a single goal, consider squashing the PR. For core-dev’s PRs, there’s implicit permission to squash (unless otherwise noted in PR intro), whereas for new contributors, we often let the commits be messy.; When discussion on issue has overcome the original problem and settled on needing long-term work, fine to move the long-term item to Wish List and close issue. table of contents. Git, Versioning; How to bump a version; How to create and remove an annotated Git tag on a remote; What Psi4 version is running; How to locate non-ascii characters in the codebase; How to fix “Psi4 undefined” version; How to fix “cannot import name ‘core’ from {top-level-psi4-dir}; How to find tests without output.ref; How to",MatchSource.WIKI,psi4manual/1.6.x/manage_git.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_git.html
https://psicode.org/psi4manual/1.6.x/manage_git.html:11125,Deployability,update,updated,11125,"ce).; PR owners who also have maintainer status can merge their PRs as GitHub enforces three external reviews.; Unless there’s been a lot of discussion on core-dev about merge order, generally the 3rd positive reviewer merges the PR. Also fine to add review and leave merge for later.; Presently only Travis-CI is set up as a required-to-merge service. Incomplete Azure won’t block merging, but we do usually let it complete before merging unless it’s a trivial PR.; We don’t enforce branches to be up to date before merging since that’d be a lot of extra CI time and coordination when merging several PRs in a day. So, if a PR hasn’t been updated in a while, and a reviewer is nervous about PR interference, fine to ask submitter to rebase. For this reason, we try to merge newer contributors first so the rebase falls on more experienced contributors.; Ideally a PR consists of atomic, compilable commits. When the PR instead is many successive small changes toward a single goal, consider squashing the PR. For core-dev’s PRs, there’s implicit permission to squash (unless otherwise noted in PR intro), whereas for new contributors, we often let the commits be messy.; When discussion on issue has overcome the original problem and settled on needing long-term work, fine to move the long-term item to Wish List and close issue. table of contents. Git, Versioning; How to bump a version; How to create and remove an annotated Git tag on a remote; What Psi4 version is running; How to locate non-ascii characters in the codebase; How to fix “Psi4 undefined” version; How to fix “cannot import name ‘core’ from {top-level-psi4-dir}; How to find tests without output.ref; How to do GitHub issue management and code review. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that; Git, Versioning. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/manage_git.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_git.html
https://psicode.org/psi4manual/1.6.x/manage_git.html:4427,Integrability,interface,interface,4427,"v1.1rc1-1-g4e0596e. >>> git describe --abbrev=7 --long --dirty; v1.1rc1-1-g4e0596e. >>> git tag; v1.0; v1.1a1; v1.1rc1. >>> cat psi4/metadata.py; __version__ = '1.1rc1'; __version_long = '1.1rc1+6100822'; __version_upcoming_annotated_v_tag = '1.1rc2'. >>> cat metadata.out.py | head -8; __version__ = '1.1rc2.dev1'; __version_branch_name = 'master'; __version_cmake = '1.0.0.999'; __version_is_clean = 'True'; __version_last_release = '1.0'; __version_long = '1.1rc2.dev1+4e0596e'; __version_prerelease = 'False'; __version_release = 'False'. >>> git log --oneline; 4e0596e Records tag for v1.1rc1; 6100822 v1.1rc1; cbee32b Fixes pcmsolver/scf for py3. Moves source for libefp upstream. ACT to inform remote of bump. Temporarily disengage “Include administrators” on protected master branch. >>> git push origin master; >>> git push origin v1.1rc1. Now https://github.com/psi4/psi4/releases says v1.1rc1 & 6100822. How to create and remove an annotated Git tag on a remote¶; PSI4 versioning only works with annotated tags, not lightweight; tags as are created with the GitHub interface. Create annotated tag:; >>> git tag -a v1.1a1 <git hash if not current> -m ""v1.1a1""; >>> git push origin v1.1a1. Delete tag:; >>> git tag -d v1.1a1; >>> git push origin :refs/tags/v1.1a1. Pull tags:; >>> git fetch <remote> 'refs/tags/*:refs/tags/*'. What Psi4 version is running¶. Psithon / from the executable:; >>> psi4 --version; 1.1rc2.dev17. PsiAPI / from the library:; >>> python -c ""import psi4; print(psi4.__version__)""; 1.1rc2.dev17. Output file header gives info like the print_header() below.; Function print_header() returns a summary of citation, version, and; git information about PSI4. Function version_formatter() can; return version and git information in any desired format string.; >>> import psi4; >>> psi4.print_header(). -----------------------------------------------------------------------; Psi4: An Open-Source Ab Initio Electronic Structure Package; Psi4 1.1rc2.dev17. Git: Rev {condado",MatchSource.WIKI,psi4manual/1.6.x/manage_git.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_git.html
https://psicode.org/psi4manual/1.6.x/manage_git.html:9158,Modifiability,rewrite,rewrite,9158,"uld add its own; output.ref. When that doesn’t happen, this command helps.; find tests/ -mindepth 1 -maxdepth 1 -type d '!' -exec test -e ""{}/output.ref"" "";"" -print. How to do GitHub issue management and code review¶. Anyone, core-dev or not, is encouraged to review PRs. It’s actually good practice for interacting with other open-source projects, where you don’t have the advantage of knowing or working with the contributors. Before venturing into projects on GitHub where you don’t know the maintainers, it doesn’t hurt to read https://snarky.ca/setting-expectations-for-open-source-participation/ .; Psi4 is a learning tool for all involved, so partial reviews in areas of confidence and questions and comments on PRs in general are encouraged.; Approving before CI completes is fine, though it can be mildly personally embarrassing when CI catches something you didn’t.; All main branches (master and 1.N.x maintenance) are protected by GitHub, including administrators, so even with write access, no one can accidentally push (master) or rewrite the history (master and maintenance).; PR owners who also have maintainer status can merge their PRs as GitHub enforces three external reviews.; Unless there’s been a lot of discussion on core-dev about merge order, generally the 3rd positive reviewer merges the PR. Also fine to add review and leave merge for later.; Presently only Travis-CI is set up as a required-to-merge service. Incomplete Azure won’t block merging, but we do usually let it complete before merging unless it’s a trivial PR.; We don’t enforce branches to be up to date before merging since that’d be a lot of extra CI time and coordination when merging several PRs in a day. So, if a PR hasn’t been updated in a while, and a reviewer is nervous about PR interference, fine to ask submitter to rebase. For this reason, we try to merge newer contributors first so the rebase falls on more experienced contributors.; Ideally a PR consists of atomic, compilable commits. When th",MatchSource.WIKI,psi4manual/1.6.x/manage_git.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_git.html
https://psicode.org/psi4manual/1.6.x/manage_git.html:1388,Safety,predict,predict,1388," with upstream as; remote.; https://github.com/psi4/psi4/releases says v1.1a1 & 007a9b6. >>> git tag; v1.0; v1.1a1. >>> cat psi4/metadata.py; __version__ = '1.1a1'; __version_long = '1.1a1+007a9b6'; __version_upcoming_annotated_v_tag = '1.1a2'. >>> git describe --abbrev=7 --long --always HEAD; v1.1a1-417-gcbee32b. >>> git describe --abbrev=7 --long --dirty; v1.1a1-417-gcbee32b. >>> ./psi4/versioner.py; Defining development snapshot version: 1.1a2.dev417+cbee32b (computed); 1.1a2.dev417 {master} cbee32b 1.0.0.999 1.0 <-- 1.1a2.dev417+cbee32b. >>> git diff. Observe that current latest tag matches metadata scipt and git; describe, that GitHub releases matches metadata script, that upcoming in; metadata script matches current versioner version.; Note that current tag is v1.1a1. Decide on imminent tag, say v1.1rc1. ACT to bump tag in code. Edit current & prospective tag in psi4/psi4/metadata.py. Use your; decided-upon tag v1.1rc1 and a speculative next tag, say v1.1rc2,; and use 7 “z”s for the part you can’t predict. >>> vi psi4/metadata.py. >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; index 5d87b55..6cbc05e 100644; --- a/psi4/metadata.py; +++ b/psi4/metadata.py; @@ -1,6 +1,6 @@; -__version__ = '1.1a1'; -__version_long = '1.1a1+007a9b6'; -__version_upcoming_annotated_v_tag = '1.1a2'; +__version__ = '1.1rc1'; +__version_long = '1.1rc1+zzzzzzz'; +__version_upcoming_annotated_v_tag = '1.1rc2'. >>> git add psi4/metadata.py. >>> git commit -m ""v1.1rc1"". OBSERVE undefined version state. >>> git describe --abbrev=7 --long --always HEAD; v1.1a1-418-g6100822. >>> git describe --abbrev=7 --long --dirty; v1.1a1-418-g6100822. >>> psi4/versioner.py; Undefining version for irreconcilable tags: 1.1a1 (computed) vs 1.1rc1 (recorded); undefined {master} 6100822 1.0.0.999 1.0 <-- undefined+6100822. Note 7-char git hash for the new commit, here “6100822”. ACT to bump tag in git, then bump git tag in code. Use the decided-upon tag v1.1rc1 and the observed hash “6100822” to",MatchSource.WIKI,psi4manual/1.6.x/manage_git.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_git.html
https://psicode.org/psi4manual/1.6.x/manage_git.html:2211,Security,hash,hash,2211,"urrent & prospective tag in psi4/psi4/metadata.py. Use your; decided-upon tag v1.1rc1 and a speculative next tag, say v1.1rc2,; and use 7 “z”s for the part you can’t predict. >>> vi psi4/metadata.py. >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; index 5d87b55..6cbc05e 100644; --- a/psi4/metadata.py; +++ b/psi4/metadata.py; @@ -1,6 +1,6 @@; -__version__ = '1.1a1'; -__version_long = '1.1a1+007a9b6'; -__version_upcoming_annotated_v_tag = '1.1a2'; +__version__ = '1.1rc1'; +__version_long = '1.1rc1+zzzzzzz'; +__version_upcoming_annotated_v_tag = '1.1rc2'. >>> git add psi4/metadata.py. >>> git commit -m ""v1.1rc1"". OBSERVE undefined version state. >>> git describe --abbrev=7 --long --always HEAD; v1.1a1-418-g6100822. >>> git describe --abbrev=7 --long --dirty; v1.1a1-418-g6100822. >>> psi4/versioner.py; Undefining version for irreconcilable tags: 1.1a1 (computed) vs 1.1rc1 (recorded); undefined {master} 6100822 1.0.0.999 1.0 <-- undefined+6100822. Note 7-char git hash for the new commit, here “6100822”. ACT to bump tag in git, then bump git tag in code. Use the decided-upon tag v1.1rc1 and the observed hash “6100822” to; mint a new annotated tag, minding that “v”s are present here.; Use the observed hash to edit psi4/psi4/metadata.py and commit immediately. >>> git tag -a v1.1rc1 6100822 -m ""v1.1rc1"". >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; index 6cbc05e..fdc202e 100644; --- a/psi4/metadata.py; +++ b/psi4/metadata.py; @@ -1,5 +1,5 @@; __version__ = '1.1rc1'; -__version_long = '1.1rc1+zzzzzzz'; +__version_long = '1.1rc1+6100822'; __version_upcoming_annotated_v_tag = '1.1rc2'. >>> psi4/versioner.py; Amazing, this can't actually happen that git hash stored at git commit.; >>> git add psi4/metadata.py; >>> git commit -m ""Records tag for v1.1rc1"". OBSERVE current versioning state. Nothing to make note of, this is just a snapshot. >>> psi4/versioner.py; Defining development snapshot version: 1.1rc2.dev1+4e0596e (c",MatchSource.WIKI,psi4manual/1.6.x/manage_git.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_git.html
https://psicode.org/psi4manual/1.6.x/manage_git.html:2353,Security,hash,hash,2353,"can’t predict. >>> vi psi4/metadata.py. >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; index 5d87b55..6cbc05e 100644; --- a/psi4/metadata.py; +++ b/psi4/metadata.py; @@ -1,6 +1,6 @@; -__version__ = '1.1a1'; -__version_long = '1.1a1+007a9b6'; -__version_upcoming_annotated_v_tag = '1.1a2'; +__version__ = '1.1rc1'; +__version_long = '1.1rc1+zzzzzzz'; +__version_upcoming_annotated_v_tag = '1.1rc2'. >>> git add psi4/metadata.py. >>> git commit -m ""v1.1rc1"". OBSERVE undefined version state. >>> git describe --abbrev=7 --long --always HEAD; v1.1a1-418-g6100822. >>> git describe --abbrev=7 --long --dirty; v1.1a1-418-g6100822. >>> psi4/versioner.py; Undefining version for irreconcilable tags: 1.1a1 (computed) vs 1.1rc1 (recorded); undefined {master} 6100822 1.0.0.999 1.0 <-- undefined+6100822. Note 7-char git hash for the new commit, here “6100822”. ACT to bump tag in git, then bump git tag in code. Use the decided-upon tag v1.1rc1 and the observed hash “6100822” to; mint a new annotated tag, minding that “v”s are present here.; Use the observed hash to edit psi4/psi4/metadata.py and commit immediately. >>> git tag -a v1.1rc1 6100822 -m ""v1.1rc1"". >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; index 6cbc05e..fdc202e 100644; --- a/psi4/metadata.py; +++ b/psi4/metadata.py; @@ -1,5 +1,5 @@; __version__ = '1.1rc1'; -__version_long = '1.1rc1+zzzzzzz'; +__version_long = '1.1rc1+6100822'; __version_upcoming_annotated_v_tag = '1.1rc2'. >>> psi4/versioner.py; Amazing, this can't actually happen that git hash stored at git commit.; >>> git add psi4/metadata.py; >>> git commit -m ""Records tag for v1.1rc1"". OBSERVE current versioning state. Nothing to make note of, this is just a snapshot. >>> psi4/versioner.py; Defining development snapshot version: 1.1rc2.dev1+4e0596e (computed); 1.1rc2.dev1 {master} 4e0596e 1.0.0.999 1.0 <-- 1.1rc2.dev1+4e0596e. >>> git describe --abbrev=7 --long --always HEAD; v1.1rc1-1-g4e0596e. >>> git des",MatchSource.WIKI,psi4manual/1.6.x/manage_git.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_git.html
https://psicode.org/psi4manual/1.6.x/manage_git.html:2452,Security,hash,hash,2452,"data.py b/psi4/metadata.py; index 5d87b55..6cbc05e 100644; --- a/psi4/metadata.py; +++ b/psi4/metadata.py; @@ -1,6 +1,6 @@; -__version__ = '1.1a1'; -__version_long = '1.1a1+007a9b6'; -__version_upcoming_annotated_v_tag = '1.1a2'; +__version__ = '1.1rc1'; +__version_long = '1.1rc1+zzzzzzz'; +__version_upcoming_annotated_v_tag = '1.1rc2'. >>> git add psi4/metadata.py. >>> git commit -m ""v1.1rc1"". OBSERVE undefined version state. >>> git describe --abbrev=7 --long --always HEAD; v1.1a1-418-g6100822. >>> git describe --abbrev=7 --long --dirty; v1.1a1-418-g6100822. >>> psi4/versioner.py; Undefining version for irreconcilable tags: 1.1a1 (computed) vs 1.1rc1 (recorded); undefined {master} 6100822 1.0.0.999 1.0 <-- undefined+6100822. Note 7-char git hash for the new commit, here “6100822”. ACT to bump tag in git, then bump git tag in code. Use the decided-upon tag v1.1rc1 and the observed hash “6100822” to; mint a new annotated tag, minding that “v”s are present here.; Use the observed hash to edit psi4/psi4/metadata.py and commit immediately. >>> git tag -a v1.1rc1 6100822 -m ""v1.1rc1"". >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; index 6cbc05e..fdc202e 100644; --- a/psi4/metadata.py; +++ b/psi4/metadata.py; @@ -1,5 +1,5 @@; __version__ = '1.1rc1'; -__version_long = '1.1rc1+zzzzzzz'; +__version_long = '1.1rc1+6100822'; __version_upcoming_annotated_v_tag = '1.1rc2'. >>> psi4/versioner.py; Amazing, this can't actually happen that git hash stored at git commit.; >>> git add psi4/metadata.py; >>> git commit -m ""Records tag for v1.1rc1"". OBSERVE current versioning state. Nothing to make note of, this is just a snapshot. >>> psi4/versioner.py; Defining development snapshot version: 1.1rc2.dev1+4e0596e (computed); 1.1rc2.dev1 {master} 4e0596e 1.0.0.999 1.0 <-- 1.1rc2.dev1+4e0596e. >>> git describe --abbrev=7 --long --always HEAD; v1.1rc1-1-g4e0596e. >>> git describe --abbrev=7 --long --dirty; v1.1rc1-1-g4e0596e. >>> git tag; v1.0; v1.1a",MatchSource.WIKI,psi4manual/1.6.x/manage_git.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_git.html
https://psicode.org/psi4manual/1.6.x/manage_git.html:2952,Security,hash,hash,2952,"1.1a1-418-g6100822. >>> git describe --abbrev=7 --long --dirty; v1.1a1-418-g6100822. >>> psi4/versioner.py; Undefining version for irreconcilable tags: 1.1a1 (computed) vs 1.1rc1 (recorded); undefined {master} 6100822 1.0.0.999 1.0 <-- undefined+6100822. Note 7-char git hash for the new commit, here “6100822”. ACT to bump tag in git, then bump git tag in code. Use the decided-upon tag v1.1rc1 and the observed hash “6100822” to; mint a new annotated tag, minding that “v”s are present here.; Use the observed hash to edit psi4/psi4/metadata.py and commit immediately. >>> git tag -a v1.1rc1 6100822 -m ""v1.1rc1"". >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; index 6cbc05e..fdc202e 100644; --- a/psi4/metadata.py; +++ b/psi4/metadata.py; @@ -1,5 +1,5 @@; __version__ = '1.1rc1'; -__version_long = '1.1rc1+zzzzzzz'; +__version_long = '1.1rc1+6100822'; __version_upcoming_annotated_v_tag = '1.1rc2'. >>> psi4/versioner.py; Amazing, this can't actually happen that git hash stored at git commit.; >>> git add psi4/metadata.py; >>> git commit -m ""Records tag for v1.1rc1"". OBSERVE current versioning state. Nothing to make note of, this is just a snapshot. >>> psi4/versioner.py; Defining development snapshot version: 1.1rc2.dev1+4e0596e (computed); 1.1rc2.dev1 {master} 4e0596e 1.0.0.999 1.0 <-- 1.1rc2.dev1+4e0596e. >>> git describe --abbrev=7 --long --always HEAD; v1.1rc1-1-g4e0596e. >>> git describe --abbrev=7 --long --dirty; v1.1rc1-1-g4e0596e. >>> git tag; v1.0; v1.1a1; v1.1rc1. >>> cat psi4/metadata.py; __version__ = '1.1rc1'; __version_long = '1.1rc1+6100822'; __version_upcoming_annotated_v_tag = '1.1rc2'. >>> cat metadata.out.py | head -8; __version__ = '1.1rc2.dev1'; __version_branch_name = 'master'; __version_cmake = '1.0.0.999'; __version_is_clean = 'True'; __version_last_release = '1.0'; __version_long = '1.1rc2.dev1+4e0596e'; __version_prerelease = 'False'; __version_release = 'False'. >>> git log --oneline; 4e0596e Records tag for ",MatchSource.WIKI,psi4manual/1.6.x/manage_git.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_git.html
https://psicode.org/psi4manual/1.6.x/manage_git.html:4488,Security,hash,hash,4488,"__version__ = '1.1rc1'; __version_long = '1.1rc1+6100822'; __version_upcoming_annotated_v_tag = '1.1rc2'. >>> cat metadata.out.py | head -8; __version__ = '1.1rc2.dev1'; __version_branch_name = 'master'; __version_cmake = '1.0.0.999'; __version_is_clean = 'True'; __version_last_release = '1.0'; __version_long = '1.1rc2.dev1+4e0596e'; __version_prerelease = 'False'; __version_release = 'False'. >>> git log --oneline; 4e0596e Records tag for v1.1rc1; 6100822 v1.1rc1; cbee32b Fixes pcmsolver/scf for py3. Moves source for libefp upstream. ACT to inform remote of bump. Temporarily disengage “Include administrators” on protected master branch. >>> git push origin master; >>> git push origin v1.1rc1. Now https://github.com/psi4/psi4/releases says v1.1rc1 & 6100822. How to create and remove an annotated Git tag on a remote¶; PSI4 versioning only works with annotated tags, not lightweight; tags as are created with the GitHub interface. Create annotated tag:; >>> git tag -a v1.1a1 <git hash if not current> -m ""v1.1a1""; >>> git push origin v1.1a1. Delete tag:; >>> git tag -d v1.1a1; >>> git push origin :refs/tags/v1.1a1. Pull tags:; >>> git fetch <remote> 'refs/tags/*:refs/tags/*'. What Psi4 version is running¶. Psithon / from the executable:; >>> psi4 --version; 1.1rc2.dev17. PsiAPI / from the library:; >>> python -c ""import psi4; print(psi4.__version__)""; 1.1rc2.dev17. Output file header gives info like the print_header() below.; Function print_header() returns a summary of citation, version, and; git information about PSI4. Function version_formatter() can; return version and git information in any desired format string.; >>> import psi4; >>> psi4.print_header(). -----------------------------------------------------------------------; Psi4: An Open-Source Ab Initio Electronic Structure Package; Psi4 1.1rc2.dev17. Git: Rev {condadoc} c852257 dirty. R. M. Parrish, L. A. Burns, D. G. A. Smith, A. C. Simmonett,; A. E. DePrince III, E. G. Hohenstein, U. Bozkaya, A. Yu. Sokolov,; ",MatchSource.WIKI,psi4manual/1.6.x/manage_git.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_git.html
https://psicode.org/psi4manual/1.6.x/manage_git.html:9109,Security,access,access,9109,"uld add its own; output.ref. When that doesn’t happen, this command helps.; find tests/ -mindepth 1 -maxdepth 1 -type d '!' -exec test -e ""{}/output.ref"" "";"" -print. How to do GitHub issue management and code review¶. Anyone, core-dev or not, is encouraged to review PRs. It’s actually good practice for interacting with other open-source projects, where you don’t have the advantage of knowing or working with the contributors. Before venturing into projects on GitHub where you don’t know the maintainers, it doesn’t hurt to read https://snarky.ca/setting-expectations-for-open-source-participation/ .; Psi4 is a learning tool for all involved, so partial reviews in areas of confidence and questions and comments on PRs in general are encouraged.; Approving before CI completes is fine, though it can be mildly personally embarrassing when CI catches something you didn’t.; All main branches (master and 1.N.x maintenance) are protected by GitHub, including administrators, so even with write access, no one can accidentally push (master) or rewrite the history (master and maintenance).; PR owners who also have maintainer status can merge their PRs as GitHub enforces three external reviews.; Unless there’s been a lot of discussion on core-dev about merge order, generally the 3rd positive reviewer merges the PR. Also fine to add review and leave merge for later.; Presently only Travis-CI is set up as a required-to-merge service. Incomplete Azure won’t block merging, but we do usually let it complete before merging unless it’s a trivial PR.; We don’t enforce branches to be up to date before merging since that’d be a lot of extra CI time and coordination when merging several PRs in a day. So, if a PR hasn’t been updated in a while, and a reviewer is nervous about PR interference, fine to ask submitter to rebase. For this reason, we try to merge newer contributors first so the rebase falls on more experienced contributors.; Ideally a PR consists of atomic, compilable commits. When th",MatchSource.WIKI,psi4manual/1.6.x/manage_git.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_git.html
https://psicode.org/psi4manual/1.6.x/manage_git.html:3902,Testability,log,log,3902,"is can't actually happen that git hash stored at git commit.; >>> git add psi4/metadata.py; >>> git commit -m ""Records tag for v1.1rc1"". OBSERVE current versioning state. Nothing to make note of, this is just a snapshot. >>> psi4/versioner.py; Defining development snapshot version: 1.1rc2.dev1+4e0596e (computed); 1.1rc2.dev1 {master} 4e0596e 1.0.0.999 1.0 <-- 1.1rc2.dev1+4e0596e. >>> git describe --abbrev=7 --long --always HEAD; v1.1rc1-1-g4e0596e. >>> git describe --abbrev=7 --long --dirty; v1.1rc1-1-g4e0596e. >>> git tag; v1.0; v1.1a1; v1.1rc1. >>> cat psi4/metadata.py; __version__ = '1.1rc1'; __version_long = '1.1rc1+6100822'; __version_upcoming_annotated_v_tag = '1.1rc2'. >>> cat metadata.out.py | head -8; __version__ = '1.1rc2.dev1'; __version_branch_name = 'master'; __version_cmake = '1.0.0.999'; __version_is_clean = 'True'; __version_last_release = '1.0'; __version_long = '1.1rc2.dev1+4e0596e'; __version_prerelease = 'False'; __version_release = 'False'. >>> git log --oneline; 4e0596e Records tag for v1.1rc1; 6100822 v1.1rc1; cbee32b Fixes pcmsolver/scf for py3. Moves source for libefp upstream. ACT to inform remote of bump. Temporarily disengage “Include administrators” on protected master branch. >>> git push origin master; >>> git push origin v1.1rc1. Now https://github.com/psi4/psi4/releases says v1.1rc1 & 6100822. How to create and remove an annotated Git tag on a remote¶; PSI4 versioning only works with annotated tags, not lightweight; tags as are created with the GitHub interface. Create annotated tag:; >>> git tag -a v1.1a1 <git hash if not current> -m ""v1.1a1""; >>> git push origin v1.1a1. Delete tag:; >>> git tag -d v1.1a1; >>> git push origin :refs/tags/v1.1a1. Pull tags:; >>> git fetch <remote> 'refs/tags/*:refs/tags/*'. What Psi4 version is running¶. Psithon / from the executable:; >>> psi4 --version; 1.1rc2.dev17. PsiAPI / from the library:; >>> python -c ""import psi4; print(psi4.__version__)""; 1.1rc2.dev17. Output file header gives info like the ",MatchSource.WIKI,psi4manual/1.6.x/manage_git.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_git.html
https://psicode.org/psi4manual/1.6.x/manage_git.html:8039,Testability,test,tests,8039,"n `git remote -v` points to github.com/psi4/psi4.git; >>> git fetch upstream 'refs/tags/*:refs/tags/*'; >>> make; # version healed. How to fix “cannot import name ‘core’ from {top-level-psi4-dir}¶; First, what’s happening? sys.path (where modules can be imported from in python) starts with ''. If you export PYTHONPATH={objdir}/stage/{prefix}/lib/{pymod_lib_dir}:$PYTHONPATH to make PsiAPI easy, that inserts starting in pos’n 1 (0-indexed), so '' still at the head of sys.path. Now, if you try to run a psiapi/python file from {top-level-psi4-dir} that contains import psi4, it will find the source tree psi4/__init__.py and fail because there’s no core.so around. That is, it’s finding what looks to be the psi4 module dir structure . when the one it wants is what you inserted into PYTHONPATH at pos’n 1.; The way around this is to move the python file you’re running to any other directory. Or, within the file, do sys.path.insert(0, {objdir}/stage/{prefix}/lib/{pymod_lib_dir}. How to find tests without output.ref¶; Ideally, each new test or much-altered test should add its own; output.ref. When that doesn’t happen, this command helps.; find tests/ -mindepth 1 -maxdepth 1 -type d '!' -exec test -e ""{}/output.ref"" "";"" -print. How to do GitHub issue management and code review¶. Anyone, core-dev or not, is encouraged to review PRs. It’s actually good practice for interacting with other open-source projects, where you don’t have the advantage of knowing or working with the contributors. Before venturing into projects on GitHub where you don’t know the maintainers, it doesn’t hurt to read https://snarky.ca/setting-expectations-for-open-source-participation/ .; Psi4 is a learning tool for all involved, so partial reviews in areas of confidence and questions and comments on PRs in general are encouraged.; Approving before CI completes is fine, though it can be mildly personally embarrassing when CI catches something you didn’t.; All main branches (master and 1.N.x maintenance) are ",MatchSource.WIKI,psi4manual/1.6.x/manage_git.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_git.html
https://psicode.org/psi4manual/1.6.x/manage_git.html:8084,Testability,test,test,8084,">> git fetch upstream 'refs/tags/*:refs/tags/*'; >>> make; # version healed. How to fix “cannot import name ‘core’ from {top-level-psi4-dir}¶; First, what’s happening? sys.path (where modules can be imported from in python) starts with ''. If you export PYTHONPATH={objdir}/stage/{prefix}/lib/{pymod_lib_dir}:$PYTHONPATH to make PsiAPI easy, that inserts starting in pos’n 1 (0-indexed), so '' still at the head of sys.path. Now, if you try to run a psiapi/python file from {top-level-psi4-dir} that contains import psi4, it will find the source tree psi4/__init__.py and fail because there’s no core.so around. That is, it’s finding what looks to be the psi4 module dir structure . when the one it wants is what you inserted into PYTHONPATH at pos’n 1.; The way around this is to move the python file you’re running to any other directory. Or, within the file, do sys.path.insert(0, {objdir}/stage/{prefix}/lib/{pymod_lib_dir}. How to find tests without output.ref¶; Ideally, each new test or much-altered test should add its own; output.ref. When that doesn’t happen, this command helps.; find tests/ -mindepth 1 -maxdepth 1 -type d '!' -exec test -e ""{}/output.ref"" "";"" -print. How to do GitHub issue management and code review¶. Anyone, core-dev or not, is encouraged to review PRs. It’s actually good practice for interacting with other open-source projects, where you don’t have the advantage of knowing or working with the contributors. Before venturing into projects on GitHub where you don’t know the maintainers, it doesn’t hurt to read https://snarky.ca/setting-expectations-for-open-source-participation/ .; Psi4 is a learning tool for all involved, so partial reviews in areas of confidence and questions and comments on PRs in general are encouraged.; Approving before CI completes is fine, though it can be mildly personally embarrassing when CI catches something you didn’t.; All main branches (master and 1.N.x maintenance) are protected by GitHub, including administrators, so even w",MatchSource.WIKI,psi4manual/1.6.x/manage_git.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_git.html
https://psicode.org/psi4manual/1.6.x/manage_git.html:8105,Testability,test,test,8105,">> git fetch upstream 'refs/tags/*:refs/tags/*'; >>> make; # version healed. How to fix “cannot import name ‘core’ from {top-level-psi4-dir}¶; First, what’s happening? sys.path (where modules can be imported from in python) starts with ''. If you export PYTHONPATH={objdir}/stage/{prefix}/lib/{pymod_lib_dir}:$PYTHONPATH to make PsiAPI easy, that inserts starting in pos’n 1 (0-indexed), so '' still at the head of sys.path. Now, if you try to run a psiapi/python file from {top-level-psi4-dir} that contains import psi4, it will find the source tree psi4/__init__.py and fail because there’s no core.so around. That is, it’s finding what looks to be the psi4 module dir structure . when the one it wants is what you inserted into PYTHONPATH at pos’n 1.; The way around this is to move the python file you’re running to any other directory. Or, within the file, do sys.path.insert(0, {objdir}/stage/{prefix}/lib/{pymod_lib_dir}. How to find tests without output.ref¶; Ideally, each new test or much-altered test should add its own; output.ref. When that doesn’t happen, this command helps.; find tests/ -mindepth 1 -maxdepth 1 -type d '!' -exec test -e ""{}/output.ref"" "";"" -print. How to do GitHub issue management and code review¶. Anyone, core-dev or not, is encouraged to review PRs. It’s actually good practice for interacting with other open-source projects, where you don’t have the advantage of knowing or working with the contributors. Before venturing into projects on GitHub where you don’t know the maintainers, it doesn’t hurt to read https://snarky.ca/setting-expectations-for-open-source-participation/ .; Psi4 is a learning tool for all involved, so partial reviews in areas of confidence and questions and comments on PRs in general are encouraged.; Approving before CI completes is fine, though it can be mildly personally embarrassing when CI catches something you didn’t.; All main branches (master and 1.N.x maintenance) are protected by GitHub, including administrators, so even w",MatchSource.WIKI,psi4manual/1.6.x/manage_git.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_git.html
https://psicode.org/psi4manual/1.6.x/manage_git.html:8194,Testability,test,tests,8194,"evel-psi4-dir}¶; First, what’s happening? sys.path (where modules can be imported from in python) starts with ''. If you export PYTHONPATH={objdir}/stage/{prefix}/lib/{pymod_lib_dir}:$PYTHONPATH to make PsiAPI easy, that inserts starting in pos’n 1 (0-indexed), so '' still at the head of sys.path. Now, if you try to run a psiapi/python file from {top-level-psi4-dir} that contains import psi4, it will find the source tree psi4/__init__.py and fail because there’s no core.so around. That is, it’s finding what looks to be the psi4 module dir structure . when the one it wants is what you inserted into PYTHONPATH at pos’n 1.; The way around this is to move the python file you’re running to any other directory. Or, within the file, do sys.path.insert(0, {objdir}/stage/{prefix}/lib/{pymod_lib_dir}. How to find tests without output.ref¶; Ideally, each new test or much-altered test should add its own; output.ref. When that doesn’t happen, this command helps.; find tests/ -mindepth 1 -maxdepth 1 -type d '!' -exec test -e ""{}/output.ref"" "";"" -print. How to do GitHub issue management and code review¶. Anyone, core-dev or not, is encouraged to review PRs. It’s actually good practice for interacting with other open-source projects, where you don’t have the advantage of knowing or working with the contributors. Before venturing into projects on GitHub where you don’t know the maintainers, it doesn’t hurt to read https://snarky.ca/setting-expectations-for-open-source-participation/ .; Psi4 is a learning tool for all involved, so partial reviews in areas of confidence and questions and comments on PRs in general are encouraged.; Approving before CI completes is fine, though it can be mildly personally embarrassing when CI catches something you didn’t.; All main branches (master and 1.N.x maintenance) are protected by GitHub, including administrators, so even with write access, no one can accidentally push (master) or rewrite the history (master and maintenance).; PR owners who also h",MatchSource.WIKI,psi4manual/1.6.x/manage_git.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_git.html
https://psicode.org/psi4manual/1.6.x/manage_git.html:8243,Testability,test,test,8243,"evel-psi4-dir}¶; First, what’s happening? sys.path (where modules can be imported from in python) starts with ''. If you export PYTHONPATH={objdir}/stage/{prefix}/lib/{pymod_lib_dir}:$PYTHONPATH to make PsiAPI easy, that inserts starting in pos’n 1 (0-indexed), so '' still at the head of sys.path. Now, if you try to run a psiapi/python file from {top-level-psi4-dir} that contains import psi4, it will find the source tree psi4/__init__.py and fail because there’s no core.so around. That is, it’s finding what looks to be the psi4 module dir structure . when the one it wants is what you inserted into PYTHONPATH at pos’n 1.; The way around this is to move the python file you’re running to any other directory. Or, within the file, do sys.path.insert(0, {objdir}/stage/{prefix}/lib/{pymod_lib_dir}. How to find tests without output.ref¶; Ideally, each new test or much-altered test should add its own; output.ref. When that doesn’t happen, this command helps.; find tests/ -mindepth 1 -maxdepth 1 -type d '!' -exec test -e ""{}/output.ref"" "";"" -print. How to do GitHub issue management and code review¶. Anyone, core-dev or not, is encouraged to review PRs. It’s actually good practice for interacting with other open-source projects, where you don’t have the advantage of knowing or working with the contributors. Before venturing into projects on GitHub where you don’t know the maintainers, it doesn’t hurt to read https://snarky.ca/setting-expectations-for-open-source-participation/ .; Psi4 is a learning tool for all involved, so partial reviews in areas of confidence and questions and comments on PRs in general are encouraged.; Approving before CI completes is fine, though it can be mildly personally embarrassing when CI catches something you didn’t.; All main branches (master and 1.N.x maintenance) are protected by GitHub, including administrators, so even with write access, no one can accidentally push (master) or rewrite the history (master and maintenance).; PR owners who also h",MatchSource.WIKI,psi4manual/1.6.x/manage_git.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_git.html
https://psicode.org/psi4manual/1.6.x/manage_git.html:10845,Testability,test,tests,10845,"ce).; PR owners who also have maintainer status can merge their PRs as GitHub enforces three external reviews.; Unless there’s been a lot of discussion on core-dev about merge order, generally the 3rd positive reviewer merges the PR. Also fine to add review and leave merge for later.; Presently only Travis-CI is set up as a required-to-merge service. Incomplete Azure won’t block merging, but we do usually let it complete before merging unless it’s a trivial PR.; We don’t enforce branches to be up to date before merging since that’d be a lot of extra CI time and coordination when merging several PRs in a day. So, if a PR hasn’t been updated in a while, and a reviewer is nervous about PR interference, fine to ask submitter to rebase. For this reason, we try to merge newer contributors first so the rebase falls on more experienced contributors.; Ideally a PR consists of atomic, compilable commits. When the PR instead is many successive small changes toward a single goal, consider squashing the PR. For core-dev’s PRs, there’s implicit permission to squash (unless otherwise noted in PR intro), whereas for new contributors, we often let the commits be messy.; When discussion on issue has overcome the original problem and settled on needing long-term work, fine to move the long-term item to Wish List and close issue. table of contents. Git, Versioning; How to bump a version; How to create and remove an annotated Git tag on a remote; What Psi4 version is running; How to locate non-ascii characters in the codebase; How to fix “Psi4 undefined” version; How to fix “cannot import name ‘core’ from {top-level-psi4-dir}; How to find tests without output.ref; How to do GitHub issue management and code review. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that; Git, Versioning. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/manage_git.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_git.html
https://psicode.org/psi4manual/1.6.x/manage_git.html:8728,Usability,learn,learning,8728," one it wants is what you inserted into PYTHONPATH at pos’n 1.; The way around this is to move the python file you’re running to any other directory. Or, within the file, do sys.path.insert(0, {objdir}/stage/{prefix}/lib/{pymod_lib_dir}. How to find tests without output.ref¶; Ideally, each new test or much-altered test should add its own; output.ref. When that doesn’t happen, this command helps.; find tests/ -mindepth 1 -maxdepth 1 -type d '!' -exec test -e ""{}/output.ref"" "";"" -print. How to do GitHub issue management and code review¶. Anyone, core-dev or not, is encouraged to review PRs. It’s actually good practice for interacting with other open-source projects, where you don’t have the advantage of knowing or working with the contributors. Before venturing into projects on GitHub where you don’t know the maintainers, it doesn’t hurt to read https://snarky.ca/setting-expectations-for-open-source-participation/ .; Psi4 is a learning tool for all involved, so partial reviews in areas of confidence and questions and comments on PRs in general are encouraged.; Approving before CI completes is fine, though it can be mildly personally embarrassing when CI catches something you didn’t.; All main branches (master and 1.N.x maintenance) are protected by GitHub, including administrators, so even with write access, no one can accidentally push (master) or rewrite the history (master and maintenance).; PR owners who also have maintainer status can merge their PRs as GitHub enforces three external reviews.; Unless there’s been a lot of discussion on core-dev about merge order, generally the 3rd positive reviewer merges the PR. Also fine to add review and leave merge for later.; Presently only Travis-CI is set up as a required-to-merge service. Incomplete Azure won’t block merging, but we do usually let it complete before merging unless it’s a trivial PR.; We don’t enforce branches to be up to date before merging since that’d be a lot of extra CI time and coordination when merg",MatchSource.WIKI,psi4manual/1.6.x/manage_git.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_git.html
https://psicode.org/psi4manual/1.6.x/manage_index.html:1295,Availability,down,download,1295,"﻿. Managing: Git, Conda, CMake and all that. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that. Managing: Git, Conda, CMake and all that¶. Adding Add-Ons; How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs; else; How to name keywords in psi4/src/read_options.cc. Git, Versioning; How to bump a version; How to create and remove an annotated Git tag on a remote; What Psi4 version is running; How to locate non-ascii characters in the codebase; How to fix “Psi4 undefined” version; How to fix “cannot import name ‘core’ from {top-level-psi4-dir}; How to find tests without output.ref; How to do GitHub issue management and code review. Release Procedures; Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1); Update copyright year; Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag (pre)release; Tag postrelease; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set (pre-Spring 2021); Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/manage_index.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_index.html
https://psicode.org/psi4manual/1.6.x/manage_index.html:298,Deployability,integrat,integrate,298,"﻿. Managing: Git, Conda, CMake and all that. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that. Managing: Git, Conda, CMake and all that¶. Adding Add-Ons; How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs; else; How to name keywords in psi4/src/read_options.cc. Git, Versioning; How to bump a version; How to create and remove an annotated Git tag on a remote; What Psi4 version is running; How to locate non-ascii characters in the codebase; How to fix “Psi4 undefined” version; How to fix “cannot import name ‘core’ from {top-level-psi4-dir}; How to find tests without output.ref; How to do GitHub issue management and code review. Release Procedures; Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1); Update copyright year; Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag (pre)release; Tag postrelease; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set (pre-Spring 2021); Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/manage_index.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_index.html
https://psicode.org/psi4manual/1.6.x/manage_index.html:961,Deployability,release,release,961,"﻿. Managing: Git, Conda, CMake and all that. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that. Managing: Git, Conda, CMake and all that¶. Adding Add-Ons; How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs; else; How to name keywords in psi4/src/read_options.cc. Git, Versioning; How to bump a version; How to create and remove an annotated Git tag on a remote; What Psi4 version is running; How to locate non-ascii characters in the codebase; How to fix “Psi4 undefined” version; How to fix “cannot import name ‘core’ from {top-level-psi4-dir}; How to find tests without output.ref; How to do GitHub issue management and code review. Release Procedures; Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1); Update copyright year; Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag (pre)release; Tag postrelease; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set (pre-Spring 2021); Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/manage_index.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_index.html
https://psicode.org/psi4manual/1.6.x/manage_index.html:1079,Deployability,release,release,1079,"﻿. Managing: Git, Conda, CMake and all that. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that. Managing: Git, Conda, CMake and all that¶. Adding Add-Ons; How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs; else; How to name keywords in psi4/src/read_options.cc. Git, Versioning; How to bump a version; How to create and remove an annotated Git tag on a remote; What Psi4 version is running; How to locate non-ascii characters in the codebase; How to fix “Psi4 undefined” version; How to fix “cannot import name ‘core’ from {top-level-psi4-dir}; How to find tests without output.ref; How to do GitHub issue management and code review. Release Procedures; Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1); Update copyright year; Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag (pre)release; Tag postrelease; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set (pre-Spring 2021); Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/manage_index.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_index.html
https://psicode.org/psi4manual/1.6.x/manage_index.html:1101,Deployability,release,release,1101,"﻿. Managing: Git, Conda, CMake and all that. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that. Managing: Git, Conda, CMake and all that¶. Adding Add-Ons; How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs; else; How to name keywords in psi4/src/read_options.cc. Git, Versioning; How to bump a version; How to create and remove an annotated Git tag on a remote; What Psi4 version is running; How to locate non-ascii characters in the codebase; How to fix “Psi4 undefined” version; How to fix “cannot import name ‘core’ from {top-level-psi4-dir}; How to find tests without output.ref; How to do GitHub issue management and code review. Release Procedures; Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1); Update copyright year; Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag (pre)release; Tag postrelease; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set (pre-Spring 2021); Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/manage_index.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_index.html
https://psicode.org/psi4manual/1.6.x/manage_index.html:1138,Deployability,release,release,1138,"﻿. Managing: Git, Conda, CMake and all that. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that. Managing: Git, Conda, CMake and all that¶. Adding Add-Ons; How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs; else; How to name keywords in psi4/src/read_options.cc. Git, Versioning; How to bump a version; How to create and remove an annotated Git tag on a remote; What Psi4 version is running; How to locate non-ascii characters in the codebase; How to fix “Psi4 undefined” version; How to fix “cannot import name ‘core’ from {top-level-psi4-dir}; How to find tests without output.ref; How to do GitHub issue management and code review. Release Procedures; Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1); Update copyright year; Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag (pre)release; Tag postrelease; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set (pre-Spring 2021); Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/manage_index.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_index.html
https://psicode.org/psi4manual/1.6.x/manage_index.html:1373,Deployability,release,release,1373,"﻿. Managing: Git, Conda, CMake and all that. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that. Managing: Git, Conda, CMake and all that¶. Adding Add-Ons; How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs; else; How to name keywords in psi4/src/read_options.cc. Git, Versioning; How to bump a version; How to create and remove an annotated Git tag on a remote; What Psi4 version is running; How to locate non-ascii characters in the codebase; How to fix “Psi4 undefined” version; How to fix “cannot import name ‘core’ from {top-level-psi4-dir}; How to find tests without output.ref; How to do GitHub issue management and code review. Release Procedures; Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1); Update copyright year; Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag (pre)release; Tag postrelease; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set (pre-Spring 2021); Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/manage_index.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_index.html
https://psicode.org/psi4manual/1.6.x/manage_index.html:1426,Deployability,release,release,1426,"﻿. Managing: Git, Conda, CMake and all that. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that. Managing: Git, Conda, CMake and all that¶. Adding Add-Ons; How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs; else; How to name keywords in psi4/src/read_options.cc. Git, Versioning; How to bump a version; How to create and remove an annotated Git tag on a remote; What Psi4 version is running; How to locate non-ascii characters in the codebase; How to fix “Psi4 undefined” version; How to fix “cannot import name ‘core’ from {top-level-psi4-dir}; How to find tests without output.ref; How to do GitHub issue management and code review. Release Procedures; Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1); Update copyright year; Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag (pre)release; Tag postrelease; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set (pre-Spring 2021); Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/manage_index.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_index.html
https://psicode.org/psi4manual/1.6.x/manage_index.html:1444,Deployability,release,release,1444,"﻿. Managing: Git, Conda, CMake and all that. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that. Managing: Git, Conda, CMake and all that¶. Adding Add-Ons; How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs; else; How to name keywords in psi4/src/read_options.cc. Git, Versioning; How to bump a version; How to create and remove an annotated Git tag on a remote; What Psi4 version is running; How to locate non-ascii characters in the codebase; How to fix “Psi4 undefined” version; How to fix “cannot import name ‘core’ from {top-level-psi4-dir}; How to find tests without output.ref; How to do GitHub issue management and code review. Release Procedures; Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1); Update copyright year; Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag (pre)release; Tag postrelease; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set (pre-Spring 2021); Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/manage_index.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_index.html
https://psicode.org/psi4manual/1.6.x/manage_index.html:1677,Deployability,update,updated,1677,"﻿. Managing: Git, Conda, CMake and all that. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that. Managing: Git, Conda, CMake and all that¶. Adding Add-Ons; How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs; else; How to name keywords in psi4/src/read_options.cc. Git, Versioning; How to bump a version; How to create and remove an annotated Git tag on a remote; What Psi4 version is running; How to locate non-ascii characters in the codebase; How to fix “Psi4 undefined” version; How to fix “cannot import name ‘core’ from {top-level-psi4-dir}; How to find tests without output.ref; How to do GitHub issue management and code review. Release Procedures; Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1); Update copyright year; Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag (pre)release; Tag postrelease; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set (pre-Spring 2021); Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/manage_index.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_index.html
https://psicode.org/psi4manual/1.6.x/manage_index.html:298,Integrability,integrat,integrate,298,"﻿. Managing: Git, Conda, CMake and all that. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that. Managing: Git, Conda, CMake and all that¶. Adding Add-Ons; How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs; else; How to name keywords in psi4/src/read_options.cc. Git, Versioning; How to bump a version; How to create and remove an annotated Git tag on a remote; What Psi4 version is running; How to locate non-ascii characters in the codebase; How to fix “Psi4 undefined” version; How to fix “cannot import name ‘core’ from {top-level-psi4-dir}; How to find tests without output.ref; How to do GitHub issue management and code review. Release Procedures; Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1); Update copyright year; Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag (pre)release; Tag postrelease; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set (pre-Spring 2021); Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/manage_index.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_index.html
https://psicode.org/psi4manual/1.6.x/manage_index.html:330,Testability,test,testing,330,"﻿. Managing: Git, Conda, CMake and all that. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that. Managing: Git, Conda, CMake and all that¶. Adding Add-Ons; How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs; else; How to name keywords in psi4/src/read_options.cc. Git, Versioning; How to bump a version; How to create and remove an annotated Git tag on a remote; What Psi4 version is running; How to locate non-ascii characters in the codebase; How to fix “Psi4 undefined” version; How to fix “cannot import name ‘core’ from {top-level-psi4-dir}; How to find tests without output.ref; How to do GitHub issue management and code review. Release Procedures; Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1); Update copyright year; Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag (pre)release; Tag postrelease; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set (pre-Spring 2021); Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/manage_index.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_index.html
https://psicode.org/psi4manual/1.6.x/manage_index.html:700,Testability,test,tests,700,"﻿. Managing: Git, Conda, CMake and all that. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that. Managing: Git, Conda, CMake and all that¶. Adding Add-Ons; How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs; else; How to name keywords in psi4/src/read_options.cc. Git, Versioning; How to bump a version; How to create and remove an annotated Git tag on a remote; What Psi4 version is running; How to locate non-ascii characters in the codebase; How to fix “Psi4 undefined” version; How to fix “cannot import name ‘core’ from {top-level-psi4-dir}; How to find tests without output.ref; How to do GitHub issue management and code review. Release Procedures; Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1); Update copyright year; Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag (pre)release; Tag postrelease; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set (pre-Spring 2021); Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/manage_index.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_index.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:418,Availability,down,download,418,"﻿. Release Procedures. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that; Release Procedures. Release Procedures¶. Annual¶. Update copyright year. Pre-Release (e.g., v1.3rc1)¶. Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Tag (pre)release; Build Conda Psi4 stack at specific commit; Build Psi4conda set; Generate download page for psicode.org; Reset psi4meta for nightly operation. Release (e.g., v1.3)¶. Do final pass before release tag; Tag (pre)release; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Post-Release (e.g., v1.3.1)¶. Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag postrelease; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Update copyright year¶. cd ~/path/to/psi4; Primary target is licenses. grep -rl ""(c) 2007-2017"" * | xargs sed -i '' ""s/(c) 2007-2017/(c) 2007-2018/g""; On Linux, drop the '' in above command; Need to do psi4/ and docs/ dirs. Also, license in these files. tests/runtest.py; README.md; tests/psitest.pl. Also, in content of psi4/doc/sphinxman/source/conf.py.in#L130. Update samples¶. Run make sphinxman at least once by hand; Check in resulting psifiles.py and all the updated and new samples/ files and dirs; Make a lone PR and warn reviewers not to read it, since autogenerated. Collect new authors¶. Survey contributions to current Milestone. Add new contribs and PR lists to release notes GitHub issue; Figure out any new “Addi",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:691,Availability,down,download,691,"﻿. Release Procedures. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that; Release Procedures. Release Procedures¶. Annual¶. Update copyright year. Pre-Release (e.g., v1.3rc1)¶. Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Tag (pre)release; Build Conda Psi4 stack at specific commit; Build Psi4conda set; Generate download page for psicode.org; Reset psi4meta for nightly operation. Release (e.g., v1.3)¶. Do final pass before release tag; Tag (pre)release; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Post-Release (e.g., v1.3.1)¶. Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag postrelease; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Update copyright year¶. cd ~/path/to/psi4; Primary target is licenses. grep -rl ""(c) 2007-2017"" * | xargs sed -i '' ""s/(c) 2007-2017/(c) 2007-2018/g""; On Linux, drop the '' in above command; Need to do psi4/ and docs/ dirs. Also, license in these files. tests/runtest.py; README.md; tests/psitest.pl. Also, in content of psi4/doc/sphinxman/source/conf.py.in#L130. Update samples¶. Run make sphinxman at least once by hand; Check in resulting psifiles.py and all the updated and new samples/ files and dirs; Make a lone PR and warn reviewers not to read it, since autogenerated. Collect new authors¶. Survey contributions to current Milestone. Add new contribs and PR lists to release notes GitHub issue; Figure out any new “Addi",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:1101,Availability,down,download,1101,"ase Procedures. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that; Release Procedures. Release Procedures¶. Annual¶. Update copyright year. Pre-Release (e.g., v1.3rc1)¶. Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Tag (pre)release; Build Conda Psi4 stack at specific commit; Build Psi4conda set; Generate download page for psicode.org; Reset psi4meta for nightly operation. Release (e.g., v1.3)¶. Do final pass before release tag; Tag (pre)release; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Post-Release (e.g., v1.3.1)¶. Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag postrelease; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Update copyright year¶. cd ~/path/to/psi4; Primary target is licenses. grep -rl ""(c) 2007-2017"" * | xargs sed -i '' ""s/(c) 2007-2017/(c) 2007-2018/g""; On Linux, drop the '' in above command; Need to do psi4/ and docs/ dirs. Also, license in these files. tests/runtest.py; README.md; tests/psitest.pl. Also, in content of psi4/doc/sphinxman/source/conf.py.in#L130. Update samples¶. Run make sphinxman at least once by hand; Check in resulting psifiles.py and all the updated and new samples/ files and dirs; Make a lone PR and warn reviewers not to read it, since autogenerated. Collect new authors¶. Survey contributions to current Milestone. Add new contribs and PR lists to release notes GitHub issue; Figure out any new “Additional ",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:2470,Availability,down,downstream,2470,"rs. Also, license in these files. tests/runtest.py; README.md; tests/psitest.pl. Also, in content of psi4/doc/sphinxman/source/conf.py.in#L130. Update samples¶. Run make sphinxman at least once by hand; Check in resulting psifiles.py and all the updated and new samples/ files and dirs; Make a lone PR and warn reviewers not to read it, since autogenerated. Collect new authors¶. Survey contributions to current Milestone. Add new contribs and PR lists to release notes GitHub issue; Figure out any new “Additional Contributors” authors since last release; Edit psi4/header.py accordingly, make PR; Get permission of new authors and their particulars for codemeta.json; Invite any contributors with at least 3 PRs to join GitHub Organization. Anticipate next release¶. Bump version in codemeta.json, psi4/codemeta.json#L9; Add to branch list in azure-pipelines.yml, psi4/azure-pipelines.yml. Build Conda ecosystem stack¶; By “ecosystem stack”, mean packages that are upstream, downstream, required, and optional for a fully featured Psi4 build and which we can’t get from “defaults” or “conda-forge” channels. Main directions are in [cbcy](https://github.com/psi4/psi4meta/blob/master/conda-recipes/conda_build_config.yaml) and [poodle](https://github.com/psi4/psi4meta/blob/master/psinet-nightly/kitandkapoodle.py); A couple weeks before the first “rc” is planned, start going through L/LT in poodle, checking with upstream to see if new versions have been released. If good changes present, rebuild the packages, changing the version numbers in the respective recipes; When L/LT all built and passed, edit the individual package version numbers in cbcy and increment to a new ltrtver with updated version numbers and/or build numbers (only if code changes); Build L/PSI4. If any trouble, edit psi4 code. Iterate until builds and passes. This stage is the only full ctest & pytest on Psi4+upstream; Build L/RT-MP. If any trouble, edit code in L/RT and rebuild those package(s). Iterate until builds ",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:3556,Availability,down,downstream,3556,"hich we can’t get from “defaults” or “conda-forge” channels. Main directions are in [cbcy](https://github.com/psi4/psi4meta/blob/master/conda-recipes/conda_build_config.yaml) and [poodle](https://github.com/psi4/psi4meta/blob/master/psinet-nightly/kitandkapoodle.py); A couple weeks before the first “rc” is planned, start going through L/LT in poodle, checking with upstream to see if new versions have been released. If good changes present, rebuild the packages, changing the version numbers in the respective recipes; When L/LT all built and passed, edit the individual package version numbers in cbcy and increment to a new ltrtver with updated version numbers and/or build numbers (only if code changes); Build L/PSI4. If any trouble, edit psi4 code. Iterate until builds and passes. This stage is the only full ctest & pytest on Psi4+upstream; Build L/RT-MP. If any trouble, edit code in L/RT and rebuild those package(s). Iterate until builds and passes. This stage is the only full ctest & pytest of Psi4+downstream; Build L/DEV. If any trouble, edit psi4 build system, plugin system, or OpenMP setup. Iterate until builds and passes; Build L/DOCS. If any trouble, edit the docs or the tests. Iterate until builds and passes; Results of last should upload to psicode.org (docs) and codecov.io (coverage); Changes to targets’ “source” and “version” in individual recipes should be edited in psi4 external/*/*/CMakeLists.txt files; Once everything’s working on Linux, repeat on Mac; At this point, ready to fine-tune builds of “Psi4 stack”. Assemble postrelease changes¶. Collect PRs with “backport” label, and request other backport suggestions on upcoming RN issue; Cherry-pick backport PRs and commits, apply other changes manually, not forgetting CI files; Do the draft parts of Publish GitHub postrelease; Test thoroughly locally, including psi4-rt (may have to step back for dependency versions or builds); Note that while can’t change maintenance branch’s history, can push to it direct",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:4491,Availability,mainten,maintenance,4491,"ytest on Psi4+upstream; Build L/RT-MP. If any trouble, edit code in L/RT and rebuild those package(s). Iterate until builds and passes. This stage is the only full ctest & pytest of Psi4+downstream; Build L/DEV. If any trouble, edit psi4 build system, plugin system, or OpenMP setup. Iterate until builds and passes; Build L/DOCS. If any trouble, edit the docs or the tests. Iterate until builds and passes; Results of last should upload to psicode.org (docs) and codecov.io (coverage); Changes to targets’ “source” and “version” in individual recipes should be edited in psi4 external/*/*/CMakeLists.txt files; Once everything’s working on Linux, repeat on Mac; At this point, ready to fine-tune builds of “Psi4 stack”. Assemble postrelease changes¶. Collect PRs with “backport” label, and request other backport suggestions on upcoming RN issue; Cherry-pick backport PRs and commits, apply other changes manually, not forgetting CI files; Do the draft parts of Publish GitHub postrelease; Test thoroughly locally, including psi4-rt (may have to step back for dependency versions or builds); Note that while can’t change maintenance branch’s history, can push to it directly on upstream; If want to do trial conda builds, requires source/git_tag: 1.3.x and fake package/version: v1.3.1rc1. Tweak Conda for postrelease¶. In psi4-* recipes, find the best combination of master meta.yaml/build.sh and the v1N(x-1)-labeled ones. comment out any dependencies in master but not yet in postrelease; add {{ dep_bld }} entries if needed to step back build. make sure normal operation is ''. In cbcy,. create a postrelease new line and record anything not in continuous order with <> or blanking; step back any dependencies versions or build numbers to ones compatible with the postrelease. Do final pass before release tag¶. Check that psi4/external/ repos and commits have been updated to match conda recipes sources. Also check versions with conda_build_config.yaml; Check psi4/doc/sphinxman/source/introduc",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:7141,Availability,mainten,maintenance,7141,"git tag -a v1.3rc2 bc8d7f5 -m ""v1.3rc2"". # pause here and push to upstream and let Azure complete if want an; # on-tag Windows conda package, not just tag+1.dev1; # below pushes commit and tag together so only one CI; # > git push --atomic upstream master v1.5; # also, grab the docs build from GHA artifacts. >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; ...; -__version_long = '1.3rc2+zzzzzzz'; +__version_long = '1.3rc2+bc8d7f5'. >>> git add psi4/metadata.py; >>> git commit -m ""Records tag for v1.3rc2""; [master 16dbd3e] Records tag for v1.3rc2. # goto GH:psi4/psi4 > Settings > Branches > master > Edit; # https://github.com/psi4/psi4/settings/branch_protection_rules/424295; # uncheck ""Include administrators"" and Save changes. >>> git push upstream master; >>> git push upstream v1.3rc2. # re-engage ""Include administrators"" protections. Tag postrelease¶. # be on clean maintenance branch up-to-date with upstream in both commits and tags; # * mind which version strings get ""v"" and which don't; # * if not fork, replace ""upstream"" with ""origin"". >>> git checkout 1.3.x; Switched to branch '1.3.x'. >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; ...; -__version__ = '1.3'; -__version_long = '1.3+zzzzzzz'; +__version__ = '1.3.1'; +__version_long = '1.3.1+zzzzzzz'. >>> git add psi4/metadata.py; >>> git commit -m ""v1.3.1""; [1.3.x 2ce1c29] v1.3.1. >>> git log --oneline | head -1; 786fb2b v1.3.1; >>> git tag -a v1.3.1 2ce1c29 -m ""v1.3.1"". # skipping the hash recording and ""upcoming"" step b/c only tags matter on maintenance branch. # free pushing to maintenance branches at present so GitHub interface steps not needed; # goto GH:psi4/psi4 > Settings > Branches > 1.3.x > Edit; # https://github.com/psi4/psi4/settings/branch_protection_rules/4385008 # !Varies!; # uncheck ""Include administrators"" and Save changes. >>> git push upstream 1.3.x; >>> git push upstream v1.3.1. # re-engage ""Include administrator",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:7826,Availability,mainten,maintenance,7826,"ag for v1.3rc2. # goto GH:psi4/psi4 > Settings > Branches > master > Edit; # https://github.com/psi4/psi4/settings/branch_protection_rules/424295; # uncheck ""Include administrators"" and Save changes. >>> git push upstream master; >>> git push upstream v1.3rc2. # re-engage ""Include administrators"" protections. Tag postrelease¶. # be on clean maintenance branch up-to-date with upstream in both commits and tags; # * mind which version strings get ""v"" and which don't; # * if not fork, replace ""upstream"" with ""origin"". >>> git checkout 1.3.x; Switched to branch '1.3.x'. >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; ...; -__version__ = '1.3'; -__version_long = '1.3+zzzzzzz'; +__version__ = '1.3.1'; +__version_long = '1.3.1+zzzzzzz'. >>> git add psi4/metadata.py; >>> git commit -m ""v1.3.1""; [1.3.x 2ce1c29] v1.3.1. >>> git log --oneline | head -1; 786fb2b v1.3.1; >>> git tag -a v1.3.1 2ce1c29 -m ""v1.3.1"". # skipping the hash recording and ""upcoming"" step b/c only tags matter on maintenance branch. # free pushing to maintenance branches at present so GitHub interface steps not needed; # goto GH:psi4/psi4 > Settings > Branches > 1.3.x > Edit; # https://github.com/psi4/psi4/settings/branch_protection_rules/4385008 # !Varies!; # uncheck ""Include administrators"" and Save changes. >>> git push upstream 1.3.x; >>> git push upstream v1.3.1. # re-engage ""Include administrators"" protections. Initialize release branch¶. follow tagging procedure; before re-engaing the “include admin” button, push a branch at the tag commit (not the records commit); >>> git log --online | head -2; 45315cb Records tag for v1.3; 20e5c7e v1.3. >>> git checkout 20e5c7e; >>> git checkout -b 1.3.x; Switched to a new branch '1.3.x'; >>> git push upstream 1.3.x. set up new branch as protected branch through GitHub psi4 org Settings. Should be already covered under 1.*.x rule. Build Conda Psi4 stack at specific commit¶; By “Psi4 stack”, mean packages psi4, psi4-rt, psi4",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:7864,Availability,mainten,maintenance,7864,"/branch_protection_rules/424295; # uncheck ""Include administrators"" and Save changes. >>> git push upstream master; >>> git push upstream v1.3rc2. # re-engage ""Include administrators"" protections. Tag postrelease¶. # be on clean maintenance branch up-to-date with upstream in both commits and tags; # * mind which version strings get ""v"" and which don't; # * if not fork, replace ""upstream"" with ""origin"". >>> git checkout 1.3.x; Switched to branch '1.3.x'. >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; ...; -__version__ = '1.3'; -__version_long = '1.3+zzzzzzz'; +__version__ = '1.3.1'; +__version_long = '1.3.1+zzzzzzz'. >>> git add psi4/metadata.py; >>> git commit -m ""v1.3.1""; [1.3.x 2ce1c29] v1.3.1. >>> git log --oneline | head -1; 786fb2b v1.3.1; >>> git tag -a v1.3.1 2ce1c29 -m ""v1.3.1"". # skipping the hash recording and ""upcoming"" step b/c only tags matter on maintenance branch. # free pushing to maintenance branches at present so GitHub interface steps not needed; # goto GH:psi4/psi4 > Settings > Branches > 1.3.x > Edit; # https://github.com/psi4/psi4/settings/branch_protection_rules/4385008 # !Varies!; # uncheck ""Include administrators"" and Save changes. >>> git push upstream 1.3.x; >>> git push upstream v1.3.1. # re-engage ""Include administrators"" protections. Initialize release branch¶. follow tagging procedure; before re-engaing the “include admin” button, push a branch at the tag commit (not the records commit); >>> git log --online | head -2; 45315cb Records tag for v1.3; 20e5c7e v1.3. >>> git checkout 20e5c7e; >>> git checkout -b 1.3.x; Switched to a new branch '1.3.x'; >>> git push upstream 1.3.x. set up new branch as protected branch through GitHub psi4 org Settings. Should be already covered under 1.*.x rule. Build Conda Psi4 stack at specific commit¶; By “Psi4 stack”, mean packages psi4, psi4-rt, psi4-dev.; Package psi4-docs used to be in “Psi4 stack”, but it’s handled by GHA and netlify now, not Conda, so skip di",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:12470,Availability,down,downloaded,12470,"kiecutter. This env presently accessed through conda activate cookie.; Enter “constructor-cutter-unified” in the psi4meta repo. There’s a good README there, https://github.com/psi4/psi4meta/blob/master/conda-recipes/constructor-cutter-unified/README.md; Edit cookiecutter/cookiecutter.json for control. Edit which python versions, if necessary; Edit release field; Edit hash field. This is the 7-char hash that’s on every psi4 conda pkg as part of version; Edit ltrtver field. This matches the current setting in conda_build_config.yaml; For prereleases, ""channel_tag"": ""/label/dev"", while for (post)releases, it should be the empty string; Leave this file set to a “rc” with Git, as that has more details. For (post)releases (not prereleases), copy cookiecutter.json to cookiecutter.json-vXXX; Edit cookiecutter/{{.../construct.yaml for templating. This is rarely needed; If it’s been a while or you need the space, clear out ~/.conda/constructor, where the downloaded packages are cached; Note that installers get written to build/ and this gets regenerated each time. Clear out between runs.; python run.py; [Outdated] Watch out for py_ in buildstring as this means a noarch package has been pulled. It must be eliminated. Constructors can’t handle “noarch” packages and will fail at runtime. If see a “noarch” package, must find the recipe and rebuild for all OS & Python combinations. Then run constructor again.; [Replacement] After adding a post_install to reposition the noarch packages, they are safe to include.; If fetching times out, may have to run run.py several times. Clear out build/ in between. It’s the fetching that takes a long time, not constucting; In the end, should have several installers; >>> ls -l build/psi4conda-1.3-py3.*/*64.sh; -rwxr-xr-x. 516M Feb 28 20:30 build/psi4conda-1.3-py3.6-linux-64/psi4conda-1.3-py36-Linux-x86_64.sh; -rwxr-xr-x. 299M Feb 28 20:31 build/psi4conda-1.3-py3.6-osx-64/psi4conda-1.3-py36-MacOSX-x86_64.sh; -rwxr-xr-x. 518M Feb 28 20:30 build/psi",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:13789,Availability,down,download,13789,"If see a “noarch” package, must find the recipe and rebuild for all OS & Python combinations. Then run constructor again.; [Replacement] After adding a post_install to reposition the noarch packages, they are safe to include.; If fetching times out, may have to run run.py several times. Clear out build/ in between. It’s the fetching that takes a long time, not constucting; In the end, should have several installers; >>> ls -l build/psi4conda-1.3-py3.*/*64.sh; -rwxr-xr-x. 516M Feb 28 20:30 build/psi4conda-1.3-py3.6-linux-64/psi4conda-1.3-py36-Linux-x86_64.sh; -rwxr-xr-x. 299M Feb 28 20:31 build/psi4conda-1.3-py3.6-osx-64/psi4conda-1.3-py36-MacOSX-x86_64.sh; -rwxr-xr-x. 518M Feb 28 20:30 build/psi4conda-1.3-py3.7-linux-64/psi4conda-1.3-py37-Linux-x86_64.sh; -rwxr-xr-x. 299M Feb 28 20:31 build/psi4conda-1.3-py3.7-osx-64/psi4conda-1.3-py37-MacOSX-x86_64.sh. Upload installer files to vergil, scp -r build/Psi4*/Psi4*sh root@vergil.chemistry.gatech.edu:/var/www/html/psicode-download/; Log in to vergil root and make WindowsWSL symlinks. Build Psi4conda set¶; Installers are build using the project constructor and build binary bash or exe scripts, one per OS per Python version. In analogy to Miniconda, they’re called Psi4Conda. They are built through GHA on the psi4meta repo and get served from vergil (cdsgroup webserver). Edit recipe https://github.com/psi4/psi4meta/blob/master/installers/construct.yaml. Edit the top matter for Configuration. See snapshots in directory for examples. Edit release fields. (Windows is often dev1 unless separate steps.); Edit ltrtver field. This matches the current setting in conda_build_config.yaml; For prereleases, ""channel_tag"": ""/label/dev"", while for (post)releases, it should be the empty string. Edit the packages and channels info if necessary. Probably long-term stable. Edit the GHA control file https://github.com/psi4/psi4meta/blob/master/.github/workflows/Installers.yml matrix.cfg; All conda packages must already have been built and in ",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:15097,Availability,down,download,15097,"on the psi4meta repo and get served from vergil (cdsgroup webserver). Edit recipe https://github.com/psi4/psi4meta/blob/master/installers/construct.yaml. Edit the top matter for Configuration. See snapshots in directory for examples. Edit release fields. (Windows is often dev1 unless separate steps.); Edit ltrtver field. This matches the current setting in conda_build_config.yaml; For prereleases, ""channel_tag"": ""/label/dev"", while for (post)releases, it should be the empty string. Edit the packages and channels info if necessary. Probably long-term stable. Edit the GHA control file https://github.com/psi4/psi4meta/blob/master/.github/workflows/Installers.yml matrix.cfg; All conda packages must already have been built and in the right channel_tag channel.; Commit construct.yaml to trigger installer builds.; When all build successfully, hover over the artifacts, and note the consecutive numbers GH has assigned them. These artifacts only linger for a day.; Log in to vergil root and move to /var/www/html/psicode-download.; Use the pull_gha_installers script to download the installers from GH to vergil. First two arguments are first and last of the artifact numbers, and third argument is an auth token. bash pull_gha_installers.sh 47226565 47226573 715...4f3.; Make WindowsWSL and any other symlinks the script head matter advises. Generate download page for psicode.org¶. Be in repo psicode-hugo-website; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/content/installs/v13rc2.md. Note the edition string v13rc2 in frontmatter for this and future filenames; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/data/installs/v13rc2.yaml for menu and notes content; Enter scripts/ dir and edit primarily https://github.com/psi4/psicode-hugo-website/blob/master/scripts/install-generator.py#L9 but also any other arrays or messages that should change.; Run the install-generator.py in place. It will dump new fil",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:15146,Availability,down,download,15146,"recipe https://github.com/psi4/psi4meta/blob/master/installers/construct.yaml. Edit the top matter for Configuration. See snapshots in directory for examples. Edit release fields. (Windows is often dev1 unless separate steps.); Edit ltrtver field. This matches the current setting in conda_build_config.yaml; For prereleases, ""channel_tag"": ""/label/dev"", while for (post)releases, it should be the empty string. Edit the packages and channels info if necessary. Probably long-term stable. Edit the GHA control file https://github.com/psi4/psi4meta/blob/master/.github/workflows/Installers.yml matrix.cfg; All conda packages must already have been built and in the right channel_tag channel.; Commit construct.yaml to trigger installer builds.; When all build successfully, hover over the artifacts, and note the consecutive numbers GH has assigned them. These artifacts only linger for a day.; Log in to vergil root and move to /var/www/html/psicode-download.; Use the pull_gha_installers script to download the installers from GH to vergil. First two arguments are first and last of the artifact numbers, and third argument is an auth token. bash pull_gha_installers.sh 47226565 47226573 715...4f3.; Make WindowsWSL and any other symlinks the script head matter advises. Generate download page for psicode.org¶. Be in repo psicode-hugo-website; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/content/installs/v13rc2.md. Note the edition string v13rc2 in frontmatter for this and future filenames; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/data/installs/v13rc2.yaml for menu and notes content; Enter scripts/ dir and edit primarily https://github.com/psi4/psicode-hugo-website/blob/master/scripts/install-generator.py#L9 but also any other arrays or messages that should change.; Run the install-generator.py in place. It will dump new files into data/installs/ _subdirs_. Be sure to git add them.; Installer page",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:15428,Availability,down,download,15428,"_build_config.yaml; For prereleases, ""channel_tag"": ""/label/dev"", while for (post)releases, it should be the empty string. Edit the packages and channels info if necessary. Probably long-term stable. Edit the GHA control file https://github.com/psi4/psi4meta/blob/master/.github/workflows/Installers.yml matrix.cfg; All conda packages must already have been built and in the right channel_tag channel.; Commit construct.yaml to trigger installer builds.; When all build successfully, hover over the artifacts, and note the consecutive numbers GH has assigned them. These artifacts only linger for a day.; Log in to vergil root and move to /var/www/html/psicode-download.; Use the pull_gha_installers script to download the installers from GH to vergil. First two arguments are first and last of the artifact numbers, and third argument is an auth token. bash pull_gha_installers.sh 47226565 47226573 715...4f3.; Make WindowsWSL and any other symlinks the script head matter advises. Generate download page for psicode.org¶. Be in repo psicode-hugo-website; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/content/installs/v13rc2.md. Note the edition string v13rc2 in frontmatter for this and future filenames; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/data/installs/v13rc2.yaml for menu and notes content; Enter scripts/ dir and edit primarily https://github.com/psi4/psicode-hugo-website/blob/master/scripts/install-generator.py#L9 but also any other arrays or messages that should change.; Run the install-generator.py in place. It will dump new files into data/installs/ _subdirs_. Be sure to git add them.; Installer page is now ready.; Shift “latest” alias in frontmatter from whichever page is currently active to the new page. This makes sure “Downloads” on the navigation bar points to new page.; Conscientiously, one should test. installer downloads in Mac and Linux. And actually installing them and psi4",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:16371,Availability,down,downloads,16371,"ymlinks the script head matter advises. Generate download page for psicode.org¶. Be in repo psicode-hugo-website; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/content/installs/v13rc2.md. Note the edition string v13rc2 in frontmatter for this and future filenames; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/data/installs/v13rc2.yaml for menu and notes content; Enter scripts/ dir and edit primarily https://github.com/psi4/psicode-hugo-website/blob/master/scripts/install-generator.py#L9 but also any other arrays or messages that should change.; Run the install-generator.py in place. It will dump new files into data/installs/ _subdirs_. Be sure to git add them.; Installer page is now ready.; Shift “latest” alias in frontmatter from whichever page is currently active to the new page. This makes sure “Downloads” on the navigation bar points to new page.; Conscientiously, one should test. installer downloads in Mac and Linux. And actually installing them and psi4 --test them.; that download button and curl downloading register on the download counters on vergil. Commit the new files, PR, and deploy psicode site; Petition on Slack for testers. Collect documentation snapshot¶. Documentation is built automatically by GHA from the latest psi4 master commit. It gets pushed to the psi4/psi4docs repository and thence served by netlify to a site independent of psicode.org. The netlify psicode.org site has a redirect so that psicode.org/psi4manual/master presents the psi4docs netlify content.; GHA controller is psi4/.github/workflows/docs.yml; This setup works great for “latest” docs, but it won’t build a nice copy on the tag because the tag commit is pushed before the tag itself, so the version shows up “undefined”.; So, anytime after “Tag (pre)release” is over, navigate on psi4 GH to the tag commit (not the record commit) and retrigger the docs GHA. Download the artifact (zipped docs dir) at th",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:16456,Availability,down,download,16456,"Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/content/installs/v13rc2.md. Note the edition string v13rc2 in frontmatter for this and future filenames; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/data/installs/v13rc2.yaml for menu and notes content; Enter scripts/ dir and edit primarily https://github.com/psi4/psicode-hugo-website/blob/master/scripts/install-generator.py#L9 but also any other arrays or messages that should change.; Run the install-generator.py in place. It will dump new files into data/installs/ _subdirs_. Be sure to git add them.; Installer page is now ready.; Shift “latest” alias in frontmatter from whichever page is currently active to the new page. This makes sure “Downloads” on the navigation bar points to new page.; Conscientiously, one should test. installer downloads in Mac and Linux. And actually installing them and psi4 --test them.; that download button and curl downloading register on the download counters on vergil. Commit the new files, PR, and deploy psicode site; Petition on Slack for testers. Collect documentation snapshot¶. Documentation is built automatically by GHA from the latest psi4 master commit. It gets pushed to the psi4/psi4docs repository and thence served by netlify to a site independent of psicode.org. The netlify psicode.org site has a redirect so that psicode.org/psi4manual/master presents the psi4docs netlify content.; GHA controller is psi4/.github/workflows/docs.yml; This setup works great for “latest” docs, but it won’t build a nice copy on the tag because the tag commit is pushed before the tag itself, so the version shows up “undefined”.; So, anytime after “Tag (pre)release” is over, navigate on psi4 GH to the tag commit (not the record commit) and retrigger the docs GHA. Download the artifact (zipped docs dir) at the end to a local computer.; In your hugo site clone, create a new directory under static/psi4manual. Copy the zipp",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:16481,Availability,down,downloading,16481,"Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/content/installs/v13rc2.md. Note the edition string v13rc2 in frontmatter for this and future filenames; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/data/installs/v13rc2.yaml for menu and notes content; Enter scripts/ dir and edit primarily https://github.com/psi4/psicode-hugo-website/blob/master/scripts/install-generator.py#L9 but also any other arrays or messages that should change.; Run the install-generator.py in place. It will dump new files into data/installs/ _subdirs_. Be sure to git add them.; Installer page is now ready.; Shift “latest” alias in frontmatter from whichever page is currently active to the new page. This makes sure “Downloads” on the navigation bar points to new page.; Conscientiously, one should test. installer downloads in Mac and Linux. And actually installing them and psi4 --test them.; that download button and curl downloading register on the download counters on vergil. Commit the new files, PR, and deploy psicode site; Petition on Slack for testers. Collect documentation snapshot¶. Documentation is built automatically by GHA from the latest psi4 master commit. It gets pushed to the psi4/psi4docs repository and thence served by netlify to a site independent of psicode.org. The netlify psicode.org site has a redirect so that psicode.org/psi4manual/master presents the psi4docs netlify content.; GHA controller is psi4/.github/workflows/docs.yml; This setup works great for “latest” docs, but it won’t build a nice copy on the tag because the tag commit is pushed before the tag itself, so the version shows up “undefined”.; So, anytime after “Tag (pre)release” is over, navigate on psi4 GH to the tag commit (not the record commit) and retrigger the docs GHA. Download the artifact (zipped docs dir) at the end to a local computer.; In your hugo site clone, create a new directory under static/psi4manual. Copy the zipp",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:16509,Availability,down,download,16509,"Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/content/installs/v13rc2.md. Note the edition string v13rc2 in frontmatter for this and future filenames; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/data/installs/v13rc2.yaml for menu and notes content; Enter scripts/ dir and edit primarily https://github.com/psi4/psicode-hugo-website/blob/master/scripts/install-generator.py#L9 but also any other arrays or messages that should change.; Run the install-generator.py in place. It will dump new files into data/installs/ _subdirs_. Be sure to git add them.; Installer page is now ready.; Shift “latest” alias in frontmatter from whichever page is currently active to the new page. This makes sure “Downloads” on the navigation bar points to new page.; Conscientiously, one should test. installer downloads in Mac and Linux. And actually installing them and psi4 --test them.; that download button and curl downloading register on the download counters on vergil. Commit the new files, PR, and deploy psicode site; Petition on Slack for testers. Collect documentation snapshot¶. Documentation is built automatically by GHA from the latest psi4 master commit. It gets pushed to the psi4/psi4docs repository and thence served by netlify to a site independent of psicode.org. The netlify psicode.org site has a redirect so that psicode.org/psi4manual/master presents the psi4docs netlify content.; GHA controller is psi4/.github/workflows/docs.yml; This setup works great for “latest” docs, but it won’t build a nice copy on the tag because the tag commit is pushed before the tag itself, so the version shows up “undefined”.; So, anytime after “Tag (pre)release” is over, navigate on psi4 GH to the tag commit (not the record commit) and retrigger the docs GHA. Download the artifact (zipped docs dir) at the end to a local computer.; In your hugo site clone, create a new directory under static/psi4manual. Copy the zipp",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:20059,Availability,down,download,20059,"d note the id field value; Use the id value in the shortcode call at the bottom. Finalize release¶. Make new PR with; * edits to main README.md badges, python versions, etc.; * edits to CMakeLists.txt find_package(PythonLibsNew 3.6 REQUIRED); Tweet about release. Reset psi4meta for nightly operation¶; On both Linux and Mac:. After (post)release (not prerelease), in conda_build_config.yaml, edit ltrtver to a new “release.dev” label; After postrelease, unpin any dependencies in cbcy that needed older either ver or bld (e.g., v2rdm_casscf_bld); Edit psi4ver back to '' in cbcy; Edit source/git_tag back to master for psi4-multiout, psi4-docs; Edit build string back to 0 if psi4-multiout needed multiple passes; Edit kitandkapoodle.py back to *** stack; Check in all release, construct, recipe changes on Linux and Mac. Synchronize both to GitHub psi4meta; Copy meta.yaml and build.sh files to vMmp-prefixed files for the record.; Edit crontab back to 2am “norm”. Comment out “anom”. table of contents. Release Procedures; Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1); Update copyright year; Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag (pre)release; Tag postrelease; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set (pre-Spring 2021); Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that; Release Procedures. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:289,Deployability,release,release,289,"﻿. Release Procedures. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that; Release Procedures. Release Procedures¶. Annual¶. Update copyright year. Pre-Release (e.g., v1.3rc1)¶. Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Tag (pre)release; Build Conda Psi4 stack at specific commit; Build Psi4conda set; Generate download page for psicode.org; Reset psi4meta for nightly operation. Release (e.g., v1.3)¶. Do final pass before release tag; Tag (pre)release; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Post-Release (e.g., v1.3.1)¶. Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag postrelease; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Update copyright year¶. cd ~/path/to/psi4; Primary target is licenses. grep -rl ""(c) 2007-2017"" * | xargs sed -i '' ""s/(c) 2007-2017/(c) 2007-2018/g""; On Linux, drop the '' in above command; Need to do psi4/ and docs/ dirs. Also, license in these files. tests/runtest.py; README.md; tests/psitest.pl. Also, in content of psi4/doc/sphinxman/source/conf.py.in#L130. Update samples¶. Run make sphinxman at least once by hand; Check in resulting psifiles.py and all the updated and new samples/ files and dirs; Make a lone PR and warn reviewers not to read it, since autogenerated. Collect new authors¶. Survey contributions to current Milestone. Add new contribs and PR lists to release notes GitHub issue; Figure out any new “Addi",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:336,Deployability,release,release,336,"﻿. Release Procedures. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that; Release Procedures. Release Procedures¶. Annual¶. Update copyright year. Pre-Release (e.g., v1.3rc1)¶. Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Tag (pre)release; Build Conda Psi4 stack at specific commit; Build Psi4conda set; Generate download page for psicode.org; Reset psi4meta for nightly operation. Release (e.g., v1.3)¶. Do final pass before release tag; Tag (pre)release; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Post-Release (e.g., v1.3.1)¶. Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag postrelease; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Update copyright year¶. cd ~/path/to/psi4; Primary target is licenses. grep -rl ""(c) 2007-2017"" * | xargs sed -i '' ""s/(c) 2007-2017/(c) 2007-2018/g""; On Linux, drop the '' in above command; Need to do psi4/ and docs/ dirs. Also, license in these files. tests/runtest.py; README.md; tests/psitest.pl. Also, in content of psi4/doc/sphinxman/source/conf.py.in#L130. Update samples¶. Run make sphinxman at least once by hand; Check in resulting psifiles.py and all the updated and new samples/ files and dirs; Make a lone PR and warn reviewers not to read it, since autogenerated. Collect new authors¶. Survey contributions to current Milestone. Add new contribs and PR lists to release notes GitHub issue; Figure out any new “Addi",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:531,Deployability,release,release,531,"﻿. Release Procedures. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that; Release Procedures. Release Procedures¶. Annual¶. Update copyright year. Pre-Release (e.g., v1.3rc1)¶. Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Tag (pre)release; Build Conda Psi4 stack at specific commit; Build Psi4conda set; Generate download page for psicode.org; Reset psi4meta for nightly operation. Release (e.g., v1.3)¶. Do final pass before release tag; Tag (pre)release; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Post-Release (e.g., v1.3.1)¶. Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag postrelease; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Update copyright year¶. cd ~/path/to/psi4; Primary target is licenses. grep -rl ""(c) 2007-2017"" * | xargs sed -i '' ""s/(c) 2007-2017/(c) 2007-2018/g""; On Linux, drop the '' in above command; Need to do psi4/ and docs/ dirs. Also, license in these files. tests/runtest.py; README.md; tests/psitest.pl. Also, in content of psi4/doc/sphinxman/source/conf.py.in#L130. Update samples¶. Run make sphinxman at least once by hand; Check in resulting psifiles.py and all the updated and new samples/ files and dirs; Make a lone PR and warn reviewers not to read it, since autogenerated. Collect new authors¶. Survey contributions to current Milestone. Add new contribs and PR lists to release notes GitHub issue; Figure out any new “Addi",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:553,Deployability,release,release,553,"﻿. Release Procedures. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that; Release Procedures. Release Procedures¶. Annual¶. Update copyright year. Pre-Release (e.g., v1.3rc1)¶. Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Tag (pre)release; Build Conda Psi4 stack at specific commit; Build Psi4conda set; Generate download page for psicode.org; Reset psi4meta for nightly operation. Release (e.g., v1.3)¶. Do final pass before release tag; Tag (pre)release; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Post-Release (e.g., v1.3.1)¶. Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag postrelease; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Update copyright year¶. cd ~/path/to/psi4; Primary target is licenses. grep -rl ""(c) 2007-2017"" * | xargs sed -i '' ""s/(c) 2007-2017/(c) 2007-2018/g""; On Linux, drop the '' in above command; Need to do psi4/ and docs/ dirs. Also, license in these files. tests/runtest.py; README.md; tests/psitest.pl. Also, in content of psi4/doc/sphinxman/source/conf.py.in#L130. Update samples¶. Run make sphinxman at least once by hand; Check in resulting psifiles.py and all the updated and new samples/ files and dirs; Make a lone PR and warn reviewers not to read it, since autogenerated. Collect new authors¶. Survey contributions to current Milestone. Add new contribs and PR lists to release notes GitHub issue; Figure out any new “Addi",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:573,Deployability,release,release,573,"﻿. Release Procedures. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that; Release Procedures. Release Procedures¶. Annual¶. Update copyright year. Pre-Release (e.g., v1.3rc1)¶. Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Tag (pre)release; Build Conda Psi4 stack at specific commit; Build Psi4conda set; Generate download page for psicode.org; Reset psi4meta for nightly operation. Release (e.g., v1.3)¶. Do final pass before release tag; Tag (pre)release; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Post-Release (e.g., v1.3.1)¶. Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag postrelease; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Update copyright year¶. cd ~/path/to/psi4; Primary target is licenses. grep -rl ""(c) 2007-2017"" * | xargs sed -i '' ""s/(c) 2007-2017/(c) 2007-2018/g""; On Linux, drop the '' in above command; Need to do psi4/ and docs/ dirs. Also, license in these files. tests/runtest.py; README.md; tests/psitest.pl. Also, in content of psi4/doc/sphinxman/source/conf.py.in#L130. Update samples¶. Run make sphinxman at least once by hand; Check in resulting psifiles.py and all the updated and new samples/ files and dirs; Make a lone PR and warn reviewers not to read it, since autogenerated. Collect new authors¶. Survey contributions to current Milestone. Add new contribs and PR lists to release notes GitHub issue; Figure out any new “Addi",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:769,Deployability,release,release,769,"﻿. Release Procedures. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that; Release Procedures. Release Procedures¶. Annual¶. Update copyright year. Pre-Release (e.g., v1.3rc1)¶. Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Tag (pre)release; Build Conda Psi4 stack at specific commit; Build Psi4conda set; Generate download page for psicode.org; Reset psi4meta for nightly operation. Release (e.g., v1.3)¶. Do final pass before release tag; Tag (pre)release; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Post-Release (e.g., v1.3.1)¶. Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag postrelease; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Update copyright year¶. cd ~/path/to/psi4; Primary target is licenses. grep -rl ""(c) 2007-2017"" * | xargs sed -i '' ""s/(c) 2007-2017/(c) 2007-2018/g""; On Linux, drop the '' in above command; Need to do psi4/ and docs/ dirs. Also, license in these files. tests/runtest.py; README.md; tests/psitest.pl. Also, in content of psi4/doc/sphinxman/source/conf.py.in#L130. Update samples¶. Run make sphinxman at least once by hand; Check in resulting psifiles.py and all the updated and new samples/ files and dirs; Make a lone PR and warn reviewers not to read it, since autogenerated. Collect new authors¶. Survey contributions to current Milestone. Add new contribs and PR lists to release notes GitHub issue; Figure out any new “Addi",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:794,Deployability,release,release,794,"﻿. Release Procedures. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that; Release Procedures. Release Procedures¶. Annual¶. Update copyright year. Pre-Release (e.g., v1.3rc1)¶. Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Tag (pre)release; Build Conda Psi4 stack at specific commit; Build Psi4conda set; Generate download page for psicode.org; Reset psi4meta for nightly operation. Release (e.g., v1.3)¶. Do final pass before release tag; Tag (pre)release; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Post-Release (e.g., v1.3.1)¶. Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag postrelease; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Update copyright year¶. cd ~/path/to/psi4; Primary target is licenses. grep -rl ""(c) 2007-2017"" * | xargs sed -i '' ""s/(c) 2007-2017/(c) 2007-2018/g""; On Linux, drop the '' in above command; Need to do psi4/ and docs/ dirs. Also, license in these files. tests/runtest.py; README.md; tests/psitest.pl. Also, in content of psi4/doc/sphinxman/source/conf.py.in#L130. Update samples¶. Run make sphinxman at least once by hand; Check in resulting psifiles.py and all the updated and new samples/ files and dirs; Make a lone PR and warn reviewers not to read it, since autogenerated. Collect new authors¶. Survey contributions to current Milestone. Add new contribs and PR lists to release notes GitHub issue; Figure out any new “Addi",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:812,Deployability,release,release,812,"﻿. Release Procedures. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that; Release Procedures. Release Procedures¶. Annual¶. Update copyright year. Pre-Release (e.g., v1.3rc1)¶. Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Tag (pre)release; Build Conda Psi4 stack at specific commit; Build Psi4conda set; Generate download page for psicode.org; Reset psi4meta for nightly operation. Release (e.g., v1.3)¶. Do final pass before release tag; Tag (pre)release; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Post-Release (e.g., v1.3.1)¶. Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag postrelease; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Update copyright year¶. cd ~/path/to/psi4; Primary target is licenses. grep -rl ""(c) 2007-2017"" * | xargs sed -i '' ""s/(c) 2007-2017/(c) 2007-2018/g""; On Linux, drop the '' in above command; Need to do psi4/ and docs/ dirs. Also, license in these files. tests/runtest.py; README.md; tests/psitest.pl. Also, in content of psi4/doc/sphinxman/source/conf.py.in#L130. Update samples¶. Run make sphinxman at least once by hand; Check in resulting psifiles.py and all the updated and new samples/ files and dirs; Make a lone PR and warn reviewers not to read it, since autogenerated. Collect new authors¶. Survey contributions to current Milestone. Add new contribs and PR lists to release notes GitHub issue; Figure out any new “Addi",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:969,Deployability,release,release,969,"ase Procedures. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that; Release Procedures. Release Procedures¶. Annual¶. Update copyright year. Pre-Release (e.g., v1.3rc1)¶. Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Tag (pre)release; Build Conda Psi4 stack at specific commit; Build Psi4conda set; Generate download page for psicode.org; Reset psi4meta for nightly operation. Release (e.g., v1.3)¶. Do final pass before release tag; Tag (pre)release; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Post-Release (e.g., v1.3.1)¶. Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag postrelease; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Update copyright year¶. cd ~/path/to/psi4; Primary target is licenses. grep -rl ""(c) 2007-2017"" * | xargs sed -i '' ""s/(c) 2007-2017/(c) 2007-2018/g""; On Linux, drop the '' in above command; Need to do psi4/ and docs/ dirs. Also, license in these files. tests/runtest.py; README.md; tests/psitest.pl. Also, in content of psi4/doc/sphinxman/source/conf.py.in#L130. Update samples¶. Run make sphinxman at least once by hand; Check in resulting psifiles.py and all the updated and new samples/ files and dirs; Make a lone PR and warn reviewers not to read it, since autogenerated. Collect new authors¶. Survey contributions to current Milestone. Add new contribs and PR lists to release notes GitHub issue; Figure out any new “Additional ",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:1208,Deployability,release,release,1208," year. Pre-Release (e.g., v1.3rc1)¶. Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Tag (pre)release; Build Conda Psi4 stack at specific commit; Build Psi4conda set; Generate download page for psicode.org; Reset psi4meta for nightly operation. Release (e.g., v1.3)¶. Do final pass before release tag; Tag (pre)release; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Post-Release (e.g., v1.3.1)¶. Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag postrelease; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Update copyright year¶. cd ~/path/to/psi4; Primary target is licenses. grep -rl ""(c) 2007-2017"" * | xargs sed -i '' ""s/(c) 2007-2017/(c) 2007-2018/g""; On Linux, drop the '' in above command; Need to do psi4/ and docs/ dirs. Also, license in these files. tests/runtest.py; README.md; tests/psitest.pl. Also, in content of psi4/doc/sphinxman/source/conf.py.in#L130. Update samples¶. Run make sphinxman at least once by hand; Check in resulting psifiles.py and all the updated and new samples/ files and dirs; Make a lone PR and warn reviewers not to read it, since autogenerated. Collect new authors¶. Survey contributions to current Milestone. Add new contribs and PR lists to release notes GitHub issue; Figure out any new “Additional Contributors” authors since last release; Edit psi4/header.py accordingly, make PR; Get permission of new authors and their particulars for codemeta.json; Invite any contributors with at least",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:1226,Deployability,release,release,1226," year. Pre-Release (e.g., v1.3rc1)¶. Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Tag (pre)release; Build Conda Psi4 stack at specific commit; Build Psi4conda set; Generate download page for psicode.org; Reset psi4meta for nightly operation. Release (e.g., v1.3)¶. Do final pass before release tag; Tag (pre)release; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Post-Release (e.g., v1.3.1)¶. Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag postrelease; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Update copyright year¶. cd ~/path/to/psi4; Primary target is licenses. grep -rl ""(c) 2007-2017"" * | xargs sed -i '' ""s/(c) 2007-2017/(c) 2007-2018/g""; On Linux, drop the '' in above command; Need to do psi4/ and docs/ dirs. Also, license in these files. tests/runtest.py; README.md; tests/psitest.pl. Also, in content of psi4/doc/sphinxman/source/conf.py.in#L130. Update samples¶. Run make sphinxman at least once by hand; Check in resulting psifiles.py and all the updated and new samples/ files and dirs; Make a lone PR and warn reviewers not to read it, since autogenerated. Collect new authors¶. Survey contributions to current Milestone. Add new contribs and PR lists to release notes GitHub issue; Figure out any new “Additional Contributors” authors since last release; Edit psi4/header.py accordingly, make PR; Get permission of new authors and their particulars for codemeta.json; Invite any contributors with at least",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:1739,Deployability,update,updated,1739,"sicode release; Finalize release; Reset psi4meta for nightly operation. Post-Release (e.g., v1.3.1)¶. Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag postrelease; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Update copyright year¶. cd ~/path/to/psi4; Primary target is licenses. grep -rl ""(c) 2007-2017"" * | xargs sed -i '' ""s/(c) 2007-2017/(c) 2007-2018/g""; On Linux, drop the '' in above command; Need to do psi4/ and docs/ dirs. Also, license in these files. tests/runtest.py; README.md; tests/psitest.pl. Also, in content of psi4/doc/sphinxman/source/conf.py.in#L130. Update samples¶. Run make sphinxman at least once by hand; Check in resulting psifiles.py and all the updated and new samples/ files and dirs; Make a lone PR and warn reviewers not to read it, since autogenerated. Collect new authors¶. Survey contributions to current Milestone. Add new contribs and PR lists to release notes GitHub issue; Figure out any new “Additional Contributors” authors since last release; Edit psi4/header.py accordingly, make PR; Get permission of new authors and their particulars for codemeta.json; Invite any contributors with at least 3 PRs to join GitHub Organization. Anticipate next release¶. Bump version in codemeta.json, psi4/codemeta.json#L9; Add to branch list in azure-pipelines.yml, psi4/azure-pipelines.yml. Build Conda ecosystem stack¶; By “ecosystem stack”, mean packages that are upstream, downstream, required, and optional for a fully featured Psi4 build and which we can’t get from “defaults” or “conda-forge” channels. Main directions are in [cbcy](https://github.com/psi4/psi4meta/blob/master/conda-recipes/conda_build_config.yaml) and [poodle](https://github.com/psi4/psi4meta/blob/master/psinet-night",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:1949,Deployability,release,release,1949,"elease; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Update copyright year¶. cd ~/path/to/psi4; Primary target is licenses. grep -rl ""(c) 2007-2017"" * | xargs sed -i '' ""s/(c) 2007-2017/(c) 2007-2018/g""; On Linux, drop the '' in above command; Need to do psi4/ and docs/ dirs. Also, license in these files. tests/runtest.py; README.md; tests/psitest.pl. Also, in content of psi4/doc/sphinxman/source/conf.py.in#L130. Update samples¶. Run make sphinxman at least once by hand; Check in resulting psifiles.py and all the updated and new samples/ files and dirs; Make a lone PR and warn reviewers not to read it, since autogenerated. Collect new authors¶. Survey contributions to current Milestone. Add new contribs and PR lists to release notes GitHub issue; Figure out any new “Additional Contributors” authors since last release; Edit psi4/header.py accordingly, make PR; Get permission of new authors and their particulars for codemeta.json; Invite any contributors with at least 3 PRs to join GitHub Organization. Anticipate next release¶. Bump version in codemeta.json, psi4/codemeta.json#L9; Add to branch list in azure-pipelines.yml, psi4/azure-pipelines.yml. Build Conda ecosystem stack¶; By “ecosystem stack”, mean packages that are upstream, downstream, required, and optional for a fully featured Psi4 build and which we can’t get from “defaults” or “conda-forge” channels. Main directions are in [cbcy](https://github.com/psi4/psi4meta/blob/master/conda-recipes/conda_build_config.yaml) and [poodle](https://github.com/psi4/psi4meta/blob/master/psinet-nightly/kitandkapoodle.py); A couple weeks before the first “rc” is planned, start going through L/LT in poodle, checking with upstream to see if new versions have been released. If good changes present, rebui",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:2041,Deployability,release,release,2041,"elease; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Update copyright year¶. cd ~/path/to/psi4; Primary target is licenses. grep -rl ""(c) 2007-2017"" * | xargs sed -i '' ""s/(c) 2007-2017/(c) 2007-2018/g""; On Linux, drop the '' in above command; Need to do psi4/ and docs/ dirs. Also, license in these files. tests/runtest.py; README.md; tests/psitest.pl. Also, in content of psi4/doc/sphinxman/source/conf.py.in#L130. Update samples¶. Run make sphinxman at least once by hand; Check in resulting psifiles.py and all the updated and new samples/ files and dirs; Make a lone PR and warn reviewers not to read it, since autogenerated. Collect new authors¶. Survey contributions to current Milestone. Add new contribs and PR lists to release notes GitHub issue; Figure out any new “Additional Contributors” authors since last release; Edit psi4/header.py accordingly, make PR; Get permission of new authors and their particulars for codemeta.json; Invite any contributors with at least 3 PRs to join GitHub Organization. Anticipate next release¶. Bump version in codemeta.json, psi4/codemeta.json#L9; Add to branch list in azure-pipelines.yml, psi4/azure-pipelines.yml. Build Conda ecosystem stack¶; By “ecosystem stack”, mean packages that are upstream, downstream, required, and optional for a fully featured Psi4 build and which we can’t get from “defaults” or “conda-forge” channels. Main directions are in [cbcy](https://github.com/psi4/psi4meta/blob/master/conda-recipes/conda_build_config.yaml) and [poodle](https://github.com/psi4/psi4meta/blob/master/psinet-nightly/kitandkapoodle.py); A couple weeks before the first “rc” is planned, start going through L/LT in poodle, checking with upstream to see if new versions have been released. If good changes present, rebui",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:2252,Deployability,release,release,2252,"a for nightly operation. Update copyright year¶. cd ~/path/to/psi4; Primary target is licenses. grep -rl ""(c) 2007-2017"" * | xargs sed -i '' ""s/(c) 2007-2017/(c) 2007-2018/g""; On Linux, drop the '' in above command; Need to do psi4/ and docs/ dirs. Also, license in these files. tests/runtest.py; README.md; tests/psitest.pl. Also, in content of psi4/doc/sphinxman/source/conf.py.in#L130. Update samples¶. Run make sphinxman at least once by hand; Check in resulting psifiles.py and all the updated and new samples/ files and dirs; Make a lone PR and warn reviewers not to read it, since autogenerated. Collect new authors¶. Survey contributions to current Milestone. Add new contribs and PR lists to release notes GitHub issue; Figure out any new “Additional Contributors” authors since last release; Edit psi4/header.py accordingly, make PR; Get permission of new authors and their particulars for codemeta.json; Invite any contributors with at least 3 PRs to join GitHub Organization. Anticipate next release¶. Bump version in codemeta.json, psi4/codemeta.json#L9; Add to branch list in azure-pipelines.yml, psi4/azure-pipelines.yml. Build Conda ecosystem stack¶; By “ecosystem stack”, mean packages that are upstream, downstream, required, and optional for a fully featured Psi4 build and which we can’t get from “defaults” or “conda-forge” channels. Main directions are in [cbcy](https://github.com/psi4/psi4meta/blob/master/conda-recipes/conda_build_config.yaml) and [poodle](https://github.com/psi4/psi4meta/blob/master/psinet-nightly/kitandkapoodle.py); A couple weeks before the first “rc” is planned, start going through L/LT in poodle, checking with upstream to see if new versions have been released. If good changes present, rebuild the packages, changing the version numbers in the respective recipes; When L/LT all built and passed, edit the individual package version numbers in cbcy and increment to a new ltrtver with updated version numbers and/or build numbers (only if code chang",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:2344,Deployability,pipeline,pipelines,2344," is licenses. grep -rl ""(c) 2007-2017"" * | xargs sed -i '' ""s/(c) 2007-2017/(c) 2007-2018/g""; On Linux, drop the '' in above command; Need to do psi4/ and docs/ dirs. Also, license in these files. tests/runtest.py; README.md; tests/psitest.pl. Also, in content of psi4/doc/sphinxman/source/conf.py.in#L130. Update samples¶. Run make sphinxman at least once by hand; Check in resulting psifiles.py and all the updated and new samples/ files and dirs; Make a lone PR and warn reviewers not to read it, since autogenerated. Collect new authors¶. Survey contributions to current Milestone. Add new contribs and PR lists to release notes GitHub issue; Figure out any new “Additional Contributors” authors since last release; Edit psi4/header.py accordingly, make PR; Get permission of new authors and their particulars for codemeta.json; Invite any contributors with at least 3 PRs to join GitHub Organization. Anticipate next release¶. Bump version in codemeta.json, psi4/codemeta.json#L9; Add to branch list in azure-pipelines.yml, psi4/azure-pipelines.yml. Build Conda ecosystem stack¶; By “ecosystem stack”, mean packages that are upstream, downstream, required, and optional for a fully featured Psi4 build and which we can’t get from “defaults” or “conda-forge” channels. Main directions are in [cbcy](https://github.com/psi4/psi4meta/blob/master/conda-recipes/conda_build_config.yaml) and [poodle](https://github.com/psi4/psi4meta/blob/master/psinet-nightly/kitandkapoodle.py); A couple weeks before the first “rc” is planned, start going through L/LT in poodle, checking with upstream to see if new versions have been released. If good changes present, rebuild the packages, changing the version numbers in the respective recipes; When L/LT all built and passed, edit the individual package version numbers in cbcy and increment to a new ltrtver with updated version numbers and/or build numbers (only if code changes); Build L/PSI4. If any trouble, edit psi4 code. Iterate until builds and passes.",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:2370,Deployability,pipeline,pipelines,2370,""" * | xargs sed -i '' ""s/(c) 2007-2017/(c) 2007-2018/g""; On Linux, drop the '' in above command; Need to do psi4/ and docs/ dirs. Also, license in these files. tests/runtest.py; README.md; tests/psitest.pl. Also, in content of psi4/doc/sphinxman/source/conf.py.in#L130. Update samples¶. Run make sphinxman at least once by hand; Check in resulting psifiles.py and all the updated and new samples/ files and dirs; Make a lone PR and warn reviewers not to read it, since autogenerated. Collect new authors¶. Survey contributions to current Milestone. Add new contribs and PR lists to release notes GitHub issue; Figure out any new “Additional Contributors” authors since last release; Edit psi4/header.py accordingly, make PR; Get permission of new authors and their particulars for codemeta.json; Invite any contributors with at least 3 PRs to join GitHub Organization. Anticipate next release¶. Bump version in codemeta.json, psi4/codemeta.json#L9; Add to branch list in azure-pipelines.yml, psi4/azure-pipelines.yml. Build Conda ecosystem stack¶; By “ecosystem stack”, mean packages that are upstream, downstream, required, and optional for a fully featured Psi4 build and which we can’t get from “defaults” or “conda-forge” channels. Main directions are in [cbcy](https://github.com/psi4/psi4meta/blob/master/conda-recipes/conda_build_config.yaml) and [poodle](https://github.com/psi4/psi4meta/blob/master/psinet-nightly/kitandkapoodle.py); A couple weeks before the first “rc” is planned, start going through L/LT in poodle, checking with upstream to see if new versions have been released. If good changes present, rebuild the packages, changing the version numbers in the respective recipes; When L/LT all built and passed, edit the individual package version numbers in cbcy and increment to a new ltrtver with updated version numbers and/or build numbers (only if code changes); Build L/PSI4. If any trouble, edit psi4 code. Iterate until builds and passes. This stage is the only full ctest &",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:2951,Deployability,release,released,2951,"ntributions to current Milestone. Add new contribs and PR lists to release notes GitHub issue; Figure out any new “Additional Contributors” authors since last release; Edit psi4/header.py accordingly, make PR; Get permission of new authors and their particulars for codemeta.json; Invite any contributors with at least 3 PRs to join GitHub Organization. Anticipate next release¶. Bump version in codemeta.json, psi4/codemeta.json#L9; Add to branch list in azure-pipelines.yml, psi4/azure-pipelines.yml. Build Conda ecosystem stack¶; By “ecosystem stack”, mean packages that are upstream, downstream, required, and optional for a fully featured Psi4 build and which we can’t get from “defaults” or “conda-forge” channels. Main directions are in [cbcy](https://github.com/psi4/psi4meta/blob/master/conda-recipes/conda_build_config.yaml) and [poodle](https://github.com/psi4/psi4meta/blob/master/psinet-nightly/kitandkapoodle.py); A couple weeks before the first “rc” is planned, start going through L/LT in poodle, checking with upstream to see if new versions have been released. If good changes present, rebuild the packages, changing the version numbers in the respective recipes; When L/LT all built and passed, edit the individual package version numbers in cbcy and increment to a new ltrtver with updated version numbers and/or build numbers (only if code changes); Build L/PSI4. If any trouble, edit psi4 code. Iterate until builds and passes. This stage is the only full ctest & pytest on Psi4+upstream; Build L/RT-MP. If any trouble, edit code in L/RT and rebuild those package(s). Iterate until builds and passes. This stage is the only full ctest & pytest of Psi4+downstream; Build L/DEV. If any trouble, edit psi4 build system, plugin system, or OpenMP setup. Iterate until builds and passes; Build L/DOCS. If any trouble, edit the docs or the tests. Iterate until builds and passes; Results of last should upload to psicode.org (docs) and codecov.io (coverage); Changes to targets’ “source",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:3184,Deployability,update,updated,3184," authors and their particulars for codemeta.json; Invite any contributors with at least 3 PRs to join GitHub Organization. Anticipate next release¶. Bump version in codemeta.json, psi4/codemeta.json#L9; Add to branch list in azure-pipelines.yml, psi4/azure-pipelines.yml. Build Conda ecosystem stack¶; By “ecosystem stack”, mean packages that are upstream, downstream, required, and optional for a fully featured Psi4 build and which we can’t get from “defaults” or “conda-forge” channels. Main directions are in [cbcy](https://github.com/psi4/psi4meta/blob/master/conda-recipes/conda_build_config.yaml) and [poodle](https://github.com/psi4/psi4meta/blob/master/psinet-nightly/kitandkapoodle.py); A couple weeks before the first “rc” is planned, start going through L/LT in poodle, checking with upstream to see if new versions have been released. If good changes present, rebuild the packages, changing the version numbers in the respective recipes; When L/LT all built and passed, edit the individual package version numbers in cbcy and increment to a new ltrtver with updated version numbers and/or build numbers (only if code changes); Build L/PSI4. If any trouble, edit psi4 code. Iterate until builds and passes. This stage is the only full ctest & pytest on Psi4+upstream; Build L/RT-MP. If any trouble, edit code in L/RT and rebuild those package(s). Iterate until builds and passes. This stage is the only full ctest & pytest of Psi4+downstream; Build L/DEV. If any trouble, edit psi4 build system, plugin system, or OpenMP setup. Iterate until builds and passes; Build L/DOCS. If any trouble, edit the docs or the tests. Iterate until builds and passes; Results of last should upload to psicode.org (docs) and codecov.io (coverage); Changes to targets’ “source” and “version” in individual recipes should be edited in psi4 external/*/*/CMakeLists.txt files; Once everything’s working on Linux, repeat on Mac; At this point, ready to fine-tune builds of “Psi4 stack”. Assemble postrelease ch",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:5019,Deployability,continuous,continuous,5019," fine-tune builds of “Psi4 stack”. Assemble postrelease changes¶. Collect PRs with “backport” label, and request other backport suggestions on upcoming RN issue; Cherry-pick backport PRs and commits, apply other changes manually, not forgetting CI files; Do the draft parts of Publish GitHub postrelease; Test thoroughly locally, including psi4-rt (may have to step back for dependency versions or builds); Note that while can’t change maintenance branch’s history, can push to it directly on upstream; If want to do trial conda builds, requires source/git_tag: 1.3.x and fake package/version: v1.3.1rc1. Tweak Conda for postrelease¶. In psi4-* recipes, find the best combination of master meta.yaml/build.sh and the v1N(x-1)-labeled ones. comment out any dependencies in master but not yet in postrelease; add {{ dep_bld }} entries if needed to step back build. make sure normal operation is ''. In cbcy,. create a postrelease new line and record anything not in continuous order with <> or blanking; step back any dependencies versions or build numbers to ones compatible with the postrelease. Do final pass before release tag¶. Check that psi4/external/ repos and commits have been updated to match conda recipes sources. Also check versions with conda_build_config.yaml; Check psi4/doc/sphinxman/source/introduction.rst for any compiler and Python minimum requirements to edit. Tag (pre)release¶. Thorough version bump directions at master http://psicode.org/psi4manual/master/manage_git.html#how-to-bump-a-version; Below is tl;dr; # be on clean master up-to-date with upstream in both commits and tags; # * mind which version strings get ""v"" and which don't; # * if not fork, replace ""upstream"" with ""origin"". >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; ...; -__version__ = '1.3rc1'; -__version_long = '1.3rc1+5a7522a'; -__version_upcoming_annotated_v_tag = '1.3rc2'; +__version__ = '1.3rc2'; +__version_long = '1.3rc2+zzzzzzz'; +__version_upcoming_an",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:5172,Deployability,release,release,5172," other backport suggestions on upcoming RN issue; Cherry-pick backport PRs and commits, apply other changes manually, not forgetting CI files; Do the draft parts of Publish GitHub postrelease; Test thoroughly locally, including psi4-rt (may have to step back for dependency versions or builds); Note that while can’t change maintenance branch’s history, can push to it directly on upstream; If want to do trial conda builds, requires source/git_tag: 1.3.x and fake package/version: v1.3.1rc1. Tweak Conda for postrelease¶. In psi4-* recipes, find the best combination of master meta.yaml/build.sh and the v1N(x-1)-labeled ones. comment out any dependencies in master but not yet in postrelease; add {{ dep_bld }} entries if needed to step back build. make sure normal operation is ''. In cbcy,. create a postrelease new line and record anything not in continuous order with <> or blanking; step back any dependencies versions or build numbers to ones compatible with the postrelease. Do final pass before release tag¶. Check that psi4/external/ repos and commits have been updated to match conda recipes sources. Also check versions with conda_build_config.yaml; Check psi4/doc/sphinxman/source/introduction.rst for any compiler and Python minimum requirements to edit. Tag (pre)release¶. Thorough version bump directions at master http://psicode.org/psi4manual/master/manage_git.html#how-to-bump-a-version; Below is tl;dr; # be on clean master up-to-date with upstream in both commits and tags; # * mind which version strings get ""v"" and which don't; # * if not fork, replace ""upstream"" with ""origin"". >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; ...; -__version__ = '1.3rc1'; -__version_long = '1.3rc1+5a7522a'; -__version_upcoming_annotated_v_tag = '1.3rc2'; +__version__ = '1.3rc2'; +__version_long = '1.3rc2+zzzzzzz'; +__version_upcoming_annotated_v_tag = '1.3rc3'. >>> git add psi4/metadata.py; >>> git commit -m ""v1.3rc2""; [master bc8d7f5] v1.3rc2. >",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:5240,Deployability,update,updated,5240,"kport PRs and commits, apply other changes manually, not forgetting CI files; Do the draft parts of Publish GitHub postrelease; Test thoroughly locally, including psi4-rt (may have to step back for dependency versions or builds); Note that while can’t change maintenance branch’s history, can push to it directly on upstream; If want to do trial conda builds, requires source/git_tag: 1.3.x and fake package/version: v1.3.1rc1. Tweak Conda for postrelease¶. In psi4-* recipes, find the best combination of master meta.yaml/build.sh and the v1N(x-1)-labeled ones. comment out any dependencies in master but not yet in postrelease; add {{ dep_bld }} entries if needed to step back build. make sure normal operation is ''. In cbcy,. create a postrelease new line and record anything not in continuous order with <> or blanking; step back any dependencies versions or build numbers to ones compatible with the postrelease. Do final pass before release tag¶. Check that psi4/external/ repos and commits have been updated to match conda recipes sources. Also check versions with conda_build_config.yaml; Check psi4/doc/sphinxman/source/introduction.rst for any compiler and Python minimum requirements to edit. Tag (pre)release¶. Thorough version bump directions at master http://psicode.org/psi4manual/master/manage_git.html#how-to-bump-a-version; Below is tl;dr; # be on clean master up-to-date with upstream in both commits and tags; # * mind which version strings get ""v"" and which don't; # * if not fork, replace ""upstream"" with ""origin"". >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; ...; -__version__ = '1.3rc1'; -__version_long = '1.3rc1+5a7522a'; -__version_upcoming_annotated_v_tag = '1.3rc2'; +__version__ = '1.3rc2'; +__version_long = '1.3rc2+zzzzzzz'; +__version_upcoming_annotated_v_tag = '1.3rc3'. >>> git add psi4/metadata.py; >>> git commit -m ""v1.3rc2""; [master bc8d7f5] v1.3rc2. >>> git log --oneline | head -1; bc8d7f5 v1.3rc2; >>> git tag -a ",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:5446,Deployability,release,release,5446,"ions or builds); Note that while can’t change maintenance branch’s history, can push to it directly on upstream; If want to do trial conda builds, requires source/git_tag: 1.3.x and fake package/version: v1.3.1rc1. Tweak Conda for postrelease¶. In psi4-* recipes, find the best combination of master meta.yaml/build.sh and the v1N(x-1)-labeled ones. comment out any dependencies in master but not yet in postrelease; add {{ dep_bld }} entries if needed to step back build. make sure normal operation is ''. In cbcy,. create a postrelease new line and record anything not in continuous order with <> or blanking; step back any dependencies versions or build numbers to ones compatible with the postrelease. Do final pass before release tag¶. Check that psi4/external/ repos and commits have been updated to match conda recipes sources. Also check versions with conda_build_config.yaml; Check psi4/doc/sphinxman/source/introduction.rst for any compiler and Python minimum requirements to edit. Tag (pre)release¶. Thorough version bump directions at master http://psicode.org/psi4manual/master/manage_git.html#how-to-bump-a-version; Below is tl;dr; # be on clean master up-to-date with upstream in both commits and tags; # * mind which version strings get ""v"" and which don't; # * if not fork, replace ""upstream"" with ""origin"". >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; ...; -__version__ = '1.3rc1'; -__version_long = '1.3rc1+5a7522a'; -__version_upcoming_annotated_v_tag = '1.3rc2'; +__version__ = '1.3rc2'; +__version_long = '1.3rc2+zzzzzzz'; +__version_upcoming_annotated_v_tag = '1.3rc3'. >>> git add psi4/metadata.py; >>> git commit -m ""v1.3rc2""; [master bc8d7f5] v1.3rc2. >>> git log --oneline | head -1; bc8d7f5 v1.3rc2; >>> git tag -a v1.3rc2 bc8d7f5 -m ""v1.3rc2"". # pause here and push to upstream and let Azure complete if want an; # on-tag Windows conda package, not just tag+1.dev1; # below pushes commit and tag together so only one CI; # > git",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:8249,Deployability,release,release,8249,"nd which don't; # * if not fork, replace ""upstream"" with ""origin"". >>> git checkout 1.3.x; Switched to branch '1.3.x'. >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; ...; -__version__ = '1.3'; -__version_long = '1.3+zzzzzzz'; +__version__ = '1.3.1'; +__version_long = '1.3.1+zzzzzzz'. >>> git add psi4/metadata.py; >>> git commit -m ""v1.3.1""; [1.3.x 2ce1c29] v1.3.1. >>> git log --oneline | head -1; 786fb2b v1.3.1; >>> git tag -a v1.3.1 2ce1c29 -m ""v1.3.1"". # skipping the hash recording and ""upcoming"" step b/c only tags matter on maintenance branch. # free pushing to maintenance branches at present so GitHub interface steps not needed; # goto GH:psi4/psi4 > Settings > Branches > 1.3.x > Edit; # https://github.com/psi4/psi4/settings/branch_protection_rules/4385008 # !Varies!; # uncheck ""Include administrators"" and Save changes. >>> git push upstream 1.3.x; >>> git push upstream v1.3.1. # re-engage ""Include administrators"" protections. Initialize release branch¶. follow tagging procedure; before re-engaing the “include admin” button, push a branch at the tag commit (not the records commit); >>> git log --online | head -2; 45315cb Records tag for v1.3; 20e5c7e v1.3. >>> git checkout 20e5c7e; >>> git checkout -b 1.3.x; Switched to a new branch '1.3.x'; >>> git push upstream 1.3.x. set up new branch as protected branch through GitHub psi4 org Settings. Should be already covered under 1.*.x rule. Build Conda Psi4 stack at specific commit¶; By “Psi4 stack”, mean packages psi4, psi4-rt, psi4-dev.; Package psi4-docs used to be in “Psi4 stack”, but it’s handled by GHA and netlify now, not Conda, so skip directions below.; Other packages, the “ecosystem stack” (e.g., libint, v2rdm_casscf) should be already built. Check poodle for stray channels that may have crept in for dependencies (like c-f for ACS season). Copy over new dependencies if needed to psi4 channel; Particularly before release (not prerelease), consider max pinnings on depen",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:9195,Deployability,release,release,9195,"inistrators"" protections. Initialize release branch¶. follow tagging procedure; before re-engaing the “include admin” button, push a branch at the tag commit (not the records commit); >>> git log --online | head -2; 45315cb Records tag for v1.3; 20e5c7e v1.3. >>> git checkout 20e5c7e; >>> git checkout -b 1.3.x; Switched to a new branch '1.3.x'; >>> git push upstream 1.3.x. set up new branch as protected branch through GitHub psi4 org Settings. Should be already covered under 1.*.x rule. Build Conda Psi4 stack at specific commit¶; By “Psi4 stack”, mean packages psi4, psi4-rt, psi4-dev.; Package psi4-docs used to be in “Psi4 stack”, but it’s handled by GHA and netlify now, not Conda, so skip directions below.; Other packages, the “ecosystem stack” (e.g., libint, v2rdm_casscf) should be already built. Check poodle for stray channels that may have crept in for dependencies (like c-f for ACS season). Copy over new dependencies if needed to psi4 channel; Particularly before release (not prerelease), consider max pinnings on dependencies, particularly any fast-moving dependencies (e.g., qcel) and whether they need version space to grow compatibly and grow incompatibly.; Nightly conda-builds work from master psi4. (Postrelease “practice” works from 1.N.x psi4.). Instead, switch source/git_tag from master to tag (e.g., v1.3rc1) in:. psi4-multiout on Linux & Mac, https://github.com/psi4/psi4meta/blob/master/conda-recipes/psi4-multiout/meta.yaml#L10; psi4-docs on Linux, https://github.com/psi4/psi4meta/blob/master/conda-recipes/psi4-docs/meta.yaml#L10 on L. In cbcy, edit psi4ver to “v”-less tag. For releases and postreleases (not prereleases), in conda_build_config.yaml, edit ltrtver to a new non-dev label (probably a ditto) matching the release (e.g., “1.3”); Set kitandkapoodle.py to the normal *** stack. Should be (psi4, psi4-rt, psi4-dev) * python_versions for Linux & Mac. Also single psi4-docs from Linux; Run kitandkapoodle.py and allow stack to upload to anaconda.org to ps",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:9828,Deployability,release,releases,9828," handled by GHA and netlify now, not Conda, so skip directions below.; Other packages, the “ecosystem stack” (e.g., libint, v2rdm_casscf) should be already built. Check poodle for stray channels that may have crept in for dependencies (like c-f for ACS season). Copy over new dependencies if needed to psi4 channel; Particularly before release (not prerelease), consider max pinnings on dependencies, particularly any fast-moving dependencies (e.g., qcel) and whether they need version space to grow compatibly and grow incompatibly.; Nightly conda-builds work from master psi4. (Postrelease “practice” works from 1.N.x psi4.). Instead, switch source/git_tag from master to tag (e.g., v1.3rc1) in:. psi4-multiout on Linux & Mac, https://github.com/psi4/psi4meta/blob/master/conda-recipes/psi4-multiout/meta.yaml#L10; psi4-docs on Linux, https://github.com/psi4/psi4meta/blob/master/conda-recipes/psi4-docs/meta.yaml#L10 on L. In cbcy, edit psi4ver to “v”-less tag. For releases and postreleases (not prereleases), in conda_build_config.yaml, edit ltrtver to a new non-dev label (probably a ditto) matching the release (e.g., “1.3”); Set kitandkapoodle.py to the normal *** stack. Should be (psi4, psi4-rt, psi4-dev) * python_versions for Linux & Mac. Also single psi4-docs from Linux; Run kitandkapoodle.py and allow stack to upload to anaconda.org to psi4/label/dev. Poodle emits with --label dev so will go to the subchannel. May need to delete packages to clear out space on anaconda.org; Copy meta.yaml and build.sh of at least psi4-multiout and psi4-rt to e.g., v121-build.sh files for easy reference or rebuilding as dependencies in master change. Publish to main conda label¶. Go through each active conda package off https://anaconda.org/psi4/repo. Find the most recent build set (Linux/Mac, active py versions) that psi4/psi4-rt/psi4-dev is using; _add_ (not replace) the main label. This makes a conda install psi4 -c psi4 get everything psi4 needs. For the moment conda install psi4 -c psi",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:9969,Deployability,release,release,9969,"ackages, the “ecosystem stack” (e.g., libint, v2rdm_casscf) should be already built. Check poodle for stray channels that may have crept in for dependencies (like c-f for ACS season). Copy over new dependencies if needed to psi4 channel; Particularly before release (not prerelease), consider max pinnings on dependencies, particularly any fast-moving dependencies (e.g., qcel) and whether they need version space to grow compatibly and grow incompatibly.; Nightly conda-builds work from master psi4. (Postrelease “practice” works from 1.N.x psi4.). Instead, switch source/git_tag from master to tag (e.g., v1.3rc1) in:. psi4-multiout on Linux & Mac, https://github.com/psi4/psi4meta/blob/master/conda-recipes/psi4-multiout/meta.yaml#L10; psi4-docs on Linux, https://github.com/psi4/psi4meta/blob/master/conda-recipes/psi4-docs/meta.yaml#L10 on L. In cbcy, edit psi4ver to “v”-less tag. For releases and postreleases (not prereleases), in conda_build_config.yaml, edit ltrtver to a new non-dev label (probably a ditto) matching the release (e.g., “1.3”); Set kitandkapoodle.py to the normal *** stack. Should be (psi4, psi4-rt, psi4-dev) * python_versions for Linux & Mac. Also single psi4-docs from Linux; Run kitandkapoodle.py and allow stack to upload to anaconda.org to psi4/label/dev. Poodle emits with --label dev so will go to the subchannel. May need to delete packages to clear out space on anaconda.org; Copy meta.yaml and build.sh of at least psi4-multiout and psi4-rt to e.g., v121-build.sh files for easy reference or rebuilding as dependencies in master change. Publish to main conda label¶. Go through each active conda package off https://anaconda.org/psi4/repo. Find the most recent build set (Linux/Mac, active py versions) that psi4/psi4-rt/psi4-dev is using; _add_ (not replace) the main label. This makes a conda install psi4 -c psi4 get everything psi4 needs. For the moment conda install psi4 -c psi4/label/dev will get the same set, until package psi4-1.4a1.dev1 gets uploaded.",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:10771,Deployability,install,install,10771," In cbcy, edit psi4ver to “v”-less tag. For releases and postreleases (not prereleases), in conda_build_config.yaml, edit ltrtver to a new non-dev label (probably a ditto) matching the release (e.g., “1.3”); Set kitandkapoodle.py to the normal *** stack. Should be (psi4, psi4-rt, psi4-dev) * python_versions for Linux & Mac. Also single psi4-docs from Linux; Run kitandkapoodle.py and allow stack to upload to anaconda.org to psi4/label/dev. Poodle emits with --label dev so will go to the subchannel. May need to delete packages to clear out space on anaconda.org; Copy meta.yaml and build.sh of at least psi4-multiout and psi4-rt to e.g., v121-build.sh files for easy reference or rebuilding as dependencies in master change. Publish to main conda label¶. Go through each active conda package off https://anaconda.org/psi4/repo. Find the most recent build set (Linux/Mac, active py versions) that psi4/psi4-rt/psi4-dev is using; _add_ (not replace) the main label. This makes a conda install psi4 -c psi4 get everything psi4 needs. For the moment conda install psi4 -c psi4/label/dev will get the same set, until package psi4-1.4a1.dev1 gets uploaded. May help to check versions and build versions against ltrtver in conda_build_config.yaml.; This step is manual, so takes a while. (It gets checked when Psi4conda installers are built b/c that pulls from “main”, not “dev”). Build Psi4conda set (pre-Spring 2021)¶; Installers are build using the project constructor and build binary bash scripts, one per OS per Python version. In analogy to Miniconda, they’re called Psi4Conda. They can be built anywhere (Mac can be built on Linux) and get served from vergil (cdsgroup webserver). Need a conda env with constructor and cookiecutter. This env presently accessed through conda activate cookie.; Enter “constructor-cutter-unified” in the psi4meta repo. There’s a good README there, https://github.com/psi4/psi4meta/blob/master/conda-recipes/constructor-cutter-unified/README.md; Edit cookiecutter/co",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:10840,Deployability,install,install,10840,"ases), in conda_build_config.yaml, edit ltrtver to a new non-dev label (probably a ditto) matching the release (e.g., “1.3”); Set kitandkapoodle.py to the normal *** stack. Should be (psi4, psi4-rt, psi4-dev) * python_versions for Linux & Mac. Also single psi4-docs from Linux; Run kitandkapoodle.py and allow stack to upload to anaconda.org to psi4/label/dev. Poodle emits with --label dev so will go to the subchannel. May need to delete packages to clear out space on anaconda.org; Copy meta.yaml and build.sh of at least psi4-multiout and psi4-rt to e.g., v121-build.sh files for easy reference or rebuilding as dependencies in master change. Publish to main conda label¶. Go through each active conda package off https://anaconda.org/psi4/repo. Find the most recent build set (Linux/Mac, active py versions) that psi4/psi4-rt/psi4-dev is using; _add_ (not replace) the main label. This makes a conda install psi4 -c psi4 get everything psi4 needs. For the moment conda install psi4 -c psi4/label/dev will get the same set, until package psi4-1.4a1.dev1 gets uploaded. May help to check versions and build versions against ltrtver in conda_build_config.yaml.; This step is manual, so takes a while. (It gets checked when Psi4conda installers are built b/c that pulls from “main”, not “dev”). Build Psi4conda set (pre-Spring 2021)¶; Installers are build using the project constructor and build binary bash scripts, one per OS per Python version. In analogy to Miniconda, they’re called Psi4Conda. They can be built anywhere (Mac can be built on Linux) and get served from vergil (cdsgroup webserver). Need a conda env with constructor and cookiecutter. This env presently accessed through conda activate cookie.; Enter “constructor-cutter-unified” in the psi4meta repo. There’s a good README there, https://github.com/psi4/psi4meta/blob/master/conda-recipes/constructor-cutter-unified/README.md; Edit cookiecutter/cookiecutter.json for control. Edit which python versions, if necessary; Edit releas",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:11101,Deployability,install,installers,11101," single psi4-docs from Linux; Run kitandkapoodle.py and allow stack to upload to anaconda.org to psi4/label/dev. Poodle emits with --label dev so will go to the subchannel. May need to delete packages to clear out space on anaconda.org; Copy meta.yaml and build.sh of at least psi4-multiout and psi4-rt to e.g., v121-build.sh files for easy reference or rebuilding as dependencies in master change. Publish to main conda label¶. Go through each active conda package off https://anaconda.org/psi4/repo. Find the most recent build set (Linux/Mac, active py versions) that psi4/psi4-rt/psi4-dev is using; _add_ (not replace) the main label. This makes a conda install psi4 -c psi4 get everything psi4 needs. For the moment conda install psi4 -c psi4/label/dev will get the same set, until package psi4-1.4a1.dev1 gets uploaded. May help to check versions and build versions against ltrtver in conda_build_config.yaml.; This step is manual, so takes a while. (It gets checked when Psi4conda installers are built b/c that pulls from “main”, not “dev”). Build Psi4conda set (pre-Spring 2021)¶; Installers are build using the project constructor and build binary bash scripts, one per OS per Python version. In analogy to Miniconda, they’re called Psi4Conda. They can be built anywhere (Mac can be built on Linux) and get served from vergil (cdsgroup webserver). Need a conda env with constructor and cookiecutter. This env presently accessed through conda activate cookie.; Enter “constructor-cutter-unified” in the psi4meta repo. There’s a good README there, https://github.com/psi4/psi4meta/blob/master/conda-recipes/constructor-cutter-unified/README.md; Edit cookiecutter/cookiecutter.json for control. Edit which python versions, if necessary; Edit release field; Edit hash field. This is the 7-char hash that’s on every psi4 conda pkg as part of version; Edit ltrtver field. This matches the current setting in conda_build_config.yaml; For prereleases, ""channel_tag"": ""/label/dev"", while for (post)rele",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:11861,Deployability,release,release,11861," -c psi4/label/dev will get the same set, until package psi4-1.4a1.dev1 gets uploaded. May help to check versions and build versions against ltrtver in conda_build_config.yaml.; This step is manual, so takes a while. (It gets checked when Psi4conda installers are built b/c that pulls from “main”, not “dev”). Build Psi4conda set (pre-Spring 2021)¶; Installers are build using the project constructor and build binary bash scripts, one per OS per Python version. In analogy to Miniconda, they’re called Psi4Conda. They can be built anywhere (Mac can be built on Linux) and get served from vergil (cdsgroup webserver). Need a conda env with constructor and cookiecutter. This env presently accessed through conda activate cookie.; Enter “constructor-cutter-unified” in the psi4meta repo. There’s a good README there, https://github.com/psi4/psi4meta/blob/master/conda-recipes/constructor-cutter-unified/README.md; Edit cookiecutter/cookiecutter.json for control. Edit which python versions, if necessary; Edit release field; Edit hash field. This is the 7-char hash that’s on every psi4 conda pkg as part of version; Edit ltrtver field. This matches the current setting in conda_build_config.yaml; For prereleases, ""channel_tag"": ""/label/dev"", while for (post)releases, it should be the empty string; Leave this file set to a “rc” with Git, as that has more details. For (post)releases (not prereleases), copy cookiecutter.json to cookiecutter.json-vXXX; Edit cookiecutter/{{.../construct.yaml for templating. This is rarely needed; If it’s been a while or you need the space, clear out ~/.conda/constructor, where the downloaded packages are cached; Note that installers get written to build/ and this gets regenerated each time. Clear out between runs.; python run.py; [Outdated] Watch out for py_ in buildstring as this means a noarch package has been pulled. It must be eliminated. Constructors can’t handle “noarch” packages and will fail at runtime. If see a “noarch” package, must find the recip",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:12111,Deployability,release,releases,12111," pulls from “main”, not “dev”). Build Psi4conda set (pre-Spring 2021)¶; Installers are build using the project constructor and build binary bash scripts, one per OS per Python version. In analogy to Miniconda, they’re called Psi4Conda. They can be built anywhere (Mac can be built on Linux) and get served from vergil (cdsgroup webserver). Need a conda env with constructor and cookiecutter. This env presently accessed through conda activate cookie.; Enter “constructor-cutter-unified” in the psi4meta repo. There’s a good README there, https://github.com/psi4/psi4meta/blob/master/conda-recipes/constructor-cutter-unified/README.md; Edit cookiecutter/cookiecutter.json for control. Edit which python versions, if necessary; Edit release field; Edit hash field. This is the 7-char hash that’s on every psi4 conda pkg as part of version; Edit ltrtver field. This matches the current setting in conda_build_config.yaml; For prereleases, ""channel_tag"": ""/label/dev"", while for (post)releases, it should be the empty string; Leave this file set to a “rc” with Git, as that has more details. For (post)releases (not prereleases), copy cookiecutter.json to cookiecutter.json-vXXX; Edit cookiecutter/{{.../construct.yaml for templating. This is rarely needed; If it’s been a while or you need the space, clear out ~/.conda/constructor, where the downloaded packages are cached; Note that installers get written to build/ and this gets regenerated each time. Clear out between runs.; python run.py; [Outdated] Watch out for py_ in buildstring as this means a noarch package has been pulled. It must be eliminated. Constructors can’t handle “noarch” packages and will fail at runtime. If see a “noarch” package, must find the recipe and rebuild for all OS & Python combinations. Then run constructor again.; [Replacement] After adding a post_install to reposition the noarch packages, they are safe to include.; If fetching times out, may have to run run.py several times. Clear out build/ in between. It’s t",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:12228,Deployability,release,releases,12228,"tructor and build binary bash scripts, one per OS per Python version. In analogy to Miniconda, they’re called Psi4Conda. They can be built anywhere (Mac can be built on Linux) and get served from vergil (cdsgroup webserver). Need a conda env with constructor and cookiecutter. This env presently accessed through conda activate cookie.; Enter “constructor-cutter-unified” in the psi4meta repo. There’s a good README there, https://github.com/psi4/psi4meta/blob/master/conda-recipes/constructor-cutter-unified/README.md; Edit cookiecutter/cookiecutter.json for control. Edit which python versions, if necessary; Edit release field; Edit hash field. This is the 7-char hash that’s on every psi4 conda pkg as part of version; Edit ltrtver field. This matches the current setting in conda_build_config.yaml; For prereleases, ""channel_tag"": ""/label/dev"", while for (post)releases, it should be the empty string; Leave this file set to a “rc” with Git, as that has more details. For (post)releases (not prereleases), copy cookiecutter.json to cookiecutter.json-vXXX; Edit cookiecutter/{{.../construct.yaml for templating. This is rarely needed; If it’s been a while or you need the space, clear out ~/.conda/constructor, where the downloaded packages are cached; Note that installers get written to build/ and this gets regenerated each time. Clear out between runs.; python run.py; [Outdated] Watch out for py_ in buildstring as this means a noarch package has been pulled. It must be eliminated. Constructors can’t handle “noarch” packages and will fail at runtime. If see a “noarch” package, must find the recipe and rebuild for all OS & Python combinations. Then run constructor again.; [Replacement] After adding a post_install to reposition the noarch packages, they are safe to include.; If fetching times out, may have to run run.py several times. Clear out build/ in between. It’s the fetching that takes a long time, not constucting; In the end, should have several installers; >>> ls -l build/psi",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:12512,Deployability,install,installers,12512,"kiecutter. This env presently accessed through conda activate cookie.; Enter “constructor-cutter-unified” in the psi4meta repo. There’s a good README there, https://github.com/psi4/psi4meta/blob/master/conda-recipes/constructor-cutter-unified/README.md; Edit cookiecutter/cookiecutter.json for control. Edit which python versions, if necessary; Edit release field; Edit hash field. This is the 7-char hash that’s on every psi4 conda pkg as part of version; Edit ltrtver field. This matches the current setting in conda_build_config.yaml; For prereleases, ""channel_tag"": ""/label/dev"", while for (post)releases, it should be the empty string; Leave this file set to a “rc” with Git, as that has more details. For (post)releases (not prereleases), copy cookiecutter.json to cookiecutter.json-vXXX; Edit cookiecutter/{{.../construct.yaml for templating. This is rarely needed; If it’s been a while or you need the space, clear out ~/.conda/constructor, where the downloaded packages are cached; Note that installers get written to build/ and this gets regenerated each time. Clear out between runs.; python run.py; [Outdated] Watch out for py_ in buildstring as this means a noarch package has been pulled. It must be eliminated. Constructors can’t handle “noarch” packages and will fail at runtime. If see a “noarch” package, must find the recipe and rebuild for all OS & Python combinations. Then run constructor again.; [Replacement] After adding a post_install to reposition the noarch packages, they are safe to include.; If fetching times out, may have to run run.py several times. Clear out build/ in between. It’s the fetching that takes a long time, not constucting; In the end, should have several installers; >>> ls -l build/psi4conda-1.3-py3.*/*64.sh; -rwxr-xr-x. 516M Feb 28 20:30 build/psi4conda-1.3-py3.6-linux-64/psi4conda-1.3-py36-Linux-x86_64.sh; -rwxr-xr-x. 299M Feb 28 20:31 build/psi4conda-1.3-py3.6-osx-64/psi4conda-1.3-py36-MacOSX-x86_64.sh; -rwxr-xr-x. 518M Feb 28 20:30 build/psi",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:13215,Deployability,install,installers,13215,"t, as that has more details. For (post)releases (not prereleases), copy cookiecutter.json to cookiecutter.json-vXXX; Edit cookiecutter/{{.../construct.yaml for templating. This is rarely needed; If it’s been a while or you need the space, clear out ~/.conda/constructor, where the downloaded packages are cached; Note that installers get written to build/ and this gets regenerated each time. Clear out between runs.; python run.py; [Outdated] Watch out for py_ in buildstring as this means a noarch package has been pulled. It must be eliminated. Constructors can’t handle “noarch” packages and will fail at runtime. If see a “noarch” package, must find the recipe and rebuild for all OS & Python combinations. Then run constructor again.; [Replacement] After adding a post_install to reposition the noarch packages, they are safe to include.; If fetching times out, may have to run run.py several times. Clear out build/ in between. It’s the fetching that takes a long time, not constucting; In the end, should have several installers; >>> ls -l build/psi4conda-1.3-py3.*/*64.sh; -rwxr-xr-x. 516M Feb 28 20:30 build/psi4conda-1.3-py3.6-linux-64/psi4conda-1.3-py36-Linux-x86_64.sh; -rwxr-xr-x. 299M Feb 28 20:31 build/psi4conda-1.3-py3.6-osx-64/psi4conda-1.3-py36-MacOSX-x86_64.sh; -rwxr-xr-x. 518M Feb 28 20:30 build/psi4conda-1.3-py3.7-linux-64/psi4conda-1.3-py37-Linux-x86_64.sh; -rwxr-xr-x. 299M Feb 28 20:31 build/psi4conda-1.3-py3.7-osx-64/psi4conda-1.3-py37-MacOSX-x86_64.sh. Upload installer files to vergil, scp -r build/Psi4*/Psi4*sh root@vergil.chemistry.gatech.edu:/var/www/html/psicode-download/; Log in to vergil root and make WindowsWSL symlinks. Build Psi4conda set¶; Installers are build using the project constructor and build binary bash or exe scripts, one per OS per Python version. In analogy to Miniconda, they’re called Psi4Conda. They are built through GHA on the psi4meta repo and get served from vergil (cdsgroup webserver). Edit recipe https://github.com/psi4/psi4meta/bl",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:13680,Deployability,install,installer,13680,"led. It must be eliminated. Constructors can’t handle “noarch” packages and will fail at runtime. If see a “noarch” package, must find the recipe and rebuild for all OS & Python combinations. Then run constructor again.; [Replacement] After adding a post_install to reposition the noarch packages, they are safe to include.; If fetching times out, may have to run run.py several times. Clear out build/ in between. It’s the fetching that takes a long time, not constucting; In the end, should have several installers; >>> ls -l build/psi4conda-1.3-py3.*/*64.sh; -rwxr-xr-x. 516M Feb 28 20:30 build/psi4conda-1.3-py3.6-linux-64/psi4conda-1.3-py36-Linux-x86_64.sh; -rwxr-xr-x. 299M Feb 28 20:31 build/psi4conda-1.3-py3.6-osx-64/psi4conda-1.3-py36-MacOSX-x86_64.sh; -rwxr-xr-x. 518M Feb 28 20:30 build/psi4conda-1.3-py3.7-linux-64/psi4conda-1.3-py37-Linux-x86_64.sh; -rwxr-xr-x. 299M Feb 28 20:31 build/psi4conda-1.3-py3.7-osx-64/psi4conda-1.3-py37-MacOSX-x86_64.sh. Upload installer files to vergil, scp -r build/Psi4*/Psi4*sh root@vergil.chemistry.gatech.edu:/var/www/html/psicode-download/; Log in to vergil root and make WindowsWSL symlinks. Build Psi4conda set¶; Installers are build using the project constructor and build binary bash or exe scripts, one per OS per Python version. In analogy to Miniconda, they’re called Psi4Conda. They are built through GHA on the psi4meta repo and get served from vergil (cdsgroup webserver). Edit recipe https://github.com/psi4/psi4meta/blob/master/installers/construct.yaml. Edit the top matter for Configuration. See snapshots in directory for examples. Edit release fields. (Windows is often dev1 unless separate steps.); Edit ltrtver field. This matches the current setting in conda_build_config.yaml; For prereleases, ""channel_tag"": ""/label/dev"", while for (post)releases, it should be the empty string. Edit the packages and channels info if necessary. Probably long-term stable. Edit the GHA control file https://github.com/psi4/psi4meta/blob/master/.g",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:14199,Deployability,install,installers,14199," should have several installers; >>> ls -l build/psi4conda-1.3-py3.*/*64.sh; -rwxr-xr-x. 516M Feb 28 20:30 build/psi4conda-1.3-py3.6-linux-64/psi4conda-1.3-py36-Linux-x86_64.sh; -rwxr-xr-x. 299M Feb 28 20:31 build/psi4conda-1.3-py3.6-osx-64/psi4conda-1.3-py36-MacOSX-x86_64.sh; -rwxr-xr-x. 518M Feb 28 20:30 build/psi4conda-1.3-py3.7-linux-64/psi4conda-1.3-py37-Linux-x86_64.sh; -rwxr-xr-x. 299M Feb 28 20:31 build/psi4conda-1.3-py3.7-osx-64/psi4conda-1.3-py37-MacOSX-x86_64.sh. Upload installer files to vergil, scp -r build/Psi4*/Psi4*sh root@vergil.chemistry.gatech.edu:/var/www/html/psicode-download/; Log in to vergil root and make WindowsWSL symlinks. Build Psi4conda set¶; Installers are build using the project constructor and build binary bash or exe scripts, one per OS per Python version. In analogy to Miniconda, they’re called Psi4Conda. They are built through GHA on the psi4meta repo and get served from vergil (cdsgroup webserver). Edit recipe https://github.com/psi4/psi4meta/blob/master/installers/construct.yaml. Edit the top matter for Configuration. See snapshots in directory for examples. Edit release fields. (Windows is often dev1 unless separate steps.); Edit ltrtver field. This matches the current setting in conda_build_config.yaml; For prereleases, ""channel_tag"": ""/label/dev"", while for (post)releases, it should be the empty string. Edit the packages and channels info if necessary. Probably long-term stable. Edit the GHA control file https://github.com/psi4/psi4meta/blob/master/.github/workflows/Installers.yml matrix.cfg; All conda packages must already have been built and in the right channel_tag channel.; Commit construct.yaml to trigger installer builds.; When all build successfully, hover over the artifacts, and note the consecutive numbers GH has assigned them. These artifacts only linger for a day.; Log in to vergil root and move to /var/www/html/psicode-download.; Use the pull_gha_installers script to download the installers from GH to vergil. First ",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:14311,Deployability,release,release,14311,"a-1.3-py3.6-linux-64/psi4conda-1.3-py36-Linux-x86_64.sh; -rwxr-xr-x. 299M Feb 28 20:31 build/psi4conda-1.3-py3.6-osx-64/psi4conda-1.3-py36-MacOSX-x86_64.sh; -rwxr-xr-x. 518M Feb 28 20:30 build/psi4conda-1.3-py3.7-linux-64/psi4conda-1.3-py37-Linux-x86_64.sh; -rwxr-xr-x. 299M Feb 28 20:31 build/psi4conda-1.3-py3.7-osx-64/psi4conda-1.3-py37-MacOSX-x86_64.sh. Upload installer files to vergil, scp -r build/Psi4*/Psi4*sh root@vergil.chemistry.gatech.edu:/var/www/html/psicode-download/; Log in to vergil root and make WindowsWSL symlinks. Build Psi4conda set¶; Installers are build using the project constructor and build binary bash or exe scripts, one per OS per Python version. In analogy to Miniconda, they’re called Psi4Conda. They are built through GHA on the psi4meta repo and get served from vergil (cdsgroup webserver). Edit recipe https://github.com/psi4/psi4meta/blob/master/installers/construct.yaml. Edit the top matter for Configuration. See snapshots in directory for examples. Edit release fields. (Windows is often dev1 unless separate steps.); Edit ltrtver field. This matches the current setting in conda_build_config.yaml; For prereleases, ""channel_tag"": ""/label/dev"", while for (post)releases, it should be the empty string. Edit the packages and channels info if necessary. Probably long-term stable. Edit the GHA control file https://github.com/psi4/psi4meta/blob/master/.github/workflows/Installers.yml matrix.cfg; All conda packages must already have been built and in the right channel_tag channel.; Commit construct.yaml to trigger installer builds.; When all build successfully, hover over the artifacts, and note the consecutive numbers GH has assigned them. These artifacts only linger for a day.; Log in to vergil root and move to /var/www/html/psicode-download.; Use the pull_gha_installers script to download the installers from GH to vergil. First two arguments are first and last of the artifact numbers, and third argument is an auth token. bash pull_gha_installers.s",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:14518,Deployability,release,releases,14518,"ild/psi4conda-1.3-py3.7-linux-64/psi4conda-1.3-py37-Linux-x86_64.sh; -rwxr-xr-x. 299M Feb 28 20:31 build/psi4conda-1.3-py3.7-osx-64/psi4conda-1.3-py37-MacOSX-x86_64.sh. Upload installer files to vergil, scp -r build/Psi4*/Psi4*sh root@vergil.chemistry.gatech.edu:/var/www/html/psicode-download/; Log in to vergil root and make WindowsWSL symlinks. Build Psi4conda set¶; Installers are build using the project constructor and build binary bash or exe scripts, one per OS per Python version. In analogy to Miniconda, they’re called Psi4Conda. They are built through GHA on the psi4meta repo and get served from vergil (cdsgroup webserver). Edit recipe https://github.com/psi4/psi4meta/blob/master/installers/construct.yaml. Edit the top matter for Configuration. See snapshots in directory for examples. Edit release fields. (Windows is often dev1 unless separate steps.); Edit ltrtver field. This matches the current setting in conda_build_config.yaml; For prereleases, ""channel_tag"": ""/label/dev"", while for (post)releases, it should be the empty string. Edit the packages and channels info if necessary. Probably long-term stable. Edit the GHA control file https://github.com/psi4/psi4meta/blob/master/.github/workflows/Installers.yml matrix.cfg; All conda packages must already have been built and in the right channel_tag channel.; Commit construct.yaml to trigger installer builds.; When all build successfully, hover over the artifacts, and note the consecutive numbers GH has assigned them. These artifacts only linger for a day.; Log in to vergil root and move to /var/www/html/psicode-download.; Use the pull_gha_installers script to download the installers from GH to vergil. First two arguments are first and last of the artifact numbers, and third argument is an auth token. bash pull_gha_installers.sh 47226565 47226573 715...4f3.; Make WindowsWSL and any other symlinks the script head matter advises. Generate download page for psicode.org¶. Be in repo psicode-hugo-website; Copy and ed",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:14872,Deployability,install,installer,14872,"; Installers are build using the project constructor and build binary bash or exe scripts, one per OS per Python version. In analogy to Miniconda, they’re called Psi4Conda. They are built through GHA on the psi4meta repo and get served from vergil (cdsgroup webserver). Edit recipe https://github.com/psi4/psi4meta/blob/master/installers/construct.yaml. Edit the top matter for Configuration. See snapshots in directory for examples. Edit release fields. (Windows is often dev1 unless separate steps.); Edit ltrtver field. This matches the current setting in conda_build_config.yaml; For prereleases, ""channel_tag"": ""/label/dev"", while for (post)releases, it should be the empty string. Edit the packages and channels info if necessary. Probably long-term stable. Edit the GHA control file https://github.com/psi4/psi4meta/blob/master/.github/workflows/Installers.yml matrix.cfg; All conda packages must already have been built and in the right channel_tag channel.; Commit construct.yaml to trigger installer builds.; When all build successfully, hover over the artifacts, and note the consecutive numbers GH has assigned them. These artifacts only linger for a day.; Log in to vergil root and move to /var/www/html/psicode-download.; Use the pull_gha_installers script to download the installers from GH to vergil. First two arguments are first and last of the artifact numbers, and third argument is an auth token. bash pull_gha_installers.sh 47226565 47226573 715...4f3.; Make WindowsWSL and any other symlinks the script head matter advises. Generate download page for psicode.org¶. Be in repo psicode-hugo-website; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/content/installs/v13rc2.md. Note the edition string v13rc2 in frontmatter for this and future filenames; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/data/installs/v13rc2.yaml for menu and notes content; Enter scripts/ dir and edit primarily https:/",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:15159,Deployability,install,installers,15159,"recipe https://github.com/psi4/psi4meta/blob/master/installers/construct.yaml. Edit the top matter for Configuration. See snapshots in directory for examples. Edit release fields. (Windows is often dev1 unless separate steps.); Edit ltrtver field. This matches the current setting in conda_build_config.yaml; For prereleases, ""channel_tag"": ""/label/dev"", while for (post)releases, it should be the empty string. Edit the packages and channels info if necessary. Probably long-term stable. Edit the GHA control file https://github.com/psi4/psi4meta/blob/master/.github/workflows/Installers.yml matrix.cfg; All conda packages must already have been built and in the right channel_tag channel.; Commit construct.yaml to trigger installer builds.; When all build successfully, hover over the artifacts, and note the consecutive numbers GH has assigned them. These artifacts only linger for a day.; Log in to vergil root and move to /var/www/html/psicode-download.; Use the pull_gha_installers script to download the installers from GH to vergil. First two arguments are first and last of the artifact numbers, and third argument is an auth token. bash pull_gha_installers.sh 47226565 47226573 715...4f3.; Make WindowsWSL and any other symlinks the script head matter advises. Generate download page for psicode.org¶. Be in repo psicode-hugo-website; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/content/installs/v13rc2.md. Note the edition string v13rc2 in frontmatter for this and future filenames; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/data/installs/v13rc2.yaml for menu and notes content; Enter scripts/ dir and edit primarily https://github.com/psi4/psicode-hugo-website/blob/master/scripts/install-generator.py#L9 but also any other arrays or messages that should change.; Run the install-generator.py in place. It will dump new files into data/installs/ _subdirs_. Be sure to git add them.; Installer page",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:15589,Deployability,install,installs,15589,"ages and channels info if necessary. Probably long-term stable. Edit the GHA control file https://github.com/psi4/psi4meta/blob/master/.github/workflows/Installers.yml matrix.cfg; All conda packages must already have been built and in the right channel_tag channel.; Commit construct.yaml to trigger installer builds.; When all build successfully, hover over the artifacts, and note the consecutive numbers GH has assigned them. These artifacts only linger for a day.; Log in to vergil root and move to /var/www/html/psicode-download.; Use the pull_gha_installers script to download the installers from GH to vergil. First two arguments are first and last of the artifact numbers, and third argument is an auth token. bash pull_gha_installers.sh 47226565 47226573 715...4f3.; Make WindowsWSL and any other symlinks the script head matter advises. Generate download page for psicode.org¶. Be in repo psicode-hugo-website; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/content/installs/v13rc2.md. Note the edition string v13rc2 in frontmatter for this and future filenames; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/data/installs/v13rc2.yaml for menu and notes content; Enter scripts/ dir and edit primarily https://github.com/psi4/psicode-hugo-website/blob/master/scripts/install-generator.py#L9 but also any other arrays or messages that should change.; Run the install-generator.py in place. It will dump new files into data/installs/ _subdirs_. Be sure to git add them.; Installer page is now ready.; Shift “latest” alias in frontmatter from whichever page is currently active to the new page. This makes sure “Downloads” on the navigation bar points to new page.; Conscientiously, one should test. installer downloads in Mac and Linux. And actually installing them and psi4 --test them.; that download button and curl downloading register on the download counters on vergil. Commit the new files, PR, and depl",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:15779,Deployability,install,installs,15779,"ackages must already have been built and in the right channel_tag channel.; Commit construct.yaml to trigger installer builds.; When all build successfully, hover over the artifacts, and note the consecutive numbers GH has assigned them. These artifacts only linger for a day.; Log in to vergil root and move to /var/www/html/psicode-download.; Use the pull_gha_installers script to download the installers from GH to vergil. First two arguments are first and last of the artifact numbers, and third argument is an auth token. bash pull_gha_installers.sh 47226565 47226573 715...4f3.; Make WindowsWSL and any other symlinks the script head matter advises. Generate download page for psicode.org¶. Be in repo psicode-hugo-website; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/content/installs/v13rc2.md. Note the edition string v13rc2 in frontmatter for this and future filenames; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/data/installs/v13rc2.yaml for menu and notes content; Enter scripts/ dir and edit primarily https://github.com/psi4/psicode-hugo-website/blob/master/scripts/install-generator.py#L9 but also any other arrays or messages that should change.; Run the install-generator.py in place. It will dump new files into data/installs/ _subdirs_. Be sure to git add them.; Installer page is now ready.; Shift “latest” alias in frontmatter from whichever page is currently active to the new page. This makes sure “Downloads” on the navigation bar points to new page.; Conscientiously, one should test. installer downloads in Mac and Linux. And actually installing them and psi4 --test them.; that download button and curl downloading register on the download counters on vergil. Commit the new files, PR, and deploy psicode site; Petition on Slack for testers. Collect documentation snapshot¶. Documentation is built automatically by GHA from the latest psi4 master commit. It gets pushed to the psi4/psi4",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:15931,Deployability,install,install-generator,15931,"lly, hover over the artifacts, and note the consecutive numbers GH has assigned them. These artifacts only linger for a day.; Log in to vergil root and move to /var/www/html/psicode-download.; Use the pull_gha_installers script to download the installers from GH to vergil. First two arguments are first and last of the artifact numbers, and third argument is an auth token. bash pull_gha_installers.sh 47226565 47226573 715...4f3.; Make WindowsWSL and any other symlinks the script head matter advises. Generate download page for psicode.org¶. Be in repo psicode-hugo-website; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/content/installs/v13rc2.md. Note the edition string v13rc2 in frontmatter for this and future filenames; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/data/installs/v13rc2.yaml for menu and notes content; Enter scripts/ dir and edit primarily https://github.com/psi4/psicode-hugo-website/blob/master/scripts/install-generator.py#L9 but also any other arrays or messages that should change.; Run the install-generator.py in place. It will dump new files into data/installs/ _subdirs_. Be sure to git add them.; Installer page is now ready.; Shift “latest” alias in frontmatter from whichever page is currently active to the new page. This makes sure “Downloads” on the navigation bar points to new page.; Conscientiously, one should test. installer downloads in Mac and Linux. And actually installing them and psi4 --test them.; that download button and curl downloading register on the download counters on vergil. Commit the new files, PR, and deploy psicode site; Petition on Slack for testers. Collect documentation snapshot¶. Documentation is built automatically by GHA from the latest psi4 master commit. It gets pushed to the psi4/psi4docs repository and thence served by netlify to a site independent of psicode.org. The netlify psicode.org site has a redirect so that psicode.org/psi4",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:16022,Deployability,install,install-generator,16022,"er for a day.; Log in to vergil root and move to /var/www/html/psicode-download.; Use the pull_gha_installers script to download the installers from GH to vergil. First two arguments are first and last of the artifact numbers, and third argument is an auth token. bash pull_gha_installers.sh 47226565 47226573 715...4f3.; Make WindowsWSL and any other symlinks the script head matter advises. Generate download page for psicode.org¶. Be in repo psicode-hugo-website; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/content/installs/v13rc2.md. Note the edition string v13rc2 in frontmatter for this and future filenames; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/data/installs/v13rc2.yaml for menu and notes content; Enter scripts/ dir and edit primarily https://github.com/psi4/psicode-hugo-website/blob/master/scripts/install-generator.py#L9 but also any other arrays or messages that should change.; Run the install-generator.py in place. It will dump new files into data/installs/ _subdirs_. Be sure to git add them.; Installer page is now ready.; Shift “latest” alias in frontmatter from whichever page is currently active to the new page. This makes sure “Downloads” on the navigation bar points to new page.; Conscientiously, one should test. installer downloads in Mac and Linux. And actually installing them and psi4 --test them.; that download button and curl downloading register on the download counters on vergil. Commit the new files, PR, and deploy psicode site; Petition on Slack for testers. Collect documentation snapshot¶. Documentation is built automatically by GHA from the latest psi4 master commit. It gets pushed to the psi4/psi4docs repository and thence served by netlify to a site independent of psicode.org. The netlify psicode.org site has a redirect so that psicode.org/psi4manual/master presents the psi4docs netlify content.; GHA controller is psi4/.github/workflows/docs.yml; This s",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:16086,Deployability,install,installs,16086,"/www/html/psicode-download.; Use the pull_gha_installers script to download the installers from GH to vergil. First two arguments are first and last of the artifact numbers, and third argument is an auth token. bash pull_gha_installers.sh 47226565 47226573 715...4f3.; Make WindowsWSL and any other symlinks the script head matter advises. Generate download page for psicode.org¶. Be in repo psicode-hugo-website; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/content/installs/v13rc2.md. Note the edition string v13rc2 in frontmatter for this and future filenames; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/data/installs/v13rc2.yaml for menu and notes content; Enter scripts/ dir and edit primarily https://github.com/psi4/psicode-hugo-website/blob/master/scripts/install-generator.py#L9 but also any other arrays or messages that should change.; Run the install-generator.py in place. It will dump new files into data/installs/ _subdirs_. Be sure to git add them.; Installer page is now ready.; Shift “latest” alias in frontmatter from whichever page is currently active to the new page. This makes sure “Downloads” on the navigation bar points to new page.; Conscientiously, one should test. installer downloads in Mac and Linux. And actually installing them and psi4 --test them.; that download button and curl downloading register on the download counters on vergil. Commit the new files, PR, and deploy psicode site; Petition on Slack for testers. Collect documentation snapshot¶. Documentation is built automatically by GHA from the latest psi4 master commit. It gets pushed to the psi4/psi4docs repository and thence served by netlify to a site independent of psicode.org. The netlify psicode.org site has a redirect so that psicode.org/psi4manual/master presents the psi4docs netlify content.; GHA controller is psi4/.github/workflows/docs.yml; This setup works great for “latest” docs, but it won’t buil",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:16361,Deployability,install,installer,16361,"ymlinks the script head matter advises. Generate download page for psicode.org¶. Be in repo psicode-hugo-website; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/content/installs/v13rc2.md. Note the edition string v13rc2 in frontmatter for this and future filenames; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/data/installs/v13rc2.yaml for menu and notes content; Enter scripts/ dir and edit primarily https://github.com/psi4/psicode-hugo-website/blob/master/scripts/install-generator.py#L9 but also any other arrays or messages that should change.; Run the install-generator.py in place. It will dump new files into data/installs/ _subdirs_. Be sure to git add them.; Installer page is now ready.; Shift “latest” alias in frontmatter from whichever page is currently active to the new page. This makes sure “Downloads” on the navigation bar points to new page.; Conscientiously, one should test. installer downloads in Mac and Linux. And actually installing them and psi4 --test them.; that download button and curl downloading register on the download counters on vergil. Commit the new files, PR, and deploy psicode site; Petition on Slack for testers. Collect documentation snapshot¶. Documentation is built automatically by GHA from the latest psi4 master commit. It gets pushed to the psi4/psi4docs repository and thence served by netlify to a site independent of psicode.org. The netlify psicode.org site has a redirect so that psicode.org/psi4manual/master presents the psi4docs netlify content.; GHA controller is psi4/.github/workflows/docs.yml; This setup works great for “latest” docs, but it won’t build a nice copy on the tag because the tag commit is pushed before the tag itself, so the version shows up “undefined”.; So, anytime after “Tag (pre)release” is over, navigate on psi4 GH to the tag commit (not the record commit) and retrigger the docs GHA. Download the artifact (zipped docs dir) at th",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:16412,Deployability,install,installing,16412,"rate download page for psicode.org¶. Be in repo psicode-hugo-website; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/content/installs/v13rc2.md. Note the edition string v13rc2 in frontmatter for this and future filenames; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/data/installs/v13rc2.yaml for menu and notes content; Enter scripts/ dir and edit primarily https://github.com/psi4/psicode-hugo-website/blob/master/scripts/install-generator.py#L9 but also any other arrays or messages that should change.; Run the install-generator.py in place. It will dump new files into data/installs/ _subdirs_. Be sure to git add them.; Installer page is now ready.; Shift “latest” alias in frontmatter from whichever page is currently active to the new page. This makes sure “Downloads” on the navigation bar points to new page.; Conscientiously, one should test. installer downloads in Mac and Linux. And actually installing them and psi4 --test them.; that download button and curl downloading register on the download counters on vergil. Commit the new files, PR, and deploy psicode site; Petition on Slack for testers. Collect documentation snapshot¶. Documentation is built automatically by GHA from the latest psi4 master commit. It gets pushed to the psi4/psi4docs repository and thence served by netlify to a site independent of psicode.org. The netlify psicode.org site has a redirect so that psicode.org/psi4manual/master presents the psi4docs netlify content.; GHA controller is psi4/.github/workflows/docs.yml; This setup works great for “latest” docs, but it won’t build a nice copy on the tag because the tag commit is pushed before the tag itself, so the version shows up “undefined”.; So, anytime after “Tag (pre)release” is over, navigate on psi4 GH to the tag commit (not the record commit) and retrigger the docs GHA. Download the artifact (zipped docs dir) at the end to a local computer.; In your hugo site",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:16568,Deployability,deploy,deploy,16568,"er/content/installs/v13rc2.md. Note the edition string v13rc2 in frontmatter for this and future filenames; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/data/installs/v13rc2.yaml for menu and notes content; Enter scripts/ dir and edit primarily https://github.com/psi4/psicode-hugo-website/blob/master/scripts/install-generator.py#L9 but also any other arrays or messages that should change.; Run the install-generator.py in place. It will dump new files into data/installs/ _subdirs_. Be sure to git add them.; Installer page is now ready.; Shift “latest” alias in frontmatter from whichever page is currently active to the new page. This makes sure “Downloads” on the navigation bar points to new page.; Conscientiously, one should test. installer downloads in Mac and Linux. And actually installing them and psi4 --test them.; that download button and curl downloading register on the download counters on vergil. Commit the new files, PR, and deploy psicode site; Petition on Slack for testers. Collect documentation snapshot¶. Documentation is built automatically by GHA from the latest psi4 master commit. It gets pushed to the psi4/psi4docs repository and thence served by netlify to a site independent of psicode.org. The netlify psicode.org site has a redirect so that psicode.org/psi4manual/master presents the psi4docs netlify content.; GHA controller is psi4/.github/workflows/docs.yml; This setup works great for “latest” docs, but it won’t build a nice copy on the tag because the tag commit is pushed before the tag itself, so the version shows up “undefined”.; So, anytime after “Tag (pre)release” is over, navigate on psi4 GH to the tag commit (not the record commit) and retrigger the docs GHA. Download the artifact (zipped docs dir) at the end to a local computer.; In your hugo site clone, create a new directory under static/psi4manual. Copy the zipped docs there, unpack, rearrange so that static/psi4manual/<new-tag>/index.html is pr",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:17226,Deployability,release,release,17226,"es sure “Downloads” on the navigation bar points to new page.; Conscientiously, one should test. installer downloads in Mac and Linux. And actually installing them and psi4 --test them.; that download button and curl downloading register on the download counters on vergil. Commit the new files, PR, and deploy psicode site; Petition on Slack for testers. Collect documentation snapshot¶. Documentation is built automatically by GHA from the latest psi4 master commit. It gets pushed to the psi4/psi4docs repository and thence served by netlify to a site independent of psicode.org. The netlify psicode.org site has a redirect so that psicode.org/psi4manual/master presents the psi4docs netlify content.; GHA controller is psi4/.github/workflows/docs.yml; This setup works great for “latest” docs, but it won’t build a nice copy on the tag because the tag commit is pushed before the tag itself, so the version shows up “undefined”.; So, anytime after “Tag (pre)release” is over, navigate on psi4 GH to the tag commit (not the record commit) and retrigger the docs GHA. Download the artifact (zipped docs dir) at the end to a local computer.; In your hugo site clone, create a new directory under static/psi4manual. Copy the zipped docs there, unpack, rearrange so that static/psi4manual/<new-tag>/index.html is present. Check in. Publish GitHub release¶. On GitHub site “Draft a New Release” with newly minted tag; Fill in frontmatter style and links from previous GitHub release; Fill in RN from hopefully existing RN issue; Fill in RN by going through the top posts from all PRs from this milestone; “publish” release. This establishes release date for GitHub API; Close the RN issue.; Close the milestone (should be 100% complete). Publish GitHub postrelease¶. On GitHub site “Draft a New Release” for anticipated or newly minted tag; Fill in frontmatter style and links from previous GitHub release; Fill in RN as cherry-pick to or edit on branch; “publish” release. This establishes release date",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:17610,Deployability,release,release,17610," for testers. Collect documentation snapshot¶. Documentation is built automatically by GHA from the latest psi4 master commit. It gets pushed to the psi4/psi4docs repository and thence served by netlify to a site independent of psicode.org. The netlify psicode.org site has a redirect so that psicode.org/psi4manual/master presents the psi4docs netlify content.; GHA controller is psi4/.github/workflows/docs.yml; This setup works great for “latest” docs, but it won’t build a nice copy on the tag because the tag commit is pushed before the tag itself, so the version shows up “undefined”.; So, anytime after “Tag (pre)release” is over, navigate on psi4 GH to the tag commit (not the record commit) and retrigger the docs GHA. Download the artifact (zipped docs dir) at the end to a local computer.; In your hugo site clone, create a new directory under static/psi4manual. Copy the zipped docs there, unpack, rearrange so that static/psi4manual/<new-tag>/index.html is present. Check in. Publish GitHub release¶. On GitHub site “Draft a New Release” with newly minted tag; Fill in frontmatter style and links from previous GitHub release; Fill in RN from hopefully existing RN issue; Fill in RN by going through the top posts from all PRs from this milestone; “publish” release. This establishes release date for GitHub API; Close the RN issue.; Close the milestone (should be 100% complete). Publish GitHub postrelease¶. On GitHub site “Draft a New Release” for anticipated or newly minted tag; Fill in frontmatter style and links from previous GitHub release; Fill in RN as cherry-pick to or edit on branch; “publish” release. This establishes release date for GitHub API. Publish psicode release¶. Copy a recent release page like https://github.com/psi4/psicode-hugo-website/blob/master/content/posts/v1p2.md; Edit its filename, title, date, image, and links; Execute https://api.github.com/repos/psi4/psi4/releases/latest and note the id field value; Use the id value in the shortcode call at the",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:17737,Deployability,release,release,17737,"he psi4/psi4docs repository and thence served by netlify to a site independent of psicode.org. The netlify psicode.org site has a redirect so that psicode.org/psi4manual/master presents the psi4docs netlify content.; GHA controller is psi4/.github/workflows/docs.yml; This setup works great for “latest” docs, but it won’t build a nice copy on the tag because the tag commit is pushed before the tag itself, so the version shows up “undefined”.; So, anytime after “Tag (pre)release” is over, navigate on psi4 GH to the tag commit (not the record commit) and retrigger the docs GHA. Download the artifact (zipped docs dir) at the end to a local computer.; In your hugo site clone, create a new directory under static/psi4manual. Copy the zipped docs there, unpack, rearrange so that static/psi4manual/<new-tag>/index.html is present. Check in. Publish GitHub release¶. On GitHub site “Draft a New Release” with newly minted tag; Fill in frontmatter style and links from previous GitHub release; Fill in RN from hopefully existing RN issue; Fill in RN by going through the top posts from all PRs from this milestone; “publish” release. This establishes release date for GitHub API; Close the RN issue.; Close the milestone (should be 100% complete). Publish GitHub postrelease¶. On GitHub site “Draft a New Release” for anticipated or newly minted tag; Fill in frontmatter style and links from previous GitHub release; Fill in RN as cherry-pick to or edit on branch; “publish” release. This establishes release date for GitHub API. Publish psicode release¶. Copy a recent release page like https://github.com/psi4/psicode-hugo-website/blob/master/content/posts/v1p2.md; Edit its filename, title, date, image, and links; Execute https://api.github.com/repos/psi4/psi4/releases/latest and note the id field value; Use the id value in the shortcode call at the bottom. Finalize release¶. Make new PR with; * edits to main README.md badges, python versions, etc.; * edits to CMakeLists.txt find_package(Pyt",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:17877,Deployability,release,release,17877,"he psi4/psi4docs repository and thence served by netlify to a site independent of psicode.org. The netlify psicode.org site has a redirect so that psicode.org/psi4manual/master presents the psi4docs netlify content.; GHA controller is psi4/.github/workflows/docs.yml; This setup works great for “latest” docs, but it won’t build a nice copy on the tag because the tag commit is pushed before the tag itself, so the version shows up “undefined”.; So, anytime after “Tag (pre)release” is over, navigate on psi4 GH to the tag commit (not the record commit) and retrigger the docs GHA. Download the artifact (zipped docs dir) at the end to a local computer.; In your hugo site clone, create a new directory under static/psi4manual. Copy the zipped docs there, unpack, rearrange so that static/psi4manual/<new-tag>/index.html is present. Check in. Publish GitHub release¶. On GitHub site “Draft a New Release” with newly minted tag; Fill in frontmatter style and links from previous GitHub release; Fill in RN from hopefully existing RN issue; Fill in RN by going through the top posts from all PRs from this milestone; “publish” release. This establishes release date for GitHub API; Close the RN issue.; Close the milestone (should be 100% complete). Publish GitHub postrelease¶. On GitHub site “Draft a New Release” for anticipated or newly minted tag; Fill in frontmatter style and links from previous GitHub release; Fill in RN as cherry-pick to or edit on branch; “publish” release. This establishes release date for GitHub API. Publish psicode release¶. Copy a recent release page like https://github.com/psi4/psicode-hugo-website/blob/master/content/posts/v1p2.md; Edit its filename, title, date, image, and links; Execute https://api.github.com/repos/psi4/psi4/releases/latest and note the id field value; Use the id value in the shortcode call at the bottom. Finalize release¶. Make new PR with; * edits to main README.md badges, python versions, etc.; * edits to CMakeLists.txt find_package(Pyt",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:17903,Deployability,release,release,17903,"ual/master presents the psi4docs netlify content.; GHA controller is psi4/.github/workflows/docs.yml; This setup works great for “latest” docs, but it won’t build a nice copy on the tag because the tag commit is pushed before the tag itself, so the version shows up “undefined”.; So, anytime after “Tag (pre)release” is over, navigate on psi4 GH to the tag commit (not the record commit) and retrigger the docs GHA. Download the artifact (zipped docs dir) at the end to a local computer.; In your hugo site clone, create a new directory under static/psi4manual. Copy the zipped docs there, unpack, rearrange so that static/psi4manual/<new-tag>/index.html is present. Check in. Publish GitHub release¶. On GitHub site “Draft a New Release” with newly minted tag; Fill in frontmatter style and links from previous GitHub release; Fill in RN from hopefully existing RN issue; Fill in RN by going through the top posts from all PRs from this milestone; “publish” release. This establishes release date for GitHub API; Close the RN issue.; Close the milestone (should be 100% complete). Publish GitHub postrelease¶. On GitHub site “Draft a New Release” for anticipated or newly minted tag; Fill in frontmatter style and links from previous GitHub release; Fill in RN as cherry-pick to or edit on branch; “publish” release. This establishes release date for GitHub API. Publish psicode release¶. Copy a recent release page like https://github.com/psi4/psicode-hugo-website/blob/master/content/posts/v1p2.md; Edit its filename, title, date, image, and links; Execute https://api.github.com/repos/psi4/psi4/releases/latest and note the id field value; Use the id value in the shortcode call at the bottom. Finalize release¶. Make new PR with; * edits to main README.md badges, python versions, etc.; * edits to CMakeLists.txt find_package(PythonLibsNew 3.6 REQUIRED); Tweet about release. Reset psi4meta for nightly operation¶; On both Linux and Mac:. After (post)release (not prerelease), in conda_build_con",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:18160,Deployability,release,release,18160,"ushed before the tag itself, so the version shows up “undefined”.; So, anytime after “Tag (pre)release” is over, navigate on psi4 GH to the tag commit (not the record commit) and retrigger the docs GHA. Download the artifact (zipped docs dir) at the end to a local computer.; In your hugo site clone, create a new directory under static/psi4manual. Copy the zipped docs there, unpack, rearrange so that static/psi4manual/<new-tag>/index.html is present. Check in. Publish GitHub release¶. On GitHub site “Draft a New Release” with newly minted tag; Fill in frontmatter style and links from previous GitHub release; Fill in RN from hopefully existing RN issue; Fill in RN by going through the top posts from all PRs from this milestone; “publish” release. This establishes release date for GitHub API; Close the RN issue.; Close the milestone (should be 100% complete). Publish GitHub postrelease¶. On GitHub site “Draft a New Release” for anticipated or newly minted tag; Fill in frontmatter style and links from previous GitHub release; Fill in RN as cherry-pick to or edit on branch; “publish” release. This establishes release date for GitHub API. Publish psicode release¶. Copy a recent release page like https://github.com/psi4/psicode-hugo-website/blob/master/content/posts/v1p2.md; Edit its filename, title, date, image, and links; Execute https://api.github.com/repos/psi4/psi4/releases/latest and note the id field value; Use the id value in the shortcode call at the bottom. Finalize release¶. Make new PR with; * edits to main README.md badges, python versions, etc.; * edits to CMakeLists.txt find_package(PythonLibsNew 3.6 REQUIRED); Tweet about release. Reset psi4meta for nightly operation¶; On both Linux and Mac:. After (post)release (not prerelease), in conda_build_config.yaml, edit ltrtver to a new “release.dev” label; After postrelease, unpin any dependencies in cbcy that needed older either ver or bld (e.g., v2rdm_casscf_bld); Edit psi4ver back to '' in cbcy; Edit source/git_",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:18227,Deployability,release,release,18227,"ushed before the tag itself, so the version shows up “undefined”.; So, anytime after “Tag (pre)release” is over, navigate on psi4 GH to the tag commit (not the record commit) and retrigger the docs GHA. Download the artifact (zipped docs dir) at the end to a local computer.; In your hugo site clone, create a new directory under static/psi4manual. Copy the zipped docs there, unpack, rearrange so that static/psi4manual/<new-tag>/index.html is present. Check in. Publish GitHub release¶. On GitHub site “Draft a New Release” with newly minted tag; Fill in frontmatter style and links from previous GitHub release; Fill in RN from hopefully existing RN issue; Fill in RN by going through the top posts from all PRs from this milestone; “publish” release. This establishes release date for GitHub API; Close the RN issue.; Close the milestone (should be 100% complete). Publish GitHub postrelease¶. On GitHub site “Draft a New Release” for anticipated or newly minted tag; Fill in frontmatter style and links from previous GitHub release; Fill in RN as cherry-pick to or edit on branch; “publish” release. This establishes release date for GitHub API. Publish psicode release¶. Copy a recent release page like https://github.com/psi4/psicode-hugo-website/blob/master/content/posts/v1p2.md; Edit its filename, title, date, image, and links; Execute https://api.github.com/repos/psi4/psi4/releases/latest and note the id field value; Use the id value in the shortcode call at the bottom. Finalize release¶. Make new PR with; * edits to main README.md badges, python versions, etc.; * edits to CMakeLists.txt find_package(PythonLibsNew 3.6 REQUIRED); Tweet about release. Reset psi4meta for nightly operation¶; On both Linux and Mac:. After (post)release (not prerelease), in conda_build_config.yaml, edit ltrtver to a new “release.dev” label; After postrelease, unpin any dependencies in cbcy that needed older either ver or bld (e.g., v2rdm_casscf_bld); Edit psi4ver back to '' in cbcy; Edit source/git_",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:18253,Deployability,release,release,18253,"i4 GH to the tag commit (not the record commit) and retrigger the docs GHA. Download the artifact (zipped docs dir) at the end to a local computer.; In your hugo site clone, create a new directory under static/psi4manual. Copy the zipped docs there, unpack, rearrange so that static/psi4manual/<new-tag>/index.html is present. Check in. Publish GitHub release¶. On GitHub site “Draft a New Release” with newly minted tag; Fill in frontmatter style and links from previous GitHub release; Fill in RN from hopefully existing RN issue; Fill in RN by going through the top posts from all PRs from this milestone; “publish” release. This establishes release date for GitHub API; Close the RN issue.; Close the milestone (should be 100% complete). Publish GitHub postrelease¶. On GitHub site “Draft a New Release” for anticipated or newly minted tag; Fill in frontmatter style and links from previous GitHub release; Fill in RN as cherry-pick to or edit on branch; “publish” release. This establishes release date for GitHub API. Publish psicode release¶. Copy a recent release page like https://github.com/psi4/psicode-hugo-website/blob/master/content/posts/v1p2.md; Edit its filename, title, date, image, and links; Execute https://api.github.com/repos/psi4/psi4/releases/latest and note the id field value; Use the id value in the shortcode call at the bottom. Finalize release¶. Make new PR with; * edits to main README.md badges, python versions, etc.; * edits to CMakeLists.txt find_package(PythonLibsNew 3.6 REQUIRED); Tweet about release. Reset psi4meta for nightly operation¶; On both Linux and Mac:. After (post)release (not prerelease), in conda_build_config.yaml, edit ltrtver to a new “release.dev” label; After postrelease, unpin any dependencies in cbcy that needed older either ver or bld (e.g., v2rdm_casscf_bld); Edit psi4ver back to '' in cbcy; Edit source/git_tag back to master for psi4-multiout, psi4-docs; Edit build string back to 0 if psi4-multiout needed multiple passes; Edit kit",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:18298,Deployability,release,release,18298,"ord commit) and retrigger the docs GHA. Download the artifact (zipped docs dir) at the end to a local computer.; In your hugo site clone, create a new directory under static/psi4manual. Copy the zipped docs there, unpack, rearrange so that static/psi4manual/<new-tag>/index.html is present. Check in. Publish GitHub release¶. On GitHub site “Draft a New Release” with newly minted tag; Fill in frontmatter style and links from previous GitHub release; Fill in RN from hopefully existing RN issue; Fill in RN by going through the top posts from all PRs from this milestone; “publish” release. This establishes release date for GitHub API; Close the RN issue.; Close the milestone (should be 100% complete). Publish GitHub postrelease¶. On GitHub site “Draft a New Release” for anticipated or newly minted tag; Fill in frontmatter style and links from previous GitHub release; Fill in RN as cherry-pick to or edit on branch; “publish” release. This establishes release date for GitHub API. Publish psicode release¶. Copy a recent release page like https://github.com/psi4/psicode-hugo-website/blob/master/content/posts/v1p2.md; Edit its filename, title, date, image, and links; Execute https://api.github.com/repos/psi4/psi4/releases/latest and note the id field value; Use the id value in the shortcode call at the bottom. Finalize release¶. Make new PR with; * edits to main README.md badges, python versions, etc.; * edits to CMakeLists.txt find_package(PythonLibsNew 3.6 REQUIRED); Tweet about release. Reset psi4meta for nightly operation¶; On both Linux and Mac:. After (post)release (not prerelease), in conda_build_config.yaml, edit ltrtver to a new “release.dev” label; After postrelease, unpin any dependencies in cbcy that needed older either ver or bld (e.g., v2rdm_casscf_bld); Edit psi4ver back to '' in cbcy; Edit source/git_tag back to master for psi4-multiout, psi4-docs; Edit build string back to 0 if psi4-multiout needed multiple passes; Edit kitandkapoodle.py back to *** stack; Ch",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:18322,Deployability,release,release,18322,"A. Download the artifact (zipped docs dir) at the end to a local computer.; In your hugo site clone, create a new directory under static/psi4manual. Copy the zipped docs there, unpack, rearrange so that static/psi4manual/<new-tag>/index.html is present. Check in. Publish GitHub release¶. On GitHub site “Draft a New Release” with newly minted tag; Fill in frontmatter style and links from previous GitHub release; Fill in RN from hopefully existing RN issue; Fill in RN by going through the top posts from all PRs from this milestone; “publish” release. This establishes release date for GitHub API; Close the RN issue.; Close the milestone (should be 100% complete). Publish GitHub postrelease¶. On GitHub site “Draft a New Release” for anticipated or newly minted tag; Fill in frontmatter style and links from previous GitHub release; Fill in RN as cherry-pick to or edit on branch; “publish” release. This establishes release date for GitHub API. Publish psicode release¶. Copy a recent release page like https://github.com/psi4/psicode-hugo-website/blob/master/content/posts/v1p2.md; Edit its filename, title, date, image, and links; Execute https://api.github.com/repos/psi4/psi4/releases/latest and note the id field value; Use the id value in the shortcode call at the bottom. Finalize release¶. Make new PR with; * edits to main README.md badges, python versions, etc.; * edits to CMakeLists.txt find_package(PythonLibsNew 3.6 REQUIRED); Tweet about release. Reset psi4meta for nightly operation¶; On both Linux and Mac:. After (post)release (not prerelease), in conda_build_config.yaml, edit ltrtver to a new “release.dev” label; After postrelease, unpin any dependencies in cbcy that needed older either ver or bld (e.g., v2rdm_casscf_bld); Edit psi4ver back to '' in cbcy; Edit source/git_tag back to master for psi4-multiout, psi4-docs; Edit build string back to 0 if psi4-multiout needed multiple passes; Edit kitandkapoodle.py back to *** stack; Check in all release, construct, recipe",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:18517,Deployability,release,releases,18517,"-tag>/index.html is present. Check in. Publish GitHub release¶. On GitHub site “Draft a New Release” with newly minted tag; Fill in frontmatter style and links from previous GitHub release; Fill in RN from hopefully existing RN issue; Fill in RN by going through the top posts from all PRs from this milestone; “publish” release. This establishes release date for GitHub API; Close the RN issue.; Close the milestone (should be 100% complete). Publish GitHub postrelease¶. On GitHub site “Draft a New Release” for anticipated or newly minted tag; Fill in frontmatter style and links from previous GitHub release; Fill in RN as cherry-pick to or edit on branch; “publish” release. This establishes release date for GitHub API. Publish psicode release¶. Copy a recent release page like https://github.com/psi4/psicode-hugo-website/blob/master/content/posts/v1p2.md; Edit its filename, title, date, image, and links; Execute https://api.github.com/repos/psi4/psi4/releases/latest and note the id field value; Use the id value in the shortcode call at the bottom. Finalize release¶. Make new PR with; * edits to main README.md badges, python versions, etc.; * edits to CMakeLists.txt find_package(PythonLibsNew 3.6 REQUIRED); Tweet about release. Reset psi4meta for nightly operation¶; On both Linux and Mac:. After (post)release (not prerelease), in conda_build_config.yaml, edit ltrtver to a new “release.dev” label; After postrelease, unpin any dependencies in cbcy that needed older either ver or bld (e.g., v2rdm_casscf_bld); Edit psi4ver back to '' in cbcy; Edit source/git_tag back to master for psi4-multiout, psi4-docs; Edit build string back to 0 if psi4-multiout needed multiple passes; Edit kitandkapoodle.py back to *** stack; Check in all release, construct, recipe changes on Linux and Mac. Synchronize both to GitHub psi4meta; Copy meta.yaml and build.sh files to vMmp-prefixed files for the record.; Edit crontab back to 2am “norm”. Comment out “anom”. table of contents. Release Procedu",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:18625,Deployability,release,release,18625,"itHub site “Draft a New Release” with newly minted tag; Fill in frontmatter style and links from previous GitHub release; Fill in RN from hopefully existing RN issue; Fill in RN by going through the top posts from all PRs from this milestone; “publish” release. This establishes release date for GitHub API; Close the RN issue.; Close the milestone (should be 100% complete). Publish GitHub postrelease¶. On GitHub site “Draft a New Release” for anticipated or newly minted tag; Fill in frontmatter style and links from previous GitHub release; Fill in RN as cherry-pick to or edit on branch; “publish” release. This establishes release date for GitHub API. Publish psicode release¶. Copy a recent release page like https://github.com/psi4/psicode-hugo-website/blob/master/content/posts/v1p2.md; Edit its filename, title, date, image, and links; Execute https://api.github.com/repos/psi4/psi4/releases/latest and note the id field value; Use the id value in the shortcode call at the bottom. Finalize release¶. Make new PR with; * edits to main README.md badges, python versions, etc.; * edits to CMakeLists.txt find_package(PythonLibsNew 3.6 REQUIRED); Tweet about release. Reset psi4meta for nightly operation¶; On both Linux and Mac:. After (post)release (not prerelease), in conda_build_config.yaml, edit ltrtver to a new “release.dev” label; After postrelease, unpin any dependencies in cbcy that needed older either ver or bld (e.g., v2rdm_casscf_bld); Edit psi4ver back to '' in cbcy; Edit source/git_tag back to master for psi4-multiout, psi4-docs; Edit build string back to 0 if psi4-multiout needed multiple passes; Edit kitandkapoodle.py back to *** stack; Check in all release, construct, recipe changes on Linux and Mac. Synchronize both to GitHub psi4meta; Copy meta.yaml and build.sh files to vMmp-prefixed files for the record.; Edit crontab back to 2am “norm”. Comment out “anom”. table of contents. Release Procedures; Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:18790,Deployability,release,release,18790,"RN issue; Fill in RN by going through the top posts from all PRs from this milestone; “publish” release. This establishes release date for GitHub API; Close the RN issue.; Close the milestone (should be 100% complete). Publish GitHub postrelease¶. On GitHub site “Draft a New Release” for anticipated or newly minted tag; Fill in frontmatter style and links from previous GitHub release; Fill in RN as cherry-pick to or edit on branch; “publish” release. This establishes release date for GitHub API. Publish psicode release¶. Copy a recent release page like https://github.com/psi4/psicode-hugo-website/blob/master/content/posts/v1p2.md; Edit its filename, title, date, image, and links; Execute https://api.github.com/repos/psi4/psi4/releases/latest and note the id field value; Use the id value in the shortcode call at the bottom. Finalize release¶. Make new PR with; * edits to main README.md badges, python versions, etc.; * edits to CMakeLists.txt find_package(PythonLibsNew 3.6 REQUIRED); Tweet about release. Reset psi4meta for nightly operation¶; On both Linux and Mac:. After (post)release (not prerelease), in conda_build_config.yaml, edit ltrtver to a new “release.dev” label; After postrelease, unpin any dependencies in cbcy that needed older either ver or bld (e.g., v2rdm_casscf_bld); Edit psi4ver back to '' in cbcy; Edit source/git_tag back to master for psi4-multiout, psi4-docs; Edit build string back to 0 if psi4-multiout needed multiple passes; Edit kitandkapoodle.py back to *** stack; Check in all release, construct, recipe changes on Linux and Mac. Synchronize both to GitHub psi4meta; Copy meta.yaml and build.sh files to vMmp-prefixed files for the record.; Edit crontab back to 2am “norm”. Comment out “anom”. table of contents. Release Procedures; Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1); Update copyright year; Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Assemble postreleas",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:18874,Deployability,release,release,18874,"establishes release date for GitHub API; Close the RN issue.; Close the milestone (should be 100% complete). Publish GitHub postrelease¶. On GitHub site “Draft a New Release” for anticipated or newly minted tag; Fill in frontmatter style and links from previous GitHub release; Fill in RN as cherry-pick to or edit on branch; “publish” release. This establishes release date for GitHub API. Publish psicode release¶. Copy a recent release page like https://github.com/psi4/psicode-hugo-website/blob/master/content/posts/v1p2.md; Edit its filename, title, date, image, and links; Execute https://api.github.com/repos/psi4/psi4/releases/latest and note the id field value; Use the id value in the shortcode call at the bottom. Finalize release¶. Make new PR with; * edits to main README.md badges, python versions, etc.; * edits to CMakeLists.txt find_package(PythonLibsNew 3.6 REQUIRED); Tweet about release. Reset psi4meta for nightly operation¶; On both Linux and Mac:. After (post)release (not prerelease), in conda_build_config.yaml, edit ltrtver to a new “release.dev” label; After postrelease, unpin any dependencies in cbcy that needed older either ver or bld (e.g., v2rdm_casscf_bld); Edit psi4ver back to '' in cbcy; Edit source/git_tag back to master for psi4-multiout, psi4-docs; Edit build string back to 0 if psi4-multiout needed multiple passes; Edit kitandkapoodle.py back to *** stack; Check in all release, construct, recipe changes on Linux and Mac. Synchronize both to GitHub psi4meta; Copy meta.yaml and build.sh files to vMmp-prefixed files for the record.; Edit crontab back to 2am “norm”. Comment out “anom”. table of contents. Release Procedures; Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1); Update copyright year; Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag (pre)release; Tag postrelease; I",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:18951,Deployability,release,release,18951,"e RN issue.; Close the milestone (should be 100% complete). Publish GitHub postrelease¶. On GitHub site “Draft a New Release” for anticipated or newly minted tag; Fill in frontmatter style and links from previous GitHub release; Fill in RN as cherry-pick to or edit on branch; “publish” release. This establishes release date for GitHub API. Publish psicode release¶. Copy a recent release page like https://github.com/psi4/psicode-hugo-website/blob/master/content/posts/v1p2.md; Edit its filename, title, date, image, and links; Execute https://api.github.com/repos/psi4/psi4/releases/latest and note the id field value; Use the id value in the shortcode call at the bottom. Finalize release¶. Make new PR with; * edits to main README.md badges, python versions, etc.; * edits to CMakeLists.txt find_package(PythonLibsNew 3.6 REQUIRED); Tweet about release. Reset psi4meta for nightly operation¶; On both Linux and Mac:. After (post)release (not prerelease), in conda_build_config.yaml, edit ltrtver to a new “release.dev” label; After postrelease, unpin any dependencies in cbcy that needed older either ver or bld (e.g., v2rdm_casscf_bld); Edit psi4ver back to '' in cbcy; Edit source/git_tag back to master for psi4-multiout, psi4-docs; Edit build string back to 0 if psi4-multiout needed multiple passes; Edit kitandkapoodle.py back to *** stack; Check in all release, construct, recipe changes on Linux and Mac. Synchronize both to GitHub psi4meta; Copy meta.yaml and build.sh files to vMmp-prefixed files for the record.; Edit crontab back to 2am “norm”. Comment out “anom”. table of contents. Release Procedures; Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1); Update copyright year; Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag (pre)release; Tag postrelease; Initialize release branch; Build Conda Psi4 stack ",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:19305,Deployability,release,release,19305,"a recent release page like https://github.com/psi4/psicode-hugo-website/blob/master/content/posts/v1p2.md; Edit its filename, title, date, image, and links; Execute https://api.github.com/repos/psi4/psi4/releases/latest and note the id field value; Use the id value in the shortcode call at the bottom. Finalize release¶. Make new PR with; * edits to main README.md badges, python versions, etc.; * edits to CMakeLists.txt find_package(PythonLibsNew 3.6 REQUIRED); Tweet about release. Reset psi4meta for nightly operation¶; On both Linux and Mac:. After (post)release (not prerelease), in conda_build_config.yaml, edit ltrtver to a new “release.dev” label; After postrelease, unpin any dependencies in cbcy that needed older either ver or bld (e.g., v2rdm_casscf_bld); Edit psi4ver back to '' in cbcy; Edit source/git_tag back to master for psi4-multiout, psi4-docs; Edit build string back to 0 if psi4-multiout needed multiple passes; Edit kitandkapoodle.py back to *** stack; Check in all release, construct, recipe changes on Linux and Mac. Synchronize both to GitHub psi4meta; Copy meta.yaml and build.sh files to vMmp-prefixed files for the record.; Edit crontab back to 2am “norm”. Comment out “anom”. table of contents. Release Procedures; Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1); Update copyright year; Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag (pre)release; Tag postrelease; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set (pre-Spring 2021); Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. «; hide menu. menu; sidebar; »; . Navigation. Index. module",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:19725,Deployability,release,release,19725,"d note the id field value; Use the id value in the shortcode call at the bottom. Finalize release¶. Make new PR with; * edits to main README.md badges, python versions, etc.; * edits to CMakeLists.txt find_package(PythonLibsNew 3.6 REQUIRED); Tweet about release. Reset psi4meta for nightly operation¶; On both Linux and Mac:. After (post)release (not prerelease), in conda_build_config.yaml, edit ltrtver to a new “release.dev” label; After postrelease, unpin any dependencies in cbcy that needed older either ver or bld (e.g., v2rdm_casscf_bld); Edit psi4ver back to '' in cbcy; Edit source/git_tag back to master for psi4-multiout, psi4-docs; Edit build string back to 0 if psi4-multiout needed multiple passes; Edit kitandkapoodle.py back to *** stack; Check in all release, construct, recipe changes on Linux and Mac. Synchronize both to GitHub psi4meta; Copy meta.yaml and build.sh files to vMmp-prefixed files for the record.; Edit crontab back to 2am “norm”. Comment out “anom”. table of contents. Release Procedures; Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1); Update copyright year; Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag (pre)release; Tag postrelease; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set (pre-Spring 2021); Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that; Release Procedures. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:19843,Deployability,release,release,19843,"d note the id field value; Use the id value in the shortcode call at the bottom. Finalize release¶. Make new PR with; * edits to main README.md badges, python versions, etc.; * edits to CMakeLists.txt find_package(PythonLibsNew 3.6 REQUIRED); Tweet about release. Reset psi4meta for nightly operation¶; On both Linux and Mac:. After (post)release (not prerelease), in conda_build_config.yaml, edit ltrtver to a new “release.dev” label; After postrelease, unpin any dependencies in cbcy that needed older either ver or bld (e.g., v2rdm_casscf_bld); Edit psi4ver back to '' in cbcy; Edit source/git_tag back to master for psi4-multiout, psi4-docs; Edit build string back to 0 if psi4-multiout needed multiple passes; Edit kitandkapoodle.py back to *** stack; Check in all release, construct, recipe changes on Linux and Mac. Synchronize both to GitHub psi4meta; Copy meta.yaml and build.sh files to vMmp-prefixed files for the record.; Edit crontab back to 2am “norm”. Comment out “anom”. table of contents. Release Procedures; Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1); Update copyright year; Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag (pre)release; Tag postrelease; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set (pre-Spring 2021); Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that; Release Procedures. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:19865,Deployability,release,release,19865,"d note the id field value; Use the id value in the shortcode call at the bottom. Finalize release¶. Make new PR with; * edits to main README.md badges, python versions, etc.; * edits to CMakeLists.txt find_package(PythonLibsNew 3.6 REQUIRED); Tweet about release. Reset psi4meta for nightly operation¶; On both Linux and Mac:. After (post)release (not prerelease), in conda_build_config.yaml, edit ltrtver to a new “release.dev” label; After postrelease, unpin any dependencies in cbcy that needed older either ver or bld (e.g., v2rdm_casscf_bld); Edit psi4ver back to '' in cbcy; Edit source/git_tag back to master for psi4-multiout, psi4-docs; Edit build string back to 0 if psi4-multiout needed multiple passes; Edit kitandkapoodle.py back to *** stack; Check in all release, construct, recipe changes on Linux and Mac. Synchronize both to GitHub psi4meta; Copy meta.yaml and build.sh files to vMmp-prefixed files for the record.; Edit crontab back to 2am “norm”. Comment out “anom”. table of contents. Release Procedures; Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1); Update copyright year; Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag (pre)release; Tag postrelease; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set (pre-Spring 2021); Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that; Release Procedures. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:19902,Deployability,release,release,19902,"d note the id field value; Use the id value in the shortcode call at the bottom. Finalize release¶. Make new PR with; * edits to main README.md badges, python versions, etc.; * edits to CMakeLists.txt find_package(PythonLibsNew 3.6 REQUIRED); Tweet about release. Reset psi4meta for nightly operation¶; On both Linux and Mac:. After (post)release (not prerelease), in conda_build_config.yaml, edit ltrtver to a new “release.dev” label; After postrelease, unpin any dependencies in cbcy that needed older either ver or bld (e.g., v2rdm_casscf_bld); Edit psi4ver back to '' in cbcy; Edit source/git_tag back to master for psi4-multiout, psi4-docs; Edit build string back to 0 if psi4-multiout needed multiple passes; Edit kitandkapoodle.py back to *** stack; Check in all release, construct, recipe changes on Linux and Mac. Synchronize both to GitHub psi4meta; Copy meta.yaml and build.sh files to vMmp-prefixed files for the record.; Edit crontab back to 2am “norm”. Comment out “anom”. table of contents. Release Procedures; Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1); Update copyright year; Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag (pre)release; Tag postrelease; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set (pre-Spring 2021); Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that; Release Procedures. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:20137,Deployability,release,release,20137,"d note the id field value; Use the id value in the shortcode call at the bottom. Finalize release¶. Make new PR with; * edits to main README.md badges, python versions, etc.; * edits to CMakeLists.txt find_package(PythonLibsNew 3.6 REQUIRED); Tweet about release. Reset psi4meta for nightly operation¶; On both Linux and Mac:. After (post)release (not prerelease), in conda_build_config.yaml, edit ltrtver to a new “release.dev” label; After postrelease, unpin any dependencies in cbcy that needed older either ver or bld (e.g., v2rdm_casscf_bld); Edit psi4ver back to '' in cbcy; Edit source/git_tag back to master for psi4-multiout, psi4-docs; Edit build string back to 0 if psi4-multiout needed multiple passes; Edit kitandkapoodle.py back to *** stack; Check in all release, construct, recipe changes on Linux and Mac. Synchronize both to GitHub psi4meta; Copy meta.yaml and build.sh files to vMmp-prefixed files for the record.; Edit crontab back to 2am “norm”. Comment out “anom”. table of contents. Release Procedures; Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1); Update copyright year; Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag (pre)release; Tag postrelease; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set (pre-Spring 2021); Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that; Release Procedures. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:20190,Deployability,release,release,20190,"d note the id field value; Use the id value in the shortcode call at the bottom. Finalize release¶. Make new PR with; * edits to main README.md badges, python versions, etc.; * edits to CMakeLists.txt find_package(PythonLibsNew 3.6 REQUIRED); Tweet about release. Reset psi4meta for nightly operation¶; On both Linux and Mac:. After (post)release (not prerelease), in conda_build_config.yaml, edit ltrtver to a new “release.dev” label; After postrelease, unpin any dependencies in cbcy that needed older either ver or bld (e.g., v2rdm_casscf_bld); Edit psi4ver back to '' in cbcy; Edit source/git_tag back to master for psi4-multiout, psi4-docs; Edit build string back to 0 if psi4-multiout needed multiple passes; Edit kitandkapoodle.py back to *** stack; Check in all release, construct, recipe changes on Linux and Mac. Synchronize both to GitHub psi4meta; Copy meta.yaml and build.sh files to vMmp-prefixed files for the record.; Edit crontab back to 2am “norm”. Comment out “anom”. table of contents. Release Procedures; Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1); Update copyright year; Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag (pre)release; Tag postrelease; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set (pre-Spring 2021); Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that; Release Procedures. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:20208,Deployability,release,release,20208,"d note the id field value; Use the id value in the shortcode call at the bottom. Finalize release¶. Make new PR with; * edits to main README.md badges, python versions, etc.; * edits to CMakeLists.txt find_package(PythonLibsNew 3.6 REQUIRED); Tweet about release. Reset psi4meta for nightly operation¶; On both Linux and Mac:. After (post)release (not prerelease), in conda_build_config.yaml, edit ltrtver to a new “release.dev” label; After postrelease, unpin any dependencies in cbcy that needed older either ver or bld (e.g., v2rdm_casscf_bld); Edit psi4ver back to '' in cbcy; Edit source/git_tag back to master for psi4-multiout, psi4-docs; Edit build string back to 0 if psi4-multiout needed multiple passes; Edit kitandkapoodle.py back to *** stack; Check in all release, construct, recipe changes on Linux and Mac. Synchronize both to GitHub psi4meta; Copy meta.yaml and build.sh files to vMmp-prefixed files for the record.; Edit crontab back to 2am “norm”. Comment out “anom”. table of contents. Release Procedures; Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1); Update copyright year; Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag (pre)release; Tag postrelease; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set (pre-Spring 2021); Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that; Release Procedures. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:20461,Deployability,update,updated,20461,"d note the id field value; Use the id value in the shortcode call at the bottom. Finalize release¶. Make new PR with; * edits to main README.md badges, python versions, etc.; * edits to CMakeLists.txt find_package(PythonLibsNew 3.6 REQUIRED); Tweet about release. Reset psi4meta for nightly operation¶; On both Linux and Mac:. After (post)release (not prerelease), in conda_build_config.yaml, edit ltrtver to a new “release.dev” label; After postrelease, unpin any dependencies in cbcy that needed older either ver or bld (e.g., v2rdm_casscf_bld); Edit psi4ver back to '' in cbcy; Edit source/git_tag back to master for psi4-multiout, psi4-docs; Edit build string back to 0 if psi4-multiout needed multiple passes; Edit kitandkapoodle.py back to *** stack; Check in all release, construct, recipe changes on Linux and Mac. Synchronize both to GitHub psi4meta; Copy meta.yaml and build.sh files to vMmp-prefixed files for the record.; Edit crontab back to 2am “norm”. Comment out “anom”. table of contents. Release Procedures; Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1); Update copyright year; Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag (pre)release; Tag postrelease; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set (pre-Spring 2021); Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Managing: Git, Conda, CMake and all that; Release Procedures. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:4430,Integrability,depend,dependency,4430,"ytest on Psi4+upstream; Build L/RT-MP. If any trouble, edit code in L/RT and rebuild those package(s). Iterate until builds and passes. This stage is the only full ctest & pytest of Psi4+downstream; Build L/DEV. If any trouble, edit psi4 build system, plugin system, or OpenMP setup. Iterate until builds and passes; Build L/DOCS. If any trouble, edit the docs or the tests. Iterate until builds and passes; Results of last should upload to psicode.org (docs) and codecov.io (coverage); Changes to targets’ “source” and “version” in individual recipes should be edited in psi4 external/*/*/CMakeLists.txt files; Once everything’s working on Linux, repeat on Mac; At this point, ready to fine-tune builds of “Psi4 stack”. Assemble postrelease changes¶. Collect PRs with “backport” label, and request other backport suggestions on upcoming RN issue; Cherry-pick backport PRs and commits, apply other changes manually, not forgetting CI files; Do the draft parts of Publish GitHub postrelease; Test thoroughly locally, including psi4-rt (may have to step back for dependency versions or builds); Note that while can’t change maintenance branch’s history, can push to it directly on upstream; If want to do trial conda builds, requires source/git_tag: 1.3.x and fake package/version: v1.3.1rc1. Tweak Conda for postrelease¶. In psi4-* recipes, find the best combination of master meta.yaml/build.sh and the v1N(x-1)-labeled ones. comment out any dependencies in master but not yet in postrelease; add {{ dep_bld }} entries if needed to step back build. make sure normal operation is ''. In cbcy,. create a postrelease new line and record anything not in continuous order with <> or blanking; step back any dependencies versions or build numbers to ones compatible with the postrelease. Do final pass before release tag¶. Check that psi4/external/ repos and commits have been updated to match conda recipes sources. Also check versions with conda_build_config.yaml; Check psi4/doc/sphinxman/source/introduc",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:4811,Integrability,depend,dependencies,4811," Changes to targets’ “source” and “version” in individual recipes should be edited in psi4 external/*/*/CMakeLists.txt files; Once everything’s working on Linux, repeat on Mac; At this point, ready to fine-tune builds of “Psi4 stack”. Assemble postrelease changes¶. Collect PRs with “backport” label, and request other backport suggestions on upcoming RN issue; Cherry-pick backport PRs and commits, apply other changes manually, not forgetting CI files; Do the draft parts of Publish GitHub postrelease; Test thoroughly locally, including psi4-rt (may have to step back for dependency versions or builds); Note that while can’t change maintenance branch’s history, can push to it directly on upstream; If want to do trial conda builds, requires source/git_tag: 1.3.x and fake package/version: v1.3.1rc1. Tweak Conda for postrelease¶. In psi4-* recipes, find the best combination of master meta.yaml/build.sh and the v1N(x-1)-labeled ones. comment out any dependencies in master but not yet in postrelease; add {{ dep_bld }} entries if needed to step back build. make sure normal operation is ''. In cbcy,. create a postrelease new line and record anything not in continuous order with <> or blanking; step back any dependencies versions or build numbers to ones compatible with the postrelease. Do final pass before release tag¶. Check that psi4/external/ repos and commits have been updated to match conda recipes sources. Also check versions with conda_build_config.yaml; Check psi4/doc/sphinxman/source/introduction.rst for any compiler and Python minimum requirements to edit. Tag (pre)release¶. Thorough version bump directions at master http://psicode.org/psi4manual/master/manage_git.html#how-to-bump-a-version; Below is tl;dr; # be on clean master up-to-date with upstream in both commits and tags; # * mind which version strings get ""v"" and which don't; # * if not fork, replace ""upstream"" with ""origin"". >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.p",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:5071,Integrability,depend,dependencies,5071," fine-tune builds of “Psi4 stack”. Assemble postrelease changes¶. Collect PRs with “backport” label, and request other backport suggestions on upcoming RN issue; Cherry-pick backport PRs and commits, apply other changes manually, not forgetting CI files; Do the draft parts of Publish GitHub postrelease; Test thoroughly locally, including psi4-rt (may have to step back for dependency versions or builds); Note that while can’t change maintenance branch’s history, can push to it directly on upstream; If want to do trial conda builds, requires source/git_tag: 1.3.x and fake package/version: v1.3.1rc1. Tweak Conda for postrelease¶. In psi4-* recipes, find the best combination of master meta.yaml/build.sh and the v1N(x-1)-labeled ones. comment out any dependencies in master but not yet in postrelease; add {{ dep_bld }} entries if needed to step back build. make sure normal operation is ''. In cbcy,. create a postrelease new line and record anything not in continuous order with <> or blanking; step back any dependencies versions or build numbers to ones compatible with the postrelease. Do final pass before release tag¶. Check that psi4/external/ repos and commits have been updated to match conda recipes sources. Also check versions with conda_build_config.yaml; Check psi4/doc/sphinxman/source/introduction.rst for any compiler and Python minimum requirements to edit. Tag (pre)release¶. Thorough version bump directions at master http://psicode.org/psi4manual/master/manage_git.html#how-to-bump-a-version; Below is tl;dr; # be on clean master up-to-date with upstream in both commits and tags; # * mind which version strings get ""v"" and which don't; # * if not fork, replace ""upstream"" with ""origin"". >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; ...; -__version__ = '1.3rc1'; -__version_long = '1.3rc1+5a7522a'; -__version_upcoming_annotated_v_tag = '1.3rc2'; +__version__ = '1.3rc2'; +__version_long = '1.3rc2+zzzzzzz'; +__version_upcoming_an",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:7906,Integrability,interface,interface,7906,"/branch_protection_rules/424295; # uncheck ""Include administrators"" and Save changes. >>> git push upstream master; >>> git push upstream v1.3rc2. # re-engage ""Include administrators"" protections. Tag postrelease¶. # be on clean maintenance branch up-to-date with upstream in both commits and tags; # * mind which version strings get ""v"" and which don't; # * if not fork, replace ""upstream"" with ""origin"". >>> git checkout 1.3.x; Switched to branch '1.3.x'. >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; ...; -__version__ = '1.3'; -__version_long = '1.3+zzzzzzz'; +__version__ = '1.3.1'; +__version_long = '1.3.1+zzzzzzz'. >>> git add psi4/metadata.py; >>> git commit -m ""v1.3.1""; [1.3.x 2ce1c29] v1.3.1. >>> git log --oneline | head -1; 786fb2b v1.3.1; >>> git tag -a v1.3.1 2ce1c29 -m ""v1.3.1"". # skipping the hash recording and ""upcoming"" step b/c only tags matter on maintenance branch. # free pushing to maintenance branches at present so GitHub interface steps not needed; # goto GH:psi4/psi4 > Settings > Branches > 1.3.x > Edit; # https://github.com/psi4/psi4/settings/branch_protection_rules/4385008 # !Varies!; # uncheck ""Include administrators"" and Save changes. >>> git push upstream 1.3.x; >>> git push upstream v1.3.1. # re-engage ""Include administrators"" protections. Initialize release branch¶. follow tagging procedure; before re-engaing the “include admin” button, push a branch at the tag commit (not the records commit); >>> git log --online | head -2; 45315cb Records tag for v1.3; 20e5c7e v1.3. >>> git checkout 20e5c7e; >>> git checkout -b 1.3.x; Switched to a new branch '1.3.x'; >>> git push upstream 1.3.x. set up new branch as protected branch through GitHub psi4 org Settings. Should be already covered under 1.*.x rule. Build Conda Psi4 stack at specific commit¶; By “Psi4 stack”, mean packages psi4, psi4-rt, psi4-dev.; Package psi4-docs used to be in “Psi4 stack”, but it’s handled by GHA and netlify now, not Conda, so skip di",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:9081,Integrability,depend,dependencies,9081,"ies!; # uncheck ""Include administrators"" and Save changes. >>> git push upstream 1.3.x; >>> git push upstream v1.3.1. # re-engage ""Include administrators"" protections. Initialize release branch¶. follow tagging procedure; before re-engaing the “include admin” button, push a branch at the tag commit (not the records commit); >>> git log --online | head -2; 45315cb Records tag for v1.3; 20e5c7e v1.3. >>> git checkout 20e5c7e; >>> git checkout -b 1.3.x; Switched to a new branch '1.3.x'; >>> git push upstream 1.3.x. set up new branch as protected branch through GitHub psi4 org Settings. Should be already covered under 1.*.x rule. Build Conda Psi4 stack at specific commit¶; By “Psi4 stack”, mean packages psi4, psi4-rt, psi4-dev.; Package psi4-docs used to be in “Psi4 stack”, but it’s handled by GHA and netlify now, not Conda, so skip directions below.; Other packages, the “ecosystem stack” (e.g., libint, v2rdm_casscf) should be already built. Check poodle for stray channels that may have crept in for dependencies (like c-f for ACS season). Copy over new dependencies if needed to psi4 channel; Particularly before release (not prerelease), consider max pinnings on dependencies, particularly any fast-moving dependencies (e.g., qcel) and whether they need version space to grow compatibly and grow incompatibly.; Nightly conda-builds work from master psi4. (Postrelease “practice” works from 1.N.x psi4.). Instead, switch source/git_tag from master to tag (e.g., v1.3rc1) in:. psi4-multiout on Linux & Mac, https://github.com/psi4/psi4meta/blob/master/conda-recipes/psi4-multiout/meta.yaml#L10; psi4-docs on Linux, https://github.com/psi4/psi4meta/blob/master/conda-recipes/psi4-docs/meta.yaml#L10 on L. In cbcy, edit psi4ver to “v”-less tag. For releases and postreleases (not prereleases), in conda_build_config.yaml, edit ltrtver to a new non-dev label (probably a ditto) matching the release (e.g., “1.3”); Set kitandkapoodle.py to the normal *** stack. Should be (psi4, psi4-rt, psi4-d",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:9135,Integrability,depend,dependencies,9135,"inistrators"" protections. Initialize release branch¶. follow tagging procedure; before re-engaing the “include admin” button, push a branch at the tag commit (not the records commit); >>> git log --online | head -2; 45315cb Records tag for v1.3; 20e5c7e v1.3. >>> git checkout 20e5c7e; >>> git checkout -b 1.3.x; Switched to a new branch '1.3.x'; >>> git push upstream 1.3.x. set up new branch as protected branch through GitHub psi4 org Settings. Should be already covered under 1.*.x rule. Build Conda Psi4 stack at specific commit¶; By “Psi4 stack”, mean packages psi4, psi4-rt, psi4-dev.; Package psi4-docs used to be in “Psi4 stack”, but it’s handled by GHA and netlify now, not Conda, so skip directions below.; Other packages, the “ecosystem stack” (e.g., libint, v2rdm_casscf) should be already built. Check poodle for stray channels that may have crept in for dependencies (like c-f for ACS season). Copy over new dependencies if needed to psi4 channel; Particularly before release (not prerelease), consider max pinnings on dependencies, particularly any fast-moving dependencies (e.g., qcel) and whether they need version space to grow compatibly and grow incompatibly.; Nightly conda-builds work from master psi4. (Postrelease “practice” works from 1.N.x psi4.). Instead, switch source/git_tag from master to tag (e.g., v1.3rc1) in:. psi4-multiout on Linux & Mac, https://github.com/psi4/psi4meta/blob/master/conda-recipes/psi4-multiout/meta.yaml#L10; psi4-docs on Linux, https://github.com/psi4/psi4meta/blob/master/conda-recipes/psi4-docs/meta.yaml#L10 on L. In cbcy, edit psi4ver to “v”-less tag. For releases and postreleases (not prereleases), in conda_build_config.yaml, edit ltrtver to a new non-dev label (probably a ditto) matching the release (e.g., “1.3”); Set kitandkapoodle.py to the normal *** stack. Should be (psi4, psi4-rt, psi4-dev) * python_versions for Linux & Mac. Also single psi4-docs from Linux; Run kitandkapoodle.py and allow stack to upload to anaconda.org to ps",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:9246,Integrability,depend,dependencies,9246,"inistrators"" protections. Initialize release branch¶. follow tagging procedure; before re-engaing the “include admin” button, push a branch at the tag commit (not the records commit); >>> git log --online | head -2; 45315cb Records tag for v1.3; 20e5c7e v1.3. >>> git checkout 20e5c7e; >>> git checkout -b 1.3.x; Switched to a new branch '1.3.x'; >>> git push upstream 1.3.x. set up new branch as protected branch through GitHub psi4 org Settings. Should be already covered under 1.*.x rule. Build Conda Psi4 stack at specific commit¶; By “Psi4 stack”, mean packages psi4, psi4-rt, psi4-dev.; Package psi4-docs used to be in “Psi4 stack”, but it’s handled by GHA and netlify now, not Conda, so skip directions below.; Other packages, the “ecosystem stack” (e.g., libint, v2rdm_casscf) should be already built. Check poodle for stray channels that may have crept in for dependencies (like c-f for ACS season). Copy over new dependencies if needed to psi4 channel; Particularly before release (not prerelease), consider max pinnings on dependencies, particularly any fast-moving dependencies (e.g., qcel) and whether they need version space to grow compatibly and grow incompatibly.; Nightly conda-builds work from master psi4. (Postrelease “practice” works from 1.N.x psi4.). Instead, switch source/git_tag from master to tag (e.g., v1.3rc1) in:. psi4-multiout on Linux & Mac, https://github.com/psi4/psi4meta/blob/master/conda-recipes/psi4-multiout/meta.yaml#L10; psi4-docs on Linux, https://github.com/psi4/psi4meta/blob/master/conda-recipes/psi4-docs/meta.yaml#L10 on L. In cbcy, edit psi4ver to “v”-less tag. For releases and postreleases (not prereleases), in conda_build_config.yaml, edit ltrtver to a new non-dev label (probably a ditto) matching the release (e.g., “1.3”); Set kitandkapoodle.py to the normal *** stack. Should be (psi4, psi4-rt, psi4-dev) * python_versions for Linux & Mac. Also single psi4-docs from Linux; Run kitandkapoodle.py and allow stack to upload to anaconda.org to ps",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:9289,Integrability,depend,dependencies,9289,"inistrators"" protections. Initialize release branch¶. follow tagging procedure; before re-engaing the “include admin” button, push a branch at the tag commit (not the records commit); >>> git log --online | head -2; 45315cb Records tag for v1.3; 20e5c7e v1.3. >>> git checkout 20e5c7e; >>> git checkout -b 1.3.x; Switched to a new branch '1.3.x'; >>> git push upstream 1.3.x. set up new branch as protected branch through GitHub psi4 org Settings. Should be already covered under 1.*.x rule. Build Conda Psi4 stack at specific commit¶; By “Psi4 stack”, mean packages psi4, psi4-rt, psi4-dev.; Package psi4-docs used to be in “Psi4 stack”, but it’s handled by GHA and netlify now, not Conda, so skip directions below.; Other packages, the “ecosystem stack” (e.g., libint, v2rdm_casscf) should be already built. Check poodle for stray channels that may have crept in for dependencies (like c-f for ACS season). Copy over new dependencies if needed to psi4 channel; Particularly before release (not prerelease), consider max pinnings on dependencies, particularly any fast-moving dependencies (e.g., qcel) and whether they need version space to grow compatibly and grow incompatibly.; Nightly conda-builds work from master psi4. (Postrelease “practice” works from 1.N.x psi4.). Instead, switch source/git_tag from master to tag (e.g., v1.3rc1) in:. psi4-multiout on Linux & Mac, https://github.com/psi4/psi4meta/blob/master/conda-recipes/psi4-multiout/meta.yaml#L10; psi4-docs on Linux, https://github.com/psi4/psi4meta/blob/master/conda-recipes/psi4-docs/meta.yaml#L10 on L. In cbcy, edit psi4ver to “v”-less tag. For releases and postreleases (not prereleases), in conda_build_config.yaml, edit ltrtver to a new non-dev label (probably a ditto) matching the release (e.g., “1.3”); Set kitandkapoodle.py to the normal *** stack. Should be (psi4, psi4-rt, psi4-dev) * python_versions for Linux & Mac. Also single psi4-docs from Linux; Run kitandkapoodle.py and allow stack to upload to anaconda.org to ps",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:10482,Integrability,depend,dependencies,10482,".N.x psi4.). Instead, switch source/git_tag from master to tag (e.g., v1.3rc1) in:. psi4-multiout on Linux & Mac, https://github.com/psi4/psi4meta/blob/master/conda-recipes/psi4-multiout/meta.yaml#L10; psi4-docs on Linux, https://github.com/psi4/psi4meta/blob/master/conda-recipes/psi4-docs/meta.yaml#L10 on L. In cbcy, edit psi4ver to “v”-less tag. For releases and postreleases (not prereleases), in conda_build_config.yaml, edit ltrtver to a new non-dev label (probably a ditto) matching the release (e.g., “1.3”); Set kitandkapoodle.py to the normal *** stack. Should be (psi4, psi4-rt, psi4-dev) * python_versions for Linux & Mac. Also single psi4-docs from Linux; Run kitandkapoodle.py and allow stack to upload to anaconda.org to psi4/label/dev. Poodle emits with --label dev so will go to the subchannel. May need to delete packages to clear out space on anaconda.org; Copy meta.yaml and build.sh of at least psi4-multiout and psi4-rt to e.g., v121-build.sh files for easy reference or rebuilding as dependencies in master change. Publish to main conda label¶. Go through each active conda package off https://anaconda.org/psi4/repo. Find the most recent build set (Linux/Mac, active py versions) that psi4/psi4-rt/psi4-dev is using; _add_ (not replace) the main label. This makes a conda install psi4 -c psi4 get everything psi4 needs. For the moment conda install psi4 -c psi4/label/dev will get the same set, until package psi4-1.4a1.dev1 gets uploaded. May help to check versions and build versions against ltrtver in conda_build_config.yaml.; This step is manual, so takes a while. (It gets checked when Psi4conda installers are built b/c that pulls from “main”, not “dev”). Build Psi4conda set (pre-Spring 2021)¶; Installers are build using the project constructor and build binary bash scripts, one per OS per Python version. In analogy to Miniconda, they’re called Psi4Conda. They can be built anywhere (Mac can be built on Linux) and get served from vergil (cdsgroup webserver). Need ",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:15984,Integrability,message,messages,15984,"H has assigned them. These artifacts only linger for a day.; Log in to vergil root and move to /var/www/html/psicode-download.; Use the pull_gha_installers script to download the installers from GH to vergil. First two arguments are first and last of the artifact numbers, and third argument is an auth token. bash pull_gha_installers.sh 47226565 47226573 715...4f3.; Make WindowsWSL and any other symlinks the script head matter advises. Generate download page for psicode.org¶. Be in repo psicode-hugo-website; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/content/installs/v13rc2.md. Note the edition string v13rc2 in frontmatter for this and future filenames; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/data/installs/v13rc2.yaml for menu and notes content; Enter scripts/ dir and edit primarily https://github.com/psi4/psicode-hugo-website/blob/master/scripts/install-generator.py#L9 but also any other arrays or messages that should change.; Run the install-generator.py in place. It will dump new files into data/installs/ _subdirs_. Be sure to git add them.; Installer page is now ready.; Shift “latest” alias in frontmatter from whichever page is currently active to the new page. This makes sure “Downloads” on the navigation bar points to new page.; Conscientiously, one should test. installer downloads in Mac and Linux. And actually installing them and psi4 --test them.; that download button and curl downloading register on the download counters on vergil. Commit the new files, PR, and deploy psicode site; Petition on Slack for testers. Collect documentation snapshot¶. Documentation is built automatically by GHA from the latest psi4 master commit. It gets pushed to the psi4/psi4docs repository and thence served by netlify to a site independent of psicode.org. The netlify psicode.org site has a redirect so that psicode.org/psi4manual/master presents the psi4docs netlify content.; GHA controll",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:19000,Integrability,depend,dependencies,19000,"itHub postrelease¶. On GitHub site “Draft a New Release” for anticipated or newly minted tag; Fill in frontmatter style and links from previous GitHub release; Fill in RN as cherry-pick to or edit on branch; “publish” release. This establishes release date for GitHub API. Publish psicode release¶. Copy a recent release page like https://github.com/psi4/psicode-hugo-website/blob/master/content/posts/v1p2.md; Edit its filename, title, date, image, and links; Execute https://api.github.com/repos/psi4/psi4/releases/latest and note the id field value; Use the id value in the shortcode call at the bottom. Finalize release¶. Make new PR with; * edits to main README.md badges, python versions, etc.; * edits to CMakeLists.txt find_package(PythonLibsNew 3.6 REQUIRED); Tweet about release. Reset psi4meta for nightly operation¶; On both Linux and Mac:. After (post)release (not prerelease), in conda_build_config.yaml, edit ltrtver to a new “release.dev” label; After postrelease, unpin any dependencies in cbcy that needed older either ver or bld (e.g., v2rdm_casscf_bld); Edit psi4ver back to '' in cbcy; Edit source/git_tag back to master for psi4-multiout, psi4-docs; Edit build string back to 0 if psi4-multiout needed multiple passes; Edit kitandkapoodle.py back to *** stack; Check in all release, construct, recipe changes on Linux and Mac. Synchronize both to GitHub psi4meta; Copy meta.yaml and build.sh files to vMmp-prefixed files for the record.; Edit crontab back to 2am “norm”. Comment out “anom”. table of contents. Release Procedures; Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1); Update copyright year; Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag (pre)release; Tag postrelease; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set ",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:3621,Modifiability,plugin,plugin,3621,"ns are in [cbcy](https://github.com/psi4/psi4meta/blob/master/conda-recipes/conda_build_config.yaml) and [poodle](https://github.com/psi4/psi4meta/blob/master/psinet-nightly/kitandkapoodle.py); A couple weeks before the first “rc” is planned, start going through L/LT in poodle, checking with upstream to see if new versions have been released. If good changes present, rebuild the packages, changing the version numbers in the respective recipes; When L/LT all built and passed, edit the individual package version numbers in cbcy and increment to a new ltrtver with updated version numbers and/or build numbers (only if code changes); Build L/PSI4. If any trouble, edit psi4 code. Iterate until builds and passes. This stage is the only full ctest & pytest on Psi4+upstream; Build L/RT-MP. If any trouble, edit code in L/RT and rebuild those package(s). Iterate until builds and passes. This stage is the only full ctest & pytest of Psi4+downstream; Build L/DEV. If any trouble, edit psi4 build system, plugin system, or OpenMP setup. Iterate until builds and passes; Build L/DOCS. If any trouble, edit the docs or the tests. Iterate until builds and passes; Results of last should upload to psicode.org (docs) and codecov.io (coverage); Changes to targets’ “source” and “version” in individual recipes should be edited in psi4 external/*/*/CMakeLists.txt files; Once everything’s working on Linux, repeat on Mac; At this point, ready to fine-tune builds of “Psi4 stack”. Assemble postrelease changes¶. Collect PRs with “backport” label, and request other backport suggestions on upcoming RN issue; Cherry-pick backport PRs and commits, apply other changes manually, not forgetting CI files; Do the draft parts of Publish GitHub postrelease; Test thoroughly locally, including psi4-rt (may have to step back for dependency versions or builds); Note that while can’t change maintenance branch’s history, can push to it directly on upstream; If want to do trial conda builds, requires source/git_tag:",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:4061,Performance,tune,tune,4061,"numbers in the respective recipes; When L/LT all built and passed, edit the individual package version numbers in cbcy and increment to a new ltrtver with updated version numbers and/or build numbers (only if code changes); Build L/PSI4. If any trouble, edit psi4 code. Iterate until builds and passes. This stage is the only full ctest & pytest on Psi4+upstream; Build L/RT-MP. If any trouble, edit code in L/RT and rebuild those package(s). Iterate until builds and passes. This stage is the only full ctest & pytest of Psi4+downstream; Build L/DEV. If any trouble, edit psi4 build system, plugin system, or OpenMP setup. Iterate until builds and passes; Build L/DOCS. If any trouble, edit the docs or the tests. Iterate until builds and passes; Results of last should upload to psicode.org (docs) and codecov.io (coverage); Changes to targets’ “source” and “version” in individual recipes should be edited in psi4 external/*/*/CMakeLists.txt files; Once everything’s working on Linux, repeat on Mac; At this point, ready to fine-tune builds of “Psi4 stack”. Assemble postrelease changes¶. Collect PRs with “backport” label, and request other backport suggestions on upcoming RN issue; Cherry-pick backport PRs and commits, apply other changes manually, not forgetting CI files; Do the draft parts of Publish GitHub postrelease; Test thoroughly locally, including psi4-rt (may have to step back for dependency versions or builds); Note that while can’t change maintenance branch’s history, can push to it directly on upstream; If want to do trial conda builds, requires source/git_tag: 1.3.x and fake package/version: v1.3.1rc1. Tweak Conda for postrelease¶. In psi4-* recipes, find the best combination of master meta.yaml/build.sh and the v1N(x-1)-labeled ones. comment out any dependencies in master but not yet in postrelease; add {{ dep_bld }} entries if needed to step back build. make sure normal operation is ''. In cbcy,. create a postrelease new line and record anything not in continuous ",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:12494,Performance,cache,cached,12494,"kiecutter. This env presently accessed through conda activate cookie.; Enter “constructor-cutter-unified” in the psi4meta repo. There’s a good README there, https://github.com/psi4/psi4meta/blob/master/conda-recipes/constructor-cutter-unified/README.md; Edit cookiecutter/cookiecutter.json for control. Edit which python versions, if necessary; Edit release field; Edit hash field. This is the 7-char hash that’s on every psi4 conda pkg as part of version; Edit ltrtver field. This matches the current setting in conda_build_config.yaml; For prereleases, ""channel_tag"": ""/label/dev"", while for (post)releases, it should be the empty string; Leave this file set to a “rc” with Git, as that has more details. For (post)releases (not prereleases), copy cookiecutter.json to cookiecutter.json-vXXX; Edit cookiecutter/{{.../construct.yaml for templating. This is rarely needed; If it’s been a while or you need the space, clear out ~/.conda/constructor, where the downloaded packages are cached; Note that installers get written to build/ and this gets regenerated each time. Clear out between runs.; python run.py; [Outdated] Watch out for py_ in buildstring as this means a noarch package has been pulled. It must be eliminated. Constructors can’t handle “noarch” packages and will fail at runtime. If see a “noarch” package, must find the recipe and rebuild for all OS & Python combinations. Then run constructor again.; [Replacement] After adding a post_install to reposition the noarch packages, they are safe to include.; If fetching times out, may have to run run.py several times. Clear out build/ in between. It’s the fetching that takes a long time, not constucting; In the end, should have several installers; >>> ls -l build/psi4conda-1.3-py3.*/*64.sh; -rwxr-xr-x. 516M Feb 28 20:30 build/psi4conda-1.3-py3.6-linux-64/psi4conda-1.3-py36-Linux-x86_64.sh; -rwxr-xr-x. 299M Feb 28 20:31 build/psi4conda-1.3-py3.6-osx-64/psi4conda-1.3-py36-MacOSX-x86_64.sh; -rwxr-xr-x. 518M Feb 28 20:30 build/psi",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:13016,Safety,safe,safe,13016," field. This matches the current setting in conda_build_config.yaml; For prereleases, ""channel_tag"": ""/label/dev"", while for (post)releases, it should be the empty string; Leave this file set to a “rc” with Git, as that has more details. For (post)releases (not prereleases), copy cookiecutter.json to cookiecutter.json-vXXX; Edit cookiecutter/{{.../construct.yaml for templating. This is rarely needed; If it’s been a while or you need the space, clear out ~/.conda/constructor, where the downloaded packages are cached; Note that installers get written to build/ and this gets regenerated each time. Clear out between runs.; python run.py; [Outdated] Watch out for py_ in buildstring as this means a noarch package has been pulled. It must be eliminated. Constructors can’t handle “noarch” packages and will fail at runtime. If see a “noarch” package, must find the recipe and rebuild for all OS & Python combinations. Then run constructor again.; [Replacement] After adding a post_install to reposition the noarch packages, they are safe to include.; If fetching times out, may have to run run.py several times. Clear out build/ in between. It’s the fetching that takes a long time, not constucting; In the end, should have several installers; >>> ls -l build/psi4conda-1.3-py3.*/*64.sh; -rwxr-xr-x. 516M Feb 28 20:30 build/psi4conda-1.3-py3.6-linux-64/psi4conda-1.3-py36-Linux-x86_64.sh; -rwxr-xr-x. 299M Feb 28 20:31 build/psi4conda-1.3-py3.6-osx-64/psi4conda-1.3-py36-MacOSX-x86_64.sh; -rwxr-xr-x. 518M Feb 28 20:30 build/psi4conda-1.3-py3.7-linux-64/psi4conda-1.3-py37-Linux-x86_64.sh; -rwxr-xr-x. 299M Feb 28 20:31 build/psi4conda-1.3-py3.7-osx-64/psi4conda-1.3-py37-MacOSX-x86_64.sh. Upload installer files to vergil, scp -r build/Psi4*/Psi4*sh root@vergil.chemistry.gatech.edu:/var/www/html/psicode-download/; Log in to vergil root and make WindowsWSL symlinks. Build Psi4conda set¶; Installers are build using the project constructor and build binary bash or exe scripts, one per OS per Py",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:7767,Security,hash,hash,7767,"ag for v1.3rc2. # goto GH:psi4/psi4 > Settings > Branches > master > Edit; # https://github.com/psi4/psi4/settings/branch_protection_rules/424295; # uncheck ""Include administrators"" and Save changes. >>> git push upstream master; >>> git push upstream v1.3rc2. # re-engage ""Include administrators"" protections. Tag postrelease¶. # be on clean maintenance branch up-to-date with upstream in both commits and tags; # * mind which version strings get ""v"" and which don't; # * if not fork, replace ""upstream"" with ""origin"". >>> git checkout 1.3.x; Switched to branch '1.3.x'. >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; ...; -__version__ = '1.3'; -__version_long = '1.3+zzzzzzz'; +__version__ = '1.3.1'; +__version_long = '1.3.1+zzzzzzz'. >>> git add psi4/metadata.py; >>> git commit -m ""v1.3.1""; [1.3.x 2ce1c29] v1.3.1. >>> git log --oneline | head -1; 786fb2b v1.3.1; >>> git tag -a v1.3.1 2ce1c29 -m ""v1.3.1"". # skipping the hash recording and ""upcoming"" step b/c only tags matter on maintenance branch. # free pushing to maintenance branches at present so GitHub interface steps not needed; # goto GH:psi4/psi4 > Settings > Branches > 1.3.x > Edit; # https://github.com/psi4/psi4/settings/branch_protection_rules/4385008 # !Varies!; # uncheck ""Include administrators"" and Save changes. >>> git push upstream 1.3.x; >>> git push upstream v1.3.1. # re-engage ""Include administrators"" protections. Initialize release branch¶. follow tagging procedure; before re-engaing the “include admin” button, push a branch at the tag commit (not the records commit); >>> git log --online | head -2; 45315cb Records tag for v1.3; 20e5c7e v1.3. >>> git checkout 20e5c7e; >>> git checkout -b 1.3.x; Switched to a new branch '1.3.x'; >>> git push upstream 1.3.x. set up new branch as protected branch through GitHub psi4 org Settings. Should be already covered under 1.*.x rule. Build Conda Psi4 stack at specific commit¶; By “Psi4 stack”, mean packages psi4, psi4-rt, psi4",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:11541,Security,access,accessed,11541,"ugh each active conda package off https://anaconda.org/psi4/repo. Find the most recent build set (Linux/Mac, active py versions) that psi4/psi4-rt/psi4-dev is using; _add_ (not replace) the main label. This makes a conda install psi4 -c psi4 get everything psi4 needs. For the moment conda install psi4 -c psi4/label/dev will get the same set, until package psi4-1.4a1.dev1 gets uploaded. May help to check versions and build versions against ltrtver in conda_build_config.yaml.; This step is manual, so takes a while. (It gets checked when Psi4conda installers are built b/c that pulls from “main”, not “dev”). Build Psi4conda set (pre-Spring 2021)¶; Installers are build using the project constructor and build binary bash scripts, one per OS per Python version. In analogy to Miniconda, they’re called Psi4Conda. They can be built anywhere (Mac can be built on Linux) and get served from vergil (cdsgroup webserver). Need a conda env with constructor and cookiecutter. This env presently accessed through conda activate cookie.; Enter “constructor-cutter-unified” in the psi4meta repo. There’s a good README there, https://github.com/psi4/psi4meta/blob/master/conda-recipes/constructor-cutter-unified/README.md; Edit cookiecutter/cookiecutter.json for control. Edit which python versions, if necessary; Edit release field; Edit hash field. This is the 7-char hash that’s on every psi4 conda pkg as part of version; Edit ltrtver field. This matches the current setting in conda_build_config.yaml; For prereleases, ""channel_tag"": ""/label/dev"", while for (post)releases, it should be the empty string; Leave this file set to a “rc” with Git, as that has more details. For (post)releases (not prereleases), copy cookiecutter.json to cookiecutter.json-vXXX; Edit cookiecutter/{{.../construct.yaml for templating. This is rarely needed; If it’s been a while or you need the space, clear out ~/.conda/constructor, where the downloaded packages are cached; Note that installers get written to build/ and th",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:11881,Security,hash,hash,11881," -c psi4/label/dev will get the same set, until package psi4-1.4a1.dev1 gets uploaded. May help to check versions and build versions against ltrtver in conda_build_config.yaml.; This step is manual, so takes a while. (It gets checked when Psi4conda installers are built b/c that pulls from “main”, not “dev”). Build Psi4conda set (pre-Spring 2021)¶; Installers are build using the project constructor and build binary bash scripts, one per OS per Python version. In analogy to Miniconda, they’re called Psi4Conda. They can be built anywhere (Mac can be built on Linux) and get served from vergil (cdsgroup webserver). Need a conda env with constructor and cookiecutter. This env presently accessed through conda activate cookie.; Enter “constructor-cutter-unified” in the psi4meta repo. There’s a good README there, https://github.com/psi4/psi4meta/blob/master/conda-recipes/constructor-cutter-unified/README.md; Edit cookiecutter/cookiecutter.json for control. Edit which python versions, if necessary; Edit release field; Edit hash field. This is the 7-char hash that’s on every psi4 conda pkg as part of version; Edit ltrtver field. This matches the current setting in conda_build_config.yaml; For prereleases, ""channel_tag"": ""/label/dev"", while for (post)releases, it should be the empty string; Leave this file set to a “rc” with Git, as that has more details. For (post)releases (not prereleases), copy cookiecutter.json to cookiecutter.json-vXXX; Edit cookiecutter/{{.../construct.yaml for templating. This is rarely needed; If it’s been a while or you need the space, clear out ~/.conda/constructor, where the downloaded packages are cached; Note that installers get written to build/ and this gets regenerated each time. Clear out between runs.; python run.py; [Outdated] Watch out for py_ in buildstring as this means a noarch package has been pulled. It must be eliminated. Constructors can’t handle “noarch” packages and will fail at runtime. If see a “noarch” package, must find the recip",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:11912,Security,hash,hash,11912,"May help to check versions and build versions against ltrtver in conda_build_config.yaml.; This step is manual, so takes a while. (It gets checked when Psi4conda installers are built b/c that pulls from “main”, not “dev”). Build Psi4conda set (pre-Spring 2021)¶; Installers are build using the project constructor and build binary bash scripts, one per OS per Python version. In analogy to Miniconda, they’re called Psi4Conda. They can be built anywhere (Mac can be built on Linux) and get served from vergil (cdsgroup webserver). Need a conda env with constructor and cookiecutter. This env presently accessed through conda activate cookie.; Enter “constructor-cutter-unified” in the psi4meta repo. There’s a good README there, https://github.com/psi4/psi4meta/blob/master/conda-recipes/constructor-cutter-unified/README.md; Edit cookiecutter/cookiecutter.json for control. Edit which python versions, if necessary; Edit release field; Edit hash field. This is the 7-char hash that’s on every psi4 conda pkg as part of version; Edit ltrtver field. This matches the current setting in conda_build_config.yaml; For prereleases, ""channel_tag"": ""/label/dev"", while for (post)releases, it should be the empty string; Leave this file set to a “rc” with Git, as that has more details. For (post)releases (not prereleases), copy cookiecutter.json to cookiecutter.json-vXXX; Edit cookiecutter/{{.../construct.yaml for templating. This is rarely needed; If it’s been a while or you need the space, clear out ~/.conda/constructor, where the downloaded packages are cached; Note that installers get written to build/ and this gets regenerated each time. Clear out between runs.; python run.py; [Outdated] Watch out for py_ in buildstring as this means a noarch package has been pulled. It must be eliminated. Constructors can’t handle “noarch” packages and will fail at runtime. If see a “noarch” package, must find the recipe and rebuild for all OS & Python combinations. Then run constructor again.; [Replaceme",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:1527,Testability,test,tests,1527,"lease tag; Tag (pre)release; Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Post-Release (e.g., v1.3.1)¶. Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag postrelease; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Update copyright year¶. cd ~/path/to/psi4; Primary target is licenses. grep -rl ""(c) 2007-2017"" * | xargs sed -i '' ""s/(c) 2007-2017/(c) 2007-2018/g""; On Linux, drop the '' in above command; Need to do psi4/ and docs/ dirs. Also, license in these files. tests/runtest.py; README.md; tests/psitest.pl. Also, in content of psi4/doc/sphinxman/source/conf.py.in#L130. Update samples¶. Run make sphinxman at least once by hand; Check in resulting psifiles.py and all the updated and new samples/ files and dirs; Make a lone PR and warn reviewers not to read it, since autogenerated. Collect new authors¶. Survey contributions to current Milestone. Add new contribs and PR lists to release notes GitHub issue; Figure out any new “Additional Contributors” authors since last release; Edit psi4/header.py accordingly, make PR; Get permission of new authors and their particulars for codemeta.json; Invite any contributors with at least 3 PRs to join GitHub Organization. Anticipate next release¶. Bump version in codemeta.json, psi4/codemeta.json#L9; Add to branch list in azure-pipelines.yml, psi4/azure-pipelines.yml. Build Conda ecosystem stack¶; By “ecosystem stack”, mean packages that are upstream, downstream, required, and optional for a fully featured Psi4 bui",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:1556,Testability,test,tests,1556," Initialize release branch; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Post-Release (e.g., v1.3.1)¶. Assemble postrelease changes; Tweak Conda for postrelease; Do final pass before release tag; Tag postrelease; Build Conda Psi4 stack at specific commit; Publish to main conda label; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub postrelease; Publish psicode release; Finalize release; Reset psi4meta for nightly operation. Update copyright year¶. cd ~/path/to/psi4; Primary target is licenses. grep -rl ""(c) 2007-2017"" * | xargs sed -i '' ""s/(c) 2007-2017/(c) 2007-2018/g""; On Linux, drop the '' in above command; Need to do psi4/ and docs/ dirs. Also, license in these files. tests/runtest.py; README.md; tests/psitest.pl. Also, in content of psi4/doc/sphinxman/source/conf.py.in#L130. Update samples¶. Run make sphinxman at least once by hand; Check in resulting psifiles.py and all the updated and new samples/ files and dirs; Make a lone PR and warn reviewers not to read it, since autogenerated. Collect new authors¶. Survey contributions to current Milestone. Add new contribs and PR lists to release notes GitHub issue; Figure out any new “Additional Contributors” authors since last release; Edit psi4/header.py accordingly, make PR; Get permission of new authors and their particulars for codemeta.json; Invite any contributors with at least 3 PRs to join GitHub Organization. Anticipate next release¶. Bump version in codemeta.json, psi4/codemeta.json#L9; Add to branch list in azure-pipelines.yml, psi4/azure-pipelines.yml. Build Conda ecosystem stack¶; By “ecosystem stack”, mean packages that are upstream, downstream, required, and optional for a fully featured Psi4 build and which we can’t get f",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:3737,Testability,test,tests,3737,"[poodle](https://github.com/psi4/psi4meta/blob/master/psinet-nightly/kitandkapoodle.py); A couple weeks before the first “rc” is planned, start going through L/LT in poodle, checking with upstream to see if new versions have been released. If good changes present, rebuild the packages, changing the version numbers in the respective recipes; When L/LT all built and passed, edit the individual package version numbers in cbcy and increment to a new ltrtver with updated version numbers and/or build numbers (only if code changes); Build L/PSI4. If any trouble, edit psi4 code. Iterate until builds and passes. This stage is the only full ctest & pytest on Psi4+upstream; Build L/RT-MP. If any trouble, edit code in L/RT and rebuild those package(s). Iterate until builds and passes. This stage is the only full ctest & pytest of Psi4+downstream; Build L/DEV. If any trouble, edit psi4 build system, plugin system, or OpenMP setup. Iterate until builds and passes; Build L/DOCS. If any trouble, edit the docs or the tests. Iterate until builds and passes; Results of last should upload to psicode.org (docs) and codecov.io (coverage); Changes to targets’ “source” and “version” in individual recipes should be edited in psi4 external/*/*/CMakeLists.txt files; Once everything’s working on Linux, repeat on Mac; At this point, ready to fine-tune builds of “Psi4 stack”. Assemble postrelease changes¶. Collect PRs with “backport” label, and request other backport suggestions on upcoming RN issue; Cherry-pick backport PRs and commits, apply other changes manually, not forgetting CI files; Do the draft parts of Publish GitHub postrelease; Test thoroughly locally, including psi4-rt (may have to step back for dependency versions or builds); Note that while can’t change maintenance branch’s history, can push to it directly on upstream; If want to do trial conda builds, requires source/git_tag: 1.3.x and fake package/version: v1.3.1rc1. Tweak Conda for postrelease¶. In psi4-* recipes, find the bes",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:6175,Testability,log,log,6175,"eck that psi4/external/ repos and commits have been updated to match conda recipes sources. Also check versions with conda_build_config.yaml; Check psi4/doc/sphinxman/source/introduction.rst for any compiler and Python minimum requirements to edit. Tag (pre)release¶. Thorough version bump directions at master http://psicode.org/psi4manual/master/manage_git.html#how-to-bump-a-version; Below is tl;dr; # be on clean master up-to-date with upstream in both commits and tags; # * mind which version strings get ""v"" and which don't; # * if not fork, replace ""upstream"" with ""origin"". >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; ...; -__version__ = '1.3rc1'; -__version_long = '1.3rc1+5a7522a'; -__version_upcoming_annotated_v_tag = '1.3rc2'; +__version__ = '1.3rc2'; +__version_long = '1.3rc2+zzzzzzz'; +__version_upcoming_annotated_v_tag = '1.3rc3'. >>> git add psi4/metadata.py; >>> git commit -m ""v1.3rc2""; [master bc8d7f5] v1.3rc2. >>> git log --oneline | head -1; bc8d7f5 v1.3rc2; >>> git tag -a v1.3rc2 bc8d7f5 -m ""v1.3rc2"". # pause here and push to upstream and let Azure complete if want an; # on-tag Windows conda package, not just tag+1.dev1; # below pushes commit and tag together so only one CI; # > git push --atomic upstream master v1.5; # also, grab the docs build from GHA artifacts. >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; ...; -__version_long = '1.3rc2+zzzzzzz'; +__version_long = '1.3rc2+bc8d7f5'. >>> git add psi4/metadata.py; >>> git commit -m ""Records tag for v1.3rc2""; [master 16dbd3e] Records tag for v1.3rc2. # goto GH:psi4/psi4 > Settings > Branches > master > Edit; # https://github.com/psi4/psi4/settings/branch_protection_rules/424295; # uncheck ""Include administrators"" and Save changes. >>> git push upstream master; >>> git push upstream v1.3rc2. # re-engage ""Include administrators"" protections. Tag postrelease¶. # be on clean maintenance branch up-to-date with upstream in b",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:7668,Testability,log,log,7668,".3rc2+bc8d7f5'. >>> git add psi4/metadata.py; >>> git commit -m ""Records tag for v1.3rc2""; [master 16dbd3e] Records tag for v1.3rc2. # goto GH:psi4/psi4 > Settings > Branches > master > Edit; # https://github.com/psi4/psi4/settings/branch_protection_rules/424295; # uncheck ""Include administrators"" and Save changes. >>> git push upstream master; >>> git push upstream v1.3rc2. # re-engage ""Include administrators"" protections. Tag postrelease¶. # be on clean maintenance branch up-to-date with upstream in both commits and tags; # * mind which version strings get ""v"" and which don't; # * if not fork, replace ""upstream"" with ""origin"". >>> git checkout 1.3.x; Switched to branch '1.3.x'. >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; ...; -__version__ = '1.3'; -__version_long = '1.3+zzzzzzz'; +__version__ = '1.3.1'; +__version_long = '1.3.1+zzzzzzz'. >>> git add psi4/metadata.py; >>> git commit -m ""v1.3.1""; [1.3.x 2ce1c29] v1.3.1. >>> git log --oneline | head -1; 786fb2b v1.3.1; >>> git tag -a v1.3.1 2ce1c29 -m ""v1.3.1"". # skipping the hash recording and ""upcoming"" step b/c only tags matter on maintenance branch. # free pushing to maintenance branches at present so GitHub interface steps not needed; # goto GH:psi4/psi4 > Settings > Branches > 1.3.x > Edit; # https://github.com/psi4/psi4/settings/branch_protection_rules/4385008 # !Varies!; # uncheck ""Include administrators"" and Save changes. >>> git push upstream 1.3.x; >>> git push upstream v1.3.1. # re-engage ""Include administrators"" protections. Initialize release branch¶. follow tagging procedure; before re-engaing the “include admin” button, push a branch at the tag commit (not the records commit); >>> git log --online | head -2; 45315cb Records tag for v1.3; 20e5c7e v1.3. >>> git checkout 20e5c7e; >>> git checkout -b 1.3.x; Switched to a new branch '1.3.x'; >>> git push upstream 1.3.x. set up new branch as protected branch through GitHub psi4 org Settings. Should be already cove",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:8404,Testability,log,log,8404," '1.3.x'. >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; ...; -__version__ = '1.3'; -__version_long = '1.3+zzzzzzz'; +__version__ = '1.3.1'; +__version_long = '1.3.1+zzzzzzz'. >>> git add psi4/metadata.py; >>> git commit -m ""v1.3.1""; [1.3.x 2ce1c29] v1.3.1. >>> git log --oneline | head -1; 786fb2b v1.3.1; >>> git tag -a v1.3.1 2ce1c29 -m ""v1.3.1"". # skipping the hash recording and ""upcoming"" step b/c only tags matter on maintenance branch. # free pushing to maintenance branches at present so GitHub interface steps not needed; # goto GH:psi4/psi4 > Settings > Branches > 1.3.x > Edit; # https://github.com/psi4/psi4/settings/branch_protection_rules/4385008 # !Varies!; # uncheck ""Include administrators"" and Save changes. >>> git push upstream 1.3.x; >>> git push upstream v1.3.1. # re-engage ""Include administrators"" protections. Initialize release branch¶. follow tagging procedure; before re-engaing the “include admin” button, push a branch at the tag commit (not the records commit); >>> git log --online | head -2; 45315cb Records tag for v1.3; 20e5c7e v1.3. >>> git checkout 20e5c7e; >>> git checkout -b 1.3.x; Switched to a new branch '1.3.x'; >>> git push upstream 1.3.x. set up new branch as protected branch through GitHub psi4 org Settings. Should be already covered under 1.*.x rule. Build Conda Psi4 stack at specific commit¶; By “Psi4 stack”, mean packages psi4, psi4-rt, psi4-dev.; Package psi4-docs used to be in “Psi4 stack”, but it’s handled by GHA and netlify now, not Conda, so skip directions below.; Other packages, the “ecosystem stack” (e.g., libint, v2rdm_casscf) should be already built. Check poodle for stray channels that may have crept in for dependencies (like c-f for ACS season). Copy over new dependencies if needed to psi4 channel; Particularly before release (not prerelease), consider max pinnings on dependencies, particularly any fast-moving dependencies (e.g., qcel) and whether they need version space to grow c",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:16355,Testability,test,test,16355,"4f3.; Make WindowsWSL and any other symlinks the script head matter advises. Generate download page for psicode.org¶. Be in repo psicode-hugo-website; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/content/installs/v13rc2.md. Note the edition string v13rc2 in frontmatter for this and future filenames; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/data/installs/v13rc2.yaml for menu and notes content; Enter scripts/ dir and edit primarily https://github.com/psi4/psicode-hugo-website/blob/master/scripts/install-generator.py#L9 but also any other arrays or messages that should change.; Run the install-generator.py in place. It will dump new files into data/installs/ _subdirs_. Be sure to git add them.; Installer page is now ready.; Shift “latest” alias in frontmatter from whichever page is currently active to the new page. This makes sure “Downloads” on the navigation bar points to new page.; Conscientiously, one should test. installer downloads in Mac and Linux. And actually installing them and psi4 --test them.; that download button and curl downloading register on the download counters on vergil. Commit the new files, PR, and deploy psicode site; Petition on Slack for testers. Collect documentation snapshot¶. Documentation is built automatically by GHA from the latest psi4 master commit. It gets pushed to the psi4/psi4docs repository and thence served by netlify to a site independent of psicode.org. The netlify psicode.org site has a redirect so that psicode.org/psi4manual/master presents the psi4docs netlify content.; GHA controller is psi4/.github/workflows/docs.yml; This setup works great for “latest” docs, but it won’t build a nice copy on the tag because the tag commit is pushed before the tag itself, so the version shows up “undefined”.; So, anytime after “Tag (pre)release” is over, navigate on psi4 GH to the tag commit (not the record commit) and retrigger the docs GHA. Download ",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:16439,Testability,test,test,16439,"rate download page for psicode.org¶. Be in repo psicode-hugo-website; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/content/installs/v13rc2.md. Note the edition string v13rc2 in frontmatter for this and future filenames; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/data/installs/v13rc2.yaml for menu and notes content; Enter scripts/ dir and edit primarily https://github.com/psi4/psicode-hugo-website/blob/master/scripts/install-generator.py#L9 but also any other arrays or messages that should change.; Run the install-generator.py in place. It will dump new files into data/installs/ _subdirs_. Be sure to git add them.; Installer page is now ready.; Shift “latest” alias in frontmatter from whichever page is currently active to the new page. This makes sure “Downloads” on the navigation bar points to new page.; Conscientiously, one should test. installer downloads in Mac and Linux. And actually installing them and psi4 --test them.; that download button and curl downloading register on the download counters on vergil. Commit the new files, PR, and deploy psicode site; Petition on Slack for testers. Collect documentation snapshot¶. Documentation is built automatically by GHA from the latest psi4 master commit. It gets pushed to the psi4/psi4docs repository and thence served by netlify to a site independent of psicode.org. The netlify psicode.org site has a redirect so that psicode.org/psi4manual/master presents the psi4docs netlify content.; GHA controller is psi4/.github/workflows/docs.yml; This setup works great for “latest” docs, but it won’t build a nice copy on the tag because the tag commit is pushed before the tag itself, so the version shows up “undefined”.; So, anytime after “Tag (pre)release” is over, navigate on psi4 GH to the tag commit (not the record commit) and retrigger the docs GHA. Download the artifact (zipped docs dir) at the end to a local computer.; In your hugo site",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:16611,Testability,test,testers,16611,"er/content/installs/v13rc2.md. Note the edition string v13rc2 in frontmatter for this and future filenames; Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/data/installs/v13rc2.yaml for menu and notes content; Enter scripts/ dir and edit primarily https://github.com/psi4/psicode-hugo-website/blob/master/scripts/install-generator.py#L9 but also any other arrays or messages that should change.; Run the install-generator.py in place. It will dump new files into data/installs/ _subdirs_. Be sure to git add them.; Installer page is now ready.; Shift “latest” alias in frontmatter from whichever page is currently active to the new page. This makes sure “Downloads” on the navigation bar points to new page.; Conscientiously, one should test. installer downloads in Mac and Linux. And actually installing them and psi4 --test them.; that download button and curl downloading register on the download counters on vergil. Commit the new files, PR, and deploy psicode site; Petition on Slack for testers. Collect documentation snapshot¶. Documentation is built automatically by GHA from the latest psi4 master commit. It gets pushed to the psi4/psi4docs repository and thence served by netlify to a site independent of psicode.org. The netlify psicode.org site has a redirect so that psicode.org/psi4manual/master presents the psi4docs netlify content.; GHA controller is psi4/.github/workflows/docs.yml; This setup works great for “latest” docs, but it won’t build a nice copy on the tag because the tag commit is pushed before the tag itself, so the version shows up “undefined”.; So, anytime after “Tag (pre)release” is over, navigate on psi4 GH to the tag commit (not the record commit) and retrigger the docs GHA. Download the artifact (zipped docs dir) at the end to a local computer.; In your hugo site clone, create a new directory under static/psi4manual. Copy the zipped docs there, unpack, rearrange so that static/psi4manual/<new-tag>/index.html is pr",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:6264,Usability,pause,pause,6264,"nfig.yaml; Check psi4/doc/sphinxman/source/introduction.rst for any compiler and Python minimum requirements to edit. Tag (pre)release¶. Thorough version bump directions at master http://psicode.org/psi4manual/master/manage_git.html#how-to-bump-a-version; Below is tl;dr; # be on clean master up-to-date with upstream in both commits and tags; # * mind which version strings get ""v"" and which don't; # * if not fork, replace ""upstream"" with ""origin"". >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; ...; -__version__ = '1.3rc1'; -__version_long = '1.3rc1+5a7522a'; -__version_upcoming_annotated_v_tag = '1.3rc2'; +__version__ = '1.3rc2'; +__version_long = '1.3rc2+zzzzzzz'; +__version_upcoming_annotated_v_tag = '1.3rc3'. >>> git add psi4/metadata.py; >>> git commit -m ""v1.3rc2""; [master bc8d7f5] v1.3rc2. >>> git log --oneline | head -1; bc8d7f5 v1.3rc2; >>> git tag -a v1.3rc2 bc8d7f5 -m ""v1.3rc2"". # pause here and push to upstream and let Azure complete if want an; # on-tag Windows conda package, not just tag+1.dev1; # below pushes commit and tag together so only one CI; # > git push --atomic upstream master v1.5; # also, grab the docs build from GHA artifacts. >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; ...; -__version_long = '1.3rc2+zzzzzzz'; +__version_long = '1.3rc2+bc8d7f5'. >>> git add psi4/metadata.py; >>> git commit -m ""Records tag for v1.3rc2""; [master 16dbd3e] Records tag for v1.3rc2. # goto GH:psi4/psi4 > Settings > Branches > master > Edit; # https://github.com/psi4/psi4/settings/branch_protection_rules/424295; # uncheck ""Include administrators"" and Save changes. >>> git push upstream master; >>> git push upstream v1.3rc2. # re-engage ""Include administrators"" protections. Tag postrelease¶. # be on clean maintenance branch up-to-date with upstream in both commits and tags; # * mind which version strings get ""v"" and which don't; # * if not fork, replace ""upstream"" with ""origin"". >>",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:10318,Usability,clear,clear,10318,"nd whether they need version space to grow compatibly and grow incompatibly.; Nightly conda-builds work from master psi4. (Postrelease “practice” works from 1.N.x psi4.). Instead, switch source/git_tag from master to tag (e.g., v1.3rc1) in:. psi4-multiout on Linux & Mac, https://github.com/psi4/psi4meta/blob/master/conda-recipes/psi4-multiout/meta.yaml#L10; psi4-docs on Linux, https://github.com/psi4/psi4meta/blob/master/conda-recipes/psi4-docs/meta.yaml#L10 on L. In cbcy, edit psi4ver to “v”-less tag. For releases and postreleases (not prereleases), in conda_build_config.yaml, edit ltrtver to a new non-dev label (probably a ditto) matching the release (e.g., “1.3”); Set kitandkapoodle.py to the normal *** stack. Should be (psi4, psi4-rt, psi4-dev) * python_versions for Linux & Mac. Also single psi4-docs from Linux; Run kitandkapoodle.py and allow stack to upload to anaconda.org to psi4/label/dev. Poodle emits with --label dev so will go to the subchannel. May need to delete packages to clear out space on anaconda.org; Copy meta.yaml and build.sh of at least psi4-multiout and psi4-rt to e.g., v121-build.sh files for easy reference or rebuilding as dependencies in master change. Publish to main conda label¶. Go through each active conda package off https://anaconda.org/psi4/repo. Find the most recent build set (Linux/Mac, active py versions) that psi4/psi4-rt/psi4-dev is using; _add_ (not replace) the main label. This makes a conda install psi4 -c psi4 get everything psi4 needs. For the moment conda install psi4 -c psi4/label/dev will get the same set, until package psi4-1.4a1.dev1 gets uploaded. May help to check versions and build versions against ltrtver in conda_build_config.yaml.; This step is manual, so takes a while. (It gets checked when Psi4conda installers are built b/c that pulls from “main”, not “dev”). Build Psi4conda set (pre-Spring 2021)¶; Installers are build using the project constructor and build binary bash scripts, one per OS per Python version. I",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/manage_release.html:12428,Usability,clear,clear,12428,"n be built on Linux) and get served from vergil (cdsgroup webserver). Need a conda env with constructor and cookiecutter. This env presently accessed through conda activate cookie.; Enter “constructor-cutter-unified” in the psi4meta repo. There’s a good README there, https://github.com/psi4/psi4meta/blob/master/conda-recipes/constructor-cutter-unified/README.md; Edit cookiecutter/cookiecutter.json for control. Edit which python versions, if necessary; Edit release field; Edit hash field. This is the 7-char hash that’s on every psi4 conda pkg as part of version; Edit ltrtver field. This matches the current setting in conda_build_config.yaml; For prereleases, ""channel_tag"": ""/label/dev"", while for (post)releases, it should be the empty string; Leave this file set to a “rc” with Git, as that has more details. For (post)releases (not prereleases), copy cookiecutter.json to cookiecutter.json-vXXX; Edit cookiecutter/{{.../construct.yaml for templating. This is rarely needed; If it’s been a while or you need the space, clear out ~/.conda/constructor, where the downloaded packages are cached; Note that installers get written to build/ and this gets regenerated each time. Clear out between runs.; python run.py; [Outdated] Watch out for py_ in buildstring as this means a noarch package has been pulled. It must be eliminated. Constructors can’t handle “noarch” packages and will fail at runtime. If see a “noarch” package, must find the recipe and rebuild for all OS & Python combinations. Then run constructor again.; [Replacement] After adding a post_install to reposition the noarch packages, they are safe to include.; If fetching times out, may have to run run.py several times. Clear out build/ in between. It’s the fetching that takes a long time, not constucting; In the end, should have several installers; >>> ls -l build/psi4conda-1.3-py3.*/*64.sh; -rwxr-xr-x. 516M Feb 28 20:30 build/psi4conda-1.3-py3.6-linux-64/psi4conda-1.3-py36-Linux-x86_64.sh; -rwxr-xr-x. 299M Feb 28 20:31",MatchSource.WIKI,psi4manual/1.6.x/manage_release.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html
https://psicode.org/psi4manual/1.6.x/mcscf.html:1328,Deployability,update,update,1328,"rill, and Matthew L. Leininger; Section author: Daniel G. A. Smith and C. David Sherrill; Module: Keywords, PSI Variables, DETCI; As the cost of Full CI scales exponentially with respect to the number of; active orbitals it is often advantageous to neglect orbitals that do not; exhibit strong correlation. These orbitals are variationally optimized; simultaneously with the CI coefficients and known as Multi-Configurational; Self-Consistent Field (MCSCF). The most commonly used MCSCF procedure is the; complete-active-space self-consistent-field (CASSCF) approach [Roos:1980],; which includes all possible determinants (with the proper symmetry) that can be; formed by distributing a set of active electrons among a set of active; orbitals. The MCSCF module performs CASSCF optimization of molecular orbitals; via a two-step procedure in which the CI coefficients and orbitals are; optimized in an alternating manner. The program uses a fairly simple; approximate orbital Hessian [Chaban:1997:88] and a Newton-Raphson update,; accelerated by Pulay’s DIIS procedure [Pulay:1980]. We have also implemented; the RASSCF method [Malmqvist:1990:RASSCF], which is another kind of MCSCF; which is typically less complete (and less expensive) than CASSCF.; Inactive orbitals in the MCSCF may be specified by the; RESTRICTED_DOCC and RESTRICTED_UOCC keywords. These; orbitals will remain doubly-occupied or doubly-unoccupied, respectively, in the; MCSCF wavefunction. However, the form of these orbitals will be optimized in; the MCSCF procedure. It is also possible to literally freeze inactive orbitals; in their original (SCF) form using the FROZEN_DOCC and; FROZEN_UOCC keywords. This is not normally what one wishes to do in; an MCSCF computation (e.g., it complicates the computation of gradients), but; it can make the computations faster and is helpful in some circumstances where; unphysical mixing of inactive and active occupied orbitals might occur.; Presently, it is not possible to mix the use ",MatchSource.WIKI,psi4manual/1.6.x/mcscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mcscf.html
https://psicode.org/psi4manual/1.6.x/mcscf.html:4461,Deployability,update,updated,4461,"f'). This input will compute the CASSCF energy of water where the 1s Oxygen orbital; and several virtual orbitals are not included in the CI expansion, but are; still optimized. The following is a full list of spaces within the various MCSCF; types. Orbital spaces for MCSCF computations¶. RASSCF; CASSCF. FROZEN_UOCC; FROZEN_UOCC. RESTRICTED_UOCC; RESTRICTED_UOCC. RAS4; ACTIVE. RAS3. RAS2. RAS1. RESTRICTED_DOCC; RESTRICTED_DOCC. FROZEN_DOCC; FROZEN_DOCC. Basic MCSCF Keywords¶. MCSCF_E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-7. MCSCF_R_CONVERGENCE¶. Convergence criterion for the RMS of the orbital gradient. Type: conv double; Default: 1e-5. MCSCF_TYPE¶. Method to handle the two-electron integrals. Type: string; Possible Values: DF, CONV, AO; Default: CONV. MCSCF_ALGORITHM¶. Convergence algorithm to utilize. Two-Step, Augmented Hessian, or One-Step. Defaults to TS for RASSCF. Type: string; Possible Values: TS, AH; Default: TS. MCSCF_MAXITER¶. Maximum number MCSCF of iterations. Type: integer; Default: 30. MCSCF_ROTATE¶. Apply a list of 2x2 rotation matrices to the orbitals in the form of [irrep, orbital1, orbital2, theta] where an angle of 0 would do nothing and an angle of 90 would switch the two orbitals. Type: array; Default: No Default. MCSCF_DIIS_START¶. Iteration to turn on DIIS for TS convergence. Type: integer; Default: 3. table of contents. MCSCF: Multi-Configurational Self-Consistent-Field; Basic MCSCF Keywords; MCSCF_E_CONVERGENCE; MCSCF_R_CONVERGENCE; MCSCF_TYPE; MCSCF_ALGORITHM; MCSCF_MAXITER; MCSCF_ROTATE; MCSCF_DIIS_START. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; MCSCF: Multi-Configurational Self-Consistent-Field. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/mcscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mcscf.html
https://psicode.org/psi4manual/1.6.x/mcscf.html:2522,Energy Efficiency,energy,energy,2522,"ich is typically less complete (and less expensive) than CASSCF.; Inactive orbitals in the MCSCF may be specified by the; RESTRICTED_DOCC and RESTRICTED_UOCC keywords. These; orbitals will remain doubly-occupied or doubly-unoccupied, respectively, in the; MCSCF wavefunction. However, the form of these orbitals will be optimized in; the MCSCF procedure. It is also possible to literally freeze inactive orbitals; in their original (SCF) form using the FROZEN_DOCC and; FROZEN_UOCC keywords. This is not normally what one wishes to do in; an MCSCF computation (e.g., it complicates the computation of gradients), but; it can make the computations faster and is helpful in some circumstances where; unphysical mixing of inactive and active occupied orbitals might occur.; Presently, it is not possible to mix the use of restricted and frozen orbitals; in PSI4.; An illustrative CASSCF example is as follows:; molecule {; O; H 1 1.00; H 1 1.00 2 103.1; }. set {; basis 6-31G**; restricted_docc [1, 0, 0, 0]; active [3, 0, 1, 2]; }; energy('casscf'). This input will compute the CASSCF energy of water where the 1s Oxygen orbital; and several virtual orbitals are not included in the CI expansion, but are; still optimized. The following is a full list of spaces within the various MCSCF; types. Orbital spaces for MCSCF computations¶. RASSCF; CASSCF. FROZEN_UOCC; FROZEN_UOCC. RESTRICTED_UOCC; RESTRICTED_UOCC. RAS4; ACTIVE. RAS3. RAS2. RAS1. RESTRICTED_DOCC; RESTRICTED_DOCC. FROZEN_DOCC; FROZEN_DOCC. Basic MCSCF Keywords¶. MCSCF_E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-7. MCSCF_R_CONVERGENCE¶. Convergence criterion for the RMS of the orbital gradient. Type: conv double; Default: 1e-5. MCSCF_TYPE¶. Method to handle the two-electron integrals. Type: string; Possible Values: DF, CONV, AO; Default: CONV. MCSCF_ALGORITHM¶. Convergence algorithm to utilize. Two-",MatchSource.WIKI,psi4manual/1.6.x/mcscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mcscf.html
https://psicode.org/psi4manual/1.6.x/mcscf.html:2575,Energy Efficiency,energy,energy,2575,"DOCC and RESTRICTED_UOCC keywords. These; orbitals will remain doubly-occupied or doubly-unoccupied, respectively, in the; MCSCF wavefunction. However, the form of these orbitals will be optimized in; the MCSCF procedure. It is also possible to literally freeze inactive orbitals; in their original (SCF) form using the FROZEN_DOCC and; FROZEN_UOCC keywords. This is not normally what one wishes to do in; an MCSCF computation (e.g., it complicates the computation of gradients), but; it can make the computations faster and is helpful in some circumstances where; unphysical mixing of inactive and active occupied orbitals might occur.; Presently, it is not possible to mix the use of restricted and frozen orbitals; in PSI4.; An illustrative CASSCF example is as follows:; molecule {; O; H 1 1.00; H 1 1.00 2 103.1; }. set {; basis 6-31G**; restricted_docc [1, 0, 0, 0]; active [3, 0, 1, 2]; }; energy('casscf'). This input will compute the CASSCF energy of water where the 1s Oxygen orbital; and several virtual orbitals are not included in the CI expansion, but are; still optimized. The following is a full list of spaces within the various MCSCF; types. Orbital spaces for MCSCF computations¶. RASSCF; CASSCF. FROZEN_UOCC; FROZEN_UOCC. RESTRICTED_UOCC; RESTRICTED_UOCC. RAS4; ACTIVE. RAS3. RAS2. RAS1. RESTRICTED_DOCC; RESTRICTED_DOCC. FROZEN_DOCC; FROZEN_DOCC. Basic MCSCF Keywords¶. MCSCF_E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-7. MCSCF_R_CONVERGENCE¶. Convergence criterion for the RMS of the orbital gradient. Type: conv double; Default: 1e-5. MCSCF_TYPE¶. Method to handle the two-electron integrals. Type: string; Possible Values: DF, CONV, AO; Default: CONV. MCSCF_ALGORITHM¶. Convergence algorithm to utilize. Two-Step, Augmented Hessian, or One-Step. Defaults to TS for RASSCF. Type: string; Possible Values: TS, AH; Default: TS. MCSCF_MAXITER¶. M",MatchSource.WIKI,psi4manual/1.6.x/mcscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mcscf.html
https://psicode.org/psi4manual/1.6.x/mcscf.html:3064,Energy Efficiency,energy,energy,3064,".g., it complicates the computation of gradients), but; it can make the computations faster and is helpful in some circumstances where; unphysical mixing of inactive and active occupied orbitals might occur.; Presently, it is not possible to mix the use of restricted and frozen orbitals; in PSI4.; An illustrative CASSCF example is as follows:; molecule {; O; H 1 1.00; H 1 1.00 2 103.1; }. set {; basis 6-31G**; restricted_docc [1, 0, 0, 0]; active [3, 0, 1, 2]; }; energy('casscf'). This input will compute the CASSCF energy of water where the 1s Oxygen orbital; and several virtual orbitals are not included in the CI expansion, but are; still optimized. The following is a full list of spaces within the various MCSCF; types. Orbital spaces for MCSCF computations¶. RASSCF; CASSCF. FROZEN_UOCC; FROZEN_UOCC. RESTRICTED_UOCC; RESTRICTED_UOCC. RAS4; ACTIVE. RAS3. RAS2. RAS1. RESTRICTED_DOCC; RESTRICTED_DOCC. FROZEN_DOCC; FROZEN_DOCC. Basic MCSCF Keywords¶. MCSCF_E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-7. MCSCF_R_CONVERGENCE¶. Convergence criterion for the RMS of the orbital gradient. Type: conv double; Default: 1e-5. MCSCF_TYPE¶. Method to handle the two-electron integrals. Type: string; Possible Values: DF, CONV, AO; Default: CONV. MCSCF_ALGORITHM¶. Convergence algorithm to utilize. Two-Step, Augmented Hessian, or One-Step. Defaults to TS for RASSCF. Type: string; Possible Values: TS, AH; Default: TS. MCSCF_MAXITER¶. Maximum number MCSCF of iterations. Type: integer; Default: 30. MCSCF_ROTATE¶. Apply a list of 2x2 rotation matrices to the orbitals in the form of [irrep, orbital1, orbital2, theta] where an angle of 0 would do nothing and an angle of 90 would switch the two orbitals. Type: array; Default: No Default. MCSCF_DIIS_START¶. Iteration to turn on DIIS for TS convergence. Type: integer; Default: 3. table of contents. MCSCF: Multi-C",MatchSource.WIKI,psi4manual/1.6.x/mcscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mcscf.html
https://psicode.org/psi4manual/1.6.x/mcscf.html:647,Performance,optimiz,optimized,647,"﻿. MCSCF: Multi-Configurational Self-Consistent-Field. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; MCSCF: Multi-Configurational Self-Consistent-Field. MCSCF: Multi-Configurational Self-Consistent-Field¶; Code author: Daniel G. A. Smith, C. David Sherrill, and Matthew L. Leininger; Section author: Daniel G. A. Smith and C. David Sherrill; Module: Keywords, PSI Variables, DETCI; As the cost of Full CI scales exponentially with respect to the number of; active orbitals it is often advantageous to neglect orbitals that do not; exhibit strong correlation. These orbitals are variationally optimized; simultaneously with the CI coefficients and known as Multi-Configurational; Self-Consistent Field (MCSCF). The most commonly used MCSCF procedure is the; complete-active-space self-consistent-field (CASSCF) approach [Roos:1980],; which includes all possible determinants (with the proper symmetry) that can be; formed by distributing a set of active electrons among a set of active; orbitals. The MCSCF module performs CASSCF optimization of molecular orbitals; via a two-step procedure in which the CI coefficients and orbitals are; optimized in an alternating manner. The program uses a fairly simple; approximate orbital Hessian [Chaban:1997:88] and a Newton-Raphson update,; accelerated by Pulay’s DIIS procedure [Pulay:1980]. We have also implemented; the RASSCF method [Malmqvist:1990:RASSCF], which is another kind of MCSCF; which is typically less complete (and less expensive) than CASSCF.; Inactive orbitals in the MCSCF may be specified by the; RESTRICTED_DOCC and RESTRICTED_UOCC keywords. These; orbitals will remain doubly-occupied or doubly-unoccupied, respectively, in the; MCSCF wavefunction. However, the form of these orbitals will be optimized in; the MCSCF procedure. It is also possible to literally freeze inactive orbitals; in their original (SCF) form using the FROZEN_DOCC and; FROZEN_UOCC keywords. This is not norma",MatchSource.WIKI,psi4manual/1.6.x/mcscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mcscf.html
https://psicode.org/psi4manual/1.6.x/mcscf.html:1068,Performance,perform,performs,1068,"hods: SCF to FCI; MCSCF: Multi-Configurational Self-Consistent-Field. MCSCF: Multi-Configurational Self-Consistent-Field¶; Code author: Daniel G. A. Smith, C. David Sherrill, and Matthew L. Leininger; Section author: Daniel G. A. Smith and C. David Sherrill; Module: Keywords, PSI Variables, DETCI; As the cost of Full CI scales exponentially with respect to the number of; active orbitals it is often advantageous to neglect orbitals that do not; exhibit strong correlation. These orbitals are variationally optimized; simultaneously with the CI coefficients and known as Multi-Configurational; Self-Consistent Field (MCSCF). The most commonly used MCSCF procedure is the; complete-active-space self-consistent-field (CASSCF) approach [Roos:1980],; which includes all possible determinants (with the proper symmetry) that can be; formed by distributing a set of active electrons among a set of active; orbitals. The MCSCF module performs CASSCF optimization of molecular orbitals; via a two-step procedure in which the CI coefficients and orbitals are; optimized in an alternating manner. The program uses a fairly simple; approximate orbital Hessian [Chaban:1997:88] and a Newton-Raphson update,; accelerated by Pulay’s DIIS procedure [Pulay:1980]. We have also implemented; the RASSCF method [Malmqvist:1990:RASSCF], which is another kind of MCSCF; which is typically less complete (and less expensive) than CASSCF.; Inactive orbitals in the MCSCF may be specified by the; RESTRICTED_DOCC and RESTRICTED_UOCC keywords. These; orbitals will remain doubly-occupied or doubly-unoccupied, respectively, in the; MCSCF wavefunction. However, the form of these orbitals will be optimized in; the MCSCF procedure. It is also possible to literally freeze inactive orbitals; in their original (SCF) form using the FROZEN_DOCC and; FROZEN_UOCC keywords. This is not normally what one wishes to do in; an MCSCF computation (e.g., it complicates the computation of gradients), but; it can make the computations ",MatchSource.WIKI,psi4manual/1.6.x/mcscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mcscf.html
https://psicode.org/psi4manual/1.6.x/mcscf.html:1084,Performance,optimiz,optimization,1084,"hods: SCF to FCI; MCSCF: Multi-Configurational Self-Consistent-Field. MCSCF: Multi-Configurational Self-Consistent-Field¶; Code author: Daniel G. A. Smith, C. David Sherrill, and Matthew L. Leininger; Section author: Daniel G. A. Smith and C. David Sherrill; Module: Keywords, PSI Variables, DETCI; As the cost of Full CI scales exponentially with respect to the number of; active orbitals it is often advantageous to neglect orbitals that do not; exhibit strong correlation. These orbitals are variationally optimized; simultaneously with the CI coefficients and known as Multi-Configurational; Self-Consistent Field (MCSCF). The most commonly used MCSCF procedure is the; complete-active-space self-consistent-field (CASSCF) approach [Roos:1980],; which includes all possible determinants (with the proper symmetry) that can be; formed by distributing a set of active electrons among a set of active; orbitals. The MCSCF module performs CASSCF optimization of molecular orbitals; via a two-step procedure in which the CI coefficients and orbitals are; optimized in an alternating manner. The program uses a fairly simple; approximate orbital Hessian [Chaban:1997:88] and a Newton-Raphson update,; accelerated by Pulay’s DIIS procedure [Pulay:1980]. We have also implemented; the RASSCF method [Malmqvist:1990:RASSCF], which is another kind of MCSCF; which is typically less complete (and less expensive) than CASSCF.; Inactive orbitals in the MCSCF may be specified by the; RESTRICTED_DOCC and RESTRICTED_UOCC keywords. These; orbitals will remain doubly-occupied or doubly-unoccupied, respectively, in the; MCSCF wavefunction. However, the form of these orbitals will be optimized in; the MCSCF procedure. It is also possible to literally freeze inactive orbitals; in their original (SCF) form using the FROZEN_DOCC and; FROZEN_UOCC keywords. This is not normally what one wishes to do in; an MCSCF computation (e.g., it complicates the computation of gradients), but; it can make the computations ",MatchSource.WIKI,psi4manual/1.6.x/mcscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mcscf.html
https://psicode.org/psi4manual/1.6.x/mcscf.html:1192,Performance,optimiz,optimized,1192,"hods: SCF to FCI; MCSCF: Multi-Configurational Self-Consistent-Field. MCSCF: Multi-Configurational Self-Consistent-Field¶; Code author: Daniel G. A. Smith, C. David Sherrill, and Matthew L. Leininger; Section author: Daniel G. A. Smith and C. David Sherrill; Module: Keywords, PSI Variables, DETCI; As the cost of Full CI scales exponentially with respect to the number of; active orbitals it is often advantageous to neglect orbitals that do not; exhibit strong correlation. These orbitals are variationally optimized; simultaneously with the CI coefficients and known as Multi-Configurational; Self-Consistent Field (MCSCF). The most commonly used MCSCF procedure is the; complete-active-space self-consistent-field (CASSCF) approach [Roos:1980],; which includes all possible determinants (with the proper symmetry) that can be; formed by distributing a set of active electrons among a set of active; orbitals. The MCSCF module performs CASSCF optimization of molecular orbitals; via a two-step procedure in which the CI coefficients and orbitals are; optimized in an alternating manner. The program uses a fairly simple; approximate orbital Hessian [Chaban:1997:88] and a Newton-Raphson update,; accelerated by Pulay’s DIIS procedure [Pulay:1980]. We have also implemented; the RASSCF method [Malmqvist:1990:RASSCF], which is another kind of MCSCF; which is typically less complete (and less expensive) than CASSCF.; Inactive orbitals in the MCSCF may be specified by the; RESTRICTED_DOCC and RESTRICTED_UOCC keywords. These; orbitals will remain doubly-occupied or doubly-unoccupied, respectively, in the; MCSCF wavefunction. However, the form of these orbitals will be optimized in; the MCSCF procedure. It is also possible to literally freeze inactive orbitals; in their original (SCF) form using the FROZEN_DOCC and; FROZEN_UOCC keywords. This is not normally what one wishes to do in; an MCSCF computation (e.g., it complicates the computation of gradients), but; it can make the computations ",MatchSource.WIKI,psi4manual/1.6.x/mcscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mcscf.html
https://psicode.org/psi4manual/1.6.x/mcscf.html:1812,Performance,optimiz,optimized,1812," the; complete-active-space self-consistent-field (CASSCF) approach [Roos:1980],; which includes all possible determinants (with the proper symmetry) that can be; formed by distributing a set of active electrons among a set of active; orbitals. The MCSCF module performs CASSCF optimization of molecular orbitals; via a two-step procedure in which the CI coefficients and orbitals are; optimized in an alternating manner. The program uses a fairly simple; approximate orbital Hessian [Chaban:1997:88] and a Newton-Raphson update,; accelerated by Pulay’s DIIS procedure [Pulay:1980]. We have also implemented; the RASSCF method [Malmqvist:1990:RASSCF], which is another kind of MCSCF; which is typically less complete (and less expensive) than CASSCF.; Inactive orbitals in the MCSCF may be specified by the; RESTRICTED_DOCC and RESTRICTED_UOCC keywords. These; orbitals will remain doubly-occupied or doubly-unoccupied, respectively, in the; MCSCF wavefunction. However, the form of these orbitals will be optimized in; the MCSCF procedure. It is also possible to literally freeze inactive orbitals; in their original (SCF) form using the FROZEN_DOCC and; FROZEN_UOCC keywords. This is not normally what one wishes to do in; an MCSCF computation (e.g., it complicates the computation of gradients), but; it can make the computations faster and is helpful in some circumstances where; unphysical mixing of inactive and active occupied orbitals might occur.; Presently, it is not possible to mix the use of restricted and frozen orbitals; in PSI4.; An illustrative CASSCF example is as follows:; molecule {; O; H 1 1.00; H 1 1.00 2 103.1; }. set {; basis 6-31G**; restricted_docc [1, 0, 0, 0]; active [3, 0, 1, 2]; }; energy('casscf'). This input will compute the CASSCF energy of water where the 1s Oxygen orbital; and several virtual orbitals are not included in the CI expansion, but are; still optimized. The following is a full list of spaces within the various MCSCF; types. Orbital spaces for MCS",MatchSource.WIKI,psi4manual/1.6.x/mcscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mcscf.html
https://psicode.org/psi4manual/1.6.x/mcscf.html:2702,Performance,optimiz,optimized,2702,"DOCC and RESTRICTED_UOCC keywords. These; orbitals will remain doubly-occupied or doubly-unoccupied, respectively, in the; MCSCF wavefunction. However, the form of these orbitals will be optimized in; the MCSCF procedure. It is also possible to literally freeze inactive orbitals; in their original (SCF) form using the FROZEN_DOCC and; FROZEN_UOCC keywords. This is not normally what one wishes to do in; an MCSCF computation (e.g., it complicates the computation of gradients), but; it can make the computations faster and is helpful in some circumstances where; unphysical mixing of inactive and active occupied orbitals might occur.; Presently, it is not possible to mix the use of restricted and frozen orbitals; in PSI4.; An illustrative CASSCF example is as follows:; molecule {; O; H 1 1.00; H 1 1.00 2 103.1; }. set {; basis 6-31G**; restricted_docc [1, 0, 0, 0]; active [3, 0, 1, 2]; }; energy('casscf'). This input will compute the CASSCF energy of water where the 1s Oxygen orbital; and several virtual orbitals are not included in the CI expansion, but are; still optimized. The following is a full list of spaces within the various MCSCF; types. Orbital spaces for MCSCF computations¶. RASSCF; CASSCF. FROZEN_UOCC; FROZEN_UOCC. RESTRICTED_UOCC; RESTRICTED_UOCC. RAS4; ACTIVE. RAS3. RAS2. RAS1. RESTRICTED_DOCC; RESTRICTED_DOCC. FROZEN_DOCC; FROZEN_DOCC. Basic MCSCF Keywords¶. MCSCF_E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-7. MCSCF_R_CONVERGENCE¶. Convergence criterion for the RMS of the orbital gradient. Type: conv double; Default: 1e-5. MCSCF_TYPE¶. Method to handle the two-electron integrals. Type: string; Possible Values: DF, CONV, AO; Default: CONV. MCSCF_ALGORITHM¶. Convergence algorithm to utilize. Two-Step, Augmented Hessian, or One-Step. Defaults to TS for RASSCF. Type: string; Possible Values: TS, AH; Default: TS. MCSCF_MAXITER¶. M",MatchSource.WIKI,psi4manual/1.6.x/mcscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mcscf.html
https://psicode.org/psi4manual/1.6.x/mcscf.html:1254,Usability,simpl,simple,1254,"rill, and Matthew L. Leininger; Section author: Daniel G. A. Smith and C. David Sherrill; Module: Keywords, PSI Variables, DETCI; As the cost of Full CI scales exponentially with respect to the number of; active orbitals it is often advantageous to neglect orbitals that do not; exhibit strong correlation. These orbitals are variationally optimized; simultaneously with the CI coefficients and known as Multi-Configurational; Self-Consistent Field (MCSCF). The most commonly used MCSCF procedure is the; complete-active-space self-consistent-field (CASSCF) approach [Roos:1980],; which includes all possible determinants (with the proper symmetry) that can be; formed by distributing a set of active electrons among a set of active; orbitals. The MCSCF module performs CASSCF optimization of molecular orbitals; via a two-step procedure in which the CI coefficients and orbitals are; optimized in an alternating manner. The program uses a fairly simple; approximate orbital Hessian [Chaban:1997:88] and a Newton-Raphson update,; accelerated by Pulay’s DIIS procedure [Pulay:1980]. We have also implemented; the RASSCF method [Malmqvist:1990:RASSCF], which is another kind of MCSCF; which is typically less complete (and less expensive) than CASSCF.; Inactive orbitals in the MCSCF may be specified by the; RESTRICTED_DOCC and RESTRICTED_UOCC keywords. These; orbitals will remain doubly-occupied or doubly-unoccupied, respectively, in the; MCSCF wavefunction. However, the form of these orbitals will be optimized in; the MCSCF procedure. It is also possible to literally freeze inactive orbitals; in their original (SCF) form using the FROZEN_DOCC and; FROZEN_UOCC keywords. This is not normally what one wishes to do in; an MCSCF computation (e.g., it complicates the computation of gradients), but; it can make the computations faster and is helpful in some circumstances where; unphysical mixing of inactive and active occupied orbitals might occur.; Presently, it is not possible to mix the use ",MatchSource.WIKI,psi4manual/1.6.x/mcscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mcscf.html
https://psicode.org/psi4manual/1.6.x/methods.html:212,Availability,avail,available,212,"﻿. Theoretical Methods: SCF to FCI. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI. Theoretical Methods: SCF to FCI¶; Several electronic structure methods are available in the PSI4; package, from Hartree–Fock molecular orbital theory to coupled-cluster; theory to full configuration interaction. This section introduces; the methods available and some of their most common input parameters.; A complete list of standard keywords is provided in Appendix; Keywords by Module. Notes on Options; Notes on Psivars; Alternate Implementations; HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess; Restarting the SCF; Convergence Stabilization; ERI Algorithms; COSX Exchange; LinK Exchange; Second-order Convergence; Stability Analysis; Effective core potentials (ECPs); External potentials and QM/MM; Convergence and Algorithm Defaults; Recommendations. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations; Advanced Functional Use and Manipulation. DFT-NL; post-SCF time savings. DCT: Density Cumulant Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Methods Summary; Minimal Input; Recommendations. DF-MP2: Density-Fitted 2nd-Order Møller–Plesset Perturbation Theory; Introduction; Theory; Recommendations. DLPNO-MP2: Domain-Based Local Pair Natural Orbital MP2; Introduction; Theory; Recommendations. CC: Coupled Cluster Theory; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Frozen natural orbitals (FNO); QCISD(T), CCSD(T), MP4, and CEPA; Quadratic configuration interaction and coupled cluster; Many-body perturbation theory; Coupled electron pa",MatchSource.WIKI,psi4manual/1.6.x/methods.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/methods.html
https://psicode.org/psi4manual/1.6.x/methods.html:386,Availability,avail,available,386,"﻿. Theoretical Methods: SCF to FCI. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI. Theoretical Methods: SCF to FCI¶; Several electronic structure methods are available in the PSI4; package, from Hartree–Fock molecular orbital theory to coupled-cluster; theory to full configuration interaction. This section introduces; the methods available and some of their most common input parameters.; A complete list of standard keywords is provided in Appendix; Keywords by Module. Notes on Options; Notes on Psivars; Alternate Implementations; HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess; Restarting the SCF; Convergence Stabilization; ERI Algorithms; COSX Exchange; LinK Exchange; Second-order Convergence; Stability Analysis; Effective core potentials (ECPs); External potentials and QM/MM; Convergence and Algorithm Defaults; Recommendations. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations; Advanced Functional Use and Manipulation. DFT-NL; post-SCF time savings. DCT: Density Cumulant Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Methods Summary; Minimal Input; Recommendations. DF-MP2: Density-Fitted 2nd-Order Møller–Plesset Perturbation Theory; Introduction; Theory; Recommendations. DLPNO-MP2: Domain-Based Local Pair Natural Orbital MP2; Introduction; Theory; Recommendations. CC: Coupled Cluster Theory; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Frozen natural orbitals (FNO); QCISD(T), CCSD(T), MP4, and CEPA; Quadratic configuration interaction and coupled cluster; Many-body perturbation theory; Coupled electron pa",MatchSource.WIKI,psi4manual/1.6.x/methods.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/methods.html
https://psicode.org/psi4manual/1.6.x/methods.html:322,Deployability,configurat,configuration,322,"﻿. Theoretical Methods: SCF to FCI. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI. Theoretical Methods: SCF to FCI¶; Several electronic structure methods are available in the PSI4; package, from Hartree–Fock molecular orbital theory to coupled-cluster; theory to full configuration interaction. This section introduces; the methods available and some of their most common input parameters.; A complete list of standard keywords is provided in Appendix; Keywords by Module. Notes on Options; Notes on Psivars; Alternate Implementations; HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess; Restarting the SCF; Convergence Stabilization; ERI Algorithms; COSX Exchange; LinK Exchange; Second-order Convergence; Stability Analysis; Effective core potentials (ECPs); External potentials and QM/MM; Convergence and Algorithm Defaults; Recommendations. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations; Advanced Functional Use and Manipulation. DFT-NL; post-SCF time savings. DCT: Density Cumulant Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Methods Summary; Minimal Input; Recommendations. DF-MP2: Density-Fitted 2nd-Order Møller–Plesset Perturbation Theory; Introduction; Theory; Recommendations. DLPNO-MP2: Domain-Based Local Pair Natural Orbital MP2; Introduction; Theory; Recommendations. CC: Coupled Cluster Theory; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Frozen natural orbitals (FNO); QCISD(T), CCSD(T), MP4, and CEPA; Quadratic configuration interaction and coupled cluster; Many-body perturbation theory; Coupled electron pa",MatchSource.WIKI,psi4manual/1.6.x/methods.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/methods.html
https://psicode.org/psi4manual/1.6.x/methods.html:1904,Deployability,configurat,configuration,1904," and Algorithm Defaults; Recommendations. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations; Advanced Functional Use and Manipulation. DFT-NL; post-SCF time savings. DCT: Density Cumulant Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Methods Summary; Minimal Input; Recommendations. DF-MP2: Density-Fitted 2nd-Order Møller–Plesset Perturbation Theory; Introduction; Theory; Recommendations. DLPNO-MP2: Domain-Based Local Pair Natural Orbital MP2; Introduction; Theory; Recommendations. CC: Coupled Cluster Theory; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Frozen natural orbitals (FNO); QCISD(T), CCSD(T), MP4, and CEPA; Quadratic configuration interaction and coupled cluster; Many-body perturbation theory; Coupled electron pair approximation; Density-fitted coupled cluster; Gn theory; Supported methods; Basic FNOCC Keywords; Advanced FNOCC Keywords. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Convergence Problems; Methods; Basic OCC Keywords; Advanced OCC Keywords; Basic DFOCC Keywords; Advanced DFOCC Keywords; Conventional (Non-OO) Coupled-Cluster and Møller–Plesset Perturbation Theories. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. CI: Configuration Interaction; Basic DETCI Keywords; Spin Multiplicities of Higher Roots; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. MCSCF: Multi-Configurational Self-Consistent-Field; Basic MCSCF Keywords. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; Advanced example; SAPT0; SAPT(DFT); Higher-Order SAPT; MP2 Natur",MatchSource.WIKI,psi4manual/1.6.x/methods.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/methods.html
https://psicode.org/psi4manual/1.6.x/methods.html:4544,Deployability,update,updated,4544," Higher Roots; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. MCSCF: Multi-Configurational Self-Consistent-Field; Basic MCSCF Keywords. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; Advanced example; SAPT0; SAPT(DFT); Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Monomer-Centered Basis Computations; Computations with Mid-bonds; Interpreting SAPT Results; Spin-Flip SAPT; Higher-Order Exchange Terms without Single-Exchange Approximation. F/I-SAPT: Functional Group and/or Intramolecular SAPT; F-SAPT: A Representative Example; Order-1 Visualization with PyMol; Difference F-SAPT Analysis; I-SAPT: A Representative Example; Cube File Visualization with PyMol; Adding Point Charges to F/I-SAPT Computations; F/I-SAPT Keywords; Additional Notes. ADC: Ab Initio Polarization Propagator; Available ADC methods; Running ADC calculations; Interface to adcc; Built-in ADC(2) code. Scalar relativistic Hamiltonians; A First Example; Basis sets options; Theory. Geometry Optimization; Basic Keywords; Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Dealing with problematic optimizations; Direct manipulation of the optmization coordinates; Convergence Criteria; Interface to GeomeTRIC; Output. Evaluation of One-Electron Properties — oeprop(); Basic Keywords; Properties evaluated on a grid; Minimal Basis Iterative Stockholder. Vibrational and Thermochemical Analysis; Keywords; Examples; Output. TDSCF: Time-dependent Hartree–Fock and density-functional theory; Introduction; Known limitations; Theory; Psithon keywords; PsiAPI usage; Plotting one-photon absorption and electronic circular dichroism spectra. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/methods.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/methods.html
https://psicode.org/psi4manual/1.6.x/methods.html:4166,Integrability,depend,dependent,4166," Higher Roots; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. MCSCF: Multi-Configurational Self-Consistent-Field; Basic MCSCF Keywords. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; Advanced example; SAPT0; SAPT(DFT); Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Monomer-Centered Basis Computations; Computations with Mid-bonds; Interpreting SAPT Results; Spin-Flip SAPT; Higher-Order Exchange Terms without Single-Exchange Approximation. F/I-SAPT: Functional Group and/or Intramolecular SAPT; F-SAPT: A Representative Example; Order-1 Visualization with PyMol; Difference F-SAPT Analysis; I-SAPT: A Representative Example; Cube File Visualization with PyMol; Adding Point Charges to F/I-SAPT Computations; F/I-SAPT Keywords; Additional Notes. ADC: Ab Initio Polarization Propagator; Available ADC methods; Running ADC calculations; Interface to adcc; Built-in ADC(2) code. Scalar relativistic Hamiltonians; A First Example; Basis sets options; Theory. Geometry Optimization; Basic Keywords; Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Dealing with problematic optimizations; Direct manipulation of the optmization coordinates; Convergence Criteria; Interface to GeomeTRIC; Output. Evaluation of One-Electron Properties — oeprop(); Basic Keywords; Properties evaluated on a grid; Minimal Basis Iterative Stockholder. Vibrational and Thermochemical Analysis; Keywords; Examples; Output. TDSCF: Time-dependent Hartree–Fock and density-functional theory; Introduction; Known limitations; Theory; Psithon keywords; PsiAPI usage; Plotting one-photon absorption and electronic circular dichroism spectra. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/methods.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/methods.html
https://psicode.org/psi4manual/1.6.x/methods.html:322,Modifiability,config,configuration,322,"﻿. Theoretical Methods: SCF to FCI. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI. Theoretical Methods: SCF to FCI¶; Several electronic structure methods are available in the PSI4; package, from Hartree–Fock molecular orbital theory to coupled-cluster; theory to full configuration interaction. This section introduces; the methods available and some of their most common input parameters.; A complete list of standard keywords is provided in Appendix; Keywords by Module. Notes on Options; Notes on Psivars; Alternate Implementations; HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess; Restarting the SCF; Convergence Stabilization; ERI Algorithms; COSX Exchange; LinK Exchange; Second-order Convergence; Stability Analysis; Effective core potentials (ECPs); External potentials and QM/MM; Convergence and Algorithm Defaults; Recommendations. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations; Advanced Functional Use and Manipulation. DFT-NL; post-SCF time savings. DCT: Density Cumulant Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Methods Summary; Minimal Input; Recommendations. DF-MP2: Density-Fitted 2nd-Order Møller–Plesset Perturbation Theory; Introduction; Theory; Recommendations. DLPNO-MP2: Domain-Based Local Pair Natural Orbital MP2; Introduction; Theory; Recommendations. CC: Coupled Cluster Theory; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Frozen natural orbitals (FNO); QCISD(T), CCSD(T), MP4, and CEPA; Quadratic configuration interaction and coupled cluster; Many-body perturbation theory; Coupled electron pa",MatchSource.WIKI,psi4manual/1.6.x/methods.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/methods.html
https://psicode.org/psi4manual/1.6.x/methods.html:1904,Modifiability,config,configuration,1904," and Algorithm Defaults; Recommendations. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations; Advanced Functional Use and Manipulation. DFT-NL; post-SCF time savings. DCT: Density Cumulant Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Methods Summary; Minimal Input; Recommendations. DF-MP2: Density-Fitted 2nd-Order Møller–Plesset Perturbation Theory; Introduction; Theory; Recommendations. DLPNO-MP2: Domain-Based Local Pair Natural Orbital MP2; Introduction; Theory; Recommendations. CC: Coupled Cluster Theory; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Frozen natural orbitals (FNO); QCISD(T), CCSD(T), MP4, and CEPA; Quadratic configuration interaction and coupled cluster; Many-body perturbation theory; Coupled electron pair approximation; Density-fitted coupled cluster; Gn theory; Supported methods; Basic FNOCC Keywords; Advanced FNOCC Keywords. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Convergence Problems; Methods; Basic OCC Keywords; Advanced OCC Keywords; Basic DFOCC Keywords; Advanced DFOCC Keywords; Conventional (Non-OO) Coupled-Cluster and Møller–Plesset Perturbation Theories. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. CI: Configuration Interaction; Basic DETCI Keywords; Spin Multiplicities of Higher Roots; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. MCSCF: Multi-Configurational Self-Consistent-Field; Basic MCSCF Keywords. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; Advanced example; SAPT0; SAPT(DFT); Higher-Order SAPT; MP2 Natur",MatchSource.WIKI,psi4manual/1.6.x/methods.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/methods.html
https://psicode.org/psi4manual/1.6.x/methods.html:3829,Performance,optimiz,optimizations,3829," Higher Roots; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. MCSCF: Multi-Configurational Self-Consistent-Field; Basic MCSCF Keywords. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; Advanced example; SAPT0; SAPT(DFT); Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Monomer-Centered Basis Computations; Computations with Mid-bonds; Interpreting SAPT Results; Spin-Flip SAPT; Higher-Order Exchange Terms without Single-Exchange Approximation. F/I-SAPT: Functional Group and/or Intramolecular SAPT; F-SAPT: A Representative Example; Order-1 Visualization with PyMol; Difference F-SAPT Analysis; I-SAPT: A Representative Example; Cube File Visualization with PyMol; Adding Point Charges to F/I-SAPT Computations; F/I-SAPT Keywords; Additional Notes. ADC: Ab Initio Polarization Propagator; Available ADC methods; Running ADC calculations; Interface to adcc; Built-in ADC(2) code. Scalar relativistic Hamiltonians; A First Example; Basis sets options; Theory. Geometry Optimization; Basic Keywords; Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Dealing with problematic optimizations; Direct manipulation of the optmization coordinates; Convergence Criteria; Interface to GeomeTRIC; Output. Evaluation of One-Electron Properties — oeprop(); Basic Keywords; Properties evaluated on a grid; Minimal Basis Iterative Stockholder. Vibrational and Thermochemical Analysis; Keywords; Examples; Output. TDSCF: Time-dependent Hartree–Fock and density-functional theory; Introduction; Known limitations; Theory; Psithon keywords; PsiAPI usage; Plotting one-photon absorption and electronic circular dichroism spectra. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/methods.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/methods.html
https://psicode.org/psi4manual/1.6.x/molden.html:469,Availability,avail,available,469,"﻿. Interface to Molden — molden(). Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Molden — molden(). Interface to Molden — molden()¶; Code author: Justin M. Turney; Section author: C. David Sherrill; PSI4 contains an interface to the Molden program. Molden is a; visualization program for electronic structure developed by Gijs Schaftenaar; at the University of of Nijmegen, Netherlands. It is available at; https://www3.cmbi.umcn.nl/molden/ . Molden can; plot atomic orbitals, densities, electrostatic potentials (ESPs), etc.; PSI4 can create a file containing; atomic coordinates, basis set, and SCF orbital coefficients in the; so-called Molden format. This file is; written by the SCF module (see Section SCF); if the user sets the MOLDEN_WRITE keyword to true. This Molden file is; also used to pass information between PSI4 and WebMO, if PSI4; computations are invoked using the WebMO GUI. The filename of the; Molden file ends in “.molden”, and the prefix is determined by; WRITER_FILE_LABEL (if set), or else by the name of the output; file plus the name of the current molecule. If MOLDEN_WITH_VIRTUAL; is set to false, the unoccupied orbitals are not written to the Molden; file. psi4.molden(wfn, filename)[source]; Function to write wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns; None. Parameters. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate cube files; filename (str) – destination file name for MOLDEN file (optional); density_a (Matrix) – density in the MO basis to bui",MatchSource.WIKI,psi4manual/1.6.x/molden.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/molden.html
https://psicode.org/psi4manual/1.6.x/molden.html:4695,Deployability,update,updated,4695,", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.get_opdm(0, 0, ""A"", True)). The following produces an INCORRECT Molden file, because the; molden function needs orbitals in the MO basis (which are internally; converted and written to the Molden file in the AO basis). The correct; usage is given in the next point.; >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). Molden file with the natural orbitals of the ground-state 1RDM of a; Post-HF calculation. Note the required transformation of Da (SO->MO).; >>> E, wfn = properties('ccsd', return_wfn=True); >>> Da_so = wfn.Da(); >>> SCa = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). Options¶. MOLDEN_WRITE¶. Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. WRITER_FILE_LABEL¶. Base filename for text files written by PSI, such as the MOLDEN output file, the Hessian file, the internal coordinate file, etc. Use the add_str_i function to make this string case sensitive. Type: string; Default: No Default. MOLDEN_WITH_VIRTUAL¶. Write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs (false). Type: boolean; Default: true. table of contents. Interface to Molden — molden(); Options; MOLDEN_WRITE; WRITER_FILE_LABEL; MOLDEN_WITH_VIRTUAL. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Molden — molden(). © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/molden.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/molden.html
https://psicode.org/psi4manual/1.6.x/molden.html:1554,Energy Efficiency,energy,energy,1554,"cn.nl/molden/ . Molden can; plot atomic orbitals, densities, electrostatic potentials (ESPs), etc.; PSI4 can create a file containing; atomic coordinates, basis set, and SCF orbital coefficients in the; so-called Molden format. This file is; written by the SCF module (see Section SCF); if the user sets the MOLDEN_WRITE keyword to true. This Molden file is; also used to pass information between PSI4 and WebMO, if PSI4; computations are invoked using the WebMO GUI. The filename of the; Molden file ends in “.molden”, and the prefix is determined by; WRITER_FILE_LABEL (if set), or else by the name of the output; file plus the name of the current molecule. If MOLDEN_WITH_VIRTUAL; is set to false, the unoccupied orbitals are not written to the Molden; file. psi4.molden(wfn, filename)[source]; Function to write wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns; None. Parameters. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate cube files; filename (str) – destination file name for MOLDEN file (optional); density_a (Matrix) – density in the MO basis to build alpha NO’s from (optional); density_b (Matrix) – density in the MO basis to build beta NO’s from, assumes restricted if not supplied (optional); dovirtual (bool) – do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO’s (false) (optional). Examples. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). Molden file for CI/MCSCF computation using NO roots.; Any method ",MatchSource.WIKI,psi4manual/1.6.x/molden.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/molden.html
https://psicode.org/psi4manual/1.6.x/molden.html:2371,Energy Efficiency,energy,energy,2371," natural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns; None. Parameters. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate cube files; filename (str) – destination file name for MOLDEN file (optional); density_a (Matrix) – density in the MO basis to build alpha NO’s from (optional); density_b (Matrix) – density in the MO basis to build beta NO’s from, assumes restricted if not supplied (optional); dovirtual (bool) – do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO’s (false) (optional). Examples. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). Molden file for CI/MCSCF computation using NO roots.; Any method returning a CIWavefunction object will work: detci,; fci, casscf, etc. The first two arguments of get_opdm can be; set to n, n where n => 0 selects the root to write out, provided; these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.get_opdm(0, 0, ""A"", True)). The following produces an INCORRECT Molden file, because the; molden function needs orbitals in the MO basis (which are internally; converted and written to the Molden file in the AO basis). The correct; usage is given in the next point.; >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). Molden file with the natural orbitals of the ground-state 1RDM",MatchSource.WIKI,psi4manual/1.6.x/molden.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/molden.html
https://psicode.org/psi4manual/1.6.x/molden.html:2880,Energy Efficiency,energy,energy,2880,"stination file name for MOLDEN file (optional); density_a (Matrix) – density in the MO basis to build alpha NO’s from (optional); density_b (Matrix) – density in the MO basis to build beta NO’s from, assumes restricted if not supplied (optional); dovirtual (bool) – do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO’s (false) (optional). Examples. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). Molden file for CI/MCSCF computation using NO roots.; Any method returning a CIWavefunction object will work: detci,; fci, casscf, etc. The first two arguments of get_opdm can be; set to n, n where n => 0 selects the root to write out, provided; these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.get_opdm(0, 0, ""A"", True)). The following produces an INCORRECT Molden file, because the; molden function needs orbitals in the MO basis (which are internally; converted and written to the Molden file in the AO basis). The correct; usage is given in the next point.; >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). Molden file with the natural orbitals of the ground-state 1RDM of a; Post-HF calculation. Note the required transformation of Da (SO->MO).; >>> E, wfn = properties('ccsd', return_wfn=True); >>> Da_so = wfn.Da(); >>> SCa = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). Options¶. MOLDEN_WRITE¶. Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the outp",MatchSource.WIKI,psi4manual/1.6.x/molden.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/molden.html
https://psicode.org/psi4manual/1.6.x/molden.html:3243,Energy Efficiency,energy,energy,3243," (false) (optional). Examples. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). Molden file for CI/MCSCF computation using NO roots.; Any method returning a CIWavefunction object will work: detci,; fci, casscf, etc. The first two arguments of get_opdm can be; set to n, n where n => 0 selects the root to write out, provided; these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.get_opdm(0, 0, ""A"", True)). The following produces an INCORRECT Molden file, because the; molden function needs orbitals in the MO basis (which are internally; converted and written to the Molden file in the AO basis). The correct; usage is given in the next point.; >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). Molden file with the natural orbitals of the ground-state 1RDM of a; Post-HF calculation. Note the required transformation of Da (SO->MO).; >>> E, wfn = properties('ccsd', return_wfn=True); >>> Da_so = wfn.Da(); >>> SCa = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). Options¶. MOLDEN_WRITE¶. Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. WRITER_FILE_LABEL¶. Base filename for text files written by PSI, such as the MOLDEN output file, the Hessian file, the internal coordinate file, etc. Use the add_str_i function to make this string case sensitive. Type: string; Default: No Default. MOLDEN_WITH_VIRTUAL¶. Write all the ",MatchSource.WIKI,psi4manual/1.6.x/molden.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/molden.html
https://psicode.org/psi4manual/1.6.x/molden.html:292,Integrability,interface,interface,292,"﻿. Interface to Molden — molden(). Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Molden — molden(). Interface to Molden — molden()¶; Code author: Justin M. Turney; Section author: C. David Sherrill; PSI4 contains an interface to the Molden program. Molden is a; visualization program for electronic structure developed by Gijs Schaftenaar; at the University of of Nijmegen, Netherlands. It is available at; https://www3.cmbi.umcn.nl/molden/ . Molden can; plot atomic orbitals, densities, electrostatic potentials (ESPs), etc.; PSI4 can create a file containing; atomic coordinates, basis set, and SCF orbital coefficients in the; so-called Molden format. This file is; written by the SCF module (see Section SCF); if the user sets the MOLDEN_WRITE keyword to true. This Molden file is; also used to pass information between PSI4 and WebMO, if PSI4; computations are invoked using the WebMO GUI. The filename of the; Molden file ends in “.molden”, and the prefix is determined by; WRITER_FILE_LABEL (if set), or else by the name of the output; file plus the name of the current molecule. If MOLDEN_WITH_VIRTUAL; is set to false, the unoccupied orbitals are not written to the Molden; file. psi4.molden(wfn, filename)[source]; Function to write wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns; None. Parameters. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate cube files; filename (str) – destination file name for MOLDEN file (optional); density_a (Matrix) – density in the MO basis to bui",MatchSource.WIKI,psi4manual/1.6.x/molden.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/molden.html
https://psicode.org/psi4manual/1.6.x/mrcc.html:760,Availability,error,error,760,"﻿. Interface to MRCC by M. Kállay. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to MRCC by M. Kállay. Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (https://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B. [Kallay:2008:144101] PSI4 will save b",MatchSource.WIKI,psi4manual/1.6.x/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mrcc.html
https://psicode.org/psi4manual/1.6.x/mrcc.html:1776,Availability,avail,available,1776,"d in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B. [Kallay:2008:144101] PSI4 will save both energies but will use; the CCSDT(Q)/B as the CCSDT(Q) energy. CCSDT(Q)/B has been found to be; more robust by Martin. [Martin:2014:785]. name; calls method in Kallay’s MRCC program [manual]. mrccsd; CC through doubles. mrccsdt; CC through triples. mrccsdtq; CC through quadruples. mrccsdtqp; CC through quintuples. mrccsdtqph; CC through sextuples. mrccsd(t); CC through doubles with perturbative triples. mrccsdt(q); CC through triples with perturbative quadruples. mrccsdtq(p); CC through quadruples with pertubative quintuples. mrccsdtqp(h); CC through quintuples with pertubative sextuples. mrccsd(t)_l. mrccsdt(q)_l. mrccsdtq(p)_l. mrccsdtqp(h)_l. mrccsdt-1a; CC through doubles with iterative triples (cheapest terms). mrccsdtq-1a; CC through triples with iterative quadruples (cheapest terms). mrccsdtqp-1",MatchSource.WIKI,psi4manual/1.6.x/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mrcc.html
https://psicode.org/psi4manual/1.6.x/mrcc.html:2105,Availability,robust,robust,2105," in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B. [Kallay:2008:144101] PSI4 will save both energies but will use; the CCSDT(Q)/B as the CCSDT(Q) energy. CCSDT(Q)/B has been found to be; more robust by Martin. [Martin:2014:785]. name; calls method in Kallay’s MRCC program [manual]. mrccsd; CC through doubles. mrccsdt; CC through triples. mrccsdtq; CC through quadruples. mrccsdtqp; CC through quintuples. mrccsdtqph; CC through sextuples. mrccsd(t); CC through doubles with perturbative triples. mrccsdt(q); CC through triples with perturbative quadruples. mrccsdtq(p); CC through quadruples with pertubative quintuples. mrccsdtqp(h); CC through quintuples with pertubative sextuples. mrccsd(t)_l. mrccsdt(q)_l. mrccsdtq(p)_l. mrccsdtqp(h)_l. mrccsdt-1a; CC through doubles with iterative triples (cheapest terms). mrccsdtq-1a; CC through triples with iterative quadruples (cheapest terms). mrccsdtqp-1a; CC through quadruples with iterative quintuples (cheapest terms). mrccsdtqph-1a; CC through quintuples with iterative sextuples (cheapest terms). mrccsdt-1b; CC through doubles with iterative triples (cheaper terms). mrccsdtq-1b; CC through triples with iterative quadruples",MatchSource.WIKI,psi4manual/1.6.x/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mrcc.html
https://psicode.org/psi4manual/1.6.x/mrcc.html:4676,Deployability,update,updated,4676,"ugh triples with iterative quadruples (cheapest terms). mrccsdtqp-1a; CC through quadruples with iterative quintuples (cheapest terms). mrccsdtqph-1a; CC through quintuples with iterative sextuples (cheapest terms). mrccsdt-1b; CC through doubles with iterative triples (cheaper terms). mrccsdtq-1b; CC through triples with iterative quadruples (cheaper terms). mrccsdtqp-1b; CC through quadruples with iterative quintuples (cheaper terms). mrccsdtqph-1b; CC through quintuples with iterative sextuples (cheaper terms). mrcc2; approximate CC through doubles. mrcc3; approximate CC through triples. mrcc4; approximate CC through quadruples. mrcc5; approximate CC through quintuples. mrcc6; approximate CC through sextuples. mrccsdt-3; CC through doubles with iterative triples (all but the most expensive terms). mrccsdtq-3; CC through triples with iterative quadruples (all but the most expensive terms). mrccsdtqp-3; CC through quadruples with iterative quintuples (all but the most expensive terms). mrccsdtqph-3; CC through quintuples with iterative sextuples (all but the most expensive terms). Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Interface Details¶. MRCC methods¶. MRCC_METHOD; Method; Description. 1; CC. 2; CC(n-1)[n]. 3; CC(n-1)(n); (CC(n-1)[n] energy is also calculated). 4; CC(n-1)(n)_L; (CC(n-1)[n] and CC(n-1)(n) energies are also calculated). 5; CC(n)-1a. 6; CC(n)-1b. 7; CCn. 8; CC(n)-3. table of contents. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to MRCC by M. Kállay. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mrcc.html
https://psicode.org/psi4manual/1.6.x/mrcc.html:920,Energy Efficiency,energy,energy,920,"﻿. Interface to MRCC by M. Kállay. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to MRCC by M. Kállay. Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (https://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B. [Kallay:2008:144101] PSI4 will save b",MatchSource.WIKI,psi4manual/1.6.x/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mrcc.html
https://psicode.org/psi4manual/1.6.x/mrcc.html:1066,Energy Efficiency,energy,energy,1066,"es    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to MRCC by M. Kállay. Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (https://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B. [Kallay:2008:144101] PSI4 will save both energies but will use; the CCSDT(Q)/B as the CCSDT(Q) e",MatchSource.WIKI,psi4manual/1.6.x/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mrcc.html
https://psicode.org/psi4manual/1.6.x/mrcc.html:1110,Energy Efficiency,energy,energy,1110,"ce to MRCC by M. Kállay. Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (https://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B. [Kallay:2008:144101] PSI4 will save both energies but will use; the CCSDT(Q)/B as the CCSDT(Q) energy. CCSDT(Q)/B has been found to be; more robust by Martin. [Martin:2014:785]. name; cal",MatchSource.WIKI,psi4manual/1.6.x/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mrcc.html
https://psicode.org/psi4manual/1.6.x/mrcc.html:1211,Energy Efficiency,energy,energy,1211,"ce to MRCC by M. Kállay. Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (https://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B. [Kallay:2008:144101] PSI4 will save both energies but will use; the CCSDT(Q)/B as the CCSDT(Q) energy. CCSDT(Q)/B has been found to be; more robust by Martin. [Martin:2014:785]. name; cal",MatchSource.WIKI,psi4manual/1.6.x/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mrcc.html
https://psicode.org/psi4manual/1.6.x/mrcc.html:1235,Energy Efficiency,energy,energy,1235,"mmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (https://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B. [Kallay:2008:144101] PSI4 will save both energies but will use; the CCSDT(Q)/B as the CCSDT(Q) energy. CCSDT(Q)/B has been found to be; more robust by Martin. [Martin:2014:785]. name; calls method in Kallay’s MRCC program [manual]. mrccsd; CC through doubles. mrccsdt; CC through triples. mr",MatchSource.WIKI,psi4manual/1.6.x/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mrcc.html
https://psicode.org/psi4manual/1.6.x/mrcc.html:1283,Energy Efficiency,energy,energy,1283,"mmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (https://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B. [Kallay:2008:144101] PSI4 will save both energies but will use; the CCSDT(Q)/B as the CCSDT(Q) energy. CCSDT(Q)/B has been found to be; more robust by Martin. [Martin:2014:785]. name; calls method in Kallay’s MRCC program [manual]. mrccsd; CC through doubles. mrccsdt; CC through triples. mr",MatchSource.WIKI,psi4manual/1.6.x/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mrcc.html
https://psicode.org/psi4manual/1.6.x/mrcc.html:2059,Energy Efficiency,energy,energy,2059,"1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B. [Kallay:2008:144101] PSI4 will save both energies but will use; the CCSDT(Q)/B as the CCSDT(Q) energy. CCSDT(Q)/B has been found to be; more robust by Martin. [Martin:2014:785]. name; calls method in Kallay’s MRCC program [manual]. mrccsd; CC through doubles. mrccsdt; CC through triples. mrccsdtq; CC through quadruples. mrccsdtqp; CC through quintuples. mrccsdtqph; CC through sextuples. mrccsd(t); CC through doubles with perturbative triples. mrccsdt(q); CC through triples with perturbative quadruples. mrccsdtq(p); CC through quadruples with pertubative quintuples. mrccsdtqp(h); CC through quintuples with pertubative sextuples. mrccsd(t)_l. mrccsdt(q)_l. mrccsdtq(p)_l. mrccsdtqp(h)_l. mrccsdt-1a; CC through doubles with iterative triples (cheapest terms). mrccsdtq-1a; CC through triples with iterative quadruples (cheapest terms). mrccsdtqp-1a; CC through quadruples with iterative quintuples (cheapest terms). mrccsdtqph-1a; CC through quintuples with iterative sextuples (cheapest terms). mrccsdt-1b; CC through doubles with iterative tri",MatchSource.WIKI,psi4manual/1.6.x/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mrcc.html
https://psicode.org/psi4manual/1.6.x/mrcc.html:4212,Energy Efficiency,energy,energy,4212,"ugh triples with iterative quadruples (cheapest terms). mrccsdtqp-1a; CC through quadruples with iterative quintuples (cheapest terms). mrccsdtqph-1a; CC through quintuples with iterative sextuples (cheapest terms). mrccsdt-1b; CC through doubles with iterative triples (cheaper terms). mrccsdtq-1b; CC through triples with iterative quadruples (cheaper terms). mrccsdtqp-1b; CC through quadruples with iterative quintuples (cheaper terms). mrccsdtqph-1b; CC through quintuples with iterative sextuples (cheaper terms). mrcc2; approximate CC through doubles. mrcc3; approximate CC through triples. mrcc4; approximate CC through quadruples. mrcc5; approximate CC through quintuples. mrcc6; approximate CC through sextuples. mrccsdt-3; CC through doubles with iterative triples (all but the most expensive terms). mrccsdtq-3; CC through triples with iterative quadruples (all but the most expensive terms). mrccsdtqp-3; CC through quadruples with iterative quintuples (all but the most expensive terms). mrccsdtqph-3; CC through quintuples with iterative sextuples (all but the most expensive terms). Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Interface Details¶. MRCC methods¶. MRCC_METHOD; Method; Description. 1; CC. 2; CC(n-1)[n]. 3; CC(n-1)(n); (CC(n-1)[n] energy is also calculated). 4; CC(n-1)(n)_L; (CC(n-1)[n] and CC(n-1)(n) energies are also calculated). 5; CC(n)-1a. 6; CC(n)-1b. 7; CCn. 8; CC(n)-3. table of contents. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to MRCC by M. Kállay. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mrcc.html
https://psicode.org/psi4manual/1.6.x/mrcc.html:368,Integrability,interface,interface,368,"﻿. Interface to MRCC by M. Kállay. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to MRCC by M. Kállay. Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (https://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B. [Kallay:2008:144101] PSI4 will save b",MatchSource.WIKI,psi4manual/1.6.x/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mrcc.html
https://psicode.org/psi4manual/1.6.x/mrcc.html:3905,Integrability,interface,interface,3905,"ugh triples with iterative quadruples (cheapest terms). mrccsdtqp-1a; CC through quadruples with iterative quintuples (cheapest terms). mrccsdtqph-1a; CC through quintuples with iterative sextuples (cheapest terms). mrccsdt-1b; CC through doubles with iterative triples (cheaper terms). mrccsdtq-1b; CC through triples with iterative quadruples (cheaper terms). mrccsdtqp-1b; CC through quadruples with iterative quintuples (cheaper terms). mrccsdtqph-1b; CC through quintuples with iterative sextuples (cheaper terms). mrcc2; approximate CC through doubles. mrcc3; approximate CC through triples. mrcc4; approximate CC through quadruples. mrcc5; approximate CC through quintuples. mrcc6; approximate CC through sextuples. mrccsdt-3; CC through doubles with iterative triples (all but the most expensive terms). mrccsdtq-3; CC through triples with iterative quadruples (all but the most expensive terms). mrccsdtqp-3; CC through quadruples with iterative quintuples (all but the most expensive terms). mrccsdtqph-3; CC through quintuples with iterative sextuples (all but the most expensive terms). Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Interface Details¶. MRCC methods¶. MRCC_METHOD; Method; Description. 1; CC. 2; CC(n-1)[n]. 3; CC(n-1)(n); (CC(n-1)[n] energy is also calculated). 4; CC(n-1)(n)_L; (CC(n-1)[n] and CC(n-1)(n) energies are also calculated). 5; CC(n)-1a. 6; CC(n)-1b. 7; CCn. 8; CC(n)-3. table of contents. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to MRCC by M. Kállay. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mrcc.html
https://psicode.org/psi4manual/1.6.x/mrcc.html:1144,Performance,perform,perform,1144,"ce to MRCC by M. Kállay. Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (https://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B. [Kallay:2008:144101] PSI4 will save both energies but will use; the CCSDT(Q)/B as the CCSDT(Q) energy. CCSDT(Q)/B has been found to be; more robust by Martin. [Martin:2014:785]. name; cal",MatchSource.WIKI,psi4manual/1.6.x/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mrcc.html
https://psicode.org/psi4manual/1.6.x/mrcc.html:1313,Performance,perform,perform,1313,"I4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (https://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B. [Kallay:2008:144101] PSI4 will save both energies but will use; the CCSDT(Q)/B as the CCSDT(Q) energy. CCSDT(Q)/B has been found to be; more robust by Martin. [Martin:2014:785]. name; calls method in Kallay’s MRCC program [manual]. mrccsd; CC through doubles. mrccsdt; CC through triples. mrccsdtq; CC through quadruples. mrccsdtqp; CC through quintuples. mrccsdtqph; CC through sextup",MatchSource.WIKI,psi4manual/1.6.x/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mrcc.html
https://psicode.org/psi4manual/1.6.x/mrcc.html:1330,Performance,optimiz,optimization,1330,"I4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (https://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B. [Kallay:2008:144101] PSI4 will save both energies but will use; the CCSDT(Q)/B as the CCSDT(Q) energy. CCSDT(Q)/B has been found to be; more robust by Martin. [Martin:2014:785]. name; calls method in Kallay’s MRCC program [manual]. mrccsd; CC through doubles. mrccsdt; CC through triples. mrccsdtq; CC through quadruples. mrccsdtqp; CC through quintuples. mrccsdtqph; CC through sextup",MatchSource.WIKI,psi4manual/1.6.x/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mrcc.html
https://psicode.org/psi4manual/1.6.x/mrcc.html:3920,Performance,optimiz,optimize,3920,"ugh triples with iterative quadruples (cheapest terms). mrccsdtqp-1a; CC through quadruples with iterative quintuples (cheapest terms). mrccsdtqph-1a; CC through quintuples with iterative sextuples (cheapest terms). mrccsdt-1b; CC through doubles with iterative triples (cheaper terms). mrccsdtq-1b; CC through triples with iterative quadruples (cheaper terms). mrccsdtqp-1b; CC through quadruples with iterative quintuples (cheaper terms). mrccsdtqph-1b; CC through quintuples with iterative sextuples (cheaper terms). mrcc2; approximate CC through doubles. mrcc3; approximate CC through triples. mrcc4; approximate CC through quadruples. mrcc5; approximate CC through quintuples. mrcc6; approximate CC through sextuples. mrccsdt-3; CC through doubles with iterative triples (all but the most expensive terms). mrccsdtq-3; CC through triples with iterative quadruples (all but the most expensive terms). mrccsdtqp-3; CC through quadruples with iterative quintuples (all but the most expensive terms). mrccsdtqph-3; CC through quintuples with iterative sextuples (all but the most expensive terms). Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Interface Details¶. MRCC methods¶. MRCC_METHOD; Method; Description. 1; CC. 2; CC(n-1)[n]. 3; CC(n-1)(n); (CC(n-1)[n] energy is also calculated). 4; CC(n-1)(n)_L; (CC(n-1)[n] and CC(n-1)(n) energies are also calculated). 5; CC(n)-1a. 6; CC(n)-1b. 7; CCn. 8; CC(n)-3. table of contents. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to MRCC by M. Kállay. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mrcc.html
https://psicode.org/psi4manual/1.6.x/mrcc.html:4073,Performance,optimiz,optimize,4073,"ugh triples with iterative quadruples (cheapest terms). mrccsdtqp-1a; CC through quadruples with iterative quintuples (cheapest terms). mrccsdtqph-1a; CC through quintuples with iterative sextuples (cheapest terms). mrccsdt-1b; CC through doubles with iterative triples (cheaper terms). mrccsdtq-1b; CC through triples with iterative quadruples (cheaper terms). mrccsdtqp-1b; CC through quadruples with iterative quintuples (cheaper terms). mrccsdtqph-1b; CC through quintuples with iterative sextuples (cheaper terms). mrcc2; approximate CC through doubles. mrcc3; approximate CC through triples. mrcc4; approximate CC through quadruples. mrcc5; approximate CC through quintuples. mrcc6; approximate CC through sextuples. mrccsdt-3; CC through doubles with iterative triples (all but the most expensive terms). mrccsdtq-3; CC through triples with iterative quadruples (all but the most expensive terms). mrccsdtqp-3; CC through quadruples with iterative quintuples (all but the most expensive terms). mrccsdtqph-3; CC through quintuples with iterative sextuples (all but the most expensive terms). Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Interface Details¶. MRCC methods¶. MRCC_METHOD; Method; Description. 1; CC. 2; CC(n-1)[n]. 3; CC(n-1)(n); (CC(n-1)[n] energy is also calculated). 4; CC(n-1)(n)_L; (CC(n-1)[n] and CC(n-1)(n) energies are also calculated). 5; CC(n)-1a. 6; CC(n)-1b. 7; CCn. 8; CC(n)-3. table of contents. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to MRCC by M. Kállay. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mrcc.html
https://psicode.org/psi4manual/1.6.x/mrcc.html:962,Usability,simpl,simply,962,"﻿. Interface to MRCC by M. Kállay. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to MRCC by M. Kállay. Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (https://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B. [Kallay:2008:144101] PSI4 will save b",MatchSource.WIKI,psi4manual/1.6.x/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mrcc.html
https://psicode.org/psi4manual/1.6.x/mrcc.html:1243,Usability,simpl,simply,1243,"mmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (https://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B. [Kallay:2008:144101] PSI4 will save both energies but will use; the CCSDT(Q)/B as the CCSDT(Q) energy. CCSDT(Q)/B has been found to be; more robust by Martin. [Martin:2014:785]. name; calls method in Kallay’s MRCC program [manual]. mrccsd; CC through doubles. mrccsdt; CC through triples. mr",MatchSource.WIKI,psi4manual/1.6.x/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mrcc.html
https://psicode.org/psi4manual/1.6.x/mrcc_table_energy.html:1986,Deployability,update,updated,1986,".  · ; 1.6;  · . PSI4. Introduction; <no title>. name; calls method in Kallay’s MRCC program [manual]. mrccsd; CC through doubles. mrccsdt; CC through triples. mrccsdtq; CC through quadruples. mrccsdtqp; CC through quintuples. mrccsdtqph; CC through sextuples. mrccsd(t); CC through doubles with perturbative triples. mrccsdt(q); CC through triples with perturbative quadruples. mrccsdtq(p); CC through quadruples with pertubative quintuples. mrccsdtqp(h); CC through quintuples with pertubative sextuples. mrccsd(t)_l. mrccsdt(q)_l. mrccsdtq(p)_l. mrccsdtqp(h)_l. mrccsdt-1a; CC through doubles with iterative triples (cheapest terms). mrccsdtq-1a; CC through triples with iterative quadruples (cheapest terms). mrccsdtqp-1a; CC through quadruples with iterative quintuples (cheapest terms). mrccsdtqph-1a; CC through quintuples with iterative sextuples (cheapest terms). mrccsdt-1b; CC through doubles with iterative triples (cheaper terms). mrccsdtq-1b; CC through triples with iterative quadruples (cheaper terms). mrccsdtqp-1b; CC through quadruples with iterative quintuples (cheaper terms). mrccsdtqph-1b; CC through quintuples with iterative sextuples (cheaper terms). mrcc2; approximate CC through doubles. mrcc3; approximate CC through triples. mrcc4; approximate CC through quadruples. mrcc5; approximate CC through quintuples. mrcc6; approximate CC through sextuples. mrccsdt-3; CC through doubles with iterative triples (all but the most expensive terms). mrccsdtq-3; CC through triples with iterative quadruples (all but the most expensive terms). mrccsdtqp-3; CC through quadruples with iterative quintuples (all but the most expensive terms). mrccsdtqph-3; CC through quintuples with iterative sextuples (all but the most expensive terms). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Introduction; <no title>. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/mrcc_table_energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mrcc_table_energy.html
https://psicode.org/psi4manual/1.6.x/nbody.html:11136,Availability,avail,available,11136,"t of bsse_type). ret_gradient; (nat, 3); when driver is g/h; interaction gradient: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type. ret_hessian; (nat * 3, nat * 3); when driver is h; interaction Hessian: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type). nbody; >=1; always; energy n-body QCVariables to be set.   CP-CORRECTED TOTAL ENERGY THROUGH 1-BODY;   1; when cp in bsse_type; MBE sum of subsystems of 1-body. summed are total energies with cp treatment.   CP-CORRECTED TOTAL ENERGY THROUGH 2-BODY;   1; when cp in bsse_type & max_nbody>=2; MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with cp treatment.   CP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY;   1; when cp in bsse_type; MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/ cp treatment.   CP-CORRECTED TOTAL ENERGY;   1; when cp in bsse_type & rtd=T; best available total energy with cp treatment: CP-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY.   CP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY;   1; when cp in bsse_type & max_nbody>=2; 2-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment.   CP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY;   1; when cp in bsse_type; {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment.   CP-CORRECTED INTERACTION ENERGY;   1; when cp in bsse_type; best available interaction energy with cp treatment: CP-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY.   CP-CORRECTED 2-BODY CONTRIBUTION TO ENERGY;   1; when cp in bsse_type & max_nbody>=2; 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/ cp treatment.   CP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY;   1; when cp in bsse_type; {max_nbody}-body total data less ({max_nbody}-1)-body data for partial IE; inputs are",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:11689,Availability,avail,available,11689,RECTED TOTAL ENERGY THROUGH 2-BODY;   1; when cp in bsse_type & max_nbody>=2; MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with cp treatment.   CP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY;   1; when cp in bsse_type; MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/ cp treatment.   CP-CORRECTED TOTAL ENERGY;   1; when cp in bsse_type & rtd=T; best available total energy with cp treatment: CP-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY.   CP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY;   1; when cp in bsse_type & max_nbody>=2; 2-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment.   CP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY;   1; when cp in bsse_type; {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment.   CP-CORRECTED INTERACTION ENERGY;   1; when cp in bsse_type; best available interaction energy with cp treatment: CP-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY.   CP-CORRECTED 2-BODY CONTRIBUTION TO ENERGY;   1; when cp in bsse_type & max_nbody>=2; 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/ cp treatment.   CP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY;   1; when cp in bsse_type; {max_nbody}-body total data less ({max_nbody}-1)-body data for partial IE; inputs are total energies w/ cp treat.   NOCP-CORRECTED TOTAL ENERGY THROUGH 1-BODY;   1; when nocp in bsse_type; MBE sum of subsystems of 1-body. summed are total energies without cp treatment.   NOCP-CORRECTED TOTAL ENERGY THROUGH 2-BODY;   1; when nocp in bsse_type & max_nbody>=2; MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies without cp treatment.   NOCP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY;   1; when nocp in bsse_type; MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/o cp treatm,MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:12778,Availability,avail,available,12778,   CP-CORRECTED 2-BODY CONTRIBUTION TO ENERGY;   1; when cp in bsse_type & max_nbody>=2; 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/ cp treatment.   CP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY;   1; when cp in bsse_type; {max_nbody}-body total data less ({max_nbody}-1)-body data for partial IE; inputs are total energies w/ cp treat.   NOCP-CORRECTED TOTAL ENERGY THROUGH 1-BODY;   1; when nocp in bsse_type; MBE sum of subsystems of 1-body. summed are total energies without cp treatment.   NOCP-CORRECTED TOTAL ENERGY THROUGH 2-BODY;   1; when nocp in bsse_type & max_nbody>=2; MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies without cp treatment.   NOCP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY;   1; when nocp in bsse_type; MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/o cp treatment.   NOCP-CORRECTED TOTAL ENERGY;   1; when nocp in bsse_type; best available total energy without cp treatment: NOCP-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY.   NOCP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY;   1; when nocp in bsse_type & max_nbody>=2; 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/o cp treatment.   NOCP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY;   1; when nocp in bsse_type; {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies w/o cp treatment.   NOCP-CORRECTED INTERACTION ENERGY;   1; when nocp in bsse_type; best available interaction energy without cp treatment: NOCP-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY.   NOCP-CORRECTED 2-BODY CONTRIBUTION TO ENERGY;   1; when nocp in bsse_type & max_nbody>=2; 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/o cp treatment.   NOCP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY;   1; when nocp in bsse_type; {max_nbody}-body total data less ({max_nbody}-1)-body data f,MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:13346,Availability,avail,available,13346,ROUGH 2-BODY;   1; when nocp in bsse_type & max_nbody>=2; MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies without cp treatment.   NOCP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY;   1; when nocp in bsse_type; MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/o cp treatment.   NOCP-CORRECTED TOTAL ENERGY;   1; when nocp in bsse_type; best available total energy without cp treatment: NOCP-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY.   NOCP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY;   1; when nocp in bsse_type & max_nbody>=2; 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/o cp treatment.   NOCP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY;   1; when nocp in bsse_type; {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies w/o cp treatment.   NOCP-CORRECTED INTERACTION ENERGY;   1; when nocp in bsse_type; best available interaction energy without cp treatment: NOCP-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY.   NOCP-CORRECTED 2-BODY CONTRIBUTION TO ENERGY;   1; when nocp in bsse_type & max_nbody>=2; 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/o cp treatment.   NOCP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY;   1; when nocp in bsse_type; {max_nbody}-body total data less ({max_nbody}-1)-body data for partial IE; inputs are total energies w/o cp treat.   VMFC-CORRECTED TOTAL ENERGY THROUGH 1-BODY;   1; when vmfc in bsse_type; MBE sum of subsystems of 1-body. summed are total energies with vmfc treatment.   VMFC-CORRECTED TOTAL ENERGY THROUGH 2-BODY;   1; when vmfc in bsse_type & max_nbody>=2; MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with vmfc treatment.   VMFC-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY;   1; when vmfc in bsse_type; MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies ,MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:14449,Availability,avail,available,14449,CORRECTED 2-BODY CONTRIBUTION TO ENERGY;   1; when nocp in bsse_type & max_nbody>=2; 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/o cp treatment.   NOCP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY;   1; when nocp in bsse_type; {max_nbody}-body total data less ({max_nbody}-1)-body data for partial IE; inputs are total energies w/o cp treat.   VMFC-CORRECTED TOTAL ENERGY THROUGH 1-BODY;   1; when vmfc in bsse_type; MBE sum of subsystems of 1-body. summed are total energies with vmfc treatment.   VMFC-CORRECTED TOTAL ENERGY THROUGH 2-BODY;   1; when vmfc in bsse_type & max_nbody>=2; MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with vmfc treatment.   VMFC-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY;   1; when vmfc in bsse_type; MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/ vmfc treatment.   VMFC-CORRECTED TOTAL ENERGY;   1; when vmfc in bsse_type; best available total energy with vmfc treatment: VMFC-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY.   VMFC-CORRECTED INTERACTION ENERGY THROUGH 2-BODY;   1; when vmfc in bsse_type & max_nbody>=2; 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment.   VMFC-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY;   1; when vmfc in bsse_type; {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment.   VMFC-CORRECTED INTERACTION ENERGY;   1; when vmfc in bsse_type; best available interaction energy with vmfc treatment: VMFC-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY.   VMFC-CORRECTED 2-BODY CONTRIBUTION TO ENERGY;   1; when vmfc in bsse_type & max_nbody>=2; 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/ vmfc treatment.   VMFC-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY;   1; when vmfc in bsse_type; {max_nbody}-body total data less ({max_nbody}-1)-body data ,MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:15018,Availability,avail,available,15018,ROUGH 2-BODY;   1; when vmfc in bsse_type & max_nbody>=2; MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with vmfc treatment.   VMFC-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY;   1; when vmfc in bsse_type; MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/ vmfc treatment.   VMFC-CORRECTED TOTAL ENERGY;   1; when vmfc in bsse_type; best available total energy with vmfc treatment: VMFC-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY.   VMFC-CORRECTED INTERACTION ENERGY THROUGH 2-BODY;   1; when vmfc in bsse_type & max_nbody>=2; 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment.   VMFC-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY;   1; when vmfc in bsse_type; {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment.   VMFC-CORRECTED INTERACTION ENERGY;   1; when vmfc in bsse_type; best available interaction energy with vmfc treatment: VMFC-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY.   VMFC-CORRECTED 2-BODY CONTRIBUTION TO ENERGY;   1; when vmfc in bsse_type & max_nbody>=2; 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/ vmfc treatment.   VMFC-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY;   1; when vmfc in bsse_type; {max_nbody}-body total data less ({max_nbody}-1)-body data for partial IE; inputs are total energies w/ vmfc treat. energy_body_dict; max_nbody; always; total energies at each n-body level.   1;   1; always; zeroed if cp & rtd=F; cumulative through 1-body total energies w/ cp/nocp/vmfc treatment (dep. on 1st of bsse_type).   2;   1; max_nbody>=2; cumulative through 2-body total energies w/ cp/nocp/vmfc treatment (dep. on 1st of bsse_type).   {max_nbody};   1; always; cumulative through {max_nbody}-body total energies w/ cp/nocp/vmfc treatment (dep. on 1st of bsse_type). gradient_body_dict; max_nbody; when driver is g/h.   1,MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:23616,Deployability,update,updated,23616,"ssians with vmfc treatment.   2vmfc;   (nat*3, nat*3); when driver is h & max_nbody>=2; zeroed if vmfc not in bsse_type; cumulative through 2-body total Hessians with vmfc treatment.   {max_nbody}vmfc;   (nat*3, nat*3); when driver is h; zeroed if vmfc not in bsse_type; cumulative through {max_nbody}-body total Hessians with vmfc treatment. intermediates; ntasks; always; all individual energies with nice labels.   N-BODY (1, 2)@(1, 2) TOTAL ENERGY;   1; always; total energy for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   N-BODY (3)@(2, 3) TOTAL ENERGY;   1; always; total energy for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_energy; ntasks; always; all individual energies.   1_((1, 2), (1, 2));   1; always; total energy for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   1; always; total energy for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_gradient; ntasks; when driver is g/h; all individual gradients.   1_((1, 2), (1, 2));   (nat, 3); when driver is g/h; total gradient for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   (nat, 3); when driver is g/h; total gradient for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_hessian; ntasks; when driver is h; all individual Hessians.   1_((1, 2), (1, 2));   (nat*3, nat*3); when driver is h; total Hessian for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   (nat*3, nat*3); when driver is h; total Hessian for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Basis Set Superposition Corrections. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:412,Energy Efficiency,energy,energy,412,"﻿. Basis Set Superposition Corrections. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Basis Set Superposition Corrections. Basis Set Superposition Corrections¶; Code author: Daniel G. A. Smith. psi4.driver.driver_nbody.nbody(func, method_string[, molecule, bsse_type, max_nbody, ptype, return_total_data])[source]¶; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. Returns; return type of func – The data. Returns; (float, Wavefunction) – data and wavefunction with energy/gradient/hessian set appropriately when return_wfn specified. Parameters. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element of a tuple. bsse_type (str or list) – 'cp' || ['nocp', 'vmfc'] || \(\Rightarrow\) None \(\Leftarrow\) || etc.; Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecular interaction energy, or VMFC for Valiron-Mayer; Function Counterpoise correction. If a list is provided, the first string in; the list determines which interaction or total energies/gradients/Hessians are; returned by this function. By default, many-body treatments are inactive. max_nbody (int) – 3 || etc.; Maximum n-body to compute, cannot exceed the number of fragments in the molecule. return_total_data (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is 'off' for energies,; 'on' for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying return_t",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:652,Energy Efficiency,energy,energy,652,"﻿. Basis Set Superposition Corrections. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Basis Set Superposition Corrections. Basis Set Superposition Corrections¶; Code author: Daniel G. A. Smith. psi4.driver.driver_nbody.nbody(func, method_string[, molecule, bsse_type, max_nbody, ptype, return_total_data])[source]¶; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. Returns; return type of func – The data. Returns; (float, Wavefunction) – data and wavefunction with energy/gradient/hessian set appropriately when return_wfn specified. Parameters. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element of a tuple. bsse_type (str or list) – 'cp' || ['nocp', 'vmfc'] || \(\Rightarrow\) None \(\Leftarrow\) || etc.; Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecular interaction energy, or VMFC for Valiron-Mayer; Function Counterpoise correction. If a list is provided, the first string in; the list determines which interaction or total energies/gradients/Hessians are; returned by this function. By default, many-body treatments are inactive. max_nbody (int) – 3 || etc.; Maximum n-body to compute, cannot exceed the number of fragments in the molecule. return_total_data (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is 'off' for energies,; 'on' for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying return_t",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:1205,Energy Efficiency,energy,energy,1205,"ions. Basis Set Superposition Corrections¶; Code author: Daniel G. A. Smith. psi4.driver.driver_nbody.nbody(func, method_string[, molecule, bsse_type, max_nbody, ptype, return_total_data])[source]¶; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. Returns; return type of func – The data. Returns; (float, Wavefunction) – data and wavefunction with energy/gradient/hessian set appropriately when return_wfn specified. Parameters. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element of a tuple. bsse_type (str or list) – 'cp' || ['nocp', 'vmfc'] || \(\Rightarrow\) None \(\Leftarrow\) || etc.; Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecular interaction energy, or VMFC for Valiron-Mayer; Function Counterpoise correction. If a list is provided, the first string in; the list determines which interaction or total energies/gradients/Hessians are; returned by this function. By default, many-body treatments are inactive. max_nbody (int) – 3 || etc.; Maximum n-body to compute, cannot exceed the number of fragments in the molecule. return_total_data (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is 'off' for energies,; 'on' for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying return_total_data = True; may carry out more computations than return_total_data = False.; For gradients and Hessians, return_total_data = False is rarely useful. levels (dict) – {1: 'ccsd(t",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:1691,Energy Efficiency,energy,energy,1691,"n set appropriately when return_wfn specified. Parameters. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element of a tuple. bsse_type (str or list) – 'cp' || ['nocp', 'vmfc'] || \(\Rightarrow\) None \(\Leftarrow\) || etc.; Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecular interaction energy, or VMFC for Valiron-Mayer; Function Counterpoise correction. If a list is provided, the first string in; the list determines which interaction or total energies/gradients/Hessians are; returned by this function. By default, many-body treatments are inactive. max_nbody (int) – 3 || etc.; Maximum n-body to compute, cannot exceed the number of fragments in the molecule. return_total_data (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is 'off' for energies,; 'on' for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying return_total_data = True; may carry out more computations than return_total_data = False.; For gradients and Hessians, return_total_data = False is rarely useful. levels (dict) – {1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'} || {1: 2, 2: 'ccsd(t)', 3: 'mp2'} || etc; Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. supersystem computes; all higher order n-body effects up to the number of fragments. embedding_charges (dict) – {1: [-0.834, 0.417, 0.417], ..}; Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:2566,Energy Efficiency,charge,charges,2566,"r of fragments in the molecule. return_total_data (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is 'off' for energies,; 'on' for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying return_total_data = True; may carry out more computations than return_total_data = False.; For gradients and Hessians, return_total_data = False is rarely useful. levels (dict) – {1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'} || {1: 2, 2: 'ccsd(t)', 3: 'mp2'} || etc; Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. supersystem computes; all higher order n-body effects up to the number of fragments. embedding_charges (dict) – {1: [-0.834, 0.417, 0.417], ..}; Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. The nbody function computes counterpoise-corrected (CP), non-CP (noCP), and Valiron-Mayer Function Counterpoise (VMFC) interaction energies for complexes composed of arbitrary numbers of monomers.; Examples :; # Counterpoise corrected CCSD(T) energies for the Helium dimer; molecule mol {; He; --; He 1 3; }; # Calculate interaction energies only (skips monomers in monomer basis):; energy('CCSD(T)', bsse_type='cp'); # Calculate interaction and total energies, return interaction energies:; energy('CCSD(T)', bsse_type=['cp','nocp']); # Calculate and return counterpoise-corrected gradient; # Useful for e.g. CP-corrected geometry optimization; gradient('CCSD(T)', bsse_type='cp', return_total_data=True). # noCP, VMFC, and CP energy for a helium cluster, limited at 3 bodies; molecule mol {; He 0 0",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:2624,Energy Efficiency,charge,charges,2624," 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is 'off' for energies,; 'on' for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying return_total_data = True; may carry out more computations than return_total_data = False.; For gradients and Hessians, return_total_data = False is rarely useful. levels (dict) – {1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'} || {1: 2, 2: 'ccsd(t)', 3: 'mp2'} || etc; Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. supersystem computes; all higher order n-body effects up to the number of fragments. embedding_charges (dict) – {1: [-0.834, 0.417, 0.417], ..}; Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. The nbody function computes counterpoise-corrected (CP), non-CP (noCP), and Valiron-Mayer Function Counterpoise (VMFC) interaction energies for complexes composed of arbitrary numbers of monomers.; Examples :; # Counterpoise corrected CCSD(T) energies for the Helium dimer; molecule mol {; He; --; He 1 3; }; # Calculate interaction energies only (skips monomers in monomer basis):; energy('CCSD(T)', bsse_type='cp'); # Calculate interaction and total energies, return interaction energies:; energy('CCSD(T)', bsse_type=['cp','nocp']); # Calculate and return counterpoise-corrected gradient; # Useful for e.g. CP-corrected geometry optimization; gradient('CCSD(T)', bsse_type='cp', return_total_data=True). # noCP, VMFC, and CP energy for a helium cluster, limited at 3 bodies; molecule mol {; He 0 0 0; --; He 0 0 4; --; He 0 4 0; --; He 4 0 0; }. # Returns t",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:2676,Energy Efficiency,charge,charges,2676,"adient/Hessian) of the system,; otherwise returns interaction data. Default is 'off' for energies,; 'on' for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying return_total_data = True; may carry out more computations than return_total_data = False.; For gradients and Hessians, return_total_data = False is rarely useful. levels (dict) – {1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'} || {1: 2, 2: 'ccsd(t)', 3: 'mp2'} || etc; Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. supersystem computes; all higher order n-body effects up to the number of fragments. embedding_charges (dict) – {1: [-0.834, 0.417, 0.417], ..}; Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. The nbody function computes counterpoise-corrected (CP), non-CP (noCP), and Valiron-Mayer Function Counterpoise (VMFC) interaction energies for complexes composed of arbitrary numbers of monomers.; Examples :; # Counterpoise corrected CCSD(T) energies for the Helium dimer; molecule mol {; He; --; He 1 3; }; # Calculate interaction energies only (skips monomers in monomer basis):; energy('CCSD(T)', bsse_type='cp'); # Calculate interaction and total energies, return interaction energies:; energy('CCSD(T)', bsse_type=['cp','nocp']); # Calculate and return counterpoise-corrected gradient; # Useful for e.g. CP-corrected geometry optimization; gradient('CCSD(T)', bsse_type='cp', return_total_data=True). # noCP, VMFC, and CP energy for a helium cluster, limited at 3 bodies; molecule mol {; He 0 0 0; --; He 0 0 4; --; He 0 4 0; --; He 4 0 0; }. # Returns the nocp energy as its first in the list; energy('CCSD(T)', bsse_type=['nocp', 'cp', 'vmfc",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:3135,Energy Efficiency,energy,energy,3135,"l. levels (dict) – {1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'} || {1: 2, 2: 'ccsd(t)', 3: 'mp2'} || etc; Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. supersystem computes; all higher order n-body effects up to the number of fragments. embedding_charges (dict) – {1: [-0.834, 0.417, 0.417], ..}; Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. The nbody function computes counterpoise-corrected (CP), non-CP (noCP), and Valiron-Mayer Function Counterpoise (VMFC) interaction energies for complexes composed of arbitrary numbers of monomers.; Examples :; # Counterpoise corrected CCSD(T) energies for the Helium dimer; molecule mol {; He; --; He 1 3; }; # Calculate interaction energies only (skips monomers in monomer basis):; energy('CCSD(T)', bsse_type='cp'); # Calculate interaction and total energies, return interaction energies:; energy('CCSD(T)', bsse_type=['cp','nocp']); # Calculate and return counterpoise-corrected gradient; # Useful for e.g. CP-corrected geometry optimization; gradient('CCSD(T)', bsse_type='cp', return_total_data=True). # noCP, VMFC, and CP energy for a helium cluster, limited at 3 bodies; molecule mol {; He 0 0 0; --; He 0 0 4; --; He 0 4 0; --; He 4 0 0; }. # Returns the nocp energy as its first in the list; energy('CCSD(T)', bsse_type=['nocp', 'cp', 'vmfc'], max_nbody=3). class psi4.driver.driver_nbody.ManyBodyComputer(**data)[source]¶. Parameters. molecule (Any) – The target molecule, if not the last molecule defined.; basis (str, Default: (auto)) – ; method (str, Default: (auto)) – ; driver ({energy,gradient,hessian,properties}) – The computation driver; i.e., energy, gradient, hessian.; keywords (Dict[Any], Default: {}) – The computation keywords/options.; bsse_type ({nocp,cp,vmfc}, Default: [<Bs",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:3244,Energy Efficiency,energy,energy,3244,"l. levels (dict) – {1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'} || {1: 2, 2: 'ccsd(t)', 3: 'mp2'} || etc; Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. supersystem computes; all higher order n-body effects up to the number of fragments. embedding_charges (dict) – {1: [-0.834, 0.417, 0.417], ..}; Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. The nbody function computes counterpoise-corrected (CP), non-CP (noCP), and Valiron-Mayer Function Counterpoise (VMFC) interaction energies for complexes composed of arbitrary numbers of monomers.; Examples :; # Counterpoise corrected CCSD(T) energies for the Helium dimer; molecule mol {; He; --; He 1 3; }; # Calculate interaction energies only (skips monomers in monomer basis):; energy('CCSD(T)', bsse_type='cp'); # Calculate interaction and total energies, return interaction energies:; energy('CCSD(T)', bsse_type=['cp','nocp']); # Calculate and return counterpoise-corrected gradient; # Useful for e.g. CP-corrected geometry optimization; gradient('CCSD(T)', bsse_type='cp', return_total_data=True). # noCP, VMFC, and CP energy for a helium cluster, limited at 3 bodies; molecule mol {; He 0 0 0; --; He 0 0 4; --; He 0 4 0; --; He 4 0 0; }. # Returns the nocp energy as its first in the list; energy('CCSD(T)', bsse_type=['nocp', 'cp', 'vmfc'], max_nbody=3). class psi4.driver.driver_nbody.ManyBodyComputer(**data)[source]¶. Parameters. molecule (Any) – The target molecule, if not the last molecule defined.; basis (str, Default: (auto)) – ; method (str, Default: (auto)) – ; driver ({energy,gradient,hessian,properties}) – The computation driver; i.e., energy, gradient, hessian.; keywords (Dict[Any], Default: {}) – The computation keywords/options.; bsse_type ({nocp,cp,vmfc}, Default: [<Bs",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:3480,Energy Efficiency,energy,energy,3480,"}; Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. The nbody function computes counterpoise-corrected (CP), non-CP (noCP), and Valiron-Mayer Function Counterpoise (VMFC) interaction energies for complexes composed of arbitrary numbers of monomers.; Examples :; # Counterpoise corrected CCSD(T) energies for the Helium dimer; molecule mol {; He; --; He 1 3; }; # Calculate interaction energies only (skips monomers in monomer basis):; energy('CCSD(T)', bsse_type='cp'); # Calculate interaction and total energies, return interaction energies:; energy('CCSD(T)', bsse_type=['cp','nocp']); # Calculate and return counterpoise-corrected gradient; # Useful for e.g. CP-corrected geometry optimization; gradient('CCSD(T)', bsse_type='cp', return_total_data=True). # noCP, VMFC, and CP energy for a helium cluster, limited at 3 bodies; molecule mol {; He 0 0 0; --; He 0 0 4; --; He 0 4 0; --; He 4 0 0; }. # Returns the nocp energy as its first in the list; energy('CCSD(T)', bsse_type=['nocp', 'cp', 'vmfc'], max_nbody=3). class psi4.driver.driver_nbody.ManyBodyComputer(**data)[source]¶. Parameters. molecule (Any) – The target molecule, if not the last molecule defined.; basis (str, Default: (auto)) – ; method (str, Default: (auto)) – ; driver ({energy,gradient,hessian,properties}) – The computation driver; i.e., energy, gradient, hessian.; keywords (Dict[Any], Default: {}) – The computation keywords/options.; bsse_type ({nocp,cp,vmfc}, Default: [<BsseEnum.cp: 'cp'>]) – Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned.; nfragments (int, Default: -1) – Number of distinct fragments comprising full molecular supersystem.; max_nbody (int, Default: -1) – Maximum number of bodies to include in the many-body treatment. Possible: max_nbody <= nfragments. Default: ",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:3620,Energy Efficiency,energy,energy,3620,"m-centered point charges for fragments whose basis sets are not included in the computation. The nbody function computes counterpoise-corrected (CP), non-CP (noCP), and Valiron-Mayer Function Counterpoise (VMFC) interaction energies for complexes composed of arbitrary numbers of monomers.; Examples :; # Counterpoise corrected CCSD(T) energies for the Helium dimer; molecule mol {; He; --; He 1 3; }; # Calculate interaction energies only (skips monomers in monomer basis):; energy('CCSD(T)', bsse_type='cp'); # Calculate interaction and total energies, return interaction energies:; energy('CCSD(T)', bsse_type=['cp','nocp']); # Calculate and return counterpoise-corrected gradient; # Useful for e.g. CP-corrected geometry optimization; gradient('CCSD(T)', bsse_type='cp', return_total_data=True). # noCP, VMFC, and CP energy for a helium cluster, limited at 3 bodies; molecule mol {; He 0 0 0; --; He 0 0 4; --; He 0 4 0; --; He 4 0 0; }. # Returns the nocp energy as its first in the list; energy('CCSD(T)', bsse_type=['nocp', 'cp', 'vmfc'], max_nbody=3). class psi4.driver.driver_nbody.ManyBodyComputer(**data)[source]¶. Parameters. molecule (Any) – The target molecule, if not the last molecule defined.; basis (str, Default: (auto)) – ; method (str, Default: (auto)) – ; driver ({energy,gradient,hessian,properties}) – The computation driver; i.e., energy, gradient, hessian.; keywords (Dict[Any], Default: {}) – The computation keywords/options.; bsse_type ({nocp,cp,vmfc}, Default: [<BsseEnum.cp: 'cp'>]) – Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned.; nfragments (int, Default: -1) – Number of distinct fragments comprising full molecular supersystem.; max_nbody (int, Default: -1) – Maximum number of bodies to include in the many-body treatment. Possible: max_nbody <= nfragments. Default: max_nbody = nfragments.; nbodies_per_mc_level (List[List[Union[int, ]]], Default: []) – Distribution of active n-body levels among",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:3653,Energy Efficiency,energy,energy,3653,"m-centered point charges for fragments whose basis sets are not included in the computation. The nbody function computes counterpoise-corrected (CP), non-CP (noCP), and Valiron-Mayer Function Counterpoise (VMFC) interaction energies for complexes composed of arbitrary numbers of monomers.; Examples :; # Counterpoise corrected CCSD(T) energies for the Helium dimer; molecule mol {; He; --; He 1 3; }; # Calculate interaction energies only (skips monomers in monomer basis):; energy('CCSD(T)', bsse_type='cp'); # Calculate interaction and total energies, return interaction energies:; energy('CCSD(T)', bsse_type=['cp','nocp']); # Calculate and return counterpoise-corrected gradient; # Useful for e.g. CP-corrected geometry optimization; gradient('CCSD(T)', bsse_type='cp', return_total_data=True). # noCP, VMFC, and CP energy for a helium cluster, limited at 3 bodies; molecule mol {; He 0 0 0; --; He 0 0 4; --; He 0 4 0; --; He 4 0 0; }. # Returns the nocp energy as its first in the list; energy('CCSD(T)', bsse_type=['nocp', 'cp', 'vmfc'], max_nbody=3). class psi4.driver.driver_nbody.ManyBodyComputer(**data)[source]¶. Parameters. molecule (Any) – The target molecule, if not the last molecule defined.; basis (str, Default: (auto)) – ; method (str, Default: (auto)) – ; driver ({energy,gradient,hessian,properties}) – The computation driver; i.e., energy, gradient, hessian.; keywords (Dict[Any], Default: {}) – The computation keywords/options.; bsse_type ({nocp,cp,vmfc}, Default: [<BsseEnum.cp: 'cp'>]) – Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned.; nfragments (int, Default: -1) – Number of distinct fragments comprising full molecular supersystem.; max_nbody (int, Default: -1) – Maximum number of bodies to include in the many-body treatment. Possible: max_nbody <= nfragments. Default: max_nbody = nfragments.; nbodies_per_mc_level (List[List[Union[int, ]]], Default: []) – Distribution of active n-body levels among",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:3946,Energy Efficiency,energy,energy,3946,"monomers.; Examples :; # Counterpoise corrected CCSD(T) energies for the Helium dimer; molecule mol {; He; --; He 1 3; }; # Calculate interaction energies only (skips monomers in monomer basis):; energy('CCSD(T)', bsse_type='cp'); # Calculate interaction and total energies, return interaction energies:; energy('CCSD(T)', bsse_type=['cp','nocp']); # Calculate and return counterpoise-corrected gradient; # Useful for e.g. CP-corrected geometry optimization; gradient('CCSD(T)', bsse_type='cp', return_total_data=True). # noCP, VMFC, and CP energy for a helium cluster, limited at 3 bodies; molecule mol {; He 0 0 0; --; He 0 0 4; --; He 0 4 0; --; He 4 0 0; }. # Returns the nocp energy as its first in the list; energy('CCSD(T)', bsse_type=['nocp', 'cp', 'vmfc'], max_nbody=3). class psi4.driver.driver_nbody.ManyBodyComputer(**data)[source]¶. Parameters. molecule (Any) – The target molecule, if not the last molecule defined.; basis (str, Default: (auto)) – ; method (str, Default: (auto)) – ; driver ({energy,gradient,hessian,properties}) – The computation driver; i.e., energy, gradient, hessian.; keywords (Dict[Any], Default: {}) – The computation keywords/options.; bsse_type ({nocp,cp,vmfc}, Default: [<BsseEnum.cp: 'cp'>]) – Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned.; nfragments (int, Default: -1) – Number of distinct fragments comprising full molecular supersystem.; max_nbody (int, Default: -1) – Maximum number of bodies to include in the many-body treatment. Possible: max_nbody <= nfragments. Default: max_nbody = nfragments.; nbodies_per_mc_level (List[List[Union[int, ]]], Default: []) – Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., [[1, 2]] has max_nbody=2 and 1-bod",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:4015,Energy Efficiency,energy,energy,4015,"olecule mol {; He; --; He 1 3; }; # Calculate interaction energies only (skips monomers in monomer basis):; energy('CCSD(T)', bsse_type='cp'); # Calculate interaction and total energies, return interaction energies:; energy('CCSD(T)', bsse_type=['cp','nocp']); # Calculate and return counterpoise-corrected gradient; # Useful for e.g. CP-corrected geometry optimization; gradient('CCSD(T)', bsse_type='cp', return_total_data=True). # noCP, VMFC, and CP energy for a helium cluster, limited at 3 bodies; molecule mol {; He 0 0 0; --; He 0 0 4; --; He 0 4 0; --; He 4 0 0; }. # Returns the nocp energy as its first in the list; energy('CCSD(T)', bsse_type=['nocp', 'cp', 'vmfc'], max_nbody=3). class psi4.driver.driver_nbody.ManyBodyComputer(**data)[source]¶. Parameters. molecule (Any) – The target molecule, if not the last molecule defined.; basis (str, Default: (auto)) – ; method (str, Default: (auto)) – ; driver ({energy,gradient,hessian,properties}) – The computation driver; i.e., energy, gradient, hessian.; keywords (Dict[Any], Default: {}) – The computation keywords/options.; bsse_type ({nocp,cp,vmfc}, Default: [<BsseEnum.cp: 'cp'>]) – Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned.; nfragments (int, Default: -1) – Number of distinct fragments comprising full molecular supersystem.; max_nbody (int, Default: -1) – Maximum number of bodies to include in the many-body treatment. Possible: max_nbody <= nfragments. Default: max_nbody = nfragments.; nbodies_per_mc_level (List[List[Union[int, ]]], Default: []) – Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., [[1, 2]] has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; [[1], [2]] has max_nbo",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:4254,Energy Efficiency,energy,energy,4254,"energy('CCSD(T)', bsse_type=['cp','nocp']); # Calculate and return counterpoise-corrected gradient; # Useful for e.g. CP-corrected geometry optimization; gradient('CCSD(T)', bsse_type='cp', return_total_data=True). # noCP, VMFC, and CP energy for a helium cluster, limited at 3 bodies; molecule mol {; He 0 0 0; --; He 0 0 4; --; He 0 4 0; --; He 4 0 0; }. # Returns the nocp energy as its first in the list; energy('CCSD(T)', bsse_type=['nocp', 'cp', 'vmfc'], max_nbody=3). class psi4.driver.driver_nbody.ManyBodyComputer(**data)[source]¶. Parameters. molecule (Any) – The target molecule, if not the last molecule defined.; basis (str, Default: (auto)) – ; method (str, Default: (auto)) – ; driver ({energy,gradient,hessian,properties}) – The computation driver; i.e., energy, gradient, hessian.; keywords (Dict[Any], Default: {}) – The computation keywords/options.; bsse_type ({nocp,cp,vmfc}, Default: [<BsseEnum.cp: 'cp'>]) – Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned.; nfragments (int, Default: -1) – Number of distinct fragments comprising full molecular supersystem.; max_nbody (int, Default: -1) – Maximum number of bodies to include in the many-body treatment. Possible: max_nbody <= nfragments. Default: max_nbody = nfragments.; nbodies_per_mc_level (List[List[Union[int, ]]], Default: []) – Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., [[1, 2]] has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; [[1], [2]] has max_nbody=2 and 1-body and 2-body contributions computed at different levels of theory. An entry ‘supersystem’ means all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in ",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:5379,Energy Efficiency,charge,charges,5379,"; max_nbody (int, Default: -1) – Maximum number of bodies to include in the many-body treatment. Possible: max_nbody <= nfragments. Default: max_nbody = nfragments.; nbodies_per_mc_level (List[List[Union[int, ]]], Default: []) – Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., [[1, 2]] has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; [[1], [2]] has max_nbody=2 and 1-body and 2-body contributions computed at different levels of theory. An entry ‘supersystem’ means all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any ‘supersystem’ element is at the end.; embedding_charges (Dict[List[float]], Default: {}) – Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment.; return_total_data (bool, Optional) – When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying return_total_data = True may carry out more computations than return_total_data = False.; quiet (bool, Default: False) – Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.; task_list (Dict[Union[, , ]], Default: {}) – ; extra_data (Any) – . Return type; None. build_tasks(mb_computer, mc_level_idx, **kwargs)[source]¶; Adds to the task_l",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:5528,Energy Efficiency,charge,charges,5528,"ax_nbody = nfragments.; nbodies_per_mc_level (List[List[Union[int, ]]], Default: []) – Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., [[1, 2]] has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; [[1], [2]] has max_nbody=2 and 1-body and 2-body contributions computed at different levels of theory. An entry ‘supersystem’ means all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any ‘supersystem’ element is at the end.; embedding_charges (Dict[List[float]], Default: {}) – Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment.; return_total_data (bool, Optional) – When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying return_total_data = True may carry out more computations than return_total_data = False.; quiet (bool, Default: False) – Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.; task_list (Dict[Union[, , ]], Default: {}) – ; extra_data (Any) – . Return type; None. build_tasks(mb_computer, mc_level_idx, **kwargs)[source]¶; Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.; New tasks are of type mb_",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:5628,Energy Efficiency,energy,energy,5628,"n of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., [[1, 2]] has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; [[1], [2]] has max_nbody=2 and 1-body and 2-body contributions computed at different levels of theory. An entry ‘supersystem’ means all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any ‘supersystem’ element is at the end.; embedding_charges (Dict[List[float]], Default: {}) – Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment.; return_total_data (bool, Optional) – When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying return_total_data = True may carry out more computations than return_total_data = False.; quiet (bool, Default: False) – Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.; task_list (Dict[Union[, , ]], Default: {}) – ; extra_data (Any) – . Return type; None. build_tasks(mb_computer, mc_level_idx, **kwargs)[source]¶; Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.; New tasks are of type mb_computer with model chemistry level specified in kwargs and n-body levels accessed through mc_level",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:6085,Energy Efficiency,energy,energy,6085,"tributions computed at different levels of theory. An entry ‘supersystem’ means all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any ‘supersystem’ element is at the end.; embedding_charges (Dict[List[float]], Default: {}) – Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment.; return_total_data (bool, Optional) – When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying return_total_data = True may carry out more computations than return_total_data = False.; quiet (bool, Default: False) – Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.; task_list (Dict[Union[, , ]], Default: {}) – ; extra_data (Any) – . Return type; None. build_tasks(mb_computer, mc_level_idx, **kwargs)[source]¶; Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.; New tasks are of type mb_computer with model chemistry level specified in kwargs and n-body levels accessed through mc_level_idx. Parameters. mb_computer (Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]) – Class of TaskComputers to instantiate and add to self.task_list. Usually AtomicComputer but may be other when wrappers are layered.; mc_level_idx (int) – Position in field self.nbodies_per_mc_level used to obtain nbodies, the list of n-body; levels (e.g., [1] or [1, 2] or [“supersystem”]) to which the modelchem specified in kw",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:9719,Energy Efficiency,energy,energy,9719,"[str, Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]]]) – A set of tasks to process instead of self.task_list. Used in multilevel processing to pass a subset of; self.task_list filtered to only one modelchem level.; client (Optional[FractalClient]) – QCFractal client if using QCArchive for distributed compute. Returns; When the ManyBodyComputer specifies a single model chemistry level (see self.nbodies_per_mc_level), the; return is a dictionary, nbody_results, described in the table below. Many of the items are actually filled; by successive calls to assemble_nbody_components(). When multiple model chemistry levels are specified, this; function diverts its return to driver_nbody_multilevel.prepare_results() wherein each mc level calls this; function again and collects separate nbody_results dictionaries and processes them into a final return that; is a small subset of the table below. Return type; nbody_results. ptype_size = (1,)/(nat, 3)/(3 * nat, 3 * nat)e/g/h := energy or gradient or Hessian; rtd := return_total_data. item; size; present / zeroed; contents / interpretation. ret_ptype; ptype_size; always. interaction data requested: IE or total (depending on return_total_data) e/g/h (depending on driver)with cp/nocp/vmfc treatment (depending on 1st of bsse_type). ret_energy; 1; always; interaction energy: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type). ret_gradient; (nat, 3); when driver is g/h; interaction gradient: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type. ret_hessian; (nat * 3, nat * 3); when driver is h; interaction Hessian: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type). nbody; >=1; always; energy n-body QCVariables to be set.   CP-CORRECTED TOTAL ENERGY THROUGH 1-BODY;   1; when cp in bsse_type; MBE sum of subsystems of 1-body. summed are total energies with cp treatment.   CP-CORRECTED TOTAL ",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:10060,Energy Efficiency,energy,energy,10060,"mputer specifies a single model chemistry level (see self.nbodies_per_mc_level), the; return is a dictionary, nbody_results, described in the table below. Many of the items are actually filled; by successive calls to assemble_nbody_components(). When multiple model chemistry levels are specified, this; function diverts its return to driver_nbody_multilevel.prepare_results() wherein each mc level calls this; function again and collects separate nbody_results dictionaries and processes them into a final return that; is a small subset of the table below. Return type; nbody_results. ptype_size = (1,)/(nat, 3)/(3 * nat, 3 * nat)e/g/h := energy or gradient or Hessian; rtd := return_total_data. item; size; present / zeroed; contents / interpretation. ret_ptype; ptype_size; always. interaction data requested: IE or total (depending on return_total_data) e/g/h (depending on driver)with cp/nocp/vmfc treatment (depending on 1st of bsse_type). ret_energy; 1; always; interaction energy: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type). ret_gradient; (nat, 3); when driver is g/h; interaction gradient: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type. ret_hessian; (nat * 3, nat * 3); when driver is h; interaction Hessian: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type). nbody; >=1; always; energy n-body QCVariables to be set.   CP-CORRECTED TOTAL ENERGY THROUGH 1-BODY;   1; when cp in bsse_type; MBE sum of subsystems of 1-body. summed are total energies with cp treatment.   CP-CORRECTED TOTAL ENERGY THROUGH 2-BODY;   1; when cp in bsse_type & max_nbody>=2; MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with cp treatment.   CP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY;   1; when cp in bsse_type; MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/ cp treatment.   CP-CORRECTE",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:10513,Energy Efficiency,energy,energy,10513,"parate nbody_results dictionaries and processes them into a final return that; is a small subset of the table below. Return type; nbody_results. ptype_size = (1,)/(nat, 3)/(3 * nat, 3 * nat)e/g/h := energy or gradient or Hessian; rtd := return_total_data. item; size; present / zeroed; contents / interpretation. ret_ptype; ptype_size; always. interaction data requested: IE or total (depending on return_total_data) e/g/h (depending on driver)with cp/nocp/vmfc treatment (depending on 1st of bsse_type). ret_energy; 1; always; interaction energy: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type). ret_gradient; (nat, 3); when driver is g/h; interaction gradient: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type. ret_hessian; (nat * 3, nat * 3); when driver is h; interaction Hessian: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type). nbody; >=1; always; energy n-body QCVariables to be set.   CP-CORRECTED TOTAL ENERGY THROUGH 1-BODY;   1; when cp in bsse_type; MBE sum of subsystems of 1-body. summed are total energies with cp treatment.   CP-CORRECTED TOTAL ENERGY THROUGH 2-BODY;   1; when cp in bsse_type & max_nbody>=2; MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with cp treatment.   CP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY;   1; when cp in bsse_type; MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/ cp treatment.   CP-CORRECTED TOTAL ENERGY;   1; when cp in bsse_type & rtd=T; best available total energy with cp treatment: CP-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY.   CP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY;   1; when cp in bsse_type & max_nbody>=2; 2-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment.   CP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY;   1; when cp in bsse_type; {max_nbody}-bo",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:11152,Energy Efficiency,energy,energy,11152,"t of bsse_type). ret_gradient; (nat, 3); when driver is g/h; interaction gradient: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type. ret_hessian; (nat * 3, nat * 3); when driver is h; interaction Hessian: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type). nbody; >=1; always; energy n-body QCVariables to be set.   CP-CORRECTED TOTAL ENERGY THROUGH 1-BODY;   1; when cp in bsse_type; MBE sum of subsystems of 1-body. summed are total energies with cp treatment.   CP-CORRECTED TOTAL ENERGY THROUGH 2-BODY;   1; when cp in bsse_type & max_nbody>=2; MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with cp treatment.   CP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY;   1; when cp in bsse_type; MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/ cp treatment.   CP-CORRECTED TOTAL ENERGY;   1; when cp in bsse_type & rtd=T; best available total energy with cp treatment: CP-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY.   CP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY;   1; when cp in bsse_type & max_nbody>=2; 2-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment.   CP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY;   1; when cp in bsse_type; {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment.   CP-CORRECTED INTERACTION ENERGY;   1; when cp in bsse_type; best available interaction energy with cp treatment: CP-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY.   CP-CORRECTED 2-BODY CONTRIBUTION TO ENERGY;   1; when cp in bsse_type & max_nbody>=2; 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/ cp treatment.   CP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY;   1; when cp in bsse_type; {max_nbody}-body total data less ({max_nbody}-1)-body data for partial IE; inputs are",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:11711,Energy Efficiency,energy,energy,11711,RECTED TOTAL ENERGY THROUGH 2-BODY;   1; when cp in bsse_type & max_nbody>=2; MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with cp treatment.   CP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY;   1; when cp in bsse_type; MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/ cp treatment.   CP-CORRECTED TOTAL ENERGY;   1; when cp in bsse_type & rtd=T; best available total energy with cp treatment: CP-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY.   CP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY;   1; when cp in bsse_type & max_nbody>=2; 2-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment.   CP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY;   1; when cp in bsse_type; {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment.   CP-CORRECTED INTERACTION ENERGY;   1; when cp in bsse_type; best available interaction energy with cp treatment: CP-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY.   CP-CORRECTED 2-BODY CONTRIBUTION TO ENERGY;   1; when cp in bsse_type & max_nbody>=2; 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/ cp treatment.   CP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY;   1; when cp in bsse_type; {max_nbody}-body total data less ({max_nbody}-1)-body data for partial IE; inputs are total energies w/ cp treat.   NOCP-CORRECTED TOTAL ENERGY THROUGH 1-BODY;   1; when nocp in bsse_type; MBE sum of subsystems of 1-body. summed are total energies without cp treatment.   NOCP-CORRECTED TOTAL ENERGY THROUGH 2-BODY;   1; when nocp in bsse_type & max_nbody>=2; MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies without cp treatment.   NOCP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY;   1; when nocp in bsse_type; MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/o cp treatm,MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:12794,Energy Efficiency,energy,energy,12794,   CP-CORRECTED 2-BODY CONTRIBUTION TO ENERGY;   1; when cp in bsse_type & max_nbody>=2; 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/ cp treatment.   CP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY;   1; when cp in bsse_type; {max_nbody}-body total data less ({max_nbody}-1)-body data for partial IE; inputs are total energies w/ cp treat.   NOCP-CORRECTED TOTAL ENERGY THROUGH 1-BODY;   1; when nocp in bsse_type; MBE sum of subsystems of 1-body. summed are total energies without cp treatment.   NOCP-CORRECTED TOTAL ENERGY THROUGH 2-BODY;   1; when nocp in bsse_type & max_nbody>=2; MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies without cp treatment.   NOCP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY;   1; when nocp in bsse_type; MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/o cp treatment.   NOCP-CORRECTED TOTAL ENERGY;   1; when nocp in bsse_type; best available total energy without cp treatment: NOCP-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY.   NOCP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY;   1; when nocp in bsse_type & max_nbody>=2; 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/o cp treatment.   NOCP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY;   1; when nocp in bsse_type; {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies w/o cp treatment.   NOCP-CORRECTED INTERACTION ENERGY;   1; when nocp in bsse_type; best available interaction energy without cp treatment: NOCP-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY.   NOCP-CORRECTED 2-BODY CONTRIBUTION TO ENERGY;   1; when nocp in bsse_type & max_nbody>=2; 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/o cp treatment.   NOCP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY;   1; when nocp in bsse_type; {max_nbody}-body total data less ({max_nbody}-1)-body data f,MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:13368,Energy Efficiency,energy,energy,13368,ROUGH 2-BODY;   1; when nocp in bsse_type & max_nbody>=2; MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies without cp treatment.   NOCP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY;   1; when nocp in bsse_type; MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/o cp treatment.   NOCP-CORRECTED TOTAL ENERGY;   1; when nocp in bsse_type; best available total energy without cp treatment: NOCP-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY.   NOCP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY;   1; when nocp in bsse_type & max_nbody>=2; 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/o cp treatment.   NOCP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY;   1; when nocp in bsse_type; {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies w/o cp treatment.   NOCP-CORRECTED INTERACTION ENERGY;   1; when nocp in bsse_type; best available interaction energy without cp treatment: NOCP-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY.   NOCP-CORRECTED 2-BODY CONTRIBUTION TO ENERGY;   1; when nocp in bsse_type & max_nbody>=2; 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/o cp treatment.   NOCP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY;   1; when nocp in bsse_type; {max_nbody}-body total data less ({max_nbody}-1)-body data for partial IE; inputs are total energies w/o cp treat.   VMFC-CORRECTED TOTAL ENERGY THROUGH 1-BODY;   1; when vmfc in bsse_type; MBE sum of subsystems of 1-body. summed are total energies with vmfc treatment.   VMFC-CORRECTED TOTAL ENERGY THROUGH 2-BODY;   1; when vmfc in bsse_type & max_nbody>=2; MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with vmfc treatment.   VMFC-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY;   1; when vmfc in bsse_type; MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies ,MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:14465,Energy Efficiency,energy,energy,14465,CORRECTED 2-BODY CONTRIBUTION TO ENERGY;   1; when nocp in bsse_type & max_nbody>=2; 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/o cp treatment.   NOCP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY;   1; when nocp in bsse_type; {max_nbody}-body total data less ({max_nbody}-1)-body data for partial IE; inputs are total energies w/o cp treat.   VMFC-CORRECTED TOTAL ENERGY THROUGH 1-BODY;   1; when vmfc in bsse_type; MBE sum of subsystems of 1-body. summed are total energies with vmfc treatment.   VMFC-CORRECTED TOTAL ENERGY THROUGH 2-BODY;   1; when vmfc in bsse_type & max_nbody>=2; MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with vmfc treatment.   VMFC-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY;   1; when vmfc in bsse_type; MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/ vmfc treatment.   VMFC-CORRECTED TOTAL ENERGY;   1; when vmfc in bsse_type; best available total energy with vmfc treatment: VMFC-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY.   VMFC-CORRECTED INTERACTION ENERGY THROUGH 2-BODY;   1; when vmfc in bsse_type & max_nbody>=2; 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment.   VMFC-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY;   1; when vmfc in bsse_type; {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment.   VMFC-CORRECTED INTERACTION ENERGY;   1; when vmfc in bsse_type; best available interaction energy with vmfc treatment: VMFC-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY.   VMFC-CORRECTED 2-BODY CONTRIBUTION TO ENERGY;   1; when vmfc in bsse_type & max_nbody>=2; 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/ vmfc treatment.   VMFC-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY;   1; when vmfc in bsse_type; {max_nbody}-body total data less ({max_nbody}-1)-body data ,MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:15040,Energy Efficiency,energy,energy,15040,ROUGH 2-BODY;   1; when vmfc in bsse_type & max_nbody>=2; MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with vmfc treatment.   VMFC-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY;   1; when vmfc in bsse_type; MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/ vmfc treatment.   VMFC-CORRECTED TOTAL ENERGY;   1; when vmfc in bsse_type; best available total energy with vmfc treatment: VMFC-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY.   VMFC-CORRECTED INTERACTION ENERGY THROUGH 2-BODY;   1; when vmfc in bsse_type & max_nbody>=2; 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment.   VMFC-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY;   1; when vmfc in bsse_type; {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment.   VMFC-CORRECTED INTERACTION ENERGY;   1; when vmfc in bsse_type; best available interaction energy with vmfc treatment: VMFC-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY.   VMFC-CORRECTED 2-BODY CONTRIBUTION TO ENERGY;   1; when vmfc in bsse_type & max_nbody>=2; 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/ vmfc treatment.   VMFC-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY;   1; when vmfc in bsse_type; {max_nbody}-body total data less ({max_nbody}-1)-body data for partial IE; inputs are total energies w/ vmfc treat. energy_body_dict; max_nbody; always; total energies at each n-body level.   1;   1; always; zeroed if cp & rtd=F; cumulative through 1-body total energies w/ cp/nocp/vmfc treatment (dep. on 1st of bsse_type).   2;   1; max_nbody>=2; cumulative through 2-body total energies w/ cp/nocp/vmfc treatment (dep. on 1st of bsse_type).   {max_nbody};   1; always; cumulative through {max_nbody}-body total energies w/ cp/nocp/vmfc treatment (dep. on 1st of bsse_type). gradient_body_dict; max_nbody; when driver is g/h.   1,MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:22162,Energy Efficiency,energy,energy,22162,"nbody>=2; zeroed if vmfc not in bsse_type; cumulative through 2-body total gradients with vmfc treatment.   {max_nbody}vmfc;   (nat, 3); when driver is g/h; zeroed if vmfc not in bsse_type; cumulative through {max_nbody}-body total gradients with vmfc treatment. vmfc_hessian_body_dict; max_nbody; when driver is h; zeroed if vmfc not in bsse_type; total Hessians at each n-body level with vmfc treatment.   1vmfc;   (nat*3, nat*3); when driver is h; zeroed if vmfc not in bsse_type; cumulative through 1-body total Hessians with vmfc treatment.   2vmfc;   (nat*3, nat*3); when driver is h & max_nbody>=2; zeroed if vmfc not in bsse_type; cumulative through 2-body total Hessians with vmfc treatment.   {max_nbody}vmfc;   (nat*3, nat*3); when driver is h; zeroed if vmfc not in bsse_type; cumulative through {max_nbody}-body total Hessians with vmfc treatment. intermediates; ntasks; always; all individual energies with nice labels.   N-BODY (1, 2)@(1, 2) TOTAL ENERGY;   1; always; total energy for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   N-BODY (3)@(2, 3) TOTAL ENERGY;   1; always; total energy for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_energy; ntasks; always; all individual energies.   1_((1, 2), (1, 2));   1; always; total energy for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   1; always; total energy for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_gradient; ntasks; when driver is g/h; all individual gradients.   1_((1, 2), (1, 2));   (nat, 3); when driver is g/h; total gradient for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   (nat, 3); when driver is g/h; total gradient for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_hessian; ntasks; when driver is h; all individual Hessians.   1_((1, 2), (1, 2));   (nat*3, nat*3); when driver is h; total Hes",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:22294,Energy Efficiency,energy,energy,22294,", 3); when driver is g/h; zeroed if vmfc not in bsse_type; cumulative through {max_nbody}-body total gradients with vmfc treatment. vmfc_hessian_body_dict; max_nbody; when driver is h; zeroed if vmfc not in bsse_type; total Hessians at each n-body level with vmfc treatment.   1vmfc;   (nat*3, nat*3); when driver is h; zeroed if vmfc not in bsse_type; cumulative through 1-body total Hessians with vmfc treatment.   2vmfc;   (nat*3, nat*3); when driver is h & max_nbody>=2; zeroed if vmfc not in bsse_type; cumulative through 2-body total Hessians with vmfc treatment.   {max_nbody}vmfc;   (nat*3, nat*3); when driver is h; zeroed if vmfc not in bsse_type; cumulative through {max_nbody}-body total Hessians with vmfc treatment. intermediates; ntasks; always; all individual energies with nice labels.   N-BODY (1, 2)@(1, 2) TOTAL ENERGY;   1; always; total energy for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   N-BODY (3)@(2, 3) TOTAL ENERGY;   1; always; total energy for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_energy; ntasks; always; all individual energies.   1_((1, 2), (1, 2));   1; always; total energy for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   1; always; total energy for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_gradient; ntasks; when driver is g/h; all individual gradients.   1_((1, 2), (1, 2));   (nat, 3); when driver is g/h; total gradient for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   (nat, 3); when driver is g/h; total gradient for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_hessian; ntasks; when driver is h; all individual Hessians.   1_((1, 2), (1, 2));   (nat*3, nat*3); when driver is h; total Hessian for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   (nat*3, nat*3); when driver is h",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:22477,Energy Efficiency,energy,energy,22477,"if vmfc not in bsse_type; total Hessians at each n-body level with vmfc treatment.   1vmfc;   (nat*3, nat*3); when driver is h; zeroed if vmfc not in bsse_type; cumulative through 1-body total Hessians with vmfc treatment.   2vmfc;   (nat*3, nat*3); when driver is h & max_nbody>=2; zeroed if vmfc not in bsse_type; cumulative through 2-body total Hessians with vmfc treatment.   {max_nbody}vmfc;   (nat*3, nat*3); when driver is h; zeroed if vmfc not in bsse_type; cumulative through {max_nbody}-body total Hessians with vmfc treatment. intermediates; ntasks; always; all individual energies with nice labels.   N-BODY (1, 2)@(1, 2) TOTAL ENERGY;   1; always; total energy for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   N-BODY (3)@(2, 3) TOTAL ENERGY;   1; always; total energy for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_energy; ntasks; always; all individual energies.   1_((1, 2), (1, 2));   1; always; total energy for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   1; always; total energy for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_gradient; ntasks; when driver is g/h; all individual gradients.   1_((1, 2), (1, 2));   (nat, 3); when driver is g/h; total gradient for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   (nat, 3); when driver is g/h; total gradient for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_hessian; ntasks; when driver is h; all individual Hessians.   1_((1, 2), (1, 2));   (nat*3, nat*3); when driver is h; total Hessian for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   (nat*3, nat*3); when driver is h; total Hessian for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. P",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:22595,Energy Efficiency,energy,energy,22595,"river is h; zeroed if vmfc not in bsse_type; cumulative through 1-body total Hessians with vmfc treatment.   2vmfc;   (nat*3, nat*3); when driver is h & max_nbody>=2; zeroed if vmfc not in bsse_type; cumulative through 2-body total Hessians with vmfc treatment.   {max_nbody}vmfc;   (nat*3, nat*3); when driver is h; zeroed if vmfc not in bsse_type; cumulative through {max_nbody}-body total Hessians with vmfc treatment. intermediates; ntasks; always; all individual energies with nice labels.   N-BODY (1, 2)@(1, 2) TOTAL ENERGY;   1; always; total energy for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   N-BODY (3)@(2, 3) TOTAL ENERGY;   1; always; total energy for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_energy; ntasks; always; all individual energies.   1_((1, 2), (1, 2));   1; always; total energy for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   1; always; total energy for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_gradient; ntasks; when driver is g/h; all individual gradients.   1_((1, 2), (1, 2));   (nat, 3); when driver is g/h; total gradient for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   (nat, 3); when driver is g/h; total gradient for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_hessian; ntasks; when driver is h; all individual Hessians.   1_((1, 2), (1, 2));   (nat*3, nat*3); when driver is h; total Hessian for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   (nat*3, nat*3); when driver is h; total Hessian for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Basis Set Superposition Corrections. © Copyright 2022, The Psi4 Project.; L",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:441,Integrability,depend,depending,441,"﻿. Basis Set Superposition Corrections. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Basis Set Superposition Corrections. Basis Set Superposition Corrections¶; Code author: Daniel G. A. Smith. psi4.driver.driver_nbody.nbody(func, method_string[, molecule, bsse_type, max_nbody, ptype, return_total_data])[source]¶; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. Returns; return type of func – The data. Returns; (float, Wavefunction) – data and wavefunction with energy/gradient/hessian set appropriately when return_wfn specified. Parameters. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element of a tuple. bsse_type (str or list) – 'cp' || ['nocp', 'vmfc'] || \(\Rightarrow\) None \(\Leftarrow\) || etc.; Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecular interaction energy, or VMFC for Valiron-Mayer; Function Counterpoise correction. If a list is provided, the first string in; the list determines which interaction or total energies/gradients/Hessians are; returned by this function. By default, many-body treatments are inactive. max_nbody (int) – 3 || etc.; Maximum n-body to compute, cannot exceed the number of fragments in the molecule. return_total_data (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is 'off' for energies,; 'on' for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying return_t",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:6840,Integrability,wrap,wrappers,6840,"nergies implies the calculation of the energies of monomers in the monomer basis, hence specifying return_total_data = True may carry out more computations than return_total_data = False.; quiet (bool, Default: False) – Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.; task_list (Dict[Union[, , ]], Default: {}) – ; extra_data (Any) – . Return type; None. build_tasks(mb_computer, mc_level_idx, **kwargs)[source]¶; Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.; New tasks are of type mb_computer with model chemistry level specified in kwargs and n-body levels accessed through mc_level_idx. Parameters. mb_computer (Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]) – Class of TaskComputers to instantiate and add to self.task_list. Usually AtomicComputer but may be other when wrappers are layered.; mc_level_idx (int) – Position in field self.nbodies_per_mc_level used to obtain nbodies, the list of n-body; levels (e.g., [1] or [1, 2] or [“supersystem”]) to which the modelchem specified in kwargs applies.; That is, nbodies = self.nbodies_per_mc_level[mc_level_idx].; Note the natural 1-indexing of nbodies _contents_, so [1] covers one-body contributions.; The corresponding user label is the 1-indexed counterpart, mc_level_lbl = mc_level_idx + 1; Formerly nlevel as in nbody = self.nbody_list[nbody_level=nlevel].; kwargs (Dict[str, Any]) – Other arguments for initializing mb_computer. In particular, specifies model chemistry. Returns; Number of new tasks planned by this call.; Formerly, didn’t include supersystem in count. Return type; count. compute(client=None)[source]¶; Run quantum chemistry. Parameters; client (Optional[FractalClient]) – . get_psi_results(return_wfn=False)[source]¶; Called by driver to assemble results into ManyBody-flavored QCSc",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:7893,Integrability,interface,interface,7893,"but may be other when wrappers are layered.; mc_level_idx (int) – Position in field self.nbodies_per_mc_level used to obtain nbodies, the list of n-body; levels (e.g., [1] or [1, 2] or [“supersystem”]) to which the modelchem specified in kwargs applies.; That is, nbodies = self.nbodies_per_mc_level[mc_level_idx].; Note the natural 1-indexing of nbodies _contents_, so [1] covers one-body contributions.; The corresponding user label is the 1-indexed counterpart, mc_level_lbl = mc_level_idx + 1; Formerly nlevel as in nbody = self.nbody_list[nbody_level=nlevel].; kwargs (Dict[str, Any]) – Other arguments for initializing mb_computer. In particular, specifies model chemistry. Returns; Number of new tasks planned by this call.; Formerly, didn’t include supersystem in count. Return type; count. compute(client=None)[source]¶; Run quantum chemistry. Parameters; client (Optional[FractalClient]) – . get_psi_results(return_wfn=False)[source]¶; Called by driver to assemble results into ManyBody-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: (e/g/h, wfn). Parameters; return_wfn (bool) – Whether to additionally return the dummy Wavefunction; calculation result as the second element of a tuple. Contents are:. supersystem molecule; dummy basis, def2-svp; e/g/h member data; QCVariables. Return type; Union[float, Matrix, Tuple[Union[float, Matrix], Wavefunction]]. Returns. ret – Energy, gradient, or Hessian according to self.driver.; wfn – Wavefunction described above when return_wfn specified. get_results(client=None)[source]¶; Return results as ManyBody-flavored QCSchema. Return type; AtomicResult. Parameters; client (Optional[FractalClient]) – . prepare_results(results=None, client=None)[source]¶; Process the results from all n-body component molecular systems and model chemistry levels into final quantities. Parameters. results (Optional[Dict[str, Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]]]) – A set of tasks to pro",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:9905,Integrability,depend,depending,9905,"hem level.; client (Optional[FractalClient]) – QCFractal client if using QCArchive for distributed compute. Returns; When the ManyBodyComputer specifies a single model chemistry level (see self.nbodies_per_mc_level), the; return is a dictionary, nbody_results, described in the table below. Many of the items are actually filled; by successive calls to assemble_nbody_components(). When multiple model chemistry levels are specified, this; function diverts its return to driver_nbody_multilevel.prepare_results() wherein each mc level calls this; function again and collects separate nbody_results dictionaries and processes them into a final return that; is a small subset of the table below. Return type; nbody_results. ptype_size = (1,)/(nat, 3)/(3 * nat, 3 * nat)e/g/h := energy or gradient or Hessian; rtd := return_total_data. item; size; present / zeroed; contents / interpretation. ret_ptype; ptype_size; always. interaction data requested: IE or total (depending on return_total_data) e/g/h (depending on driver)with cp/nocp/vmfc treatment (depending on 1st of bsse_type). ret_energy; 1; always; interaction energy: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type). ret_gradient; (nat, 3); when driver is g/h; interaction gradient: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type. ret_hessian; (nat * 3, nat * 3); when driver is h; interaction Hessian: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type). nbody; >=1; always; energy n-body QCVariables to be set.   CP-CORRECTED TOTAL ENERGY THROUGH 1-BODY;   1; when cp in bsse_type; MBE sum of subsystems of 1-body. summed are total energies with cp treatment.   CP-CORRECTED TOTAL ENERGY THROUGH 2-BODY;   1; when cp in bsse_type & max_nbody>=2; MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with cp treatment.   CP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY;   1; when cp",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:9944,Integrability,depend,depending,9944,"hem level.; client (Optional[FractalClient]) – QCFractal client if using QCArchive for distributed compute. Returns; When the ManyBodyComputer specifies a single model chemistry level (see self.nbodies_per_mc_level), the; return is a dictionary, nbody_results, described in the table below. Many of the items are actually filled; by successive calls to assemble_nbody_components(). When multiple model chemistry levels are specified, this; function diverts its return to driver_nbody_multilevel.prepare_results() wherein each mc level calls this; function again and collects separate nbody_results dictionaries and processes them into a final return that; is a small subset of the table below. Return type; nbody_results. ptype_size = (1,)/(nat, 3)/(3 * nat, 3 * nat)e/g/h := energy or gradient or Hessian; rtd := return_total_data. item; size; present / zeroed; contents / interpretation. ret_ptype; ptype_size; always. interaction data requested: IE or total (depending on return_total_data) e/g/h (depending on driver)with cp/nocp/vmfc treatment (depending on 1st of bsse_type). ret_energy; 1; always; interaction energy: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type). ret_gradient; (nat, 3); when driver is g/h; interaction gradient: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type. ret_hessian; (nat * 3, nat * 3); when driver is h; interaction Hessian: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type). nbody; >=1; always; energy n-body QCVariables to be set.   CP-CORRECTED TOTAL ENERGY THROUGH 1-BODY;   1; when cp in bsse_type; MBE sum of subsystems of 1-body. summed are total energies with cp treatment.   CP-CORRECTED TOTAL ENERGY THROUGH 2-BODY;   1; when cp in bsse_type & max_nbody>=2; MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with cp treatment.   CP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY;   1; when cp",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:9993,Integrability,depend,depending,9993,"hem level.; client (Optional[FractalClient]) – QCFractal client if using QCArchive for distributed compute. Returns; When the ManyBodyComputer specifies a single model chemistry level (see self.nbodies_per_mc_level), the; return is a dictionary, nbody_results, described in the table below. Many of the items are actually filled; by successive calls to assemble_nbody_components(). When multiple model chemistry levels are specified, this; function diverts its return to driver_nbody_multilevel.prepare_results() wherein each mc level calls this; function again and collects separate nbody_results dictionaries and processes them into a final return that; is a small subset of the table below. Return type; nbody_results. ptype_size = (1,)/(nat, 3)/(3 * nat, 3 * nat)e/g/h := energy or gradient or Hessian; rtd := return_total_data. item; size; present / zeroed; contents / interpretation. ret_ptype; ptype_size; always. interaction data requested: IE or total (depending on return_total_data) e/g/h (depending on driver)with cp/nocp/vmfc treatment (depending on 1st of bsse_type). ret_energy; 1; always; interaction energy: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type). ret_gradient; (nat, 3); when driver is g/h; interaction gradient: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type. ret_hessian; (nat * 3, nat * 3); when driver is h; interaction Hessian: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type). nbody; >=1; always; energy n-body QCVariables to be set.   CP-CORRECTED TOTAL ENERGY THROUGH 1-BODY;   1; when cp in bsse_type; MBE sum of subsystems of 1-body. summed are total energies with cp treatment.   CP-CORRECTED TOTAL ENERGY THROUGH 2-BODY;   1; when cp in bsse_type & max_nbody>=2; MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with cp treatment.   CP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY;   1; when cp",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:10081,Integrability,depend,depending,10081,"mputer specifies a single model chemistry level (see self.nbodies_per_mc_level), the; return is a dictionary, nbody_results, described in the table below. Many of the items are actually filled; by successive calls to assemble_nbody_components(). When multiple model chemistry levels are specified, this; function diverts its return to driver_nbody_multilevel.prepare_results() wherein each mc level calls this; function again and collects separate nbody_results dictionaries and processes them into a final return that; is a small subset of the table below. Return type; nbody_results. ptype_size = (1,)/(nat, 3)/(3 * nat, 3 * nat)e/g/h := energy or gradient or Hessian; rtd := return_total_data. item; size; present / zeroed; contents / interpretation. ret_ptype; ptype_size; always. interaction data requested: IE or total (depending on return_total_data) e/g/h (depending on driver)with cp/nocp/vmfc treatment (depending on 1st of bsse_type). ret_energy; 1; always; interaction energy: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type). ret_gradient; (nat, 3); when driver is g/h; interaction gradient: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type. ret_hessian; (nat * 3, nat * 3); when driver is h; interaction Hessian: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type). nbody; >=1; always; energy n-body QCVariables to be set.   CP-CORRECTED TOTAL ENERGY THROUGH 1-BODY;   1; when cp in bsse_type; MBE sum of subsystems of 1-body. summed are total energies with cp treatment.   CP-CORRECTED TOTAL ENERGY THROUGH 2-BODY;   1; when cp in bsse_type & max_nbody>=2; MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with cp treatment.   CP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY;   1; when cp in bsse_type; MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/ cp treatment.   CP-CORRECTE",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:10243,Integrability,depend,depending,10243,"ow. Many of the items are actually filled; by successive calls to assemble_nbody_components(). When multiple model chemistry levels are specified, this; function diverts its return to driver_nbody_multilevel.prepare_results() wherein each mc level calls this; function again and collects separate nbody_results dictionaries and processes them into a final return that; is a small subset of the table below. Return type; nbody_results. ptype_size = (1,)/(nat, 3)/(3 * nat, 3 * nat)e/g/h := energy or gradient or Hessian; rtd := return_total_data. item; size; present / zeroed; contents / interpretation. ret_ptype; ptype_size; always. interaction data requested: IE or total (depending on return_total_data) e/g/h (depending on driver)with cp/nocp/vmfc treatment (depending on 1st of bsse_type). ret_energy; 1; always; interaction energy: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type). ret_gradient; (nat, 3); when driver is g/h; interaction gradient: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type. ret_hessian; (nat * 3, nat * 3); when driver is h; interaction Hessian: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type). nbody; >=1; always; energy n-body QCVariables to be set.   CP-CORRECTED TOTAL ENERGY THROUGH 1-BODY;   1; when cp in bsse_type; MBE sum of subsystems of 1-body. summed are total energies with cp treatment.   CP-CORRECTED TOTAL ENERGY THROUGH 2-BODY;   1; when cp in bsse_type & max_nbody>=2; MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with cp treatment.   CP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY;   1; when cp in bsse_type; MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/ cp treatment.   CP-CORRECTED TOTAL ENERGY;   1; when cp in bsse_type & rtd=T; best available total energy with cp treatment: CP-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY. ",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:10410,Integrability,depend,depending,10410,"verts its return to driver_nbody_multilevel.prepare_results() wherein each mc level calls this; function again and collects separate nbody_results dictionaries and processes them into a final return that; is a small subset of the table below. Return type; nbody_results. ptype_size = (1,)/(nat, 3)/(3 * nat, 3 * nat)e/g/h := energy or gradient or Hessian; rtd := return_total_data. item; size; present / zeroed; contents / interpretation. ret_ptype; ptype_size; always. interaction data requested: IE or total (depending on return_total_data) e/g/h (depending on driver)with cp/nocp/vmfc treatment (depending on 1st of bsse_type). ret_energy; 1; always; interaction energy: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type). ret_gradient; (nat, 3); when driver is g/h; interaction gradient: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type. ret_hessian; (nat * 3, nat * 3); when driver is h; interaction Hessian: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type). nbody; >=1; always; energy n-body QCVariables to be set.   CP-CORRECTED TOTAL ENERGY THROUGH 1-BODY;   1; when cp in bsse_type; MBE sum of subsystems of 1-body. summed are total energies with cp treatment.   CP-CORRECTED TOTAL ENERGY THROUGH 2-BODY;   1; when cp in bsse_type & max_nbody>=2; MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with cp treatment.   CP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY;   1; when cp in bsse_type; MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/ cp treatment.   CP-CORRECTED TOTAL ENERGY;   1; when cp in bsse_type & rtd=T; best available total energy with cp treatment: CP-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY.   CP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY;   1; when cp in bsse_type & max_nbody>=2; 2-body total data less 1-body total data for cumulative IE; inputs are t",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:3384,Performance,optimiz,optimization,3384,"all higher order n-body effects up to the number of fragments. embedding_charges (dict) – {1: [-0.834, 0.417, 0.417], ..}; Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. The nbody function computes counterpoise-corrected (CP), non-CP (noCP), and Valiron-Mayer Function Counterpoise (VMFC) interaction energies for complexes composed of arbitrary numbers of monomers.; Examples :; # Counterpoise corrected CCSD(T) energies for the Helium dimer; molecule mol {; He; --; He 1 3; }; # Calculate interaction energies only (skips monomers in monomer basis):; energy('CCSD(T)', bsse_type='cp'); # Calculate interaction and total energies, return interaction energies:; energy('CCSD(T)', bsse_type=['cp','nocp']); # Calculate and return counterpoise-corrected gradient; # Useful for e.g. CP-corrected geometry optimization; gradient('CCSD(T)', bsse_type='cp', return_total_data=True). # noCP, VMFC, and CP energy for a helium cluster, limited at 3 bodies; molecule mol {; He 0 0 0; --; He 0 0 4; --; He 0 4 0; --; He 4 0 0; }. # Returns the nocp energy as its first in the list; energy('CCSD(T)', bsse_type=['nocp', 'cp', 'vmfc'], max_nbody=3). class psi4.driver.driver_nbody.ManyBodyComputer(**data)[source]¶. Parameters. molecule (Any) – The target molecule, if not the last molecule defined.; basis (str, Default: (auto)) – ; method (str, Default: (auto)) – ; driver ({energy,gradient,hessian,properties}) – The computation driver; i.e., energy, gradient, hessian.; keywords (Dict[Any], Default: {}) – The computation keywords/options.; bsse_type ({nocp,cp,vmfc}, Default: [<BsseEnum.cp: 'cp'>]) – Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned.; nfragments (int, Default: -1) – Number of distinct fragments comprising full molecular supersystem.; max_nbody (int, Defa",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:6604,Security,access,accessed,6604,"_data (bool, Optional) – When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying return_total_data = True may carry out more computations than return_total_data = False.; quiet (bool, Default: False) – Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.; task_list (Dict[Union[, , ]], Default: {}) – ; extra_data (Any) – . Return type; None. build_tasks(mb_computer, mc_level_idx, **kwargs)[source]¶; Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.; New tasks are of type mb_computer with model chemistry level specified in kwargs and n-body levels accessed through mc_level_idx. Parameters. mb_computer (Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]) – Class of TaskComputers to instantiate and add to self.task_list. Usually AtomicComputer but may be other when wrappers are layered.; mc_level_idx (int) – Position in field self.nbodies_per_mc_level used to obtain nbodies, the list of n-body; levels (e.g., [1] or [1, 2] or [“supersystem”]) to which the modelchem specified in kwargs applies.; That is, nbodies = self.nbodies_per_mc_level[mc_level_idx].; Note the natural 1-indexing of nbodies _contents_, so [1] covers one-body contributions.; The corresponding user label is the 1-indexed counterpart, mc_level_lbl = mc_level_idx + 1; Formerly nlevel as in nbody = self.nbody_list[nbody_level=nlevel].; kwargs (Dict[str, Any]) – Other arguments for initializing mb_computer. In particular, specifies model chemistry. Returns; Number of new tasks planned by this call.; Formerly, didn’t in",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/nbody.html:6064,Testability,log,log,6064,"tributions computed at different levels of theory. An entry ‘supersystem’ means all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any ‘supersystem’ element is at the end.; embedding_charges (Dict[List[float]], Default: {}) – Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment.; return_total_data (bool, Optional) – When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying return_total_data = True may carry out more computations than return_total_data = False.; quiet (bool, Default: False) – Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.; task_list (Dict[Union[, , ]], Default: {}) – ; extra_data (Any) – . Return type; None. build_tasks(mb_computer, mc_level_idx, **kwargs)[source]¶; Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.; New tasks are of type mb_computer with model chemistry level specified in kwargs and n-body levels accessed through mc_level_idx. Parameters. mb_computer (Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]) – Class of TaskComputers to instantiate and add to self.task_list. Usually AtomicComputer but may be other when wrappers are layered.; mc_level_idx (int) – Position in field self.nbodies_per_mc_level used to obtain nbodies, the list of n-body; levels (e.g., [1] or [1, 2] or [“supersystem”]) to which the modelchem specified in kw",MatchSource.WIKI,psi4manual/1.6.x/nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html
https://psicode.org/psi4manual/1.6.x/notes_c.html:828,Availability,toler,tolerance,828,"﻿. Notes on Options. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; Notes on Options. Notes on Options¶. Note; The options referred to in the Theoretical Methods: SCF to FCI section below; and indexed in Keywords by Module are placed in set blocks as; described in Job Control Keywords, not as arguments to a Python function; (like energy()). Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number or an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to \(10^{-6} E_h\), the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Notes on Psivars¶. Note; Starting in 1.6, there are three standard ways to access an excited state; property. We give examples below, but the method name and property name may change.; * method ROOT 0 -> ROOT m property to get root m. method ROOT 0 -> ROOT m property - h TRANSITION to get root m andindependently specify that the total transition symmetry is h, e.g., A2. method ROOT 0 (h) -> ROOT m (i) property to get the transition; between two roots, specifying the symmetry of both states and the index of the target; roots among states of their own symmetry. For example, to target the second excited-state, which is also the lowest energy state; of its irrep, the first two calls will take m = 2, while the last takes m = 0.; Methods that use this interface are: TD-fctl.; Note that numberings are associated with the calculation much ",MatchSource.WIKI,psi4manual/1.6.x/notes_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/notes_c.html
https://psicode.org/psi4manual/1.6.x/notes_c.html:2736,Availability,avail,available,2736,"mong states of their own symmetry. For example, to target the second excited-state, which is also the lowest energy state; of its irrep, the first two calls will take m = 2, while the last takes m = 0.; Methods that use this interface are: TD-fctl.; Note that numberings are associated with the calculation much more strongly than; with the molecular system. Changing the number of roots sought, the symmetry; subspace or the symmetry apportionment of roots under which the computation is run,; or the excited state method are all likely to scramble root numberings. Alternate Implementations¶; Depending on the reference (RHF, UHF, ROHF) and the integral treatment; (conventional CONV, density-fitted DF, and Cholesky-decomposed CD),; computational methods are sometimes implemented by multiple coders or even; multiple times. PSI4 transparently selects the most efficient; implementation, so one generally needn’t consult this table. However, to; understand the details of what combinations are accessible or what; alternate implementations are available, read on.; Below, “Y” means method available in module, “D” means module is default; for that method, and “” means method not available. HF, DFT, and MP2; default to density-fitted integrals, while all higher methods default to; conventional integrals. Therefore, for a closed-shell molecule:. runs MP2 with default DF with default implementation DFMP2; energy('mp2'). runs MP2 with CONV with default implementation OCC; set mp2_type conv; energy('mp2'). runs MP2 with default DF with implementation OCC; set qc_module occ; energy('mp2'). Overlapping capabilities of PSI4. “Y” is available; “D” is default.¶. name; _; type select 1. QC_MODULE; REFERENCE; _. energy(); gradient(). RHF; UHF; ROHF; RHF; UHF; ROHF. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. mp2; MP2_TYPE. CCENERGY. DETCI; Y. Y. DFMP2. D 2. D 2. D. D. FNOCC; Y. OCC; D; Y; D; D; Y; Y; D; Y; D; D; Y. D; D. mp3; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2.",MatchSource.WIKI,psi4manual/1.6.x/notes_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/notes_c.html
https://psicode.org/psi4manual/1.6.x/notes_c.html:2781,Availability,avail,available,2781," irrep, the first two calls will take m = 2, while the last takes m = 0.; Methods that use this interface are: TD-fctl.; Note that numberings are associated with the calculation much more strongly than; with the molecular system. Changing the number of roots sought, the symmetry; subspace or the symmetry apportionment of roots under which the computation is run,; or the excited state method are all likely to scramble root numberings. Alternate Implementations¶; Depending on the reference (RHF, UHF, ROHF) and the integral treatment; (conventional CONV, density-fitted DF, and Cholesky-decomposed CD),; computational methods are sometimes implemented by multiple coders or even; multiple times. PSI4 transparently selects the most efficient; implementation, so one generally needn’t consult this table. However, to; understand the details of what combinations are accessible or what; alternate implementations are available, read on.; Below, “Y” means method available in module, “D” means module is default; for that method, and “” means method not available. HF, DFT, and MP2; default to density-fitted integrals, while all higher methods default to; conventional integrals. Therefore, for a closed-shell molecule:. runs MP2 with default DF with default implementation DFMP2; energy('mp2'). runs MP2 with CONV with default implementation OCC; set mp2_type conv; energy('mp2'). runs MP2 with default DF with implementation OCC; set qc_module occ; energy('mp2'). Overlapping capabilities of PSI4. “Y” is available; “D” is default.¶. name; _; type select 1. QC_MODULE; REFERENCE; _. energy(); gradient(). RHF; UHF; ROHF; RHF; UHF; ROHF. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. mp2; MP2_TYPE. CCENERGY. DETCI; Y. Y. DFMP2. D 2. D 2. D. D. FNOCC; Y. OCC; D; Y; D; D; Y; Y; D; Y; D; D; Y. D; D. mp3; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2. FNOCC; Y. OCC; D; D; D; D; D; D. D; D. D; D. mp2.5; MP_TYPE. CCENERGY. DETCI. DFMP2. FNOCC. OCC; D; D; D; D; D; D. D; D. D; D. m",MatchSource.WIKI,psi4manual/1.6.x/notes_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/notes_c.html
https://psicode.org/psi4manual/1.6.x/notes_c.html:2872,Availability,avail,available,2872," irrep, the first two calls will take m = 2, while the last takes m = 0.; Methods that use this interface are: TD-fctl.; Note that numberings are associated with the calculation much more strongly than; with the molecular system. Changing the number of roots sought, the symmetry; subspace or the symmetry apportionment of roots under which the computation is run,; or the excited state method are all likely to scramble root numberings. Alternate Implementations¶; Depending on the reference (RHF, UHF, ROHF) and the integral treatment; (conventional CONV, density-fitted DF, and Cholesky-decomposed CD),; computational methods are sometimes implemented by multiple coders or even; multiple times. PSI4 transparently selects the most efficient; implementation, so one generally needn’t consult this table. However, to; understand the details of what combinations are accessible or what; alternate implementations are available, read on.; Below, “Y” means method available in module, “D” means module is default; for that method, and “” means method not available. HF, DFT, and MP2; default to density-fitted integrals, while all higher methods default to; conventional integrals. Therefore, for a closed-shell molecule:. runs MP2 with default DF with default implementation DFMP2; energy('mp2'). runs MP2 with CONV with default implementation OCC; set mp2_type conv; energy('mp2'). runs MP2 with default DF with implementation OCC; set qc_module occ; energy('mp2'). Overlapping capabilities of PSI4. “Y” is available; “D” is default.¶. name; _; type select 1. QC_MODULE; REFERENCE; _. energy(); gradient(). RHF; UHF; ROHF; RHF; UHF; ROHF. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. mp2; MP2_TYPE. CCENERGY. DETCI; Y. Y. DFMP2. D 2. D 2. D. D. FNOCC; Y. OCC; D; Y; D; D; Y; Y; D; Y; D; D; Y. D; D. mp3; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2. FNOCC; Y. OCC; D; D; D; D; D; D. D; D. D; D. mp2.5; MP_TYPE. CCENERGY. DETCI. DFMP2. FNOCC. OCC; D; D; D; D; D; D. D; D. D; D. m",MatchSource.WIKI,psi4manual/1.6.x/notes_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/notes_c.html
https://psicode.org/psi4manual/1.6.x/notes_c.html:3326,Availability,avail,available,3326," integral treatment; (conventional CONV, density-fitted DF, and Cholesky-decomposed CD),; computational methods are sometimes implemented by multiple coders or even; multiple times. PSI4 transparently selects the most efficient; implementation, so one generally needn’t consult this table. However, to; understand the details of what combinations are accessible or what; alternate implementations are available, read on.; Below, “Y” means method available in module, “D” means module is default; for that method, and “” means method not available. HF, DFT, and MP2; default to density-fitted integrals, while all higher methods default to; conventional integrals. Therefore, for a closed-shell molecule:. runs MP2 with default DF with default implementation DFMP2; energy('mp2'). runs MP2 with CONV with default implementation OCC; set mp2_type conv; energy('mp2'). runs MP2 with default DF with implementation OCC; set qc_module occ; energy('mp2'). Overlapping capabilities of PSI4. “Y” is available; “D” is default.¶. name; _; type select 1. QC_MODULE; REFERENCE; _. energy(); gradient(). RHF; UHF; ROHF; RHF; UHF; ROHF. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. mp2; MP2_TYPE. CCENERGY. DETCI; Y. Y. DFMP2. D 2. D 2. D. D. FNOCC; Y. OCC; D; Y; D; D; Y; Y; D; Y; D; D; Y. D; D. mp3; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2. FNOCC; Y. OCC; D; D; D; D; D; D. D; D. D; D. mp2.5; MP_TYPE. CCENERGY. DETCI. DFMP2. FNOCC. OCC; D; D; D; D; D; D. D; D. D; D. mp4; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2. FNOCC; D. OCC. lccd; CC_TYPE. CCENERGY. DETCI. DFMP2. FNOCC; D. OCC; Y; D; D; D; D; D. D; D. D; D. lccsd, cepa(0); CC_TYPE. CCENERGY. DETCI. DFMP2. FNOCC; D. OCC. ccsd; CC_TYPE. CCENERGY; D. D. D. D. D. D. DETCI. DFMP2. FNOCC; Y; D; D. OCC. Y; Y. D. ccsd(t); CC_TYPE. CCENERGY; D. D. D. D. D. DETCI. DFMP2. FNOCC; Y; D; D. OCC. Y; Y. a-ccsd(t) 4; CC_TYPE. CCENERGY; D. DETCI. DFMP2. FNOCC. OCC. D; D. cisd; CI_TYPE. CCENERGY. DETCI; Y. D. DFMP2. FNOCC; D. OCC. adc(2); MP",MatchSource.WIKI,psi4manual/1.6.x/notes_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/notes_c.html
https://psicode.org/psi4manual/1.6.x/notes_c.html:4542,Availability,avail,available,4542,"2; energy('mp2'). runs MP2 with CONV with default implementation OCC; set mp2_type conv; energy('mp2'). runs MP2 with default DF with implementation OCC; set qc_module occ; energy('mp2'). Overlapping capabilities of PSI4. “Y” is available; “D” is default.¶. name; _; type select 1. QC_MODULE; REFERENCE; _. energy(); gradient(). RHF; UHF; ROHF; RHF; UHF; ROHF. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. mp2; MP2_TYPE. CCENERGY. DETCI; Y. Y. DFMP2. D 2. D 2. D. D. FNOCC; Y. OCC; D; Y; D; D; Y; Y; D; Y; D; D; Y. D; D. mp3; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2. FNOCC; Y. OCC; D; D; D; D; D; D. D; D. D; D. mp2.5; MP_TYPE. CCENERGY. DETCI. DFMP2. FNOCC. OCC; D; D; D; D; D; D. D; D. D; D. mp4; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2. FNOCC; D. OCC. lccd; CC_TYPE. CCENERGY. DETCI. DFMP2. FNOCC; D. OCC; Y; D; D; D; D; D. D; D. D; D. lccsd, cepa(0); CC_TYPE. CCENERGY. DETCI. DFMP2. FNOCC; D. OCC. ccsd; CC_TYPE. CCENERGY; D. D. D. D. D. D. DETCI. DFMP2. FNOCC; Y; D; D. OCC. Y; Y. D. ccsd(t); CC_TYPE. CCENERGY; D. D. D. D. D. DETCI. DFMP2. FNOCC; Y; D; D. OCC. Y; Y. a-ccsd(t) 4; CC_TYPE. CCENERGY; D. DETCI. DFMP2. FNOCC. OCC. D; D. cisd; CI_TYPE. CCENERGY. DETCI; Y. D. DFMP2. FNOCC; D. OCC. adc(2); MP_TYPE. ADCC; Y. D. BUILTIN; D. Footnotes. 1; Algorithm type selection keyword below. Values to the right: conventional CONV (here abbreviated CV), density-fitted DF, and Cholesky-decomposed CD. 2(1,2); Also available for KS reference. 3(1,2); Conditions have no default module (computationally inefficient) and can only be accessed by specifying QC_MODULE. 4; Also known as CCSD(AT), Lambda-CCSD(T), CCSD(T)_L. table of contents. Notes on Options; Notes on Psivars; Alternate Implementations. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; Notes on Options. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/notes_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/notes_c.html
https://psicode.org/psi4manual/1.6.x/notes_c.html:5023,Deployability,update,updated,5023,"2; energy('mp2'). runs MP2 with CONV with default implementation OCC; set mp2_type conv; energy('mp2'). runs MP2 with default DF with implementation OCC; set qc_module occ; energy('mp2'). Overlapping capabilities of PSI4. “Y” is available; “D” is default.¶. name; _; type select 1. QC_MODULE; REFERENCE; _. energy(); gradient(). RHF; UHF; ROHF; RHF; UHF; ROHF. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. mp2; MP2_TYPE. CCENERGY. DETCI; Y. Y. DFMP2. D 2. D 2. D. D. FNOCC; Y. OCC; D; Y; D; D; Y; Y; D; Y; D; D; Y. D; D. mp3; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2. FNOCC; Y. OCC; D; D; D; D; D; D. D; D. D; D. mp2.5; MP_TYPE. CCENERGY. DETCI. DFMP2. FNOCC. OCC; D; D; D; D; D; D. D; D. D; D. mp4; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2. FNOCC; D. OCC. lccd; CC_TYPE. CCENERGY. DETCI. DFMP2. FNOCC; D. OCC; Y; D; D; D; D; D. D; D. D; D. lccsd, cepa(0); CC_TYPE. CCENERGY. DETCI. DFMP2. FNOCC; D. OCC. ccsd; CC_TYPE. CCENERGY; D. D. D. D. D. D. DETCI. DFMP2. FNOCC; Y; D; D. OCC. Y; Y. D. ccsd(t); CC_TYPE. CCENERGY; D. D. D. D. D. DETCI. DFMP2. FNOCC; Y; D; D. OCC. Y; Y. a-ccsd(t) 4; CC_TYPE. CCENERGY; D. DETCI. DFMP2. FNOCC. OCC. D; D. cisd; CI_TYPE. CCENERGY. DETCI; Y. D. DFMP2. FNOCC; D. OCC. adc(2); MP_TYPE. ADCC; Y. D. BUILTIN; D. Footnotes. 1; Algorithm type selection keyword below. Values to the right: conventional CONV (here abbreviated CV), density-fitted DF, and Cholesky-decomposed CD. 2(1,2); Also available for KS reference. 3(1,2); Conditions have no default module (computationally inefficient) and can only be accessed by specifying QC_MODULE. 4; Also known as CCSD(AT), Lambda-CCSD(T), CCSD(T)_L. table of contents. Notes on Options; Notes on Psivars; Alternate Implementations. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; Notes on Options. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/notes_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/notes_c.html
https://psicode.org/psi4manual/1.6.x/notes_c.html:386,Energy Efficiency,energy,energy,386,"﻿. Notes on Options. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; Notes on Options. Notes on Options¶. Note; The options referred to in the Theoretical Methods: SCF to FCI section below; and indexed in Keywords by Module are placed in set blocks as; described in Job Control Keywords, not as arguments to a Python function; (like energy()). Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number or an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to \(10^{-6} E_h\), the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Notes on Psivars¶. Note; Starting in 1.6, there are three standard ways to access an excited state; property. We give examples below, but the method name and property name may change.; * method ROOT 0 -> ROOT m property to get root m. method ROOT 0 -> ROOT m property - h TRANSITION to get root m andindependently specify that the total transition symmetry is h, e.g., A2. method ROOT 0 (h) -> ROOT m (i) property to get the transition; between two roots, specifying the symmetry of both states and the index of the target; roots among states of their own symmetry. For example, to target the second excited-state, which is also the lowest energy state; of its irrep, the first two calls will take m = 2, while the last takes m = 0.; Methods that use this interface are: TD-fctl.; Note that numberings are associated with the calculation much ",MatchSource.WIKI,psi4manual/1.6.x/notes_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/notes_c.html
https://psicode.org/psi4manual/1.6.x/notes_c.html:1050,Energy Efficiency,energy,energy,1050," · . PSI4. Theoretical Methods: SCF to FCI; Notes on Options. Notes on Options¶. Note; The options referred to in the Theoretical Methods: SCF to FCI section below; and indexed in Keywords by Module are placed in set blocks as; described in Job Control Keywords, not as arguments to a Python function; (like energy()). Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number or an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to \(10^{-6} E_h\), the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Notes on Psivars¶. Note; Starting in 1.6, there are three standard ways to access an excited state; property. We give examples below, but the method name and property name may change.; * method ROOT 0 -> ROOT m property to get root m. method ROOT 0 -> ROOT m property - h TRANSITION to get root m andindependently specify that the total transition symmetry is h, e.g., A2. method ROOT 0 (h) -> ROOT m (i) property to get the transition; between two roots, specifying the symmetry of both states and the index of the target; roots among states of their own symmetry. For example, to target the second excited-state, which is also the lowest energy state; of its irrep, the first two calls will take m = 2, while the last takes m = 0.; Methods that use this interface are: TD-fctl.; Note that numberings are associated with the calculation much more strongly than; with the molecular system. Changing the number of roots so",MatchSource.WIKI,psi4manual/1.6.x/notes_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/notes_c.html
https://psicode.org/psi4manual/1.6.x/notes_c.html:1798,Energy Efficiency,energy,energy,1798,"rtain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number or an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to \(10^{-6} E_h\), the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Notes on Psivars¶. Note; Starting in 1.6, there are three standard ways to access an excited state; property. We give examples below, but the method name and property name may change.; * method ROOT 0 -> ROOT m property to get root m. method ROOT 0 -> ROOT m property - h TRANSITION to get root m andindependently specify that the total transition symmetry is h, e.g., A2. method ROOT 0 (h) -> ROOT m (i) property to get the transition; between two roots, specifying the symmetry of both states and the index of the target; roots among states of their own symmetry. For example, to target the second excited-state, which is also the lowest energy state; of its irrep, the first two calls will take m = 2, while the last takes m = 0.; Methods that use this interface are: TD-fctl.; Note that numberings are associated with the calculation much more strongly than; with the molecular system. Changing the number of roots sought, the symmetry; subspace or the symmetry apportionment of roots under which the computation is run,; or the excited state method are all likely to scramble root numberings. Alternate Implementations¶; Depending on the reference (RHF, UHF, ROHF) and the integral treatment; (conventional CONV, density-fitted DF, and Cholesky-decomposed CD),; computational methods are sometimes implemented by multiple coders or even; multiple times. PSI4 transparently selects the most efficient; implementation, so one generally needn’t consult this table. However, to; understand the details of what combinations are accessible or what; alternate implementations are available, read on.; Below, “Y” means method available in module, “D” m",MatchSource.WIKI,psi4manual/1.6.x/notes_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/notes_c.html
https://psicode.org/psi4manual/1.6.x/notes_c.html:2553,Energy Efficiency,efficient,efficient,2553,"y to get the transition; between two roots, specifying the symmetry of both states and the index of the target; roots among states of their own symmetry. For example, to target the second excited-state, which is also the lowest energy state; of its irrep, the first two calls will take m = 2, while the last takes m = 0.; Methods that use this interface are: TD-fctl.; Note that numberings are associated with the calculation much more strongly than; with the molecular system. Changing the number of roots sought, the symmetry; subspace or the symmetry apportionment of roots under which the computation is run,; or the excited state method are all likely to scramble root numberings. Alternate Implementations¶; Depending on the reference (RHF, UHF, ROHF) and the integral treatment; (conventional CONV, density-fitted DF, and Cholesky-decomposed CD),; computational methods are sometimes implemented by multiple coders or even; multiple times. PSI4 transparently selects the most efficient; implementation, so one generally needn’t consult this table. However, to; understand the details of what combinations are accessible or what; alternate implementations are available, read on.; Below, “Y” means method available in module, “D” means module is default; for that method, and “” means method not available. HF, DFT, and MP2; default to density-fitted integrals, while all higher methods default to; conventional integrals. Therefore, for a closed-shell molecule:. runs MP2 with default DF with default implementation DFMP2; energy('mp2'). runs MP2 with CONV with default implementation OCC; set mp2_type conv; energy('mp2'). runs MP2 with default DF with implementation OCC; set qc_module occ; energy('mp2'). Overlapping capabilities of PSI4. “Y” is available; “D” is default.¶. name; _; type select 1. QC_MODULE; REFERENCE; _. energy(); gradient(). RHF; UHF; ROHF; RHF; UHF; ROHF. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. mp2; MP2_TYPE. CCENERGY. DETCI; Y. Y. DF",MatchSource.WIKI,psi4manual/1.6.x/notes_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/notes_c.html
https://psicode.org/psi4manual/1.6.x/notes_c.html:3100,Energy Efficiency,energy,energy,3100," sought, the symmetry; subspace or the symmetry apportionment of roots under which the computation is run,; or the excited state method are all likely to scramble root numberings. Alternate Implementations¶; Depending on the reference (RHF, UHF, ROHF) and the integral treatment; (conventional CONV, density-fitted DF, and Cholesky-decomposed CD),; computational methods are sometimes implemented by multiple coders or even; multiple times. PSI4 transparently selects the most efficient; implementation, so one generally needn’t consult this table. However, to; understand the details of what combinations are accessible or what; alternate implementations are available, read on.; Below, “Y” means method available in module, “D” means module is default; for that method, and “” means method not available. HF, DFT, and MP2; default to density-fitted integrals, while all higher methods default to; conventional integrals. Therefore, for a closed-shell molecule:. runs MP2 with default DF with default implementation DFMP2; energy('mp2'). runs MP2 with CONV with default implementation OCC; set mp2_type conv; energy('mp2'). runs MP2 with default DF with implementation OCC; set qc_module occ; energy('mp2'). Overlapping capabilities of PSI4. “Y” is available; “D” is default.¶. name; _; type select 1. QC_MODULE; REFERENCE; _. energy(); gradient(). RHF; UHF; ROHF; RHF; UHF; ROHF. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. mp2; MP2_TYPE. CCENERGY. DETCI; Y. Y. DFMP2. D 2. D 2. D. D. FNOCC; Y. OCC; D; Y; D; D; Y; Y; D; Y; D; D; Y. D; D. mp3; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2. FNOCC; Y. OCC; D; D; D; D; D; D. D; D. D; D. mp2.5; MP_TYPE. CCENERGY. DETCI. DFMP2. FNOCC. OCC; D; D; D; D; D; D. D; D. D; D. mp4; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2. FNOCC; D. OCC. lccd; CC_TYPE. CCENERGY. DETCI. DFMP2. FNOCC; D. OCC; Y; D; D; D; D; D. D; D. D; D. lccsd, cepa(0); CC_TYPE. CCENERGY. DETCI. DFMP2. FNOCC; D. OCC. ccsd; CC_TYPE. CCENERGY; D. D. D. D. D. D. DETCI. ",MatchSource.WIKI,psi4manual/1.6.x/notes_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/notes_c.html
https://psicode.org/psi4manual/1.6.x/notes_c.html:3186,Energy Efficiency,energy,energy,3186,"h the computation is run,; or the excited state method are all likely to scramble root numberings. Alternate Implementations¶; Depending on the reference (RHF, UHF, ROHF) and the integral treatment; (conventional CONV, density-fitted DF, and Cholesky-decomposed CD),; computational methods are sometimes implemented by multiple coders or even; multiple times. PSI4 transparently selects the most efficient; implementation, so one generally needn’t consult this table. However, to; understand the details of what combinations are accessible or what; alternate implementations are available, read on.; Below, “Y” means method available in module, “D” means module is default; for that method, and “” means method not available. HF, DFT, and MP2; default to density-fitted integrals, while all higher methods default to; conventional integrals. Therefore, for a closed-shell molecule:. runs MP2 with default DF with default implementation DFMP2; energy('mp2'). runs MP2 with CONV with default implementation OCC; set mp2_type conv; energy('mp2'). runs MP2 with default DF with implementation OCC; set qc_module occ; energy('mp2'). Overlapping capabilities of PSI4. “Y” is available; “D” is default.¶. name; _; type select 1. QC_MODULE; REFERENCE; _. energy(); gradient(). RHF; UHF; ROHF; RHF; UHF; ROHF. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. mp2; MP2_TYPE. CCENERGY. DETCI; Y. Y. DFMP2. D 2. D 2. D. D. FNOCC; Y. OCC; D; Y; D; D; Y; Y; D; Y; D; D; Y. D; D. mp3; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2. FNOCC; Y. OCC; D; D; D; D; D; D. D; D. D; D. mp2.5; MP_TYPE. CCENERGY. DETCI. DFMP2. FNOCC. OCC; D; D; D; D; D; D. D; D. D; D. mp4; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2. FNOCC; D. OCC. lccd; CC_TYPE. CCENERGY. DETCI. DFMP2. FNOCC; D. OCC; Y; D; D; D; D; D. D; D. D; D. lccsd, cepa(0); CC_TYPE. CCENERGY. DETCI. DFMP2. FNOCC; D. OCC. ccsd; CC_TYPE. CCENERGY; D. D. D. D. D. D. DETCI. DFMP2. FNOCC; Y; D; D. OCC. Y; Y. D. ccsd(t); CC_TYPE. CCENERGY; D. D. D. D. D. ",MatchSource.WIKI,psi4manual/1.6.x/notes_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/notes_c.html
https://psicode.org/psi4manual/1.6.x/notes_c.html:3270,Energy Efficiency,energy,energy,3270,"t numberings. Alternate Implementations¶; Depending on the reference (RHF, UHF, ROHF) and the integral treatment; (conventional CONV, density-fitted DF, and Cholesky-decomposed CD),; computational methods are sometimes implemented by multiple coders or even; multiple times. PSI4 transparently selects the most efficient; implementation, so one generally needn’t consult this table. However, to; understand the details of what combinations are accessible or what; alternate implementations are available, read on.; Below, “Y” means method available in module, “D” means module is default; for that method, and “” means method not available. HF, DFT, and MP2; default to density-fitted integrals, while all higher methods default to; conventional integrals. Therefore, for a closed-shell molecule:. runs MP2 with default DF with default implementation DFMP2; energy('mp2'). runs MP2 with CONV with default implementation OCC; set mp2_type conv; energy('mp2'). runs MP2 with default DF with implementation OCC; set qc_module occ; energy('mp2'). Overlapping capabilities of PSI4. “Y” is available; “D” is default.¶. name; _; type select 1. QC_MODULE; REFERENCE; _. energy(); gradient(). RHF; UHF; ROHF; RHF; UHF; ROHF. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. mp2; MP2_TYPE. CCENERGY. DETCI; Y. Y. DFMP2. D 2. D 2. D. D. FNOCC; Y. OCC; D; Y; D; D; Y; Y; D; Y; D; D; Y. D; D. mp3; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2. FNOCC; Y. OCC; D; D; D; D; D; D. D; D. D; D. mp2.5; MP_TYPE. CCENERGY. DETCI. DFMP2. FNOCC. OCC; D; D; D; D; D; D. D; D. D; D. mp4; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2. FNOCC; D. OCC. lccd; CC_TYPE. CCENERGY. DETCI. DFMP2. FNOCC; D. OCC; Y; D; D; D; D; D. D; D. D; D. lccsd, cepa(0); CC_TYPE. CCENERGY. DETCI. DFMP2. FNOCC; D. OCC. ccsd; CC_TYPE. CCENERGY; D. D. D. D. D. D. DETCI. DFMP2. FNOCC; Y; D; D. OCC. Y; Y. D. ccsd(t); CC_TYPE. CCENERGY; D. D. D. D. D. DETCI. DFMP2. FNOCC; Y; D; D. OCC. Y; Y. a-ccsd(t) 4; CC_TYPE. CCENERGY; D. DETCI. DF",MatchSource.WIKI,psi4manual/1.6.x/notes_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/notes_c.html
https://psicode.org/psi4manual/1.6.x/notes_c.html:3404,Energy Efficiency,energy,energy,3404,"osed CD),; computational methods are sometimes implemented by multiple coders or even; multiple times. PSI4 transparently selects the most efficient; implementation, so one generally needn’t consult this table. However, to; understand the details of what combinations are accessible or what; alternate implementations are available, read on.; Below, “Y” means method available in module, “D” means module is default; for that method, and “” means method not available. HF, DFT, and MP2; default to density-fitted integrals, while all higher methods default to; conventional integrals. Therefore, for a closed-shell molecule:. runs MP2 with default DF with default implementation DFMP2; energy('mp2'). runs MP2 with CONV with default implementation OCC; set mp2_type conv; energy('mp2'). runs MP2 with default DF with implementation OCC; set qc_module occ; energy('mp2'). Overlapping capabilities of PSI4. “Y” is available; “D” is default.¶. name; _; type select 1. QC_MODULE; REFERENCE; _. energy(); gradient(). RHF; UHF; ROHF; RHF; UHF; ROHF. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. mp2; MP2_TYPE. CCENERGY. DETCI; Y. Y. DFMP2. D 2. D 2. D. D. FNOCC; Y. OCC; D; Y; D; D; Y; Y; D; Y; D; D; Y. D; D. mp3; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2. FNOCC; Y. OCC; D; D; D; D; D; D. D; D. D; D. mp2.5; MP_TYPE. CCENERGY. DETCI. DFMP2. FNOCC. OCC; D; D; D; D; D; D. D; D. D; D. mp4; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2. FNOCC; D. OCC. lccd; CC_TYPE. CCENERGY. DETCI. DFMP2. FNOCC; D. OCC; Y; D; D; D; D; D. D; D. D; D. lccsd, cepa(0); CC_TYPE. CCENERGY. DETCI. DFMP2. FNOCC; D. OCC. ccsd; CC_TYPE. CCENERGY; D. D. D. D. D. D. DETCI. DFMP2. FNOCC; Y; D; D. OCC. Y; Y. D. ccsd(t); CC_TYPE. CCENERGY; D. D. D. D. D. DETCI. DFMP2. FNOCC; Y; D; D. OCC. Y; Y. a-ccsd(t) 4; CC_TYPE. CCENERGY; D. DETCI. DFMP2. FNOCC. OCC. D; D. cisd; CI_TYPE. CCENERGY. DETCI; Y. D. DFMP2. FNOCC; D. OCC. adc(2); MP_TYPE. ADCC; Y. D. BUILTIN; D. Footnotes. 1; Algorithm type selection keyword b",MatchSource.WIKI,psi4manual/1.6.x/notes_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/notes_c.html
https://psicode.org/psi4manual/1.6.x/notes_c.html:1914,Integrability,interface,interface,1914,"eal number or an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to \(10^{-6} E_h\), the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Notes on Psivars¶. Note; Starting in 1.6, there are three standard ways to access an excited state; property. We give examples below, but the method name and property name may change.; * method ROOT 0 -> ROOT m property to get root m. method ROOT 0 -> ROOT m property - h TRANSITION to get root m andindependently specify that the total transition symmetry is h, e.g., A2. method ROOT 0 (h) -> ROOT m (i) property to get the transition; between two roots, specifying the symmetry of both states and the index of the target; roots among states of their own symmetry. For example, to target the second excited-state, which is also the lowest energy state; of its irrep, the first two calls will take m = 2, while the last takes m = 0.; Methods that use this interface are: TD-fctl.; Note that numberings are associated with the calculation much more strongly than; with the molecular system. Changing the number of roots sought, the symmetry; subspace or the symmetry apportionment of roots under which the computation is run,; or the excited state method are all likely to scramble root numberings. Alternate Implementations¶; Depending on the reference (RHF, UHF, ROHF) and the integral treatment; (conventional CONV, density-fitted DF, and Cholesky-decomposed CD),; computational methods are sometimes implemented by multiple coders or even; multiple times. PSI4 transparently selects the most efficient; implementation, so one generally needn’t consult this table. However, to; understand the details of what combinations are accessible or what; alternate implementations are available, read on.; Below, “Y” means method available in module, “D” means module is default; for that method, and “” means method not available. HF, DFT, and MP2; default to de",MatchSource.WIKI,psi4manual/1.6.x/notes_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/notes_c.html
https://psicode.org/psi4manual/1.6.x/notes_c.html:1233,Security,access,access,1233,"ion below; and indexed in Keywords by Module are placed in set blocks as; described in Job Control Keywords, not as arguments to a Python function; (like energy()). Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number or an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to \(10^{-6} E_h\), the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Notes on Psivars¶. Note; Starting in 1.6, there are three standard ways to access an excited state; property. We give examples below, but the method name and property name may change.; * method ROOT 0 -> ROOT m property to get root m. method ROOT 0 -> ROOT m property - h TRANSITION to get root m andindependently specify that the total transition symmetry is h, e.g., A2. method ROOT 0 (h) -> ROOT m (i) property to get the transition; between two roots, specifying the symmetry of both states and the index of the target; roots among states of their own symmetry. For example, to target the second excited-state, which is also the lowest energy state; of its irrep, the first two calls will take m = 2, while the last takes m = 0.; Methods that use this interface are: TD-fctl.; Note that numberings are associated with the calculation much more strongly than; with the molecular system. Changing the number of roots sought, the symmetry; subspace or the symmetry apportionment of roots under which the computation is run,; or the excited state method are all likely to sc",MatchSource.WIKI,psi4manual/1.6.x/notes_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/notes_c.html
https://psicode.org/psi4manual/1.6.x/notes_c.html:2686,Security,access,accessible,2686,"mong states of their own symmetry. For example, to target the second excited-state, which is also the lowest energy state; of its irrep, the first two calls will take m = 2, while the last takes m = 0.; Methods that use this interface are: TD-fctl.; Note that numberings are associated with the calculation much more strongly than; with the molecular system. Changing the number of roots sought, the symmetry; subspace or the symmetry apportionment of roots under which the computation is run,; or the excited state method are all likely to scramble root numberings. Alternate Implementations¶; Depending on the reference (RHF, UHF, ROHF) and the integral treatment; (conventional CONV, density-fitted DF, and Cholesky-decomposed CD),; computational methods are sometimes implemented by multiple coders or even; multiple times. PSI4 transparently selects the most efficient; implementation, so one generally needn’t consult this table. However, to; understand the details of what combinations are accessible or what; alternate implementations are available, read on.; Below, “Y” means method available in module, “D” means module is default; for that method, and “” means method not available. HF, DFT, and MP2; default to density-fitted integrals, while all higher methods default to; conventional integrals. Therefore, for a closed-shell molecule:. runs MP2 with default DF with default implementation DFMP2; energy('mp2'). runs MP2 with CONV with default implementation OCC; set mp2_type conv; energy('mp2'). runs MP2 with default DF with implementation OCC; set qc_module occ; energy('mp2'). Overlapping capabilities of PSI4. “Y” is available; “D” is default.¶. name; _; type select 1. QC_MODULE; REFERENCE; _. energy(); gradient(). RHF; UHF; ROHF; RHF; UHF; ROHF. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. mp2; MP2_TYPE. CCENERGY. DETCI; Y. Y. DFMP2. D 2. D 2. D. D. FNOCC; Y. OCC; D; Y; D; D; Y; Y; D; Y; D; D; Y. D; D. mp3; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2.",MatchSource.WIKI,psi4manual/1.6.x/notes_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/notes_c.html
https://psicode.org/psi4manual/1.6.x/notes_c.html:4658,Security,access,accessed,4658,"2; energy('mp2'). runs MP2 with CONV with default implementation OCC; set mp2_type conv; energy('mp2'). runs MP2 with default DF with implementation OCC; set qc_module occ; energy('mp2'). Overlapping capabilities of PSI4. “Y” is available; “D” is default.¶. name; _; type select 1. QC_MODULE; REFERENCE; _. energy(); gradient(). RHF; UHF; ROHF; RHF; UHF; ROHF. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. mp2; MP2_TYPE. CCENERGY. DETCI; Y. Y. DFMP2. D 2. D 2. D. D. FNOCC; Y. OCC; D; Y; D; D; Y; Y; D; Y; D; D; Y. D; D. mp3; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2. FNOCC; Y. OCC; D; D; D; D; D; D. D; D. D; D. mp2.5; MP_TYPE. CCENERGY. DETCI. DFMP2. FNOCC. OCC; D; D; D; D; D; D. D; D. D; D. mp4; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2. FNOCC; D. OCC. lccd; CC_TYPE. CCENERGY. DETCI. DFMP2. FNOCC; D. OCC; Y; D; D; D; D; D. D; D. D; D. lccsd, cepa(0); CC_TYPE. CCENERGY. DETCI. DFMP2. FNOCC; D. OCC. ccsd; CC_TYPE. CCENERGY; D. D. D. D. D. D. DETCI. DFMP2. FNOCC; Y; D; D. OCC. Y; Y. D. ccsd(t); CC_TYPE. CCENERGY; D. D. D. D. D. DETCI. DFMP2. FNOCC; Y; D; D. OCC. Y; Y. a-ccsd(t) 4; CC_TYPE. CCENERGY; D. DETCI. DFMP2. FNOCC. OCC. D; D. cisd; CI_TYPE. CCENERGY. DETCI; Y. D. DFMP2. FNOCC; D. OCC. adc(2); MP_TYPE. ADCC; Y. D. BUILTIN; D. Footnotes. 1; Algorithm type selection keyword below. Values to the right: conventional CONV (here abbreviated CV), density-fitted DF, and Cholesky-decomposed CD. 2(1,2); Also available for KS reference. 3(1,2); Conditions have no default module (computationally inefficient) and can only be accessed by specifying QC_MODULE. 4; Also known as CCSD(AT), Lambda-CCSD(T), CCSD(T)_L. table of contents. Notes on Options; Notes on Psivars; Alternate Implementations. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; Notes on Options. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/notes_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/notes_c.html
https://psicode.org/psi4manual/1.6.x/notes_py.html:2007,Deployability,update,updated,2007,". PSI4. Psithon Functions: Invoking a Calculation; Notes on Options. Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. For finite difference, as opposed to analytic, derivatives, the POINTS option can be increased to 5 for greater accuracy at increased cost. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; “active” molecule, which is the nearest preceeding molecule declared in a; molecule mymol {...} block or in an activate(mymol) statement. Note; that the value of this keyword (mymol in the example) is a Python object; and so is not wrapped in quotes like a string. Technically, this is a; Molecule object. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Notes on Options. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/notes_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/notes_py.html
https://psicode.org/psi4manual/1.6.x/notes_py.html:322,Energy Efficiency,energy,energy,322,"﻿. Notes on Options. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Notes on Options. Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. For finite difference, as opposed to analytic, derivatives, the POINTS option can be increased to 5 for greater accuracy at increased cost. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; “active” molecule, which is the nearest preceeding molecule declared in a; molecule mymol {...} block or in an activate(mymol) statement. Note; that the value of this keyword (mymol in the example) is a Python object; and so is not wrapped in quotes like a string. Technically, this is a; Molecule object. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Notes on Options. © Copyright 2022, The Psi4 Project.;",MatchSource.WIKI,psi4manual/1.6.x/notes_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/notes_py.html
https://psicode.org/psi4manual/1.6.x/notes_py.html:877,Energy Efficiency,energy,energy,877,"﻿. Notes on Options. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Notes on Options. Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. For finite difference, as opposed to analytic, derivatives, the POINTS option can be increased to 5 for greater accuracy at increased cost. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; “active” molecule, which is the nearest preceeding molecule declared in a; molecule mymol {...} block or in an activate(mymol) statement. Note; that the value of this keyword (mymol in the example) is a Python object; and so is not wrapped in quotes like a string. Technically, this is a; Molecule object. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Notes on Options. © Copyright 2022, The Psi4 Project.;",MatchSource.WIKI,psi4manual/1.6.x/notes_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/notes_py.html
https://psicode.org/psi4manual/1.6.x/notes_py.html:1247,Energy Efficiency,energy,energy,1247,". PSI4. Psithon Functions: Invoking a Calculation; Notes on Options. Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. For finite difference, as opposed to analytic, derivatives, the POINTS option can be increased to 5 for greater accuracy at increased cost. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; “active” molecule, which is the nearest preceeding molecule declared in a; molecule mymol {...} block or in an activate(mymol) statement. Note; that the value of this keyword (mymol in the example) is a Python object; and so is not wrapped in quotes like a string. Technically, this is a; Molecule object. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Notes on Options. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/notes_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/notes_py.html
https://psicode.org/psi4manual/1.6.x/notes_py.html:1382,Integrability,wrap,wrapped,1382,". PSI4. Psithon Functions: Invoking a Calculation; Notes on Options. Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. For finite difference, as opposed to analytic, derivatives, the POINTS option can be increased to 5 for greater accuracy at increased cost. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; “active” molecule, which is the nearest preceeding molecule declared in a; molecule mymol {...} block or in an activate(mymol) statement. Note; that the value of this keyword (mymol in the example) is a Python object; and so is not wrapped in quotes like a string. Technically, this is a; Molecule object. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Notes on Options. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/notes_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/notes_py.html
https://psicode.org/psi4manual/1.6.x/notes_py.html:1728,Integrability,wrap,wrapped,1728,". PSI4. Psithon Functions: Invoking a Calculation; Notes on Options. Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. For finite difference, as opposed to analytic, derivatives, the POINTS option can be increased to 5 for greater accuracy at increased cost. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; “active” molecule, which is the nearest preceeding molecule declared in a; molecule mymol {...} block or in an activate(mymol) statement. Note; that the value of this keyword (mymol in the example) is a Python object; and so is not wrapped in quotes like a string. Technically, this is a; Molecule object. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Notes on Options. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/notes_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/notes_py.html
https://psicode.org/psi4manual/1.6.x/notes_py.html:820,Performance,optimiz,optimize,820,"﻿. Notes on Options. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Notes on Options. Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. For finite difference, as opposed to analytic, derivatives, the POINTS option can be increased to 5 for greater accuracy at increased cost. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; “active” molecule, which is the nearest preceeding molecule declared in a; molecule mymol {...} block or in an activate(mymol) statement. Note; that the value of this keyword (mymol in the example) is a Python object; and so is not wrapped in quotes like a string. Technically, this is a; Molecule object. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Notes on Options. © Copyright 2022, The Psi4 Project.;",MatchSource.WIKI,psi4manual/1.6.x/notes_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/notes_py.html
https://psicode.org/psi4manual/1.6.x/numpy.html:1441,Availability,error,errors,1441,"onality can be found here. In addition,; numerous example of hybrid NumPy and Psi4 can be found at the Psi4Numpy; project. Currently only the Matrix; and Vector objects support NumPy interfacing. Let us begin with a simple; conversion from these objects to a NumPy array:; >>> import psi4; >>> import numpy as np. # Build the Psi4 data objects; >>> mat = psi4.core.Matrix(3, 3); >>> vec = psi4.core.Vector(3). # Convert to a NumPy array; >>> numpy_mat = np.array(mat); >>> numpy_vec = np.array(vec). Here the data is copied into new NumPy arrays. NumPy arrays can be converted; back to PSI4 objects using the from_array interface:; >>> new_mat = psi4.core.Matrix.from_array(mat); >>> new_vec = psi4.core.Vector.from_array(vec). NumPy Views¶; Copying the data between NumPy and Psi4 objects can lead to excessive data; movement and convoluted code. Here we introduce the idea of “Views” where the; same data can be viewed by multiple objects. However, this can lead to very; subtle errors if used incorrectly and care needs to be taken when using these; views. Views can be created in two ways:; >>> numpy_mat_view = np.asarray(mat). # Access the NumPy object and set all values to 1 through broadcasting; >>> numpy_mat_view[:] = 1. >>> print(np.array(mat)); [[ 1. 1. 1.]; [ 1. 1. 1.]; [ 1. 1. 1.]]. Secondly, these objects have a .np attribute for easy access to the underlying data:; >>> mat.np[:] = 1. this operation is identical to the above. PSI4 Data Objects with Irreps¶; PSI4 data objects natively support multiple irreducible representations; which is quite useful for Quantum Chemistry. However, this is not fundamental; to NumPy and some work around are required to natively support these; operations. Take the following irreped Matrix:; >>> dim = psi4.core.Dimension.from_list([1, 2, 3]); >>> irreped_mat = psi4.core.Matrix(""New Matrix"", dim, dim). # Create a list of Psi4 arrays; >>> list_of_arrays = irreped_mat.to_array(). # Or, use the .nph irreped accessor; >>> irreped_mat.nph[0][:] ",MatchSource.WIKI,psi4manual/1.6.x/numpy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/numpy.html
https://psicode.org/psi4manual/1.6.x/numpy.html:2571,Availability,error,error,2571,"). # Access the NumPy object and set all values to 1 through broadcasting; >>> numpy_mat_view[:] = 1. >>> print(np.array(mat)); [[ 1. 1. 1.]; [ 1. 1. 1.]; [ 1. 1. 1.]]. Secondly, these objects have a .np attribute for easy access to the underlying data:; >>> mat.np[:] = 1. this operation is identical to the above. PSI4 Data Objects with Irreps¶; PSI4 data objects natively support multiple irreducible representations; which is quite useful for Quantum Chemistry. However, this is not fundamental; to NumPy and some work around are required to natively support these; operations. Take the following irreped Matrix:; >>> dim = psi4.core.Dimension.from_list([1, 2, 3]); >>> irreped_mat = psi4.core.Matrix(""New Matrix"", dim, dim). # Create a list of Psi4 arrays; >>> list_of_arrays = irreped_mat.to_array(). # Or, use the .nph irreped accessor; >>> irreped_mat.nph[0][:] = 1. Where .nph is the irreped accessor form. If .np or np.array are; called on irreped Matrices or Vectors an error will be thrown; however, the; irreped form is always valid for non-irreped matrices. Array to Matrix¶; A general function that converts PSI4 data objects to NumPy arrays. psi4.driver.p4util.numpy_helper.array_to_matrix(self, arr, name='New Matrix', dim1=None, dim2=None)[source]¶; Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Parameters. arr (Union[ndarray, List[ndarray]]) – Numpy array or list of arrays to use as the data for a new core.Matrix; name (str) – Name to give the new core.Matrix; dim1 (Union[List, Tuple, Dimension, None]) – If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 (Optional[Dimension]) – Same as dim1 only if using a psi4.core.Dimension object. Returns; Returns the given Psi4 object. Return type; Matrix or Vector. Notes; This is a generalized function to co",MatchSource.WIKI,psi4manual/1.6.x/numpy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/numpy.html
https://psicode.org/psi4manual/1.6.x/numpy.html:5117,Deployability,update,updated,5117,"iven, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 (Optional[Dimension]) – Same as dim1 only if using a psi4.core.Dimension object. Returns; Returns the given Psi4 object. Return type; Matrix or Vector. Notes; This is a generalized function to convert a NumPy array to a Psi4 object; Examples; >>> data = np.random.rand(20,1); >>> vector = psi4.core.Matrix.from_array(data). >>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = psi4.core.Matrix.from_array(irrep_data); >>> print(matrix.rowdim().to_tuple()); (2, 0, 4). Matrix to Array¶; A general function that converts NumPy arrays to PSI4 data objects. psi4.driver.p4util.numpy_helper._to_array(matrix, copy=True, dense=False)[source]¶; Converts a Psi4 Matrix or Vector to a NumPy array. Either copies the data or simply; constructs a view. Parameters. matrix (Union[Matrix, Vector]) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns; Returns either a list of np.array’s or the base array depending on options. Return type; numpy.ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. table of contents. Interface to NumPy; Basics; NumPy Views; PSI4 Data Objects with Irreps; Array to Matrix; Matrix to Array. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to NumPy. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/numpy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/numpy.html
https://psicode.org/psi4manual/1.6.x/numpy.html:1080,Integrability,interface,interface,1080,".    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to NumPy. Interface to NumPy¶; Code author: Daniel G. A. Smith; Section author: Daniel G. A. Smith; Module: psi4/psi4/driver/p4util/numpy_helper.py. Basics¶; Converting between the PSI4 Data classes and a NumPy array is easy through; various helper functions as detailed in this section. A quick overview NumPy; functionality can be found here. In addition,; numerous example of hybrid NumPy and Psi4 can be found at the Psi4Numpy; project. Currently only the Matrix; and Vector objects support NumPy interfacing. Let us begin with a simple; conversion from these objects to a NumPy array:; >>> import psi4; >>> import numpy as np. # Build the Psi4 data objects; >>> mat = psi4.core.Matrix(3, 3); >>> vec = psi4.core.Vector(3). # Convert to a NumPy array; >>> numpy_mat = np.array(mat); >>> numpy_vec = np.array(vec). Here the data is copied into new NumPy arrays. NumPy arrays can be converted; back to PSI4 objects using the from_array interface:; >>> new_mat = psi4.core.Matrix.from_array(mat); >>> new_vec = psi4.core.Vector.from_array(vec). NumPy Views¶; Copying the data between NumPy and Psi4 objects can lead to excessive data; movement and convoluted code. Here we introduce the idea of “Views” where the; same data can be viewed by multiple objects. However, this can lead to very; subtle errors if used incorrectly and care needs to be taken when using these; views. Views can be created in two ways:; >>> numpy_mat_view = np.asarray(mat). # Access the NumPy object and set all values to 1 through broadcasting; >>> numpy_mat_view[:] = 1. >>> print(np.array(mat)); [[ 1. 1. 1.]; [ 1. 1. 1.]; [ 1. 1. 1.]]. Secondly, these objects have a .np attribute for easy access to the underlying data:; >>> mat.np[:] = 1. this operation is identical to the above. PSI4 Data Objects with Irreps¶; PSI4 data objects natively support multiple irreducible representations; which is quite useful for Quantum Chemistry. How",MatchSource.WIKI,psi4manual/1.6.x/numpy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/numpy.html
https://psicode.org/psi4manual/1.6.x/numpy.html:4549,Integrability,depend,depending,4549,"iven, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 (Optional[Dimension]) – Same as dim1 only if using a psi4.core.Dimension object. Returns; Returns the given Psi4 object. Return type; Matrix or Vector. Notes; This is a generalized function to convert a NumPy array to a Psi4 object; Examples; >>> data = np.random.rand(20,1); >>> vector = psi4.core.Matrix.from_array(data). >>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = psi4.core.Matrix.from_array(irrep_data); >>> print(matrix.rowdim().to_tuple()); (2, 0, 4). Matrix to Array¶; A general function that converts NumPy arrays to PSI4 data objects. psi4.driver.p4util.numpy_helper._to_array(matrix, copy=True, dense=False)[source]¶; Converts a Psi4 Matrix or Vector to a NumPy array. Either copies the data or simply; constructs a view. Parameters. matrix (Union[Matrix, Vector]) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns; Returns either a list of np.array’s or the base array depending on options. Return type; numpy.ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. table of contents. Interface to NumPy; Basics; NumPy Views; PSI4 Data Objects with Irreps; Array to Matrix; Matrix to Array. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to NumPy. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/numpy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/numpy.html
https://psicode.org/psi4manual/1.6.x/numpy.html:1813,Security,access,access,1813,"re.Matrix(3, 3); >>> vec = psi4.core.Vector(3). # Convert to a NumPy array; >>> numpy_mat = np.array(mat); >>> numpy_vec = np.array(vec). Here the data is copied into new NumPy arrays. NumPy arrays can be converted; back to PSI4 objects using the from_array interface:; >>> new_mat = psi4.core.Matrix.from_array(mat); >>> new_vec = psi4.core.Vector.from_array(vec). NumPy Views¶; Copying the data between NumPy and Psi4 objects can lead to excessive data; movement and convoluted code. Here we introduce the idea of “Views” where the; same data can be viewed by multiple objects. However, this can lead to very; subtle errors if used incorrectly and care needs to be taken when using these; views. Views can be created in two ways:; >>> numpy_mat_view = np.asarray(mat). # Access the NumPy object and set all values to 1 through broadcasting; >>> numpy_mat_view[:] = 1. >>> print(np.array(mat)); [[ 1. 1. 1.]; [ 1. 1. 1.]; [ 1. 1. 1.]]. Secondly, these objects have a .np attribute for easy access to the underlying data:; >>> mat.np[:] = 1. this operation is identical to the above. PSI4 Data Objects with Irreps¶; PSI4 data objects natively support multiple irreducible representations; which is quite useful for Quantum Chemistry. However, this is not fundamental; to NumPy and some work around are required to natively support these; operations. Take the following irreped Matrix:; >>> dim = psi4.core.Dimension.from_list([1, 2, 3]); >>> irreped_mat = psi4.core.Matrix(""New Matrix"", dim, dim). # Create a list of Psi4 arrays; >>> list_of_arrays = irreped_mat.to_array(). # Or, use the .nph irreped accessor; >>> irreped_mat.nph[0][:] = 1. Where .nph is the irreped accessor form. If .np or np.array are; called on irreped Matrices or Vectors an error will be thrown; however, the; irreped form is always valid for non-irreped matrices. Array to Matrix¶; A general function that converts PSI4 data objects to NumPy arrays. psi4.driver.p4util.numpy_helper.array_to_matrix(self, arr, name='New Matri",MatchSource.WIKI,psi4manual/1.6.x/numpy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/numpy.html
https://psicode.org/psi4manual/1.6.x/numpy.html:2424,Security,access,accessor,2424,"y; subtle errors if used incorrectly and care needs to be taken when using these; views. Views can be created in two ways:; >>> numpy_mat_view = np.asarray(mat). # Access the NumPy object and set all values to 1 through broadcasting; >>> numpy_mat_view[:] = 1. >>> print(np.array(mat)); [[ 1. 1. 1.]; [ 1. 1. 1.]; [ 1. 1. 1.]]. Secondly, these objects have a .np attribute for easy access to the underlying data:; >>> mat.np[:] = 1. this operation is identical to the above. PSI4 Data Objects with Irreps¶; PSI4 data objects natively support multiple irreducible representations; which is quite useful for Quantum Chemistry. However, this is not fundamental; to NumPy and some work around are required to natively support these; operations. Take the following irreped Matrix:; >>> dim = psi4.core.Dimension.from_list([1, 2, 3]); >>> irreped_mat = psi4.core.Matrix(""New Matrix"", dim, dim). # Create a list of Psi4 arrays; >>> list_of_arrays = irreped_mat.to_array(). # Or, use the .nph irreped accessor; >>> irreped_mat.nph[0][:] = 1. Where .nph is the irreped accessor form. If .np or np.array are; called on irreped Matrices or Vectors an error will be thrown; however, the; irreped form is always valid for non-irreped matrices. Array to Matrix¶; A general function that converts PSI4 data objects to NumPy arrays. psi4.driver.p4util.numpy_helper.array_to_matrix(self, arr, name='New Matrix', dim1=None, dim2=None)[source]¶; Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Parameters. arr (Union[ndarray, List[ndarray]]) – Numpy array or list of arrays to use as the data for a new core.Matrix; name (str) – Name to give the new core.Matrix; dim1 (Union[List, Tuple, Dimension, None]) – If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 (Optional[Dimension]) – Same as dim1",MatchSource.WIKI,psi4manual/1.6.x/numpy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/numpy.html
https://psicode.org/psi4manual/1.6.x/numpy.html:2491,Security,access,accessor,2491," taken when using these; views. Views can be created in two ways:; >>> numpy_mat_view = np.asarray(mat). # Access the NumPy object and set all values to 1 through broadcasting; >>> numpy_mat_view[:] = 1. >>> print(np.array(mat)); [[ 1. 1. 1.]; [ 1. 1. 1.]; [ 1. 1. 1.]]. Secondly, these objects have a .np attribute for easy access to the underlying data:; >>> mat.np[:] = 1. this operation is identical to the above. PSI4 Data Objects with Irreps¶; PSI4 data objects natively support multiple irreducible representations; which is quite useful for Quantum Chemistry. However, this is not fundamental; to NumPy and some work around are required to natively support these; operations. Take the following irreped Matrix:; >>> dim = psi4.core.Dimension.from_list([1, 2, 3]); >>> irreped_mat = psi4.core.Matrix(""New Matrix"", dim, dim). # Create a list of Psi4 arrays; >>> list_of_arrays = irreped_mat.to_array(). # Or, use the .nph irreped accessor; >>> irreped_mat.nph[0][:] = 1. Where .nph is the irreped accessor form. If .np or np.array are; called on irreped Matrices or Vectors an error will be thrown; however, the; irreped form is always valid for non-irreped matrices. Array to Matrix¶; A general function that converts PSI4 data objects to NumPy arrays. psi4.driver.p4util.numpy_helper.array_to_matrix(self, arr, name='New Matrix', dim1=None, dim2=None)[source]¶; Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Parameters. arr (Union[ndarray, List[ndarray]]) – Numpy array or list of arrays to use as the data for a new core.Matrix; name (str) – Name to give the new core.Matrix; dim1 (Union[List, Tuple, Dimension, None]) – If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 (Optional[Dimension]) – Same as dim1 only if using a psi4.core.Dimension object. Returns; Retu",MatchSource.WIKI,psi4manual/1.6.x/numpy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/numpy.html
https://psicode.org/psi4manual/1.6.x/numpy.html:676,Usability,simpl,simple,676,"﻿. Interface to NumPy. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to NumPy. Interface to NumPy¶; Code author: Daniel G. A. Smith; Section author: Daniel G. A. Smith; Module: psi4/psi4/driver/p4util/numpy_helper.py. Basics¶; Converting between the PSI4 Data classes and a NumPy array is easy through; various helper functions as detailed in this section. A quick overview NumPy; functionality can be found here. In addition,; numerous example of hybrid NumPy and Psi4 can be found at the Psi4Numpy; project. Currently only the Matrix; and Vector objects support NumPy interfacing. Let us begin with a simple; conversion from these objects to a NumPy array:; >>> import psi4; >>> import numpy as np. # Build the Psi4 data objects; >>> mat = psi4.core.Matrix(3, 3); >>> vec = psi4.core.Vector(3). # Convert to a NumPy array; >>> numpy_mat = np.array(mat); >>> numpy_vec = np.array(vec). Here the data is copied into new NumPy arrays. NumPy arrays can be converted; back to PSI4 objects using the from_array interface:; >>> new_mat = psi4.core.Matrix.from_array(mat); >>> new_vec = psi4.core.Vector.from_array(vec). NumPy Views¶; Copying the data between NumPy and Psi4 objects can lead to excessive data; movement and convoluted code. Here we introduce the idea of “Views” where the; same data can be viewed by multiple objects. However, this can lead to very; subtle errors if used incorrectly and care needs to be taken when using these; views. Views can be created in two ways:; >>> numpy_mat_view = np.asarray(mat). # Access the NumPy object and set all values to 1 through broadcasting; >>> numpy_mat_view[:] = 1. >>> print(np.array(mat)); [[ 1. 1. 1.]; [ 1. 1. 1.]; [ 1. 1. 1.]]. Secondly, these objects have a .np attribute for easy access to the underlying data:; >>> mat.np[:] = 1. this operation is identical to the above. PSI4 Data Objects with Irreps¶; PSI4 data objects natively support multiple irreducible represe",MatchSource.WIKI,psi4manual/1.6.x/numpy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/numpy.html
https://psicode.org/psi4manual/1.6.x/numpy.html:4156,Usability,simpl,simply,4156,"– If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 (Optional[Dimension]) – Same as dim1 only if using a psi4.core.Dimension object. Returns; Returns the given Psi4 object. Return type; Matrix or Vector. Notes; This is a generalized function to convert a NumPy array to a Psi4 object; Examples; >>> data = np.random.rand(20,1); >>> vector = psi4.core.Matrix.from_array(data). >>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = psi4.core.Matrix.from_array(irrep_data); >>> print(matrix.rowdim().to_tuple()); (2, 0, 4). Matrix to Array¶; A general function that converts NumPy arrays to PSI4 data objects. psi4.driver.p4util.numpy_helper._to_array(matrix, copy=True, dense=False)[source]¶; Converts a Psi4 Matrix or Vector to a NumPy array. Either copies the data or simply; constructs a view. Parameters. matrix (Union[Matrix, Vector]) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns; Returns either a list of np.array’s or the base array depending on options. Return type; numpy.ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. table of contents. Interface to NumPy; Basics; NumPy Views; PSI4 Data Objects with Irreps; Array to Matrix; Matrix to Array. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to NumPy. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57P",MatchSource.WIKI,psi4manual/1.6.x/numpy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/numpy.html
https://psicode.org/psi4manual/1.6.x/occ.html:9105,Availability,avail,available,9105,"f A}\) is the MO Hessian matrix. Therefore, minimizing the energy with respect to \({\bf \kappa}\); yields. \[{\bf \kappa} = -{\bf A^{-1}w}\]; This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the orbital-optimized code should cite the following publications:. OMP2 [Bozkaya:2011:omp2] and [Bozkaya:2013:omp2grad]; OMP3 [Bozkaya:2011:omp3] , [Bozkaya:2013:omp3], and [Bozkaya:2013:omp3grad]; OMP2.5 [Bozkaya:2011:omp3]; OLCCD [Bozkaya:2013:ocepa]; LCCD [Bozkaya:2013:ocepa]. Convergence Problems¶; For problematic open-shell systems, we recommend to use the ROHF or DFT orbitals as an initial guess for orbital-optimized methods. Both ROHF and; DFT orbitals may provide better initial guesses than UHF orbitals, hence convergence may be significantly speeded up with ROHF or DFT orbitals.; In order to use ROHF orbitals, simply set reference rohf. For DFT orbitals, set reference uks and set dft_functional b3lyp. Of; course users can use any DFT functional available in PSI4. Methods¶; The orbital-optimized MPn and OLCCD methods currently supported in; PSI4 are outlined in Table Orbital-Optimzed OCC/DFOCC; Methods. The following methods are available; and can be controlled through OCC (conventional integrals CONV); and DFOCC (density-fitted DF and Cholesky-decomposed CD); keywords. Switching between the integrals treatments is controlled; through “type select” values in the rightmost Table column. Orbital-Optimized MP and LCCD capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient; type select. omp2; Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP2_TYPE CONV. Density-Fitted Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP2_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —; MP2_TYPE CD. omp3; Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE CONV. Density-Fitted Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/RO",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:9292,Availability,avail,available,9292,"l-optimized code should cite the following publications:. OMP2 [Bozkaya:2011:omp2] and [Bozkaya:2013:omp2grad]; OMP3 [Bozkaya:2011:omp3] , [Bozkaya:2013:omp3], and [Bozkaya:2013:omp3grad]; OMP2.5 [Bozkaya:2011:omp3]; OLCCD [Bozkaya:2013:ocepa]; LCCD [Bozkaya:2013:ocepa]. Convergence Problems¶; For problematic open-shell systems, we recommend to use the ROHF or DFT orbitals as an initial guess for orbital-optimized methods. Both ROHF and; DFT orbitals may provide better initial guesses than UHF orbitals, hence convergence may be significantly speeded up with ROHF or DFT orbitals.; In order to use ROHF orbitals, simply set reference rohf. For DFT orbitals, set reference uks and set dft_functional b3lyp. Of; course users can use any DFT functional available in PSI4. Methods¶; The orbital-optimized MPn and OLCCD methods currently supported in; PSI4 are outlined in Table Orbital-Optimzed OCC/DFOCC; Methods. The following methods are available; and can be controlled through OCC (conventional integrals CONV); and DFOCC (density-fitted DF and Cholesky-decomposed CD); keywords. Switching between the integrals treatments is controlled; through “type select” values in the rightmost Table column. Orbital-Optimized MP and LCCD capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient; type select. omp2; Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP2_TYPE CONV. Density-Fitted Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP2_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —; MP2_TYPE CD. omp3; Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE CONV. Density-Fitted Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —; MP_TYPE CD. omp2.5; Orbital-Optimized MP2.5; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE CONV. Density-Fitted Orbital-Optimized MP2.5; RHF/UHF/ROHF/RKS/UKS; R",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:13682,Availability,error,error,13682,"ine the orbitals. Type: integer; Default: 50. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5; Default: OMP2. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced OCC Keywords¶. OPT_METHOD¶. The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters with a crude approximation to all elements of the MO Hessian. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: MSD. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. MP2_OS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 6.0. MP2_SS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.0. MP2_SOS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.2. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algorithm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Removed in 1.4. Will raise an error in 1.5. Type: boolean; Default: true. Basic DFOCC Keywords¶. E_CONVERGENCE¶. C",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:13769,Availability,error,error,13769,": string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5; Default: OMP2. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced OCC Keywords¶. OPT_METHOD¶. The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters with a crude approximation to all elements of the MO Hessian. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: MSD. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. MP2_OS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 6.0. MP2_SS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.0. MP2_SOS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.2. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algorithm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Removed in 1.4. Will raise an error in 1.5. Type: boolean; Default: true. Basic DFOCC Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:13857,Availability,error,error,13857,"ze the orbitals?. Type: boolean; Default: true. Advanced OCC Keywords¶. OPT_METHOD¶. The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters with a crude approximation to all elements of the MO Hessian. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: MSD. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. MP2_OS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 6.0. MP2_SS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.0. MP2_SOS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.2. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algorithm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Removed in 1.4. Will raise an error in 1.5. Type: boolean; Default: true. Basic DFOCC Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGEN",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:13946,Availability,error,error,13946,"optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters with a crude approximation to all elements of the MO Hessian. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: MSD. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. MP2_OS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 6.0. MP2_SS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.0. MP2_SOS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.2. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algorithm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Removed in 1.4. Will raise an error in 1.5. Type: boolean; Default: true. Basic DFOCC Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. ",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:14596,Availability,error,error,14596,"g; Possible Values: GS, MGS; Default: MGS. MP2_OS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 6.0. MP2_SS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.0. MP2_SOS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.2. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algorithm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Removed in 1.4. Will raise an error in 1.5. Type: boolean; Default: true. Basic DFOCC Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. If this keyword is not set by the user, DFOCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. If this keyword is not set by the user, DFOCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:15830,Availability,avail,available,15830,"Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. If this keyword is not set by the user, DFOCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. If this keyword is not set by the user, DFOCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced DFOCC Keywords¶. OPT_METHOD¶. The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian * options. Type: string; Possible Values: QNR; Default: QNR. HESS_TYPE¶. Type of the MO Hessian matrix. Type: string; Possible Values: APPROX_DIAG, APPROX_DIAG_EKT, APPROX_DIAG_HF, HF; Default: HF. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. Conventional (Non-OO) Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Non-orbital-optimized counterparts to higher order MPn methods are also; available. The following methods are available and can be controlled; through OCC (conventional integrals CONV) and DFOCC (density-fitted; DF and Cholesky-decomposed CD) keywords. Switching between; the integrals treatments is controlled through ‘type select’ values;; see right",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:16552,Availability,avail,available,16552," the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced DFOCC Keywords¶. OPT_METHOD¶. The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian * options. Type: string; Possible Values: QNR; Default: QNR. HESS_TYPE¶. Type of the MO Hessian matrix. Type: string; Possible Values: APPROX_DIAG, APPROX_DIAG_EKT, APPROX_DIAG_HF, HF; Default: HF. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. Conventional (Non-OO) Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Non-orbital-optimized counterparts to higher order MPn methods are also; available. The following methods are available and can be controlled; through OCC (conventional integrals CONV) and DFOCC (density-fitted; DF and Cholesky-decomposed CD) keywords. Switching between; the integrals treatments is controlled through ‘type select’ values;; see rightmost column in Table Conventional OCC/DFOCC Methods.; Depending on efficiency considerations, the OCC & DFOCC modules may; or may not be the default in PSI4 for available methods. (See; Cross-module Redundancies for gory; details.) To call the OCC/DFOCC implementation of any method below in; preference to the default module, issue set qc_module occ.; Starting in v1.4, MP2.5 and MP3 default to the density-fit algorithm. Set MP_TYPE to CONV to get previous behavior. Conventional (non-OO) CC and MP capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient; type select. mp2; MP2; RHF/UHF/ROHF; RHF/UHF; MP2_TYPE CONV. Density-Fitted",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:16589,Availability,avail,available,16589," ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced DFOCC Keywords¶. OPT_METHOD¶. The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian * options. Type: string; Possible Values: QNR; Default: QNR. HESS_TYPE¶. Type of the MO Hessian matrix. Type: string; Possible Values: APPROX_DIAG, APPROX_DIAG_EKT, APPROX_DIAG_HF, HF; Default: HF. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. Conventional (Non-OO) Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Non-orbital-optimized counterparts to higher order MPn methods are also; available. The following methods are available and can be controlled; through OCC (conventional integrals CONV) and DFOCC (density-fitted; DF and Cholesky-decomposed CD) keywords. Switching between; the integrals treatments is controlled through ‘type select’ values;; see rightmost column in Table Conventional OCC/DFOCC Methods.; Depending on efficiency considerations, the OCC & DFOCC modules may; or may not be the default in PSI4 for available methods. (See; Cross-module Redundancies for gory; details.) To call the OCC/DFOCC implementation of any method below in; preference to the default module, issue set qc_module occ.; Starting in v1.4, MP2.5 and MP3 default to the density-fit algorithm. Set MP_TYPE to CONV to get previous behavior. Conventional (non-OO) CC and MP capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient; type select. mp2; MP2; RHF/UHF/ROHF; RHF/UHF; MP2_TYPE CONV. Density-Fitted MP2; RHF/UHF/ROHF; RHF/UHF; MP2_TYPE DF. Cholesky-Decomposed MP2; RHF/UHF/ROHF; —; MP2_TYPE CD. mp3; MP3; RHF/UHF; RHF/UHF; MP_TYPE CONV. Density-Fitted MP3; RHF/UHF;",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:16991,Availability,avail,available,16991," MO Hessian matrix. Type: string; Possible Values: APPROX_DIAG, APPROX_DIAG_EKT, APPROX_DIAG_HF, HF; Default: HF. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. Conventional (Non-OO) Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Non-orbital-optimized counterparts to higher order MPn methods are also; available. The following methods are available and can be controlled; through OCC (conventional integrals CONV) and DFOCC (density-fitted; DF and Cholesky-decomposed CD) keywords. Switching between; the integrals treatments is controlled through ‘type select’ values;; see rightmost column in Table Conventional OCC/DFOCC Methods.; Depending on efficiency considerations, the OCC & DFOCC modules may; or may not be the default in PSI4 for available methods. (See; Cross-module Redundancies for gory; details.) To call the OCC/DFOCC implementation of any method below in; preference to the default module, issue set qc_module occ.; Starting in v1.4, MP2.5 and MP3 default to the density-fit algorithm. Set MP_TYPE to CONV to get previous behavior. Conventional (non-OO) CC and MP capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient; type select. mp2; MP2; RHF/UHF/ROHF; RHF/UHF; MP2_TYPE CONV. Density-Fitted MP2; RHF/UHF/ROHF; RHF/UHF; MP2_TYPE DF. Cholesky-Decomposed MP2; RHF/UHF/ROHF; —; MP2_TYPE CD. mp3; MP3; RHF/UHF; RHF/UHF; MP_TYPE CONV. Density-Fitted MP3; RHF/UHF; RHF/UHF; MP_TYPE DF. Cholesky-Decomposed MP3; RHF/UHF; —; MP_TYPE CD. mp2.5; MP2.5; RHF/UHF; RHF/UHF; MP_TYPE CONV. Density-Fitted MP2.5; RHF/UHF; RHF/UHF; MP_TYPE DF. Cholesky-Decomposed MP2.5; RHF/UHF; —; MP_TYPE CD. lccd; Linearized CCD; RHF/UHF; RHF/UHF; CC_TYPE CONV. Density-Fitted LCCD; RHF/",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:19576,Deployability,update,updated,19576,"F/UHF; MP_TYPE DF. Cholesky-Decomposed MP3; RHF/UHF; —; MP_TYPE CD. mp2.5; MP2.5; RHF/UHF; RHF/UHF; MP_TYPE CONV. Density-Fitted MP2.5; RHF/UHF; RHF/UHF; MP_TYPE DF. Cholesky-Decomposed MP2.5; RHF/UHF; —; MP_TYPE CD. lccd; Linearized CCD; RHF/UHF; RHF/UHF; CC_TYPE CONV. Density-Fitted LCCD; RHF/UHF; RHF/UHF; CC_TYPE DF. Cholesky-Decomposed LCCD; RHF/UHF; —; CC_TYPE CD. ccd; CCD; —; —; CC_TYPE CONV. Density-Fitted CCD; RHF; RHF; CC_TYPE DF. Cholesky-Decomposed CCD; RHF; —; CC_TYPE CD. ccsd; CCSD; —; —; CC_TYPE CONV. Density-Fitted CCSD; RHF; RHF; CC_TYPE DF. Cholesky-Decomposed CCSD; RHF; —; CC_TYPE CD. ccsd(t); CCSD(T); —; —; CC_TYPE CONV. Density-Fitted CCSD(T); RHF; RHF; CC_TYPE DF. Cholesky-Decomposed CCSD(T); RHF; —; CC_TYPE CD. a-ccsd(t); Lambda-CCSD(T); —; —; CC_TYPE CONV. Density-Fitted Lambda-CCSD(T); RHF; —; CC_TYPE DF. Cholesky-Decomposed Lambda-CCSD(T); RHF; —; CC_TYPE CD. table of contents. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Convergence Problems; Methods; Basic OCC Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; WFN_TYPE; ORB_OPT. Advanced OCC Keywords; OPT_METHOD; LINEQ_SOLVER; ORTH_TYPE; MP2_OS_SCALE; MP2_SS_SCALE; MP2_SOS_SCALE; MP2_SOS_SCALE2; NAT_ORBS; OCC_ORBS_PRINT; TPDM_ABCD_TYPE; DO_DIIS; DO_LEVEL_SHIFT. Basic DFOCC Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; ORB_OPT. Advanced DFOCC Keywords; OPT_METHOD; HESS_TYPE; MO_DIIS_NUM_VECS; ORTH_TYPE; DO_DIIS; DO_LEVEL_SHIFT. Conventional (Non-OO) Coupled-Cluster and Møller–Plesset Perturbation Theories. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:1847,Energy Efficiency,energy,energy,1847,"rbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invariant [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods do not suffer from artifactual symmetry-breaking; instabilities [Crawford:1997:instability], [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Furthermore, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital-optimized MP2 (also MP3); will solve this N-representability problem by disregarding orbital response contribution of one-particle; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple correct",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:2987,Energy Efficiency,energy,energy,2987,"s greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital-optimized MP2 (also MP3); will solve this N-representability problem by disregarding orbital response contribution of one-particle; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections.; A lot of the functionality in OCC has been enabled with Density Fitting (DF) and Cholesky; Decomposition (CD) techniques, which can greatly speed up calculations and reduce memory; requirements for typically negligible losses in accuracy.; NOTE: As will be discussed later, all methods with orbital-optimization functionality have non-orbital; optimized counterparts. Consequently, there arise two possible ways to call density-fitted MP2. In most; cases, users should prefer the DF-MP2 code described in the DF-MP2 section because it is; faster. If gradients are needed (like in a geometry optimization), then the procedures outlined hereafter; should be followed.; In general, choose the desired method, reference, and ERI type (e.g.,; set reference uhf, set mp2_type df, opt('mp2')) and the most; efficient module will be selected automatically, according to; Cross-module Redundanci",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:3206,Energy Efficiency,reduce,reduce,3206,"orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital-optimized MP2 (also MP3); will solve this N-representability problem by disregarding orbital response contribution of one-particle; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections.; A lot of the functionality in OCC has been enabled with Density Fitting (DF) and Cholesky; Decomposition (CD) techniques, which can greatly speed up calculations and reduce memory; requirements for typically negligible losses in accuracy.; NOTE: As will be discussed later, all methods with orbital-optimization functionality have non-orbital; optimized counterparts. Consequently, there arise two possible ways to call density-fitted MP2. In most; cases, users should prefer the DF-MP2 code described in the DF-MP2 section because it is; faster. If gradients are needed (like in a geometry optimization), then the procedures outlined hereafter; should be followed.; In general, choose the desired method, reference, and ERI type (e.g.,; set reference uhf, set mp2_type df, opt('mp2')) and the most; efficient module will be selected automatically, according to; Cross-module Redundancies.; Thus, there arise a few categories of method, each with corresponding input keywords:. Orbital-optimized MP and CC methods with conventional integrals (OMP Methods OCC keywords); Orbital-optimized MP and CC methods with DF and ",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:3840,Energy Efficiency,efficient,efficient,3840,"t orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections.; A lot of the functionality in OCC has been enabled with Density Fitting (DF) and Cholesky; Decomposition (CD) techniques, which can greatly speed up calculations and reduce memory; requirements for typically negligible losses in accuracy.; NOTE: As will be discussed later, all methods with orbital-optimization functionality have non-orbital; optimized counterparts. Consequently, there arise two possible ways to call density-fitted MP2. In most; cases, users should prefer the DF-MP2 code described in the DF-MP2 section because it is; faster. If gradients are needed (like in a geometry optimization), then the procedures outlined hereafter; should be followed.; In general, choose the desired method, reference, and ERI type (e.g.,; set reference uhf, set mp2_type df, opt('mp2')) and the most; efficient module will be selected automatically, according to; Cross-module Redundancies.; Thus, there arise a few categories of method, each with corresponding input keywords:. Orbital-optimized MP and CC methods with conventional integrals (OMP Methods OCC keywords); Orbital-optimized MP and CC methods with DF and CD integrals (OMP Methods DFOCC keywords); Non-orbital-optimized MP and CC methods with conventional integrals (MP/CC Methods OCC keywords); Non-orbital-optimized MP and CC methods with DF and CD integrals (MP/CC Methods DFOCC keywords). Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. \[\begin{split}\widetilde{\hat{p}}^{\dagger} &= e^{\hat{K}} \hat{p}^{\dagger} e^{-\hat{K}}\\; \widetilde{\hat{p}} &= e^{\hat{K}}",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:5589,Energy Efficiency,energy,energy,5589,"1:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. \[\begin{split}\widetilde{\hat{p}}^{\dagger} &= e^{\hat{K}} \hat{p}^{\dagger} e^{-\hat{K}}\\; \widetilde{\hat{p}} &= e^{\hat{K}} \ \hat{p} \ e^{-\hat{K}} \\; | \widetilde{p} \rangle &= e^{\hat{K}} \ | p \rangle\end{split}\]; where \(\hat{K}\) is the orbital rotation operator. \[\begin{split}\hat{K} &= \sum_{p,q}^{} K_{pq} \ \hat{E}_{pq} = \sum_{p>q}^{} \kappa_{pq} \ \hat{E}_{pq}^{-} \\; \hat{E}_{pq} &= \hat{p}^{\dagger} \hat{q} \\; \hat{E}_{pq}^{-} &= \hat{E}_{pq} \ - \ \hat{E}_{qp} \\; {\bf K} &= Skew({\bf \kappa})\end{split}\]; The effect of the orbital rotations on the MO coefficients can be written as. \[{\bf C({\bf \kappa})} = {\bf C^{(0)}} \ e^{{\bf K}}\]; where \({\bf C^{(0)}}\) is the initial MO coefficient matrix and \({\bf C({\bf \kappa})}\) is the new; MO coefficient matrix as a function of \({\bf \kappa}\).; Now, let us define a variational energy functional (Lagrangian) as a function of \({\bf \kappa}\). OMP2. \[\begin{split}\widetilde{E}({\bf \kappa}) &= \langle 0| \hat{H}^{\kappa} | 0 \rangle \\; &+ \langle 0| \big(\hat{W}_{N}^{\kappa}\hat{T}_{2}^{(1)}\big)_{c} | 0 \rangle \\; &+ \langle 0| \{\hat{\Lambda}_{2}^{(1)} \ \big(\hat{f}_{N}^{\kappa} \hat{T}_{2}^{(1)}; \ + \ \hat{W}_{N}^{\kappa} \big)_{c}\}_{c} | 0 \rangle\end{split}\]. OMP3. \[\begin{split}\widetilde{E}({\bf \kappa}) &= \langle 0| \hat{H}^{\kappa} | 0 \rangle \\; &+ \langle 0| \big(\hat{W}_{N}^{\kappa}\hat{T}_{2}^{(1)}\big)_{c} | 0 \rangle; \ + \ \langle 0| \big(\hat{W}_{N}^{\kappa}\hat{T}_{2}^{(2)}\big)_{c} | 0 \rangle \\; &+ \langle 0| \{\hat{\Lambda}_{2}^{(1)} \ \big(\hat{f}_{N}^{\kappa} \hat{T}_{2}^{(1)}; \ + \ \hat{W}_{N}^{\kappa} \big)_{c}\}_{c} | 0 \rangle \\; &+ \langle 0| \{\hat{\Lambda}_{2}^{(1)} \ \big(\hat{f}_{N}^{\kappa} \hat{T}_{2}^{(2)}; \ + \ \hat{W}_{N}^{\kappa}\hat{T}_{2}^{(1)} \big)_{c}\}_{c} | 0 \rangle \\; &+ \langle 0| \{\hat{\Lambda}_{2}^{(2)} \ \big",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:7558,Energy Efficiency,energy,energy,7558,"hat{\Lambda}_{2}^{(2)} \ \big(\hat{f}_{N}^{\kappa} \hat{T}_{2}^{(1)}; \ + \ \hat{W}_{N}^{\kappa} \big)_{c}\}_{c} | 0 \rangle\end{split}\]. OLCCD. \[\begin{split}\widetilde{E}({\bf \kappa}) &= \langle 0| \hat{H}^{\kappa} | 0 \rangle; \ + \ \langle 0| \big(\hat{W}_{N}^{\kappa}\hat{T}_{2}\big)_{c} | 0 \rangle \\; &+ \langle 0| \{\hat{\Lambda}_{2} \ \big(\hat{W}_{N}^{\kappa} \ + \ \hat{H}_{N}^{\kappa}\hat{T}_{2} \big)_{c}\}_{c} | 0 \rangle\end{split}\]; where subscript c means only connected diagrams are allowed, and; \(\hat{H}^{\kappa}\), \(\hat{f}_{N}^{\kappa}\), and \(\hat{W}_{N}^{\kappa}\) defined as. \[\begin{split}\hat{H}^{\kappa} &= e^{-\hat{K}} \hat{H} e^{\hat{K}} \\; \hat{f}_{N}^{\kappa} &= e^{-\hat{K}} \hat{f}_{N}^{d} e^{\hat{K}} \\; \hat{W}_{N}^{\kappa} &= e^{-\hat{K}} \hat{W}_{N} e^{\hat{K}}\end{split}\]; where \(\hat{f}_{N}\), and \(\hat{W}_{N}\) are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to the \({\bf \kappa}\) parameter at \({\bf \kappa} = 0\). \[w_{pq} = \frac{\partial \widetilde{E}}{\partial \kappa_{pq}}\]. \[A_{pq,rs} = \frac{\partial^2 \widetilde{E}}{\partial \kappa_{pq} \partial \kappa_{rs}}\]; Then the energy can be expanded up to second-order as follows. \[\widetilde{E}^{(2)}({\bf \kappa}) = \widetilde{E}^{(0)} + {\bf \kappa^{\dagger} w} + \frac{1}{2}~{\bf \kappa^{\dagger} A \kappa}\]; where \({\bf w}\) is the MO gradient vector, \({\bf \kappa}\) is the MO rotation vector,; and \({\bf A}\) is the MO Hessian matrix. Therefore, minimizing the energy with respect to \({\bf \kappa}\); yields. \[{\bf \kappa} = -{\bf A^{-1}w}\]; This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the orbital-optimized code should cite the following publications:. OMP2 [Bozkaya:2011:omp2] and [Bozkaya:2013:omp2grad]; OMP3 [Bozkaya:2011:omp3] , [Bozkaya:2013:omp3], and [Bozkaya:2013:omp3grad]; OMP2.5 [Bozkaya:2011:omp3]; OLCCD [B",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:7804,Energy Efficiency,energy,energy,7804,"hat{H}^{\kappa} | 0 \rangle; \ + \ \langle 0| \big(\hat{W}_{N}^{\kappa}\hat{T}_{2}\big)_{c} | 0 \rangle \\; &+ \langle 0| \{\hat{\Lambda}_{2} \ \big(\hat{W}_{N}^{\kappa} \ + \ \hat{H}_{N}^{\kappa}\hat{T}_{2} \big)_{c}\}_{c} | 0 \rangle\end{split}\]; where subscript c means only connected diagrams are allowed, and; \(\hat{H}^{\kappa}\), \(\hat{f}_{N}^{\kappa}\), and \(\hat{W}_{N}^{\kappa}\) defined as. \[\begin{split}\hat{H}^{\kappa} &= e^{-\hat{K}} \hat{H} e^{\hat{K}} \\; \hat{f}_{N}^{\kappa} &= e^{-\hat{K}} \hat{f}_{N}^{d} e^{\hat{K}} \\; \hat{W}_{N}^{\kappa} &= e^{-\hat{K}} \hat{W}_{N} e^{\hat{K}}\end{split}\]; where \(\hat{f}_{N}\), and \(\hat{W}_{N}\) are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to the \({\bf \kappa}\) parameter at \({\bf \kappa} = 0\). \[w_{pq} = \frac{\partial \widetilde{E}}{\partial \kappa_{pq}}\]. \[A_{pq,rs} = \frac{\partial^2 \widetilde{E}}{\partial \kappa_{pq} \partial \kappa_{rs}}\]; Then the energy can be expanded up to second-order as follows. \[\widetilde{E}^{(2)}({\bf \kappa}) = \widetilde{E}^{(0)} + {\bf \kappa^{\dagger} w} + \frac{1}{2}~{\bf \kappa^{\dagger} A \kappa}\]; where \({\bf w}\) is the MO gradient vector, \({\bf \kappa}\) is the MO rotation vector,; and \({\bf A}\) is the MO Hessian matrix. Therefore, minimizing the energy with respect to \({\bf \kappa}\); yields. \[{\bf \kappa} = -{\bf A^{-1}w}\]; This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the orbital-optimized code should cite the following publications:. OMP2 [Bozkaya:2011:omp2] and [Bozkaya:2013:omp2grad]; OMP3 [Bozkaya:2011:omp3] , [Bozkaya:2013:omp3], and [Bozkaya:2013:omp3grad]; OMP2.5 [Bozkaya:2011:omp3]; OLCCD [Bozkaya:2013:ocepa]; LCCD [Bozkaya:2013:ocepa]. Convergence Problems¶; For problematic open-shell systems, we recommend to use the ROHF or DFT orbitals as an initial guess for orbital-optimized methods. Bot",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:8150,Energy Efficiency,energy,energy,8150,"^{\kappa}\) defined as. \[\begin{split}\hat{H}^{\kappa} &= e^{-\hat{K}} \hat{H} e^{\hat{K}} \\; \hat{f}_{N}^{\kappa} &= e^{-\hat{K}} \hat{f}_{N}^{d} e^{\hat{K}} \\; \hat{W}_{N}^{\kappa} &= e^{-\hat{K}} \hat{W}_{N} e^{\hat{K}}\end{split}\]; where \(\hat{f}_{N}\), and \(\hat{W}_{N}\) are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to the \({\bf \kappa}\) parameter at \({\bf \kappa} = 0\). \[w_{pq} = \frac{\partial \widetilde{E}}{\partial \kappa_{pq}}\]. \[A_{pq,rs} = \frac{\partial^2 \widetilde{E}}{\partial \kappa_{pq} \partial \kappa_{rs}}\]; Then the energy can be expanded up to second-order as follows. \[\widetilde{E}^{(2)}({\bf \kappa}) = \widetilde{E}^{(0)} + {\bf \kappa^{\dagger} w} + \frac{1}{2}~{\bf \kappa^{\dagger} A \kappa}\]; where \({\bf w}\) is the MO gradient vector, \({\bf \kappa}\) is the MO rotation vector,; and \({\bf A}\) is the MO Hessian matrix. Therefore, minimizing the energy with respect to \({\bf \kappa}\); yields. \[{\bf \kappa} = -{\bf A^{-1}w}\]; This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the orbital-optimized code should cite the following publications:. OMP2 [Bozkaya:2011:omp2] and [Bozkaya:2013:omp2grad]; OMP3 [Bozkaya:2011:omp3] , [Bozkaya:2013:omp3], and [Bozkaya:2013:omp3grad]; OMP2.5 [Bozkaya:2011:omp3]; OLCCD [Bozkaya:2013:ocepa]; LCCD [Bozkaya:2013:ocepa]. Convergence Problems¶; For problematic open-shell systems, we recommend to use the ROHF or DFT orbitals as an initial guess for orbital-optimized methods. Both ROHF and; DFT orbitals may provide better initial guesses than UHF orbitals, hence convergence may be significantly speeded up with ROHF or DFT orbitals.; In order to use ROHF orbitals, simply set reference rohf. For DFT orbitals, set reference uks and set dft_functional b3lyp. Of; course users can use any DFT functional available in PSI4. Methods¶; The orbital-optimized MPn a",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:11788,Energy Efficiency,energy,energy,11788," capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —. scs(n)-omp3; A special version of SCS-OMP3 for nucleobase interactions; RHF/UHF/ROHF/RKS/UKS; —. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); RHF/UHF/ROHF/RKS/UKS; —. sos-pi-omp3; A special version of SOS-OMP3 for \(\pi\)-systems; RHF/UHF/ROHF/RKS/UKS; —. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —. scs(n)-omp2; A special version of SCS-OMP2 for nucleobase interactions; RHF/UHF/ROHF/RKS/UKS; —. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); RHF/UHF/ROHF/RKS/UKS; —. sos-pi-omp2; A special version of SOS-OMP2 for \(\pi\)-systems; RHF/UHF/ROHF/RKS/UKS; —. Basic OCC Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. If this keyword is not set by the user, OCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. If this keyword is not set by the user, OCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. WFN_TYPE¶. Type of the wavefunction. Type: string; P",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:14705,Energy Efficiency,energy,energy,14705," Type: double; Default: 6.0. MP2_SS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.0. MP2_SOS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.2. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algorithm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Removed in 1.4. Will raise an error in 1.5. Type: boolean; Default: true. Basic DFOCC Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. If this keyword is not set by the user, DFOCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. If this keyword is not set by the user, DFOCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. ORB_OPT¶. Do optimize the orbitals?. Type: boole",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:506,Performance,optimiz,optimized,506,"﻿. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Code author: Ugur Bozkaya; Section author: Ugur Bozkaya; Module: Keywords, PSI Variables, OCC; Module: Keywords, PSI Variables, DFOCC. Introduction¶; Orbital-optimized methods have several advantages over their non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann–Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invariant [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods do not suffer from artifactual symmetry-breaking; instabilities [Crawford:1997:instability], [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Furthermore, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability c",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:563,Performance,optimiz,optimized,563,"﻿. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Code author: Ugur Bozkaya; Section author: Ugur Bozkaya; Module: Keywords, PSI Variables, OCC; Module: Keywords, PSI Variables, DFOCC. Introduction¶; Orbital-optimized methods have several advantages over their non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann–Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invariant [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods do not suffer from artifactual symmetry-breaking; instabilities [Crawford:1997:instability], [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Furthermore, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability c",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:610,Performance,optimiz,optimized,610,"﻿. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Code author: Ugur Bozkaya; Section author: Ugur Bozkaya; Module: Keywords, PSI Variables, OCC; Module: Keywords, PSI Variables, DFOCC. Introduction¶; Orbital-optimized methods have several advantages over their non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann–Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invariant [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods do not suffer from artifactual symmetry-breaking; instabilities [Crawford:1997:instability], [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Furthermore, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability c",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:1215,Performance,optimiz,optimized,1215,"ized Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Code author: Ugur Bozkaya; Section author: Ugur Bozkaya; Module: Keywords, PSI Variables, OCC; Module: Keywords, PSI Variables, DFOCC. Introduction¶; Orbital-optimized methods have several advantages over their non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann–Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invariant [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods do not suffer from artifactual symmetry-breaking; instabilities [Crawford:1997:instability], [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Furthermore, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particl",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:1416,Performance,optimiz,optimized,1416,"ntroduction¶; Orbital-optimized methods have several advantages over their non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann–Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invariant [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods do not suffer from artifactual symmetry-breaking; instabilities [Crawford:1997:instability], [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Furthermore, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital-optimized MP2 (also MP3); will solve this N-represent",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:2431,Performance,optimiz,optimized,2431,"es [Crawford:1997:instability], [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Furthermore, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital-optimized MP2 (also MP3); will solve this N-representability problem by disregarding orbital response contribution of one-particle; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections.; A lot of the functionality in OCC has been enabled with Density Fitting (DF) and Cholesky; Decomposition (CD) techniques, which can greatly speed up calculations and reduce memory; requirements for typically negligible losses in accuracy.; NOTE: As will be discussed later, all methods with orbital-optimization functionality have non-orbital; optimized counterparts. Consequently, there arise two possible ways to call density-fitted MP2. In most; cases, ",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:2593,Performance,perform,performance,2593,"h as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital-optimized MP2 (also MP3); will solve this N-representability problem by disregarding orbital response contribution of one-particle; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections.; A lot of the functionality in OCC has been enabled with Density Fitting (DF) and Cholesky; Decomposition (CD) techniques, which can greatly speed up calculations and reduce memory; requirements for typically negligible losses in accuracy.; NOTE: As will be discussed later, all methods with orbital-optimization functionality have non-orbital; optimized counterparts. Consequently, there arise two possible ways to call density-fitted MP2. In most; cases, users should prefer the DF-MP2 code described in the DF-MP2 section because it is; faster. If gradients are needed (like in a geometry optimization), then the procedures outlined hereafter; should be ",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:2663,Performance,optimiz,optimized,2663,"h as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital-optimized MP2 (also MP3); will solve this N-representability problem by disregarding orbital response contribution of one-particle; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections.; A lot of the functionality in OCC has been enabled with Density Fitting (DF) and Cholesky; Decomposition (CD) techniques, which can greatly speed up calculations and reduce memory; requirements for typically negligible losses in accuracy.; NOTE: As will be discussed later, all methods with orbital-optimization functionality have non-orbital; optimized counterparts. Consequently, there arise two possible ways to call density-fitted MP2. In most; cases, users should prefer the DF-MP2 code described in the DF-MP2 section because it is; faster. If gradients are needed (like in a geometry optimization), then the procedures outlined hereafter; should be ",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:2862,Performance,optimiz,optimized,2862,"s greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital-optimized MP2 (also MP3); will solve this N-representability problem by disregarding orbital response contribution of one-particle; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections.; A lot of the functionality in OCC has been enabled with Density Fitting (DF) and Cholesky; Decomposition (CD) techniques, which can greatly speed up calculations and reduce memory; requirements for typically negligible losses in accuracy.; NOTE: As will be discussed later, all methods with orbital-optimization functionality have non-orbital; optimized counterparts. Consequently, there arise two possible ways to call density-fitted MP2. In most; cases, users should prefer the DF-MP2 code described in the DF-MP2 section because it is; faster. If gradients are needed (like in a geometry optimization), then the procedures outlined hereafter; should be followed.; In general, choose the desired method, reference, and ERI type (e.g.,; set reference uhf, set mp2_type df, opt('mp2')) and the most; efficient module will be selected automatically, according to; Cross-module Redundanci",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:3339,Performance,optimiz,optimization,3339,"ad to unphysical; molecular properties such as vibrational frequencies. However, orbital-optimized MP2 (also MP3); will solve this N-representability problem by disregarding orbital response contribution of one-particle; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections.; A lot of the functionality in OCC has been enabled with Density Fitting (DF) and Cholesky; Decomposition (CD) techniques, which can greatly speed up calculations and reduce memory; requirements for typically negligible losses in accuracy.; NOTE: As will be discussed later, all methods with orbital-optimization functionality have non-orbital; optimized counterparts. Consequently, there arise two possible ways to call density-fitted MP2. In most; cases, users should prefer the DF-MP2 code described in the DF-MP2 section because it is; faster. If gradients are needed (like in a geometry optimization), then the procedures outlined hereafter; should be followed.; In general, choose the desired method, reference, and ERI type (e.g.,; set reference uhf, set mp2_type df, opt('mp2')) and the most; efficient module will be selected automatically, according to; Cross-module Redundancies.; Thus, there arise a few categories of method, each with corresponding input keywords:. Orbital-optimized MP and CC methods with conventional integrals (OMP Methods OCC keywords); Orbital-optimized MP and CC methods with DF and CD integrals (OMP Methods DFOCC keywords); Non-orbital-optimized MP and CC methods with conventional integrals (MP/CC Methods OCC keywords); Non-orbital-optimized MP and CC methods with",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:3384,Performance,optimiz,optimized,3384,"ad to unphysical; molecular properties such as vibrational frequencies. However, orbital-optimized MP2 (also MP3); will solve this N-representability problem by disregarding orbital response contribution of one-particle; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections.; A lot of the functionality in OCC has been enabled with Density Fitting (DF) and Cholesky; Decomposition (CD) techniques, which can greatly speed up calculations and reduce memory; requirements for typically negligible losses in accuracy.; NOTE: As will be discussed later, all methods with orbital-optimization functionality have non-orbital; optimized counterparts. Consequently, there arise two possible ways to call density-fitted MP2. In most; cases, users should prefer the DF-MP2 code described in the DF-MP2 section because it is; faster. If gradients are needed (like in a geometry optimization), then the procedures outlined hereafter; should be followed.; In general, choose the desired method, reference, and ERI type (e.g.,; set reference uhf, set mp2_type df, opt('mp2')) and the most; efficient module will be selected automatically, according to; Cross-module Redundancies.; Thus, there arise a few categories of method, each with corresponding input keywords:. Orbital-optimized MP and CC methods with conventional integrals (OMP Methods OCC keywords); Orbital-optimized MP and CC methods with DF and CD integrals (OMP Methods DFOCC keywords); Non-orbital-optimized MP and CC methods with conventional integrals (MP/CC Methods OCC keywords); Non-orbital-optimized MP and CC methods with",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:3631,Performance,optimiz,optimization,3631,"CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections.; A lot of the functionality in OCC has been enabled with Density Fitting (DF) and Cholesky; Decomposition (CD) techniques, which can greatly speed up calculations and reduce memory; requirements for typically negligible losses in accuracy.; NOTE: As will be discussed later, all methods with orbital-optimization functionality have non-orbital; optimized counterparts. Consequently, there arise two possible ways to call density-fitted MP2. In most; cases, users should prefer the DF-MP2 code described in the DF-MP2 section because it is; faster. If gradients are needed (like in a geometry optimization), then the procedures outlined hereafter; should be followed.; In general, choose the desired method, reference, and ERI type (e.g.,; set reference uhf, set mp2_type df, opt('mp2')) and the most; efficient module will be selected automatically, according to; Cross-module Redundancies.; Thus, there arise a few categories of method, each with corresponding input keywords:. Orbital-optimized MP and CC methods with conventional integrals (OMP Methods OCC keywords); Orbital-optimized MP and CC methods with DF and CD integrals (OMP Methods DFOCC keywords); Non-orbital-optimized MP and CC methods with conventional integrals (MP/CC Methods OCC keywords); Non-orbital-optimized MP and CC methods with DF and CD integrals (MP/CC Methods DFOCC keywords). Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orb",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:4026,Performance,optimiz,optimized,4026,"reduce memory; requirements for typically negligible losses in accuracy.; NOTE: As will be discussed later, all methods with orbital-optimization functionality have non-orbital; optimized counterparts. Consequently, there arise two possible ways to call density-fitted MP2. In most; cases, users should prefer the DF-MP2 code described in the DF-MP2 section because it is; faster. If gradients are needed (like in a geometry optimization), then the procedures outlined hereafter; should be followed.; In general, choose the desired method, reference, and ERI type (e.g.,; set reference uhf, set mp2_type df, opt('mp2')) and the most; efficient module will be selected automatically, according to; Cross-module Redundancies.; Thus, there arise a few categories of method, each with corresponding input keywords:. Orbital-optimized MP and CC methods with conventional integrals (OMP Methods OCC keywords); Orbital-optimized MP and CC methods with DF and CD integrals (OMP Methods DFOCC keywords); Non-orbital-optimized MP and CC methods with conventional integrals (MP/CC Methods OCC keywords); Non-orbital-optimized MP and CC methods with DF and CD integrals (MP/CC Methods DFOCC keywords). Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. \[\begin{split}\widetilde{\hat{p}}^{\dagger} &= e^{\hat{K}} \hat{p}^{\dagger} e^{-\hat{K}}\\; \widetilde{\hat{p}} &= e^{\hat{K}} \ \hat{p} \ e^{-\hat{K}} \\; | \widetilde{p} \rangle &= e^{\hat{K}} \ | p \rangle\end{split}\]; where \(\hat{K}\) is the orbital rotation operator. \[\begin{split}\hat{K} &= \sum_{p,q}^{} K_{pq} \ \hat{E}_{pq} = \sum_{p>q}^{} \kappa_{pq} \ \hat{E}_{pq}^{-} \\; \hat{E}_{pq} &= \hat{p}^{\dagger} \hat{q} \\; \hat{E}_{pq}^{-} &= \hat{E}_{pq} \ - \ \hat{E}",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:4118,Performance,optimiz,optimized,4118,"reduce memory; requirements for typically negligible losses in accuracy.; NOTE: As will be discussed later, all methods with orbital-optimization functionality have non-orbital; optimized counterparts. Consequently, there arise two possible ways to call density-fitted MP2. In most; cases, users should prefer the DF-MP2 code described in the DF-MP2 section because it is; faster. If gradients are needed (like in a geometry optimization), then the procedures outlined hereafter; should be followed.; In general, choose the desired method, reference, and ERI type (e.g.,; set reference uhf, set mp2_type df, opt('mp2')) and the most; efficient module will be selected automatically, according to; Cross-module Redundancies.; Thus, there arise a few categories of method, each with corresponding input keywords:. Orbital-optimized MP and CC methods with conventional integrals (OMP Methods OCC keywords); Orbital-optimized MP and CC methods with DF and CD integrals (OMP Methods DFOCC keywords); Non-orbital-optimized MP and CC methods with conventional integrals (MP/CC Methods OCC keywords); Non-orbital-optimized MP and CC methods with DF and CD integrals (MP/CC Methods DFOCC keywords). Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. \[\begin{split}\widetilde{\hat{p}}^{\dagger} &= e^{\hat{K}} \hat{p}^{\dagger} e^{-\hat{K}}\\; \widetilde{\hat{p}} &= e^{\hat{K}} \ \hat{p} \ e^{-\hat{K}} \\; | \widetilde{p} \rangle &= e^{\hat{K}} \ | p \rangle\end{split}\]; where \(\hat{K}\) is the orbital rotation operator. \[\begin{split}\hat{K} &= \sum_{p,q}^{} K_{pq} \ \hat{E}_{pq} = \sum_{p>q}^{} \kappa_{pq} \ \hat{E}_{pq}^{-} \\; \hat{E}_{pq} &= \hat{p}^{\dagger} \hat{q} \\; \hat{E}_{pq}^{-} &= \hat{E}_{pq} \ - \ \hat{E}",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:4213,Performance,optimiz,optimized,4213,"reduce memory; requirements for typically negligible losses in accuracy.; NOTE: As will be discussed later, all methods with orbital-optimization functionality have non-orbital; optimized counterparts. Consequently, there arise two possible ways to call density-fitted MP2. In most; cases, users should prefer the DF-MP2 code described in the DF-MP2 section because it is; faster. If gradients are needed (like in a geometry optimization), then the procedures outlined hereafter; should be followed.; In general, choose the desired method, reference, and ERI type (e.g.,; set reference uhf, set mp2_type df, opt('mp2')) and the most; efficient module will be selected automatically, according to; Cross-module Redundancies.; Thus, there arise a few categories of method, each with corresponding input keywords:. Orbital-optimized MP and CC methods with conventional integrals (OMP Methods OCC keywords); Orbital-optimized MP and CC methods with DF and CD integrals (OMP Methods DFOCC keywords); Non-orbital-optimized MP and CC methods with conventional integrals (MP/CC Methods OCC keywords); Non-orbital-optimized MP and CC methods with DF and CD integrals (MP/CC Methods DFOCC keywords). Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. \[\begin{split}\widetilde{\hat{p}}^{\dagger} &= e^{\hat{K}} \hat{p}^{\dagger} e^{-\hat{K}}\\; \widetilde{\hat{p}} &= e^{\hat{K}} \ \hat{p} \ e^{-\hat{K}} \\; | \widetilde{p} \rangle &= e^{\hat{K}} \ | p \rangle\end{split}\]; where \(\hat{K}\) is the orbital rotation operator. \[\begin{split}\hat{K} &= \sum_{p,q}^{} K_{pq} \ \hat{E}_{pq} = \sum_{p>q}^{} \kappa_{pq} \ \hat{E}_{pq}^{-} \\; \hat{E}_{pq} &= \hat{p}^{\dagger} \hat{q} \\; \hat{E}_{pq}^{-} &= \hat{E}_{pq} \ - \ \hat{E}",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:4311,Performance,optimiz,optimized,4311,"reduce memory; requirements for typically negligible losses in accuracy.; NOTE: As will be discussed later, all methods with orbital-optimization functionality have non-orbital; optimized counterparts. Consequently, there arise two possible ways to call density-fitted MP2. In most; cases, users should prefer the DF-MP2 code described in the DF-MP2 section because it is; faster. If gradients are needed (like in a geometry optimization), then the procedures outlined hereafter; should be followed.; In general, choose the desired method, reference, and ERI type (e.g.,; set reference uhf, set mp2_type df, opt('mp2')) and the most; efficient module will be selected automatically, according to; Cross-module Redundancies.; Thus, there arise a few categories of method, each with corresponding input keywords:. Orbital-optimized MP and CC methods with conventional integrals (OMP Methods OCC keywords); Orbital-optimized MP and CC methods with DF and CD integrals (OMP Methods DFOCC keywords); Non-orbital-optimized MP and CC methods with conventional integrals (MP/CC Methods OCC keywords); Non-orbital-optimized MP and CC methods with DF and CD integrals (MP/CC Methods DFOCC keywords). Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. \[\begin{split}\widetilde{\hat{p}}^{\dagger} &= e^{\hat{K}} \hat{p}^{\dagger} e^{-\hat{K}}\\; \widetilde{\hat{p}} &= e^{\hat{K}} \ \hat{p} \ e^{-\hat{K}} \\; | \widetilde{p} \rangle &= e^{\hat{K}} \ | p \rangle\end{split}\]; where \(\hat{K}\) is the orbital rotation operator. \[\begin{split}\hat{K} &= \sum_{p,q}^{} K_{pq} \ \hat{E}_{pq} = \sum_{p>q}^{} \kappa_{pq} \ \hat{E}_{pq}^{-} \\; \hat{E}_{pq} &= \hat{p}^{\dagger} \hat{q} \\; \hat{E}_{pq}^{-} &= \hat{E}_{pq} \ - \ \hat{E}",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:4457,Performance,optimiz,optimized,4457,"density-fitted MP2. In most; cases, users should prefer the DF-MP2 code described in the DF-MP2 section because it is; faster. If gradients are needed (like in a geometry optimization), then the procedures outlined hereafter; should be followed.; In general, choose the desired method, reference, and ERI type (e.g.,; set reference uhf, set mp2_type df, opt('mp2')) and the most; efficient module will be selected automatically, according to; Cross-module Redundancies.; Thus, there arise a few categories of method, each with corresponding input keywords:. Orbital-optimized MP and CC methods with conventional integrals (OMP Methods OCC keywords); Orbital-optimized MP and CC methods with DF and CD integrals (OMP Methods DFOCC keywords); Non-orbital-optimized MP and CC methods with conventional integrals (MP/CC Methods OCC keywords); Non-orbital-optimized MP and CC methods with DF and CD integrals (MP/CC Methods DFOCC keywords). Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. \[\begin{split}\widetilde{\hat{p}}^{\dagger} &= e^{\hat{K}} \hat{p}^{\dagger} e^{-\hat{K}}\\; \widetilde{\hat{p}} &= e^{\hat{K}} \ \hat{p} \ e^{-\hat{K}} \\; | \widetilde{p} \rangle &= e^{\hat{K}} \ | p \rangle\end{split}\]; where \(\hat{K}\) is the orbital rotation operator. \[\begin{split}\hat{K} &= \sum_{p,q}^{} K_{pq} \ \hat{E}_{pq} = \sum_{p>q}^{} \kappa_{pq} \ \hat{E}_{pq}^{-} \\; \hat{E}_{pq} &= \hat{p}^{\dagger} \hat{q} \\; \hat{E}_{pq}^{-} &= \hat{E}_{pq} \ - \ \hat{E}_{qp} \\; {\bf K} &= Skew({\bf \kappa})\end{split}\]; The effect of the orbital rotations on the MO coefficients can be written as. \[{\bf C({\bf \kappa})} = {\bf C^{(0)}} \ e^{{\bf K}}\]; where \({\bf C^{(0)}}\) is the initial MO coefficient matrix and \",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:8352,Performance,optimiz,optimized,8352,"\hat{K}} \hat{W}_{N} e^{\hat{K}}\end{split}\]; where \(\hat{f}_{N}\), and \(\hat{W}_{N}\) are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to the \({\bf \kappa}\) parameter at \({\bf \kappa} = 0\). \[w_{pq} = \frac{\partial \widetilde{E}}{\partial \kappa_{pq}}\]. \[A_{pq,rs} = \frac{\partial^2 \widetilde{E}}{\partial \kappa_{pq} \partial \kappa_{rs}}\]; Then the energy can be expanded up to second-order as follows. \[\widetilde{E}^{(2)}({\bf \kappa}) = \widetilde{E}^{(0)} + {\bf \kappa^{\dagger} w} + \frac{1}{2}~{\bf \kappa^{\dagger} A \kappa}\]; where \({\bf w}\) is the MO gradient vector, \({\bf \kappa}\) is the MO rotation vector,; and \({\bf A}\) is the MO Hessian matrix. Therefore, minimizing the energy with respect to \({\bf \kappa}\); yields. \[{\bf \kappa} = -{\bf A^{-1}w}\]; This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the orbital-optimized code should cite the following publications:. OMP2 [Bozkaya:2011:omp2] and [Bozkaya:2013:omp2grad]; OMP3 [Bozkaya:2011:omp3] , [Bozkaya:2013:omp3], and [Bozkaya:2013:omp3grad]; OMP2.5 [Bozkaya:2011:omp3]; OLCCD [Bozkaya:2013:ocepa]; LCCD [Bozkaya:2013:ocepa]. Convergence Problems¶; For problematic open-shell systems, we recommend to use the ROHF or DFT orbitals as an initial guess for orbital-optimized methods. Both ROHF and; DFT orbitals may provide better initial guesses than UHF orbitals, hence convergence may be significantly speeded up with ROHF or DFT orbitals.; In order to use ROHF orbitals, simply set reference rohf. For DFT orbitals, set reference uks and set dft_functional b3lyp. Of; course users can use any DFT functional available in PSI4. Methods¶; The orbital-optimized MPn and OLCCD methods currently supported in; PSI4 are outlined in Table Orbital-Optimzed OCC/DFOCC; Methods. The following methods are available; and can be controlled through OCC (conventional in",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:8758,Performance,optimiz,optimized,8758,"}\]. \[A_{pq,rs} = \frac{\partial^2 \widetilde{E}}{\partial \kappa_{pq} \partial \kappa_{rs}}\]; Then the energy can be expanded up to second-order as follows. \[\widetilde{E}^{(2)}({\bf \kappa}) = \widetilde{E}^{(0)} + {\bf \kappa^{\dagger} w} + \frac{1}{2}~{\bf \kappa^{\dagger} A \kappa}\]; where \({\bf w}\) is the MO gradient vector, \({\bf \kappa}\) is the MO rotation vector,; and \({\bf A}\) is the MO Hessian matrix. Therefore, minimizing the energy with respect to \({\bf \kappa}\); yields. \[{\bf \kappa} = -{\bf A^{-1}w}\]; This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the orbital-optimized code should cite the following publications:. OMP2 [Bozkaya:2011:omp2] and [Bozkaya:2013:omp2grad]; OMP3 [Bozkaya:2011:omp3] , [Bozkaya:2013:omp3], and [Bozkaya:2013:omp3grad]; OMP2.5 [Bozkaya:2011:omp3]; OLCCD [Bozkaya:2013:ocepa]; LCCD [Bozkaya:2013:ocepa]. Convergence Problems¶; For problematic open-shell systems, we recommend to use the ROHF or DFT orbitals as an initial guess for orbital-optimized methods. Both ROHF and; DFT orbitals may provide better initial guesses than UHF orbitals, hence convergence may be significantly speeded up with ROHF or DFT orbitals.; In order to use ROHF orbitals, simply set reference rohf. For DFT orbitals, set reference uks and set dft_functional b3lyp. Of; course users can use any DFT functional available in PSI4. Methods¶; The orbital-optimized MPn and OLCCD methods currently supported in; PSI4 are outlined in Table Orbital-Optimzed OCC/DFOCC; Methods. The following methods are available; and can be controlled through OCC (conventional integrals CONV); and DFOCC (density-fitted DF and Cholesky-decomposed CD); keywords. Switching between the integrals treatments is controlled; through “type select” values in the rightmost Table column. Orbital-Optimized MP and LCCD capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient; type select. omp2; Orbital-Optimized MP2;",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:9146,Performance,optimiz,optimized,9146,"lds. \[{\bf \kappa} = -{\bf A^{-1}w}\]; This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the orbital-optimized code should cite the following publications:. OMP2 [Bozkaya:2011:omp2] and [Bozkaya:2013:omp2grad]; OMP3 [Bozkaya:2011:omp3] , [Bozkaya:2013:omp3], and [Bozkaya:2013:omp3grad]; OMP2.5 [Bozkaya:2011:omp3]; OLCCD [Bozkaya:2013:ocepa]; LCCD [Bozkaya:2013:ocepa]. Convergence Problems¶; For problematic open-shell systems, we recommend to use the ROHF or DFT orbitals as an initial guess for orbital-optimized methods. Both ROHF and; DFT orbitals may provide better initial guesses than UHF orbitals, hence convergence may be significantly speeded up with ROHF or DFT orbitals.; In order to use ROHF orbitals, simply set reference rohf. For DFT orbitals, set reference uks and set dft_functional b3lyp. Of; course users can use any DFT functional available in PSI4. Methods¶; The orbital-optimized MPn and OLCCD methods currently supported in; PSI4 are outlined in Table Orbital-Optimzed OCC/DFOCC; Methods. The following methods are available; and can be controlled through OCC (conventional integrals CONV); and DFOCC (density-fitted DF and Cholesky-decomposed CD); keywords. Switching between the integrals treatments is controlled; through “type select” values in the rightmost Table column. Orbital-Optimized MP and LCCD capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient; type select. omp2; Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP2_TYPE CONV. Density-Fitted Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP2_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —; MP2_TYPE CD. omp3; Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE CONV. Density-Fitted Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —; MP_TYPE CD",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:12849,Performance,optimiz,optimize,12849,"a for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. If this keyword is not set by the user, OCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. If this keyword is not set by the user, OCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5; Default: OMP2. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced OCC Keywords¶. OPT_METHOD¶. The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters with a crude approximation to all elements of the MO Hessian. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: MSD. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. MP2_OS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 6.0. MP2_SS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.0. MP2_SOS_SCALE¶. Removed in 1.4. Will raise an er",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:12944,Performance,optimiz,optimization,12944,"e criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. If this keyword is not set by the user, OCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. If this keyword is not set by the user, OCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5; Default: OMP2. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced OCC Keywords¶. OPT_METHOD¶. The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters with a crude approximation to all elements of the MO Hessian. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: MSD. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. MP2_OS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 6.0. MP2_SS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.0. MP2_SOS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Removed in 1.4. Will raise an error i",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:13282,Performance,perform,performed,13282,"e of E_CONVERGENCE. Type: conv double; Default: 1e-4. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. If this keyword is not set by the user, OCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5; Default: OMP2. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced OCC Keywords¶. OPT_METHOD¶. The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters with a crude approximation to all elements of the MO Hessian. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: MSD. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. MP2_OS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 6.0. MP2_SS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.0. MP2_SOS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.2. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algorithm. The ",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:15660,Performance,optimiz,optimize,15660,"ERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. If this keyword is not set by the user, DFOCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. If this keyword is not set by the user, DFOCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced DFOCC Keywords¶. OPT_METHOD¶. The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian * options. Type: string; Possible Values: QNR; Default: QNR. HESS_TYPE¶. Type of the MO Hessian matrix. Type: string; Possible Values: APPROX_DIAG, APPROX_DIAG_EKT, APPROX_DIAG_HF, HF; Default: HF. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. Conventional (Non-OO) Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Non-orbital-optimized counterparts to higher order MPn methods are also; available. The following methods are available and can be controlled; through OCC (conventional integrals CONV) and DF",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:15765,Performance,optimiz,optimization,15765,"iteria for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. If this keyword is not set by the user, DFOCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. If this keyword is not set by the user, DFOCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced DFOCC Keywords¶. OPT_METHOD¶. The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian * options. Type: string; Possible Values: QNR; Default: QNR. HESS_TYPE¶. Type of the MO Hessian matrix. Type: string; Possible Values: APPROX_DIAG, APPROX_DIAG_EKT, APPROX_DIAG_HF, HF; Default: HF. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. Conventional (Non-OO) Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Non-orbital-optimized counterparts to higher order MPn methods are also; available. The following methods are available and can be controlled; through OCC (conventional integrals CONV) and DFOCC (density-fitted; DF and Cholesky-decomposed CD) keywords. Switching between; the integrals treat",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:16491,Performance,optimiz,optimized,16491," the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced DFOCC Keywords¶. OPT_METHOD¶. The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian * options. Type: string; Possible Values: QNR; Default: QNR. HESS_TYPE¶. Type of the MO Hessian matrix. Type: string; Possible Values: APPROX_DIAG, APPROX_DIAG_EKT, APPROX_DIAG_HF, HF; Default: HF. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. Conventional (Non-OO) Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Non-orbital-optimized counterparts to higher order MPn methods are also; available. The following methods are available and can be controlled; through OCC (conventional integrals CONV) and DFOCC (density-fitted; DF and Cholesky-decomposed CD) keywords. Switching between; the integrals treatments is controlled through ‘type select’ values;; see rightmost column in Table Conventional OCC/DFOCC Methods.; Depending on efficiency considerations, the OCC & DFOCC modules may; or may not be the default in PSI4 for available methods. (See; Cross-module Redundancies for gory; details.) To call the OCC/DFOCC implementation of any method below in; preference to the default module, issue set qc_module occ.; Starting in v1.4, MP2.5 and MP3 default to the density-fit algorithm. Set MP_TYPE to CONV to get previous behavior. Conventional (non-OO) CC and MP capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient; type select. mp2; MP2; RHF/UHF/ROHF; RHF/UHF; MP2_TYPE CONV. Density-Fitted",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:1241,Safety,avoid,avoids,1241,"ized Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Code author: Ugur Bozkaya; Section author: Ugur Bozkaya; Module: Keywords, PSI Variables, OCC; Module: Keywords, PSI Variables, DFOCC. Introduction¶; Orbital-optimized methods have several advantages over their non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann–Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invariant [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods do not suffer from artifactual symmetry-breaking; instabilities [Crawford:1997:instability], [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Furthermore, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particl",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/occ.html:8968,Usability,simpl,simply,8968,"appa^{\dagger} A \kappa}\]; where \({\bf w}\) is the MO gradient vector, \({\bf \kappa}\) is the MO rotation vector,; and \({\bf A}\) is the MO Hessian matrix. Therefore, minimizing the energy with respect to \({\bf \kappa}\); yields. \[{\bf \kappa} = -{\bf A^{-1}w}\]; This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the orbital-optimized code should cite the following publications:. OMP2 [Bozkaya:2011:omp2] and [Bozkaya:2013:omp2grad]; OMP3 [Bozkaya:2011:omp3] , [Bozkaya:2013:omp3], and [Bozkaya:2013:omp3grad]; OMP2.5 [Bozkaya:2011:omp3]; OLCCD [Bozkaya:2013:ocepa]; LCCD [Bozkaya:2013:ocepa]. Convergence Problems¶; For problematic open-shell systems, we recommend to use the ROHF or DFT orbitals as an initial guess for orbital-optimized methods. Both ROHF and; DFT orbitals may provide better initial guesses than UHF orbitals, hence convergence may be significantly speeded up with ROHF or DFT orbitals.; In order to use ROHF orbitals, simply set reference rohf. For DFT orbitals, set reference uks and set dft_functional b3lyp. Of; course users can use any DFT functional available in PSI4. Methods¶; The orbital-optimized MPn and OLCCD methods currently supported in; PSI4 are outlined in Table Orbital-Optimzed OCC/DFOCC; Methods. The following methods are available; and can be controlled through OCC (conventional integrals CONV); and DFOCC (density-fitted DF and Cholesky-decomposed CD); keywords. Switching between the integrals treatments is controlled; through “type select” values in the rightmost Table column. Orbital-Optimized MP and LCCD capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient; type select. omp2; Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP2_TYPE CONV. Density-Fitted Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP2_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —; MP2_TYPE CD. omp3; Orbital-Optimized MP3; R",MatchSource.WIKI,psi4manual/1.6.x/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/occ.html
https://psicode.org/psi4manual/1.6.x/oeprop.html:2916,Availability,avail,available,2916,"oles; MBIS_CHARGES; Generates atomic charges, dipoles, etc. See Minimal Basis Iterative Stockholder. There are two ways the computation of one-electron properties can be requested.; Firstly, the properties can be evaluated from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). Note that it is the user’s responsibility to ensure that the relaxed density; matrix is computed using the method of interest, which may require setting; additional keywords (see the method’s manual section for details). The named; argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table above.; The syntax above works well for computing properties using the SCF; wavefunction, however, may be difficult (or impossible) to use for some of the; correlated levels of theory. Alternatively, one-electron properties can be; computed using the built-in properties() function, e.g.:; properties('ccsd', properties=['dipole']). The properties() function provides limited functionality, but is a lot easier to; use for correlated methods. For capabilities of properties() see the; corresponding section of the manual. Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications¶. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nuclear charge. Properties e",MatchSource.WIKI,psi4manual/1.6.x/oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/oeprop.html
https://psicode.org/psi4manual/1.6.x/oeprop.html:7038,Deployability,update,updated,7038,"s(). In this example, the Vvals array contains the electrostatic potential at each; grid point, in the order that the grid was specified, while the Exvals,; Eyvals and Ezvals arrays contain the x, y and z components of the; electric field, respectively; all of these arrays can be iterated and; manipulated using standard Python syntax. For a complete demonstration of this; utility, see the props4 test case. Minimal Basis Iterative Stockholder¶; The Minimal Basis Iterative Stockholder (MBIS) method is one of many procedures; that partitions a molecular one-particle density matrix into atomic electron densities.; Running MBIS in PSI4 will calculate atomic valence charge widths, volume ratios,; atomic charges, as well as dipoles, quadrupoles, and octupoles.; Additionally, all expectation values of radial moments of n-th order (\(<r^n>\)); are computed up to fourth order. Higher moments can be computed by specifying MAX_RADIAL_MOMENT.; The volume ratios are computed as the ratio between the volume of the atomic density; (\(<r^3>\)) and the volume of the free atom computed using the same level; of theory, but with a potentially unrestricted reference.; The allowed number of iterations and convergence criteria for the stockholder; algorithm is controlled by MBIS_MAXITER and MBIS_D_CONVERGENCE. Note; that the density is partitioned on a molecular quadrature grid, the details of which can be; controlled with the keywords MBIS_RADIAL_POINTS, MBIS_SPHERICAL_POINTS, and; MBIS_PRUNING_SCHEME. (Associated Paper: [Verstraelen:2016]). table of contents. Evaluation of One-Electron Properties — oeprop(); Basic Keywords; Properties evaluated on a grid; Minimal Basis Iterative Stockholder. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; Evaluation of One-Electron Properties — oeprop(). © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/oeprop.html
https://psicode.org/psi4manual/1.6.x/oeprop.html:762,Energy Efficiency,energy,energy,762,"﻿. Evaluation of One-Electron Properties — oeprop(). Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; Evaluation of One-Electron Properties — oeprop(). Evaluation of One-Electron Properties — oeprop()¶; Code author: Robert M. Parrish and Andrew C. Simmonett; Section author: Andrew C. Simmonett. psi4.oeprop(wfn, *args, **kwargs)[source]; Evaluate one-electron properties. Returns; None. Parameters; wfn (Wavefunction) – set of molecule, basis, orbitals from which to compute properties. How to specify args, which are actually the most important. Parameters. title (str) – label prepended to all psivars computed; wfn (psi4.core.Wavefunction) – . Examples. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). PSI4 is capable of computing a number of one-electron properties; summarized in the table below. Current one-electron property capabilities of PSI4¶. Feature; Keyword; Notes. Electric dipole moment; DIPOLE. Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE”, “32-POLE”. Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Electrostatic potential, on grid; GRID_ESP; Generates V at each point in grid_esp.dat. See Properties evaluated on a grid. Electric field, on grid; GRID_FIELD; Generates {Ex,Ey,Ez} at each point grid_field.dat. See Properties evaluated on a grid. Molecular orbital extents; MO_EXTENTS. Mulliken atomic charges; MULLIKEN_CHARGES. Löwdin atomic charges; LOWDIN_CHARGES. Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES. Natural orbital occupations; NO_OCCUPATIONS. Stockholder Atomic Multipoles; MBIS_CHARGES; Generates atomic charges, dipoles, etc. See",MatchSource.WIKI,psi4manual/1.6.x/oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/oeprop.html
https://psicode.org/psi4manual/1.6.x/oeprop.html:1670,Energy Efficiency,charge,charges,1670,"i4.core.Wavefunction) – . Examples. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). PSI4 is capable of computing a number of one-electron properties; summarized in the table below. Current one-electron property capabilities of PSI4¶. Feature; Keyword; Notes. Electric dipole moment; DIPOLE. Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE”, “32-POLE”. Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Electrostatic potential, on grid; GRID_ESP; Generates V at each point in grid_esp.dat. See Properties evaluated on a grid. Electric field, on grid; GRID_FIELD; Generates {Ex,Ey,Ez} at each point grid_field.dat. See Properties evaluated on a grid. Molecular orbital extents; MO_EXTENTS. Mulliken atomic charges; MULLIKEN_CHARGES. Löwdin atomic charges; LOWDIN_CHARGES. Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES. Natural orbital occupations; NO_OCCUPATIONS. Stockholder Atomic Multipoles; MBIS_CHARGES; Generates atomic charges, dipoles, etc. See Minimal Basis Iterative Stockholder. There are two ways the computation of one-electron properties can be requested.; Firstly, the properties can be evaluated from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). Note that it is the user’s responsibility to ensure that the relaxed density; matrix is computed using the method of interest, which may require setting; additional keywords (see the method’s manual section for details). The named; argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; propertie",MatchSource.WIKI,psi4manual/1.6.x/oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/oeprop.html
https://psicode.org/psi4manual/1.6.x/oeprop.html:1711,Energy Efficiency,charge,charges,1711," [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). PSI4 is capable of computing a number of one-electron properties; summarized in the table below. Current one-electron property capabilities of PSI4¶. Feature; Keyword; Notes. Electric dipole moment; DIPOLE. Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE”, “32-POLE”. Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Electrostatic potential, on grid; GRID_ESP; Generates V at each point in grid_esp.dat. See Properties evaluated on a grid. Electric field, on grid; GRID_FIELD; Generates {Ex,Ey,Ez} at each point grid_field.dat. See Properties evaluated on a grid. Molecular orbital extents; MO_EXTENTS. Mulliken atomic charges; MULLIKEN_CHARGES. Löwdin atomic charges; LOWDIN_CHARGES. Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES. Natural orbital occupations; NO_OCCUPATIONS. Stockholder Atomic Multipoles; MBIS_CHARGES; Generates atomic charges, dipoles, etc. See Minimal Basis Iterative Stockholder. There are two ways the computation of one-electron properties can be requested.; Firstly, the properties can be evaluated from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). Note that it is the user’s responsibility to ensure that the relaxed density; matrix is computed using the method of interest, which may require setting; additional keywords (see the method’s manual section for details). The named; argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any",MatchSource.WIKI,psi4manual/1.6.x/oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/oeprop.html
https://psicode.org/psi4manual/1.6.x/oeprop.html:1975,Energy Efficiency,charge,charges,1975,"nt one-electron property capabilities of PSI4¶. Feature; Keyword; Notes. Electric dipole moment; DIPOLE. Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE”, “32-POLE”. Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Electrostatic potential, on grid; GRID_ESP; Generates V at each point in grid_esp.dat. See Properties evaluated on a grid. Electric field, on grid; GRID_FIELD; Generates {Ex,Ey,Ez} at each point grid_field.dat. See Properties evaluated on a grid. Molecular orbital extents; MO_EXTENTS. Mulliken atomic charges; MULLIKEN_CHARGES. Löwdin atomic charges; LOWDIN_CHARGES. Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES. Natural orbital occupations; NO_OCCUPATIONS. Stockholder Atomic Multipoles; MBIS_CHARGES; Generates atomic charges, dipoles, etc. See Minimal Basis Iterative Stockholder. There are two ways the computation of one-electron properties can be requested.; Firstly, the properties can be evaluated from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). Note that it is the user’s responsibility to ensure that the relaxed density; matrix is computed using the method of interest, which may require setting; additional keywords (see the method’s manual section for details). The named; argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the t",MatchSource.WIKI,psi4manual/1.6.x/oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/oeprop.html
https://psicode.org/psi4manual/1.6.x/oeprop.html:3919,Energy Efficiency,charge,charge,3919,"rties to compute. The available properties are shown in the table above.; The syntax above works well for computing properties using the SCF; wavefunction, however, may be difficult (or impossible) to use for some of the; correlated levels of theory. Alternatively, one-electron properties can be; computed using the built-in properties() function, e.g.:; properties('ccsd', properties=['dipole']). The properties() function provides limited functionality, but is a lot easier to; use for correlated methods. For capabilities of properties() see the; corresponding section of the manual. Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications¶. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nuclear charge. Properties evaluated on a grid¶; Certain properties may be evaluated a user-specified grid points. The grid; points are completely arbitrary and are specified by providing a file called; grid.dat containing the x,y,z values separated with spaces for each point in order:; x1 y1 z1; x2 y2 z2; ..........; xn yn zn. The grid.dat file is completely free form; any number of spaces and/or newlines; between entries is permitted. The units of the coordinates in grid.dat are the; same as those used to specify the molecule’s geometry, and the output; quantities are always in atomic units. The requested properties will be; written out in the same order as the grid point specification in grid.dat; see; the above table for the format and file name of the output.; The grid may be generated in the input file using standard Python loops. By; capturing the wavefunction used to evaluate the one-electron properties, the; values at each grid point may be captured as Python a",MatchSource.WIKI,psi4manual/1.6.x/oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/oeprop.html
https://psicode.org/psi4manual/1.6.x/oeprop.html:5781,Energy Efficiency,charge,charge,5781,"aluate the one-electron properties, the; values at each grid point may be captured as Python arrays in the input file:; E, wfn = prop('scf', properties=[""GRID_ESP"", ""GRID_FIELD""], return_wfn=True); Vvals = wfn.oeprop.Vvals(); Exvals = wfn.oeprop.Exvals(); Eyvals = wfn.oeprop.Eyvals(); Ezvals = wfn.oeprop.Ezvals(). In this example, the Vvals array contains the electrostatic potential at each; grid point, in the order that the grid was specified, while the Exvals,; Eyvals and Ezvals arrays contain the x, y and z components of the; electric field, respectively; all of these arrays can be iterated and; manipulated using standard Python syntax. For a complete demonstration of this; utility, see the props4 test case. Minimal Basis Iterative Stockholder¶; The Minimal Basis Iterative Stockholder (MBIS) method is one of many procedures; that partitions a molecular one-particle density matrix into atomic electron densities.; Running MBIS in PSI4 will calculate atomic valence charge widths, volume ratios,; atomic charges, as well as dipoles, quadrupoles, and octupoles.; Additionally, all expectation values of radial moments of n-th order (\(<r^n>\)); are computed up to fourth order. Higher moments can be computed by specifying MAX_RADIAL_MOMENT.; The volume ratios are computed as the ratio between the volume of the atomic density; (\(<r^3>\)) and the volume of the free atom computed using the same level; of theory, but with a potentially unrestricted reference.; The allowed number of iterations and convergence criteria for the stockholder; algorithm is controlled by MBIS_MAXITER and MBIS_D_CONVERGENCE. Note; that the density is partitioned on a molecular quadrature grid, the details of which can be; controlled with the keywords MBIS_RADIAL_POINTS, MBIS_SPHERICAL_POINTS, and; MBIS_PRUNING_SCHEME. (Associated Paper: [Verstraelen:2016]). table of contents. Evaluation of One-Electron Properties — oeprop(); Basic Keywords; Properties evaluated on a grid; Minimal Basis Iterative Stoc",MatchSource.WIKI,psi4manual/1.6.x/oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/oeprop.html
https://psicode.org/psi4manual/1.6.x/oeprop.html:5819,Energy Efficiency,charge,charges,5819,"aluate the one-electron properties, the; values at each grid point may be captured as Python arrays in the input file:; E, wfn = prop('scf', properties=[""GRID_ESP"", ""GRID_FIELD""], return_wfn=True); Vvals = wfn.oeprop.Vvals(); Exvals = wfn.oeprop.Exvals(); Eyvals = wfn.oeprop.Eyvals(); Ezvals = wfn.oeprop.Ezvals(). In this example, the Vvals array contains the electrostatic potential at each; grid point, in the order that the grid was specified, while the Exvals,; Eyvals and Ezvals arrays contain the x, y and z components of the; electric field, respectively; all of these arrays can be iterated and; manipulated using standard Python syntax. For a complete demonstration of this; utility, see the props4 test case. Minimal Basis Iterative Stockholder¶; The Minimal Basis Iterative Stockholder (MBIS) method is one of many procedures; that partitions a molecular one-particle density matrix into atomic electron densities.; Running MBIS in PSI4 will calculate atomic valence charge widths, volume ratios,; atomic charges, as well as dipoles, quadrupoles, and octupoles.; Additionally, all expectation values of radial moments of n-th order (\(<r^n>\)); are computed up to fourth order. Higher moments can be computed by specifying MAX_RADIAL_MOMENT.; The volume ratios are computed as the ratio between the volume of the atomic density; (\(<r^3>\)) and the volume of the free atom computed using the same level; of theory, but with a potentially unrestricted reference.; The allowed number of iterations and convergence criteria for the stockholder; algorithm is controlled by MBIS_MAXITER and MBIS_D_CONVERGENCE. Note; that the density is partitioned on a molecular quadrature grid, the details of which can be; controlled with the keywords MBIS_RADIAL_POINTS, MBIS_SPHERICAL_POINTS, and; MBIS_PRUNING_SCHEME. (Associated Paper: [Verstraelen:2016]). table of contents. Evaluation of One-Electron Properties — oeprop(); Basic Keywords; Properties evaluated on a grid; Minimal Basis Iterative Stoc",MatchSource.WIKI,psi4manual/1.6.x/oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/oeprop.html
https://psicode.org/psi4manual/1.6.x/oeprop.html:1223,Modifiability,variab,variables,1223,"Electron Properties — oeprop()¶; Code author: Robert M. Parrish and Andrew C. Simmonett; Section author: Andrew C. Simmonett. psi4.oeprop(wfn, *args, **kwargs)[source]; Evaluate one-electron properties. Returns; None. Parameters; wfn (Wavefunction) – set of molecule, basis, orbitals from which to compute properties. How to specify args, which are actually the most important. Parameters. title (str) – label prepended to all psivars computed; wfn (psi4.core.Wavefunction) – . Examples. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). PSI4 is capable of computing a number of one-electron properties; summarized in the table below. Current one-electron property capabilities of PSI4¶. Feature; Keyword; Notes. Electric dipole moment; DIPOLE. Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE”, “32-POLE”. Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Electrostatic potential, on grid; GRID_ESP; Generates V at each point in grid_esp.dat. See Properties evaluated on a grid. Electric field, on grid; GRID_FIELD; Generates {Ex,Ey,Ez} at each point grid_field.dat. See Properties evaluated on a grid. Molecular orbital extents; MO_EXTENTS. Mulliken atomic charges; MULLIKEN_CHARGES. Löwdin atomic charges; LOWDIN_CHARGES. Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES. Natural orbital occupations; NO_OCCUPATIONS. Stockholder Atomic Multipoles; MBIS_CHARGES; Generates atomic charges, dipoles, etc. See Minimal Basis Iterative Stockholder. There are two ways the computation of one-electron properties can be requested.; Firstly, the properties can be evaluated from the last; computed one-particle density, using the follow",MatchSource.WIKI,psi4manual/1.6.x/oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/oeprop.html
https://psicode.org/psi4manual/1.6.x/oeprop.html:1322,Modifiability,variab,variables,1322,"ection author: Andrew C. Simmonett. psi4.oeprop(wfn, *args, **kwargs)[source]; Evaluate one-electron properties. Returns; None. Parameters; wfn (Wavefunction) – set of molecule, basis, orbitals from which to compute properties. How to specify args, which are actually the most important. Parameters. title (str) – label prepended to all psivars computed; wfn (psi4.core.Wavefunction) – . Examples. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). PSI4 is capable of computing a number of one-electron properties; summarized in the table below. Current one-electron property capabilities of PSI4¶. Feature; Keyword; Notes. Electric dipole moment; DIPOLE. Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE”, “32-POLE”. Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Electrostatic potential, on grid; GRID_ESP; Generates V at each point in grid_esp.dat. See Properties evaluated on a grid. Electric field, on grid; GRID_FIELD; Generates {Ex,Ey,Ez} at each point grid_field.dat. See Properties evaluated on a grid. Molecular orbital extents; MO_EXTENTS. Mulliken atomic charges; MULLIKEN_CHARGES. Löwdin atomic charges; LOWDIN_CHARGES. Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES. Natural orbital occupations; NO_OCCUPATIONS. Stockholder Atomic Multipoles; MBIS_CHARGES; Generates atomic charges, dipoles, etc. See Minimal Basis Iterative Stockholder. There are two ways the computation of one-electron properties can be requested.; Firstly, the properties can be evaluated from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). Note that it is the u",MatchSource.WIKI,psi4manual/1.6.x/oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/oeprop.html
https://psicode.org/psi4manual/1.6.x/oeprop.html:2597,Modifiability,variab,variables,2597,".dat. See Properties evaluated on a grid. Molecular orbital extents; MO_EXTENTS. Mulliken atomic charges; MULLIKEN_CHARGES. Löwdin atomic charges; LOWDIN_CHARGES. Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES. Natural orbital occupations; NO_OCCUPATIONS. Stockholder Atomic Multipoles; MBIS_CHARGES; Generates atomic charges, dipoles, etc. See Minimal Basis Iterative Stockholder. There are two ways the computation of one-electron properties can be requested.; Firstly, the properties can be evaluated from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). Note that it is the user’s responsibility to ensure that the relaxed density; matrix is computed using the method of interest, which may require setting; additional keywords (see the method’s manual section for details). The named; argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table above.; The syntax above works well for computing properties using the SCF; wavefunction, however, may be difficult (or impossible) to use for some of the; correlated levels of theory. Alternatively, one-electron properties can be; computed using the built-in properties() function, e.g.:; properties('ccsd', properties=['dipole']). The properties() function provides limited functionality, but is a lot easier to; use for correlated methods. For capabilities of properties() see the; corresponding section of the manual. Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by th",MatchSource.WIKI,psi4manual/1.6.x/oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/oeprop.html
https://psicode.org/psi4manual/1.6.x/oeprop.html:5511,Testability,test,test,5511,"are always in atomic units. The requested properties will be; written out in the same order as the grid point specification in grid.dat; see; the above table for the format and file name of the output.; The grid may be generated in the input file using standard Python loops. By; capturing the wavefunction used to evaluate the one-electron properties, the; values at each grid point may be captured as Python arrays in the input file:; E, wfn = prop('scf', properties=[""GRID_ESP"", ""GRID_FIELD""], return_wfn=True); Vvals = wfn.oeprop.Vvals(); Exvals = wfn.oeprop.Exvals(); Eyvals = wfn.oeprop.Eyvals(); Ezvals = wfn.oeprop.Ezvals(). In this example, the Vvals array contains the electrostatic potential at each; grid point, in the order that the grid was specified, while the Exvals,; Eyvals and Ezvals arrays contain the x, y and z components of the; electric field, respectively; all of these arrays can be iterated and; manipulated using standard Python syntax. For a complete demonstration of this; utility, see the props4 test case. Minimal Basis Iterative Stockholder¶; The Minimal Basis Iterative Stockholder (MBIS) method is one of many procedures; that partitions a molecular one-particle density matrix into atomic electron densities.; Running MBIS in PSI4 will calculate atomic valence charge widths, volume ratios,; atomic charges, as well as dipoles, quadrupoles, and octupoles.; Additionally, all expectation values of radial moments of n-th order (\(<r^n>\)); are computed up to fourth order. Higher moments can be computed by specifying MAX_RADIAL_MOMENT.; The volume ratios are computed as the ratio between the volume of the atomic density; (\(<r^3>\)) and the volume of the free atom computed using the same level; of theory, but with a potentially unrestricted reference.; The allowed number of iterations and convergence criteria for the stockholder; algorithm is controlled by MBIS_MAXITER and MBIS_D_CONVERGENCE. Note; that the density is partitioned on a molecular quadrature g",MatchSource.WIKI,psi4manual/1.6.x/oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/oeprop.html
https://psicode.org/psi4manual/1.6.x/opt.html:2711,Availability,avail,available,2711,"an) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Options passed to the GeomeTRIC optimizer; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized se",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:3132,Availability,avail,available,3132,"imizer; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:15308,Deployability,update,updated,15308,"r; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns; Matrix – Total electronic gradient in Hartrees/Bohr. Returns; (Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — optimize() and gradient(). © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:932,Energy Efficiency,energy,energy,932,"﻿. Geometry Optimization — optimize() and gradient(). Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — optimize() and gradient(). Geometry Optimization — optimize() and gradient()¶. Psi4 Native Gradient Methods; Psi4 Native DFT Gradient Methods (excepting double-hybrids); CFOUR Interfaced Gradient Methods. For further discussion of geometry optimization, see; Sec. Geometry Optimization.; optimize() is the only command most users will ever; need to access directly to perform geometry optimizations. Behind; the scenes, optimize() is a wrapper that repeatedly; calls gradient() that computes the gradient then adds a; call to the geometry optimization module. psi4.optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]; Function to perform a geometry optimization. Aliases; opt(). Returns; float – Total electronic energy of optimized structure in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises; psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables. CURRENT ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, whic",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:1008,Energy Efficiency,energy,energy,1008,"mization — optimize() and gradient(). Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — optimize() and gradient(). Geometry Optimization — optimize() and gradient()¶. Psi4 Native Gradient Methods; Psi4 Native DFT Gradient Methods (excepting double-hybrids); CFOUR Interfaced Gradient Methods. For further discussion of geometry optimization, see; Sec. Geometry Optimization.; optimize() is the only command most users will ever; need to access directly to perform geometry optimizations. Behind; the scenes, optimize() is a wrapper that repeatedly; calls gradient() that computes the gradient then adds a; call to the geometry optimization module. psi4.optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]; Function to perform a geometry optimization. Aliases; opt(). Returns; float – Total electronic energy of optimized structure in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises; psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables. CURRENT ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:1391,Energy Efficiency,energy,energy,1391,"or further discussion of geometry optimization, see; Sec. Geometry Optimization.; optimize() is the only command most users will ever; need to access directly to perform geometry optimizations. Behind; the scenes, optimize() is a wrapper that repeatedly; calls gradient() that computes the gradient then adds a; call to the geometry optimization module. psi4.optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]; Function to perform a geometry optimization. Aliases; opt(). Returns; float – Total electronic energy of optimized structure in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises; psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables. CURRENT ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Options passed to the GeomeTRIC optimizer; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:1664,Energy Efficiency,energy,energy,1664,"s. Behind; the scenes, optimize() is a wrapper that repeatedly; calls gradient() that computes the gradient then adds a; call to the geometry optimization module. psi4.optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]; Function to perform a geometry optimization. Aliases; opt(). Returns; float – Total electronic energy of optimized structure in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises; psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables. CURRENT ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Options passed to the GeomeTRIC optimizer; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Int",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:2316,Energy Efficiency,energy,energy,2316,"to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Options passed to the GeomeTRIC optimizer; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:2443,Energy Efficiency,energy,energy,2443,"if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Options passed to the GeomeTRIC optimizer; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dct; density cumulant (function",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:2671,Energy Efficiency,energy,energy,2671,"an) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Options passed to the GeomeTRIC optimizer; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized se",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:3219,Energy Efficiency,energy,energy,3219,"chosen as the optimization engine. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:14110,Energy Efficiency,energy,energy,14110,"cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns; Matrix – Total electronic gradient in Hartrees/Bohr. Returns; (Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). «; hide menu. menu; sidebar; »; . Navigat",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:14172,Energy Efficiency,energy,energy,14172,"d triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns; Matrix – Total electronic gradient in Hartrees/Bohr. Returns; (Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — opt",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:625,Integrability,wrap,wrapper,625,"﻿. Geometry Optimization — optimize() and gradient(). Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — optimize() and gradient(). Geometry Optimization — optimize() and gradient()¶. Psi4 Native Gradient Methods; Psi4 Native DFT Gradient Methods (excepting double-hybrids); CFOUR Interfaced Gradient Methods. For further discussion of geometry optimization, see; Sec. Geometry Optimization.; optimize() is the only command most users will ever; need to access directly to perform geometry optimizations. Behind; the scenes, optimize() is a wrapper that repeatedly; calls gradient() that computes the gradient then adds a; call to the geometry optimization module. psi4.optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]; Function to perform a geometry optimization. Aliases; opt(). Returns; float – Total electronic energy of optimized structure in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises; psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables. CURRENT ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, whic",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:1169,Modifiability,variab,variables,1169,"ry Optimization — optimize() and gradient(). Geometry Optimization — optimize() and gradient()¶. Psi4 Native Gradient Methods; Psi4 Native DFT Gradient Methods (excepting double-hybrids); CFOUR Interfaced Gradient Methods. For further discussion of geometry optimization, see; Sec. Geometry Optimization.; optimize() is the only command most users will ever; need to access directly to perform geometry optimizations. Behind; the scenes, optimize() is a wrapper that repeatedly; calls gradient() that computes the gradient then adds a; call to the geometry optimization module. psi4.optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]; Function to perform a geometry optimization. Aliases; opt(). Returns; float – Total electronic energy of optimized structure in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises; psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables. CURRENT ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Options passed to the GeomeTRIC optimizer; Indicates additional opti",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:27,Performance,optimiz,optimize,27,"﻿. Geometry Optimization — optimize() and gradient(). Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — optimize() and gradient(). Geometry Optimization — optimize() and gradient()¶. Psi4 Native Gradient Methods; Psi4 Native DFT Gradient Methods (excepting double-hybrids); CFOUR Interfaced Gradient Methods. For further discussion of geometry optimization, see; Sec. Geometry Optimization.; optimize() is the only command most users will ever; need to access directly to perform geometry optimizations. Behind; the scenes, optimize() is a wrapper that repeatedly; calls gradient() that computes the gradient then adds a; call to the geometry optimization module. psi4.optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]; Function to perform a geometry optimization. Aliases; opt(). Returns; float – Total electronic energy of optimized structure in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises; psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables. CURRENT ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, whic",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:189,Performance,optimiz,optimize,189,"﻿. Geometry Optimization — optimize() and gradient(). Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — optimize() and gradient(). Geometry Optimization — optimize() and gradient()¶. Psi4 Native Gradient Methods; Psi4 Native DFT Gradient Methods (excepting double-hybrids); CFOUR Interfaced Gradient Methods. For further discussion of geometry optimization, see; Sec. Geometry Optimization.; optimize() is the only command most users will ever; need to access directly to perform geometry optimizations. Behind; the scenes, optimize() is a wrapper that repeatedly; calls gradient() that computes the gradient then adds a; call to the geometry optimization module. psi4.optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]; Function to perform a geometry optimization. Aliases; opt(). Returns; float – Total electronic energy of optimized structure in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises; psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables. CURRENT ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, whic",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:240,Performance,optimiz,optimize,240,"﻿. Geometry Optimization — optimize() and gradient(). Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — optimize() and gradient(). Geometry Optimization — optimize() and gradient()¶. Psi4 Native Gradient Methods; Psi4 Native DFT Gradient Methods (excepting double-hybrids); CFOUR Interfaced Gradient Methods. For further discussion of geometry optimization, see; Sec. Geometry Optimization.; optimize() is the only command most users will ever; need to access directly to perform geometry optimizations. Behind; the scenes, optimize() is a wrapper that repeatedly; calls gradient() that computes the gradient then adds a; call to the geometry optimization module. psi4.optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]; Function to perform a geometry optimization. Aliases; opt(). Returns; float – Total electronic energy of optimized structure in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises; psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables. CURRENT ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, whic",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:429,Performance,optimiz,optimization,429,"﻿. Geometry Optimization — optimize() and gradient(). Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — optimize() and gradient(). Geometry Optimization — optimize() and gradient()¶. Psi4 Native Gradient Methods; Psi4 Native DFT Gradient Methods (excepting double-hybrids); CFOUR Interfaced Gradient Methods. For further discussion of geometry optimization, see; Sec. Geometry Optimization.; optimize() is the only command most users will ever; need to access directly to perform geometry optimizations. Behind; the scenes, optimize() is a wrapper that repeatedly; calls gradient() that computes the gradient then adds a; call to the geometry optimization module. psi4.optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]; Function to perform a geometry optimization. Aliases; opt(). Returns; float – Total electronic energy of optimized structure in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises; psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables. CURRENT ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, whic",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:477,Performance,optimiz,optimize,477,"﻿. Geometry Optimization — optimize() and gradient(). Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — optimize() and gradient(). Geometry Optimization — optimize() and gradient()¶. Psi4 Native Gradient Methods; Psi4 Native DFT Gradient Methods (excepting double-hybrids); CFOUR Interfaced Gradient Methods. For further discussion of geometry optimization, see; Sec. Geometry Optimization.; optimize() is the only command most users will ever; need to access directly to perform geometry optimizations. Behind; the scenes, optimize() is a wrapper that repeatedly; calls gradient() that computes the gradient then adds a; call to the geometry optimization module. psi4.optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]; Function to perform a geometry optimization. Aliases; opt(). Returns; float – Total electronic energy of optimized structure in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises; psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables. CURRENT ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, whic",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:557,Performance,perform,perform,557,"﻿. Geometry Optimization — optimize() and gradient(). Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — optimize() and gradient(). Geometry Optimization — optimize() and gradient()¶. Psi4 Native Gradient Methods; Psi4 Native DFT Gradient Methods (excepting double-hybrids); CFOUR Interfaced Gradient Methods. For further discussion of geometry optimization, see; Sec. Geometry Optimization.; optimize() is the only command most users will ever; need to access directly to perform geometry optimizations. Behind; the scenes, optimize() is a wrapper that repeatedly; calls gradient() that computes the gradient then adds a; call to the geometry optimization module. psi4.optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]; Function to perform a geometry optimization. Aliases; opt(). Returns; float – Total electronic energy of optimized structure in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises; psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables. CURRENT ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, whic",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:574,Performance,optimiz,optimizations,574,"﻿. Geometry Optimization — optimize() and gradient(). Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — optimize() and gradient(). Geometry Optimization — optimize() and gradient()¶. Psi4 Native Gradient Methods; Psi4 Native DFT Gradient Methods (excepting double-hybrids); CFOUR Interfaced Gradient Methods. For further discussion of geometry optimization, see; Sec. Geometry Optimization.; optimize() is the only command most users will ever; need to access directly to perform geometry optimizations. Behind; the scenes, optimize() is a wrapper that repeatedly; calls gradient() that computes the gradient then adds a; call to the geometry optimization module. psi4.optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]; Function to perform a geometry optimization. Aliases; opt(). Returns; float – Total electronic energy of optimized structure in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises; psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables. CURRENT ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, whic",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:609,Performance,optimiz,optimize,609,"﻿. Geometry Optimization — optimize() and gradient(). Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — optimize() and gradient(). Geometry Optimization — optimize() and gradient()¶. Psi4 Native Gradient Methods; Psi4 Native DFT Gradient Methods (excepting double-hybrids); CFOUR Interfaced Gradient Methods. For further discussion of geometry optimization, see; Sec. Geometry Optimization.; optimize() is the only command most users will ever; need to access directly to perform geometry optimizations. Behind; the scenes, optimize() is a wrapper that repeatedly; calls gradient() that computes the gradient then adds a; call to the geometry optimization module. psi4.optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]; Function to perform a geometry optimization. Aliases; opt(). Returns; float – Total electronic energy of optimized structure in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises; psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables. CURRENT ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, whic",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:728,Performance,optimiz,optimization,728,"﻿. Geometry Optimization — optimize() and gradient(). Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — optimize() and gradient(). Geometry Optimization — optimize() and gradient()¶. Psi4 Native Gradient Methods; Psi4 Native DFT Gradient Methods (excepting double-hybrids); CFOUR Interfaced Gradient Methods. For further discussion of geometry optimization, see; Sec. Geometry Optimization.; optimize() is the only command most users will ever; need to access directly to perform geometry optimizations. Behind; the scenes, optimize() is a wrapper that repeatedly; calls gradient() that computes the gradient then adds a; call to the geometry optimization module. psi4.optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]; Function to perform a geometry optimization. Aliases; opt(). Returns; float – Total electronic energy of optimized structure in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises; psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables. CURRENT ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, whic",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:754,Performance,optimiz,optimize,754,"﻿. Geometry Optimization — optimize() and gradient(). Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — optimize() and gradient(). Geometry Optimization — optimize() and gradient()¶. Psi4 Native Gradient Methods; Psi4 Native DFT Gradient Methods (excepting double-hybrids); CFOUR Interfaced Gradient Methods. For further discussion of geometry optimization, see; Sec. Geometry Optimization.; optimize() is the only command most users will ever; need to access directly to perform geometry optimizations. Behind; the scenes, optimize() is a wrapper that repeatedly; calls gradient() that computes the gradient then adds a; call to the geometry optimization module. psi4.optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]; Function to perform a geometry optimization. Aliases; opt(). Returns; float – Total electronic energy of optimized structure in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises; psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables. CURRENT ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, whic",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:849,Performance,perform,perform,849,"﻿. Geometry Optimization — optimize() and gradient(). Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — optimize() and gradient(). Geometry Optimization — optimize() and gradient()¶. Psi4 Native Gradient Methods; Psi4 Native DFT Gradient Methods (excepting double-hybrids); CFOUR Interfaced Gradient Methods. For further discussion of geometry optimization, see; Sec. Geometry Optimization.; optimize() is the only command most users will ever; need to access directly to perform geometry optimizations. Behind; the scenes, optimize() is a wrapper that repeatedly; calls gradient() that computes the gradient then adds a; call to the geometry optimization module. psi4.optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]; Function to perform a geometry optimization. Aliases; opt(). Returns; float – Total electronic energy of optimized structure in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises; psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables. CURRENT ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, whic",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:868,Performance,optimiz,optimization,868,"﻿. Geometry Optimization — optimize() and gradient(). Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — optimize() and gradient(). Geometry Optimization — optimize() and gradient()¶. Psi4 Native Gradient Methods; Psi4 Native DFT Gradient Methods (excepting double-hybrids); CFOUR Interfaced Gradient Methods. For further discussion of geometry optimization, see; Sec. Geometry Optimization.; optimize() is the only command most users will ever; need to access directly to perform geometry optimizations. Behind; the scenes, optimize() is a wrapper that repeatedly; calls gradient() that computes the gradient then adds a; call to the geometry optimization module. psi4.optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]; Function to perform a geometry optimization. Aliases; opt(). Returns; float – Total electronic energy of optimized structure in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises; psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables. CURRENT ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, whic",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:942,Performance,optimiz,optimized,942,"﻿. Geometry Optimization — optimize() and gradient(). Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — optimize() and gradient(). Geometry Optimization — optimize() and gradient()¶. Psi4 Native Gradient Methods; Psi4 Native DFT Gradient Methods (excepting double-hybrids); CFOUR Interfaced Gradient Methods. For further discussion of geometry optimization, see; Sec. Geometry Optimization.; optimize() is the only command most users will ever; need to access directly to perform geometry optimizations. Behind; the scenes, optimize() is a wrapper that repeatedly; calls gradient() that computes the gradient then adds a; call to the geometry optimization module. psi4.optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]; Function to perform a geometry optimization. Aliases; opt(). Returns; float – Total electronic energy of optimized structure in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises; psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables. CURRENT ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, whic",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:1869,Performance,optimiz,optimization,1869,"turn_wfn, func, mode, dertype, hessian_with])[source]; Function to perform a geometry optimization. Aliases; opt(). Returns; float – Total electronic energy of optimized structure in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises; psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables. CURRENT ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Options passed to the GeomeTRIC optimizer; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessia",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:1969,Performance,optimiz,optimization,1969,"urns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises; psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables. CURRENT ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Options passed to the GeomeTRIC optimizer; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:2040,Performance,optimiz,optimizer,2040,"urns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises; psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables. CURRENT ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Options passed to the GeomeTRIC optimizer; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:2136,Performance,optimiz,optimizer,2136," PSI variables. CURRENT ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Options passed to the GeomeTRIC optimizer; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the ",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:2206,Performance,optimiz,optimizer,2206," PSI variables. CURRENT ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Options passed to the GeomeTRIC optimizer; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the ",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:2234,Performance,optimiz,optimization,2234," PSI variables. CURRENT ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Options passed to the GeomeTRIC optimizer; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the ",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:2371,Performance,perform,performed,2371,"to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Options passed to the GeomeTRIC optimizer; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:2465,Performance,perform,performs,2465,"if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Options passed to the GeomeTRIC optimizer; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dct; density cumulant (function",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:2744,Performance,optimiz,optimization,2744,"an) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Options passed to the GeomeTRIC optimizer; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized se",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:2766,Performance,perform,performed,2766,"an) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Options passed to the GeomeTRIC optimizer; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized se",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:2871,Performance,perform,perform,2871,"tion. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Options passed to the GeomeTRIC optimizer; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:2921,Performance,optimiz,optimization,2921,"tion. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Options passed to the GeomeTRIC optimizer; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:3298,Performance,optimiz,optimizations,3298," \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb-GGA Exchange-Correlation Functional. b1lyp-d3bj. b1pw91; B1PW91 Hyb-GGA Exch",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:3694,Performance,optimiz,optimized,3694,ilable) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb-GGA Exchange-Correlation Functional. b1lyp-d3bj. b1pw91; B1PW91 Hyb-GGA Exchange-Correlation Functional. b1wc; B1WC Hyb-GGA Exchange-Correlation Functional. b3lyp; B3LYP Hyb-GGA Exchange-Correlation Functional. b3lyp-d3bj. b3lyp-d3mbj. b3lyp-nl; B3LYP-nl Hyb-GGA Exchange-Correlation Functional. b3lyp5; B3LYP5 Hyb-GGA Exchange-Correlation Functional. b3lyps; B3LYPs Hyb-GGA Exchange-Correlation Functional. b3p86; B3P86 Hyb-GGA Exchange-Correlation Functional. b3p86-d3bj. b3pw91; B3PW91 Hyb,MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:3764,Performance,optimiz,optimized,3764,n_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb-GGA Exchange-Correlation Functional. b1lyp-d3bj. b1pw91; B1PW91 Hyb-GGA Exchange-Correlation Functional. b1wc; B1WC Hyb-GGA Exchange-Correlation Functional. b3lyp; B3LYP Hyb-GGA Exchange-Correlation Functional. b3lyp-d3bj. b3lyp-d3mbj. b3lyp-nl; B3LYP-nl Hyb-GGA Exchange-Correlation Functional. b3lyp5; B3LYP5 Hyb-GGA Exchange-Correlation Functional. b3lyps; B3LYPs Hyb-GGA Exchange-Correlation Functional. b3p86; B3P86 Hyb-GGA Exchange-Correlation Functional. b3p86-d3bj. b3pw91; B3PW91 Hyb-GGA Exchange-Correlation Functional. b3pw91-d3bj. b3pw91-nl; B3PW91-n,MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:3835,Performance,optimiz,optimized,3835,computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb-GGA Exchange-Correlation Functional. b1lyp-d3bj. b1pw91; B1PW91 Hyb-GGA Exchange-Correlation Functional. b1wc; B1WC Hyb-GGA Exchange-Correlation Functional. b3lyp; B3LYP Hyb-GGA Exchange-Correlation Functional. b3lyp-d3bj. b3lyp-d3mbj. b3lyp-nl; B3LYP-nl Hyb-GGA Exchange-Correlation Functional. b3lyp5; B3LYP5 Hyb-GGA Exchange-Correlation Functional. b3lyps; B3LYPs Hyb-GGA Exchange-Correlation Functional. b3p86; B3P86 Hyb-GGA Exchange-Correlation Functional. b3p86-d3bj. b3pw91; B3PW91 Hyb-GGA Exchange-Correlation Functional. b3pw91-d3bj. b3pw91-nl; B3PW91-nl Hyb-GGA Exchange-Correlation Functional. b5050lyp; ,MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:3913,Performance,optimiz,optimized,3913,try optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb-GGA Exchange-Correlation Functional. b1lyp-d3bj. b1pw91; B1PW91 Hyb-GGA Exchange-Correlation Functional. b1wc; B1WC Hyb-GGA Exchange-Correlation Functional. b3lyp; B3LYP Hyb-GGA Exchange-Correlation Functional. b3lyp-d3bj. b3lyp-d3mbj. b3lyp-nl; B3LYP-nl Hyb-GGA Exchange-Correlation Functional. b3lyp5; B3LYP5 Hyb-GGA Exchange-Correlation Functional. b3lyps; B3LYPs Hyb-GGA Exchange-Correlation Functional. b3p86; B3P86 Hyb-GGA Exchange-Correlation Functional. b3p86-d3bj. b3pw91; B3PW91 Hyb-GGA Exchange-Correlation Functional. b3pw91-d3bj. b3pw91-nl; B3PW91-nl Hyb-GGA Exchange-Correlation Functional. b5050lyp; B5050LYP Hyb-GGA Exchange-Correlation Functional. b86b95; B86B95 Hyb-GGA Exchang,MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:13457,Performance,optimiz,optimization,13457,"-Correlation Functional. x1b95; X1B95 Hyb-GGA Exchange-Correlation Functional. x3lyp; X3LYP Hyb-GGA Exchange-Correlation Functional. x3lyp-d3bj. xb1k; XB1K Hyb-GGA Exchange-Correlation Functional. xlyp; XLYP GGA Exchange-Correlation Functional. xlyp-d3bj. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.a",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:13475,Performance,optimiz,optimize,13475,"-Correlation Functional. x1b95; X1B95 Hyb-GGA Exchange-Correlation Functional. x3lyp; X3LYP Hyb-GGA Exchange-Correlation Functional. x3lyp-d3bj. xb1k; XB1K Hyb-GGA Exchange-Correlation Functional. xlyp; XLYP GGA Exchange-Correlation Functional. xlyp-d3bj. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.a",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:13523,Performance,optimiz,optimization,13523," Exchange-Correlation Functional. x3lyp-d3bj. xb1k; XB1K Hyb-GGA Exchange-Correlation Functional. xlyp; XLYP GGA Exchange-Correlation Functional. xlyp-d3bj. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[so",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:13684,Performance,perform,perform,13684,"yp-d3bj. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns; Matrix – Total electro",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:13731,Performance,optimiz,optimize,13731,"yp-d3bj. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns; Matrix – Total electro",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:13792,Performance,perform,perform,13792,"4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns; Matrix – Total electronic gradient in Hartrees/Bohr. Returns; (Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examp",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:13985,Performance,optimiz,optimize,13985,"on theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns; Matrix – Total electronic gradient in Hartrees/Bohr. Returns; (Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = ",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:14138,Performance,optimiz,optimization,14138,"cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns; Matrix – Total electronic gradient in Hartrees/Bohr. Returns; (Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). «; hide menu. menu; sidebar; »; . Navigat",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:14222,Performance,optimiz,optimization,14222,"d triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns; Matrix – Total electronic gradient in Hartrees/Bohr. Returns; (Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — opt",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:14309,Performance,optimiz,optimization,14309,"d triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns; Matrix – Total electronic gradient in Hartrees/Bohr. Returns; (Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — opt",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:14343,Performance,optimiz,optimize,14343,", and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns; Matrix – Total electronic gradient in Hartrees/Bohr. Returns; (Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — optimize() and gradient(). © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Crea",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:14594,Performance,optimiz,optimize,14594,"r; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns; Matrix – Total electronic gradient in Hartrees/Bohr. Returns; (Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — optimize() and gradient(). © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:15239,Performance,optimiz,optimize,15239,"r; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns; Matrix – Total electronic gradient in Hartrees/Bohr. Returns; (Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — optimize() and gradient(). © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:538,Security,access,access,538,"﻿. Geometry Optimization — optimize() and gradient(). Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — optimize() and gradient(). Geometry Optimization — optimize() and gradient()¶. Psi4 Native Gradient Methods; Psi4 Native DFT Gradient Methods (excepting double-hybrids); CFOUR Interfaced Gradient Methods. For further discussion of geometry optimization, see; Sec. Geometry Optimization.; optimize() is the only command most users will ever; need to access directly to perform geometry optimizations. Behind; the scenes, optimize() is a wrapper that repeatedly; calls gradient() that computes the gradient then adds a; call to the geometry optimization module. psi4.optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]; Function to perform a geometry optimization. Aliases; opt(). Returns; float – Total electronic energy of optimized structure in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises; psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables. CURRENT ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, whic",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:2419,Security,access,accesses,2419,"if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Options passed to the GeomeTRIC optimizer; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dct; density cumulant (function",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/opt.html:2902,Usability,guid,guide,2902,"tion. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Options passed to the GeomeTRIC optimizer; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD",MatchSource.WIKI,psi4manual/1.6.x/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html
https://psicode.org/psi4manual/1.6.x/optionshandling.html:902,Availability,avail,available,902,"﻿. LibOptions: globals, locals, has_changed and all that. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Programming with the Core Libraries; LibOptions: globals, locals, has_changed and all that. LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options section. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/psi4/src/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str_i(""DATA_FILE"", ""data.dat"");; /*- The ",MatchSource.WIKI,psi4manual/1.6.x/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optionshandling.html
https://psicode.org/psi4manual/1.6.x/optionshandling.html:6422,Availability,avail,available,6422,"n driver function is to query for the value of any option the; function may want to change and for the current has_changed status; (presumably reflecting whether the user has changed the value, as long as; no preceding code has corrupted that definition). The python function; then makes its changes to the option and runs any c-side modules with; those changes. Finally, just before the function returns, the options are; reset to the user’s value and has_changed status (which should now again; reflect only whether the user has changed the value). Warning; PUREAM is an exception in that its value and; has_changed() value only reflect what the user has explicitly set.; This keyword should not be queried to find out the current; PUREAM state for the active basis; use instead,; psi4.MintsHelper().basisset().has_puream(). Reading Options in Module¶. Handling Options in Driver¶; This section is about the scopes of options and how best to handle them in; the python driver. There are four groups of commands available.; Options from the c-side Options object are accessible in the Python driver through four sets of commands. get. psi4.core.get_global_option(); psi4.core.get_local_option(); psi4.core.get_option(). set. psi4.core.set_global_option(); psi4.core.set_local_option(). has_changed. psi4.core.has_global_option_changed(); psi4.core.has_local_option_changed(); psi4.core.has_option_changed(). revoke_changed. psi4.core.revoke_global_option_changed(); psi4.core.revoke_local_option_changed(). There’s a pattern here. Setting something, either a value (set) or a; negative changed status (revoke_changed), can only be done for a specific; scope, either global or local to the specified module. Querying, either a; value (get) or a changed status (has_changed), can be done in the global; scope, in a specified local scope, or in the context of “What will the; specified module use?”. Note; “Global” in the sense of the discussion has nothing; to do with the globals section at the top of",MatchSource.WIKI,psi4manual/1.6.x/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optionshandling.html
https://psicode.org/psi4manual/1.6.x/optionshandling.html:11534,Deployability,update,updated,11534,", 'SCF_TYPE'],; ['MP2', 'WFN'],; ['DF_BASIS_SCF']). # body of function; # scf_type and wfn are freely changed, LOCALLY; # puream and df_basis_scf are freely changed, GLOBALLY; # core.scf() and core.mp2() are run. optstash.restore(). Note; Some options (BASIS, BASIS-like, and PUREAM) should always; be used globally (no module argument) with the OptionsState objects.; Similarly, within the body of the function, they should always be; queried and set globally. Same for FREEZE_CORE. Setting-Up Calculations; The other types of options calls in python driver functions are (a); those to query what option value an upcoming c++ module is going to use; (determined by user and defaults) and (b) those to set options to govern; the course of a procedure. Finding out the intended option value for a; molecule should employ the get_option() command; (and has_option_changed() for has_changed), which; requires a module for scope. (Programmer-supplied scope is needed Py-side,; whereas C-side, commands use the “active module”.); if (psi4.core.get_option(""SCF"", ""REFERENCE"") == ""RHF""):; psi4.core.set_local_option(""SCF"", ""REFERENCE"", ""RKS""). Setting of options in python should use the; set_local_option() command. Using the local, rather; than global, scope will ensure that the newly set option will be used by; the module. Otherwise, if the python procedure set in the global scope; and the user had happened to set that option in local scope, the local; user option will take precedence against the programmer’s intent. table of contents. LibOptions: globals, locals, has_changed and all that; Declaring Options; What is has_changed ?; Reading Options in Module; Handling Options in Driver. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Programming with the Core Libraries; LibOptions: globals, locals, has_changed and all that. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optionshandling.html
https://psicode.org/psi4manual/1.6.x/optionshandling.html:1052,Integrability,rout,routine,1052,". Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Programming with the Core Libraries; LibOptions: globals, locals, has_changed and all that. LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options section. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/psi4/src/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str_i(""DATA_FILE"", ""data.dat"");; /*- The algorithm to use for the $\left<VV||VV\right>$ terms -*/; options.ad",MatchSource.WIKI,psi4manual/1.6.x/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optionshandling.html
https://psicode.org/psi4manual/1.6.x/optionshandling.html:1244,Integrability,rout,routine,1244,"ged and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options section. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/psi4/src/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str_i(""DATA_FILE"", ""data.dat"");; /*- The algorithm to use for the $\left<VV||VV\right>$ terms -*/; options.add_str(""AO_BASIS"", ""NONE"", ""NONE DISK DIRECT"");; }. In the above example, the following options are declared (in order):. An integer called PRINT with a default value of 1.; A boolean cal",MatchSource.WIKI,psi4manual/1.6.x/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optionshandling.html
https://psicode.org/psi4manual/1.6.x/optionshandling.html:415,Modifiability,plugin,plugin,415,"﻿. LibOptions: globals, locals, has_changed and all that. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Programming with the Core Libraries; LibOptions: globals, locals, has_changed and all that. LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options section. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/psi4/src/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str_i(""DATA_FILE"", ""data.dat"");; /*- The ",MatchSource.WIKI,psi4manual/1.6.x/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optionshandling.html
https://psicode.org/psi4manual/1.6.x/optionshandling.html:700,Modifiability,plugin,plugin,700,"﻿. LibOptions: globals, locals, has_changed and all that. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Programming with the Core Libraries; LibOptions: globals, locals, has_changed and all that. LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options section. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/psi4/src/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str_i(""DATA_FILE"", ""data.dat"");; /*- The ",MatchSource.WIKI,psi4manual/1.6.x/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optionshandling.html
https://psicode.org/psi4manual/1.6.x/optionshandling.html:1038,Modifiability,plugin,plugins,1038,". Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Programming with the Core Libraries; LibOptions: globals, locals, has_changed and all that. LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options section. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/psi4/src/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str_i(""DATA_FILE"", ""data.dat"");; /*- The algorithm to use for the $\left<VV||VV\right>$ terms -*/; options.ad",MatchSource.WIKI,psi4manual/1.6.x/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optionshandling.html
https://psicode.org/psi4manual/1.6.x/optionshandling.html:1092,Modifiability,plugin,plugin,1092,". Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Programming with the Core Libraries; LibOptions: globals, locals, has_changed and all that. LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options section. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/psi4/src/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str_i(""DATA_FILE"", ""data.dat"");; /*- The algorithm to use for the $\left<VV||VV\right>$ terms -*/; options.ad",MatchSource.WIKI,psi4manual/1.6.x/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optionshandling.html
https://psicode.org/psi4manual/1.6.x/optionshandling.html:7964,Performance,perform,performed,7964,"d status (revoke_changed), can only be done for a specific; scope, either global or local to the specified module. Querying, either a; value (get) or a changed status (has_changed), can be done in the global; scope, in a specified local scope, or in the context of “What will the; specified module use?”. Note; “Global” in the sense of the discussion has nothing; to do with the globals section at the top of psi4/psi4/src/read_options.cc. That; section is just a convenient place for options and associated values; that are used by most, if not all, modules. There are two primary purposes for interacting with options in the python driver. Preserving User Options (Enforcing definition [a] of has_changed); The first, less-interesting, use of retrieving user option values has; been to preserve them so that they may be restored at the end after the; procedure itself has clobbered them. By decoupling global_option and; local_option commands, this can now be performed neatly by saving at the; beginning the global and local values and the global and local; has_changed values, then restoring them at the end. Below is an example; of this procedure; don’t actually do this.; from psi4 import core. g_user_scftype = core.get_global_option('SCF_TYPE'); l_user_scftype_scf = core.get_local_option('SCF', 'SCF_TYPE'); bg_user_scftype = core.has_global_option_changed('SCF_TYPE'); bl_user_scftype_scf = core.has_local_option_changed('SCF', 'SCF_TYPE'). g_user_wfn = core.get_global_option('WFN'); l_user_wfn = core.get_local_option('MP2', 'WFN'); bg_user_wfn = core.has_global_option_changed('WFN'); bl_user_wfn = core.has_local_option_changed('MP2', 'WFN'). # body of function; # scf_type and wfn are freely changed, LOCALLY; # core.scf() and core.mp2() are run. core.set_global_option('SCF_TYPE', g_user_scftype); if not bg_user_scftype:; core.revoke_global_option_changed('SCF_TYPE'); core.set_local_option('SCF', 'SCF_TYPE', l_user_scftype_scf); if not bl_user_scftype_scf:; core.revoke_local_option",MatchSource.WIKI,psi4manual/1.6.x/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optionshandling.html
https://psicode.org/psi4manual/1.6.x/optionshandling.html:813,Security,access,accessible,813,"﻿. LibOptions: globals, locals, has_changed and all that. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Programming with the Core Libraries; LibOptions: globals, locals, has_changed and all that. LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options section. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/psi4/src/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str_i(""DATA_FILE"", ""data.dat"");; /*- The ",MatchSource.WIKI,psi4manual/1.6.x/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optionshandling.html
https://psicode.org/psi4manual/1.6.x/optionshandling.html:6477,Security,access,accessible,6477,"want to change and for the current has_changed status; (presumably reflecting whether the user has changed the value, as long as; no preceding code has corrupted that definition). The python function; then makes its changes to the option and runs any c-side modules with; those changes. Finally, just before the function returns, the options are; reset to the user’s value and has_changed status (which should now again; reflect only whether the user has changed the value). Warning; PUREAM is an exception in that its value and; has_changed() value only reflect what the user has explicitly set.; This keyword should not be queried to find out the current; PUREAM state for the active basis; use instead,; psi4.MintsHelper().basisset().has_puream(). Reading Options in Module¶. Handling Options in Driver¶; This section is about the scopes of options and how best to handle them in; the python driver. There are four groups of commands available.; Options from the c-side Options object are accessible in the Python driver through four sets of commands. get. psi4.core.get_global_option(); psi4.core.get_local_option(); psi4.core.get_option(). set. psi4.core.set_global_option(); psi4.core.set_local_option(). has_changed. psi4.core.has_global_option_changed(); psi4.core.has_local_option_changed(); psi4.core.has_option_changed(). revoke_changed. psi4.core.revoke_global_option_changed(); psi4.core.revoke_local_option_changed(). There’s a pattern here. Setting something, either a value (set) or a; negative changed status (revoke_changed), can only be done for a specific; scope, either global or local to the specified module. Querying, either a; value (get) or a changed status (has_changed), can be done in the global; scope, in a specified local scope, or in the context of “What will the; specified module use?”. Note; “Global” in the sense of the discussion has nothing; to do with the globals section at the top of psi4/psi4/src/read_options.cc. That; section is just a convenient place for",MatchSource.WIKI,psi4manual/1.6.x/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optionshandling.html
https://psicode.org/psi4manual/1.6.x/optionshandling.html:277,Usability,simpl,simplify,277,"﻿. LibOptions: globals, locals, has_changed and all that. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Programming with the Core Libraries; LibOptions: globals, locals, has_changed and all that. LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options section. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/psi4/src/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str_i(""DATA_FILE"", ""data.dat"");; /*- The ",MatchSource.WIKI,psi4manual/1.6.x/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optionshandling.html
https://psicode.org/psi4manual/1.6.x/optionshandling.html:3450,Usability,clear,clear,3450,"tive string called DATA_FILE, with a default of “data.dat” and any possible value.; A string called AO_BASIS with a default of “NONE”, and possible values of “NONE”, “DISK”, or “DIRECT”. The purpose of the “if” statement in the above read_options function is; the following. Suppose in an input file the user sets an option through; the construct set mymodule print 1 or through a set mymodule {...}; block. The first thing to happen is a call to read_options with name set; to “MYMODULE”. (Note that all user input is converted to upper case unless a; add_str_i which should be used sparingly for files.) This; call to read_options should tell the Options object only about those; options expected by the module called “mymodule”; this prevents overlap of; options between different modules.; Notice also that there’s a special comment immediately before the; declaration of each keyword. You must provide these comments for any; options you add as they will be automatically inserted into the user; manual Providing a clear description will also help you to remember what; the keywords do and how they’re used. The comments must live between the; special comment delimiters. For options that most users shouldn’t need,; add an expert flag to the comment. This will place these options in a; separate section of the user manual.; /*- comment -*/; options.add_ ...; /*- comment !expert -*/; options.add_ ... As is apparent from the examples above, comments can span multiple lines; (see PRINT), can refer to other options (through hyperlinks; see; SAVE_INFO), can refer to sections of the manual (through hyperlinks;; see DOCC), and can contain LaTeX notation (see AO_BASIS). (To get; the LaTeX subscript command, use “@@” instead of “_”.); See How to name keywords in psi4/src/read_options.cc; for guidelines on naming options. What is has_changed ?¶; There are times when we need to know whether an option was provided by the; user or if the defaults are being used. For this reason, the Options; ob",MatchSource.WIKI,psi4manual/1.6.x/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optionshandling.html
https://psicode.org/psi4manual/1.6.x/optionshandling.html:4229,Usability,guid,guidelines,4229,"t there’s a special comment immediately before the; declaration of each keyword. You must provide these comments for any; options you add as they will be automatically inserted into the user; manual Providing a clear description will also help you to remember what; the keywords do and how they’re used. The comments must live between the; special comment delimiters. For options that most users shouldn’t need,; add an expert flag to the comment. This will place these options in a; separate section of the user manual.; /*- comment -*/; options.add_ ...; /*- comment !expert -*/; options.add_ ... As is apparent from the examples above, comments can span multiple lines; (see PRINT), can refer to other options (through hyperlinks; see; SAVE_INFO), can refer to sections of the manual (through hyperlinks;; see DOCC), and can contain LaTeX notation (see AO_BASIS). (To get; the LaTeX subscript command, use “@@” instead of “_”.); See How to name keywords in psi4/src/read_options.cc; for guidelines on naming options. What is has_changed ?¶; There are times when we need to know whether an option was provided by the; user or if the defaults are being used. For this reason, the Options; object stores a boolean has_changed value, in addition to the option; value itself. A clarification of definition:. [a] has_changed DOESN’T answer “Has option been changed by the user?”; [b] has_changed DOESN’T answer “Is option now different from the default?”; [c] has_changed DOES answer “Has option value been touched at all, by user or code?”. The above items notwithstanding, psi4 code should be written so that; has_changed DOES effectively mean, “Has option been changed by the; user?”. The way to do this is to isolate and nullify any changes to; options made by the code, the difference between [a] and [c]. C-side,; there is no concern since options are essentially read-only; within the modules.; Py-side is another matter since the driver’s role is to take terse; instructions from the user and tra",MatchSource.WIKI,psi4manual/1.6.x/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optionshandling.html
https://psicode.org/psi4manual/1.6.x/optking.html:572,Availability,redundant,redundant,572,"﻿. Geometry Optimization. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; Geometry Optimization. Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, an RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified directly. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension “.intco”. See the Optimizing Minima; section for more detail. Warning; The selection of a Z-matrix input, and in particular the inclusion; of dummy atoms, has no effect on the behavior of the optimizer, which begins; from a Cartesian rep",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:711,Availability,redundant,redundant,711,"﻿. Geometry Optimization. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; Geometry Optimization. Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, an RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified directly. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension “.intco”. See the Optimizing Minima; section for more detail. Warning; The selection of a Z-matrix input, and in particular the inclusion; of dummy atoms, has no effect on the behavior of the optimizer, which begins; from a Cartesian rep",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:1022,Availability,redundant,redundant,1022,"ptimization. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; Geometry Optimization. Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, an RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified directly. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension “.intco”. See the Optimizing Minima; section for more detail. Warning; The selection of a Z-matrix input, and in particular the inclusion; of dummy atoms, has no effect on the behavior of the optimizer, which begins; from a Cartesian representation o",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:4879,Availability,avail,available,4879,"nternal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:. set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:. set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:5053,Availability,avail,available,5053,"1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:. set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:. set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:5298,Availability,avail,available,5298," Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:. set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:. set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Optimize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; molecule {; H; O 1 0.90; O 2 1.4",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:7841,Availability,robust,robustness,7841,"stance between; atoms 1 and 3, as well as that between 2 and 4. set optking {; fixed_distance = (""; 1 3 0.95; 2 4 0.95; ""); }. Note that the effect of the frozen and fixed keywords is independent of; how the geometry of the molecule was input (whether Z-matrix or cartesian, etc.).. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH. molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDIN",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:8590,Availability,robust,robust,8590,"(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals. Direct manipulation of the optmization coordinates¶. Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3; C 1; 1 1.000000; C 1; 2 1.000000; C 1; 3 1.000000. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. Th",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:8893,Availability,redundant,redundant,8893,"minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals. Direct manipulation of the optmization coordinates¶. Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3; C 1; 1 1.000000; C 1; 2 1.000000; C 1; 3 1.000000. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. The lines below the simple internal coordinates; specify linear combinations of coordinates. In the simplest default case, the lines; above simply define combination coordinates which are identical to the simple internals.; If OPT_COORDINATES specifies delocalized coordinates, then the combinations; will be more comple",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:11547,Availability,avail,available,11547,") a value that is not satisfied by the; initial structure, then the value is added to the end of the line. The following; corresponds to an optimization that will add additional forces to move the O-H bonds; to 1.70 au.; F 1 3; R 1 2 1.70; R 1 3 1.70; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4¶. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE 4. \(4.5 \times 10^{-3}\); \(3.0 \times 10^{-3}\); \(5.4 \times 10^{-3}\); \(3.6 \times 10^{-3}\). GAU_LOOSE 6. \(2.5 \times 10^{-3}\); \(1.7 \times 10^{-3}\); \(1.0 \times 10^{-2}\); \(6.7 \times 10^{-3}\). TURBOMOLE 4; \(1.0 \times 10^{-6}\); \(1.0 \times 10^{-3}\); \(5.0 \times 10^{-4}\); \(1.0 \times 10^{-3}\); \(5.0 \times 10^{-4}\). GAU 3 6. \(4.5 \times 10^{-4}\); \(3.0 \times 10^{-4}\); \(1.8 \times 10^{-3}\); \(1.2 \times 10^{-3}\). CFOUR 4. \(1.0 \times 10^{-4}\). QCHEM 1 5; \(1.0 \times 10^{-6}\); \(3.0 \times 10^{-4}\). \(1.2 \times 10^{-3}\). MOLPRO 2 5; \(1.0 \times 10^{-6}\); \(3.0 \times 10^{-4}\). \(3.0 \times 10^{-4}\). INTERFRAG_TIGHT 7; \(1.0 \times 10^{-6}\); \(1.5 \times 10^{-5}\); \(1.0 \times 10^{-5}\); \(6.0 \times 10^{-4}\); \(4.0 \times 10^{-4}\). GAU_TIGHT 3 6. \(1.5 \times 10^{-5}\); \(1.0 \times 10^{-5}\); \(6.0 \times 10^{-5}\); \(4.0 \tim",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:638,Deployability,update,update,638,"﻿. Geometry Optimization. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; Geometry Optimization. Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, an RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified directly. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension “.intco”. See the Optimizing Minima; section for more detail. Warning; The selection of a Z-matrix input, and in particular the inclusion; of dummy atoms, has no effect on the behavior of the optimizer, which begins; from a Cartesian rep",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:5279,Deployability,update,update,5279," Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:. set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:. set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Optimize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; molecule {; H; O 1 0.90; O 2 1.4",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:7814,Deployability,continuous,continuously,7814,"stance between; atoms 1 and 3, as well as that between 2 and 4. set optking {; fixed_distance = (""; 1 3 0.95; 2 4 0.95; ""); }. Note that the effect of the frozen and fixed keywords is independent of; how the geometry of the molecule was input (whether Z-matrix or cartesian, etc.).. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH. molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDIN",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:18040,Deployability,update,updated,18040," engine='geometric', optimizer_keywords=geometric_keywords). Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). table of contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY; INTCOS_GENERATE_EXIT. Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Dealing with problematic optimizations; Direct manipulation of the optmization coordinates; Convergence Criteria; Interface to GeomeTRIC; Output. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; Geometry Optimization. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:4391,Energy Efficiency,energy,energy,4391," Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, INTERFRAG_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:. set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:. set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed dur",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:4453,Energy Efficiency,energy,energy,4453," Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, INTERFRAG_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:. set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:. set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed dur",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:7154,Energy Efficiency,energy,energy,7154,"ize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; molecule {; H; O 1 0.90; O 2 1.40 1 100.0; H 3 0.90 2 100.0 1 90.0; }. set optking {; frozen_dihedral = (""; 1 2 3 4; ""); }; optimize('scf'). To instead freeze the two O-H bond distances; set optking {; frozen_distance = (""; 1 2; 3 4; ""); }. For bends, the corresponding keyword is “frozen_bend”. To freeze the cartesian coordinates of atom 2. freeze_list = """"""; 2 xyz; """"""; set optking frozen_cartesian $freeze_list. To freeze only the y coordinates of atoms 2 and 3. freeze_list = """"""; 2 y; 3 y; """"""; set optking frozen_cartesian $freeze_list. To optimize toward a value of 0.95 Angstroms for the distance between; atoms 1 and 3, as well as that between 2 and 4. set optking {; fixed_distance = (""; 1 3 0.95; 2 4 0.95; ""); }. Note that the effect of the frozen and fixed keywords is independent of; how the geometry of the molecule was input (whether Z-matrix or cartesian, etc.).. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH. molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:7655,Energy Efficiency,energy,energy,7655,"e only the y coordinates of atoms 2 and 3. freeze_list = """"""; 2 y; 3 y; """"""; set optking frozen_cartesian $freeze_list. To optimize toward a value of 0.95 Angstroms for the distance between; atoms 1 and 3, as well as that between 2 and 4. set optking {; fixed_distance = (""; 1 3 0.95; 2 4 0.95; ""); }. Note that the effect of the frozen and fixed keywords is independent of; how the geometry of the molecule was input (whether Z-matrix or cartesian, etc.).. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH. molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow back",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:8194,Energy Efficiency,efficient,efficiently,8194,"veral fixed values; of the dihedral angle of HOOH. molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals. Direct manipulation of the optmization coordinates¶. Generate the internal coordinates and then stop:; set intcos_",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:8412,Energy Efficiency,efficient,efficient,8412,"3468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals. Direct manipulation of the optmization coordinates¶. Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3; C 1; 1 1.000000; C 1; 2 1.000000; C 1;",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:8640,Energy Efficiency,reduce,reduce,8640,"\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals. Direct manipulation of the optmization coordinates¶. Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3; C 1; 1 1.000000; C 1; 2 1.000000; C 1; 3 1.000000. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. The lines below the simple internal coordinates; specify linear combinations of coordinates. I",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:10823,Energy Efficiency,monitor,monitors,10823," OPT_COORDINATES specifies delocalized coordinates, then the combinations; will be more complex.; Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen by adding an asterisk after the letter of the coordinate. The; asterisk results in that internal coordinate being frozen at its initial value. The; “intco” file below for water specifies an optimization with both O-H bonds frozen.:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. If one instead wishes to optimize toward (“fix”) a value that is not satisfied by the; initial structure, then the value is added to the end of the line. The following; corresponds to an optimization that will add additional forces to move the O-H bonds; to 1.70 au.; F 1 3; R 1 2 1.70; R 1 3 1.70; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4¶. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE 4. \(4.5 \times 10^{-3}\); \(3.0 \times 10^{-3}\); \(5.4 \times 10^{-3}\); \(3.6 \times 10^{-3}\). GAU_LOOSE 6. \(2.5 \times 10^{-3}\); \(1.7 \times 10^{-3}\); \(1.0 \times 10^{-2}\); \(6.7 \times ",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:10948,Energy Efficiency,energy,energy,10948,"RAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen by adding an asterisk after the letter of the coordinate. The; asterisk results in that internal coordinate being frozen at its initial value. The; “intco” file below for water specifies an optimization with both O-H bonds frozen.:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. If one instead wishes to optimize toward (“fix”) a value that is not satisfied by the; initial structure, then the value is added to the end of the line. The following; corresponds to an optimization that will add additional forces to move the O-H bonds; to 1.70 au.; F 1 3; R 1 2 1.70; R 1 3 1.70; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4¶. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE 4. \(4.5 \times 10^{-3}\); \(3.0 \times 10^{-3}\); \(5.4 \times 10^{-3}\); \(3.6 \times 10^{-3}\). GAU_LOOSE 6. \(2.5 \times 10^{-3}\); \(1.7 \times 10^{-3}\); \(1.0 \times 10^{-2}\); \(6.7 \times 10^{-3}\). TURBOMOLE 4; \(1.0 \times 10^{-6}\); \(1.0 \times 10^{-3}\); \(5.0 \times 10^{-4}\); \(1.0 \times 10^{-3}\); \(5.0 \times 10^{-4}\). GAU 3 6. \(4.5 \times 10^{-4}\); \(3.0 \times 10^{-4}\); \(1.8 \times 10^{-3}\); \(1.2 \times 10^{-3}\). C",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:13504,Energy Efficiency,monitor,monitored,13504," \times 10^{-5}\). GAU_VERYTIGHT 6. \(2.0 \times 10^{-6}\); \(1.0 \times 10^{-6}\); \(6.0 \times 10^{-6}\); \(4.0 \times 10^{-6}\). Footnotes. 1; Default. 2; Baker convergence criteria are the same. 3(1,2); Counterpart NWCHEM convergence criteria are the same. 4(1,2,3); Convergence achieved when all active criteria are fulfilled. 5(1,2,3); Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. 6(1,2,3,4,5); Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100\(\times\)rms force is less; than RMS Force criterion. 7; Compensates for difficulties in converging geometry optmizations of supermolecular complexes; tightly, where large rms disp and max disp may result from flat potential surfaces even when; max force and/or rms force are small. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes 5 and 6; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Interface to GeomeTRIC¶; The GeomeTRIC optimizer developed by Wang and Song [Wang:2016:214108] may be used in place of; Psi4’s native Optking optimizer. GeomeTRIC uses a translation-rotation-internal coordinate (TRIC); system that works well for optimizing geometries of systems containing noncovalent interactions.; Use of the GeomeTRIC optimizer is specified with the engine argument to; optimize(). The optimization will respect the keywords G_CONVERGENCE; and GEOM_MAXITER. Any other GeomeTRIC-specific options (including constraints); may be specified with the optimizer_keywords argument to optimize().; Constraints may be placed on cartesian coordinates, bonds, angles, an",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:16231,Energy Efficiency,monitor,monitored,16231,"ndices' : [0, 1],; 'value' : 2.0 },; {'type' : 'angle',; 'indices' : [1, 0, 2],; 'value' : 104.5 }]; }; }. optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords). Optimize the benzene/water dimer using GeomeTRIC, with the 6 carbon atoms of benzene frozen in; place:; molecule h2o {; C 0.833 1.221 -0.504; H 1.482 2.086 -0.518; C 1.379 -0.055 -0.486; H 2.453 -0.184 -0.483; C 0.546 -1.167 -0.474; H 0.971 -2.162 -0.466; C -0.833 -1.001 -0.475; H -1.482 -1.867 -0.468; C -1.379 0.275 -0.490; H -2.453 0.404 -0.491; C -0.546 1.386 -0.506; H -0.971 2.381 -0.524; --; O 0.000 0.147 3.265; H 0.000 -0.505 2.581; H 0.000 0.965 2.790; no_com; no_reorient; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = {; 'coordsys' : 'tric',; 'constraints' : {; 'freeze' : [{'type' : 'xyz',; 'indices' : [0, 2, 4, 6, 8, 10]}]; }; }. optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords). Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:322,Performance,optimiz,optimizations,322,"﻿. Geometry Optimization. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; Geometry Optimization. Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, an RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified directly. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension “.intco”. See the Optimizing Minima; section for more detail. Warning; The selection of a Z-matrix input, and in particular the inclusion; of dummy atoms, has no effect on the behavior of the optimizer, which begins; from a Cartesian rep",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:1956,Performance,optimiz,optimizer,1956,"9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified directly. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension “.intco”. See the Optimizing Minima; section for more detail. Warning; The selection of a Z-matrix input, and in particular the inclusion; of dummy atoms, has no effect on the behavior of the optimizer, which begins; from a Cartesian representation of the system. The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimi",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:2920,Performance,optimiz,optimization,2920," optimizer, which begins; from a Cartesian representation of the system. The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, INTERFRAG_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:3120,Performance,optimiz,optimization,3120,"ich connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, INTERFRAG_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basi",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:3191,Performance,optimiz,optimization,3191,"ragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, INTERFRAG_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:3667,Performance,optimiz,optimization,3667,"rent default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, INTERFRAG_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:. set {; int",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:4265,Performance,optimiz,optimize,4265,"NVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, INTERFRAG_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:. set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:. set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:4359,Performance,optimiz,optimize,4359,"here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, INTERFRAG_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:. set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:. set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; ",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:4428,Performance,optimiz,optimize,4428," Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, INTERFRAG_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:. set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:. set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed dur",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:4551,Performance,optimiz,optimize,4551,"efault: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:. set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:. set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a star",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:4721,Performance,optimiz,optimize,4721,"means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:. set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:. set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:4816,Performance,optimiz,optimize,4816," to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:. set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:. set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_ever",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:5426,Performance,optimiz,optimization,5426,"timize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:. set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:. set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Optimize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; molecule {; H; O 1 0.90; O 2 1.40 1 100.0; H 3 0.90 2 100.0 1 90.0; }. set optking {; frozen_dihedral = (""; 1 2 3 4; ""); }; optimize('scf'). To instead freeze the two O-H bond dista",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:5575,Performance,optimiz,optimize,5575,"mit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:. set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Optimize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; molecule {; H; O 1 0.90; O 2 1.40 1 100.0; H 3 0.90 2 100.0 1 90.0; }. set optking {; frozen_dihedral = (""; 1 2 3 4; ""); }; optimize('scf'). To instead freeze the two O-H bond distances; set optking {; frozen_distance = (""; 1 2; 3 4; ""); }. For bends, the corresponding keyword is “frozen_bend”. To freeze the cartesian coordinates of atom 2. freeze_list = """"""; 2 xyz; """"""; set optking frozen_cartesia",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:5833,Performance,optimiz,optimize,5833,"¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Optimize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; molecule {; H; O 1 0.90; O 2 1.40 1 100.0; H 3 0.90 2 100.0 1 90.0; }. set optking {; frozen_dihedral = (""; 1 2 3 4; ""); }; optimize('scf'). To instead freeze the two O-H bond distances; set optking {; frozen_distance = (""; 1 2; 3 4; ""); }. For bends, the corresponding keyword is “frozen_bend”. To freeze the cartesian coordinates of atom 2. freeze_list = """"""; 2 xyz; """"""; set optking frozen_cartesian $freeze_list. To freeze only the y coordinates of atoms 2 and 3. freeze_list = """"""; 2 y; 3 y; """"""; set optking frozen_cartesian $freeze_list. To optimize toward a value of 0.95 Angstroms fo",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:6162,Performance,optimiz,optimize,6162,"Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Optimize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; molecule {; H; O 1 0.90; O 2 1.40 1 100.0; H 3 0.90 2 100.0 1 90.0; }. set optking {; frozen_dihedral = (""; 1 2 3 4; ""); }; optimize('scf'). To instead freeze the two O-H bond distances; set optking {; frozen_distance = (""; 1 2; 3 4; ""); }. For bends, the corresponding keyword is “frozen_bend”. To freeze the cartesian coordinates of atom 2. freeze_list = """"""; 2 xyz; """"""; set optking frozen_cartesian $freeze_list. To freeze only the y coordinates of atoms 2 and 3. freeze_list = """"""; 2 y; 3 y; """"""; set optking frozen_cartesian $freeze_list. To optimize toward a value of 0.95 Angstroms for the distance between; atoms 1 and 3, as well as that between 2 and 4. set optking {; fixed_distance = (""; 1 3 0.95; 2 4 0.95; ""); }. Note that the effect of the frozen and fixed keywords is independent of; how the geometry of the molecule was input (whether Z-matrix or cartesian, etc.).. To scan the potential energy",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:6373,Performance,optimiz,optimize,6373,"MQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Optimize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; molecule {; H; O 1 0.90; O 2 1.40 1 100.0; H 3 0.90 2 100.0 1 90.0; }. set optking {; frozen_dihedral = (""; 1 2 3 4; ""); }; optimize('scf'). To instead freeze the two O-H bond distances; set optking {; frozen_distance = (""; 1 2; 3 4; ""); }. For bends, the corresponding keyword is “frozen_bend”. To freeze the cartesian coordinates of atom 2. freeze_list = """"""; 2 xyz; """"""; set optking frozen_cartesian $freeze_list. To freeze only the y coordinates of atoms 2 and 3. freeze_list = """"""; 2 y; 3 y; """"""; set optking frozen_cartesian $freeze_list. To optimize toward a value of 0.95 Angstroms for the distance between; atoms 1 and 3, as well as that between 2 and 4. set optking {; fixed_distance = (""; 1 3 0.95; 2 4 0.95; ""); }. Note that the effect of the frozen and fixed keywords is independent of; how the geometry of the molecule was input (whether Z-matrix or cartesian, etc.).. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH. molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503;",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:6797,Performance,optimiz,optimize,6797,"very 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Optimize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; molecule {; H; O 1 0.90; O 2 1.40 1 100.0; H 3 0.90 2 100.0 1 90.0; }. set optking {; frozen_dihedral = (""; 1 2 3 4; ""); }; optimize('scf'). To instead freeze the two O-H bond distances; set optking {; frozen_distance = (""; 1 2; 3 4; ""); }. For bends, the corresponding keyword is “frozen_bend”. To freeze the cartesian coordinates of atom 2. freeze_list = """"""; 2 xyz; """"""; set optking frozen_cartesian $freeze_list. To freeze only the y coordinates of atoms 2 and 3. freeze_list = """"""; 2 y; 3 y; """"""; set optking frozen_cartesian $freeze_list. To optimize toward a value of 0.95 Angstroms for the distance between; atoms 1 and 3, as well as that between 2 and 4. set optking {; fixed_distance = (""; 1 3 0.95; 2 4 0.95; ""); }. Note that the effect of the frozen and fixed keywords is independent of; how the geometry of the molecule was input (whether Z-matrix or cartesian, etc.).. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH. molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:7172,Performance,optimiz,optimizing,7172,"ize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; molecule {; H; O 1 0.90; O 2 1.40 1 100.0; H 3 0.90 2 100.0 1 90.0; }. set optking {; frozen_dihedral = (""; 1 2 3 4; ""); }; optimize('scf'). To instead freeze the two O-H bond distances; set optking {; frozen_distance = (""; 1 2; 3 4; ""); }. For bends, the corresponding keyword is “frozen_bend”. To freeze the cartesian coordinates of atom 2. freeze_list = """"""; 2 xyz; """"""; set optking frozen_cartesian $freeze_list. To freeze only the y coordinates of atoms 2 and 3. freeze_list = """"""; 2 y; 3 y; """"""; set optking frozen_cartesian $freeze_list. To optimize toward a value of 0.95 Angstroms for the distance between; atoms 1 and 3, as well as that between 2 and 4. set optking {; fixed_distance = (""; 1 3 0.95; 2 4 0.95; ""); }. Note that the effect of the frozen and fixed keywords is independent of; how the geometry of the molecule was input (whether Z-matrix or cartesian, etc.).. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH. molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:7593,Performance,optimiz,optimize,7593,"eze the cartesian coordinates of atom 2. freeze_list = """"""; 2 xyz; """"""; set optking frozen_cartesian $freeze_list. To freeze only the y coordinates of atoms 2 and 3. freeze_list = """"""; 2 y; 3 y; """"""; set optking frozen_cartesian $freeze_list. To optimize toward a value of 0.95 Angstroms for the distance between; atoms 1 and 3, as well as that between 2 and 4. set optking {; fixed_distance = (""; 1 3 0.95; 2 4 0.95; ""); }. Note that the effect of the frozen and fixed keywords is independent of; how the geometry of the molecule was input (whether Z-matrix or cartesian, etc.).. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH. molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase th",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:7778,Performance,optimiz,optimizations,7778,"stance between; atoms 1 and 3, as well as that between 2 and 4. set optking {; fixed_distance = (""; 1 3 0.95; 2 4 0.95; ""); }. Note that the effect of the frozen and fixed keywords is independent of; how the geometry of the molecule was input (whether Z-matrix or cartesian, etc.).. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH. molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDIN",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:7877,Performance,optimiz,optimizations,7877,"stance between; atoms 1 and 3, as well as that between 2 and 4. set optking {; fixed_distance = (""; 1 3 0.95; 2 4 0.95; ""); }. Note that the effect of the frozen and fixed keywords is independent of; how the geometry of the molecule was input (whether Z-matrix or cartesian, etc.).. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH. molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDIN",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:8016,Performance,optimiz,optimizer,8016," the molecule was input (whether Z-matrix or cartesian, etc.).. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH. molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local intern",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:8186,Performance,perform,perform,8186,"veral fixed values; of the dihedral angle of HOOH. molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals. Direct manipulation of the optmization coordinates¶. Generate the internal coordinates and then stop:; set intcos_",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:8357,Performance,optimiz,optimization,8357,"3468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals. Direct manipulation of the optmization coordinates¶. Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3; C 1; 1 1.000000; C 1; 2 1.000000; C 1;",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:9208,Performance,optimiz,optimize,9208,"cause they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals. Direct manipulation of the optmization coordinates¶. Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3; C 1; 1 1.000000; C 1; 2 1.000000; C 1; 3 1.000000. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. The lines below the simple internal coordinates; specify linear combinations of coordinates. In the simplest default case, the lines; above simply define combination coordinates which are identical to the simple internals.; If OPT_COORDINATES specifies delocalized coordinates, then the combinations; will be more complex.; Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment syst",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:9605,Performance,optimiz,optimizations,9605,"rms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals. Direct manipulation of the optmization coordinates¶. Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3; C 1; 1 1.000000; C 1; 2 1.000000; C 1; 3 1.000000. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. The lines below the simple internal coordinates; specify linear combinations of coordinates. In the simplest default case, the lines; above simply define combination coordinates which are identical to the simple internals.; If OPT_COORDINATES specifies delocalized coordinates, then the combinations; will be more complex.; Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen by adding an asterisk after the letter of the coordinate. The; asterisk results in that internal coordinate being frozen at its initial value. The; “intco” file below for water specifies an optimization with both O-H bonds frozen.:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. If one instead wishes to optimize toward (“fix”) a value that is not satisfied by the; initial ",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:10409,Performance,optimiz,optimization,10409,"line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. The lines below the simple internal coordinates; specify linear combinations of coordinates. In the simplest default case, the lines; above simply define combination coordinates which are identical to the simple internals.; If OPT_COORDINATES specifies delocalized coordinates, then the combinations; will be more complex.; Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen by adding an asterisk after the letter of the coordinate. The; asterisk results in that internal coordinate being frozen at its initial value. The; “intco” file below for water specifies an optimization with both O-H bonds frozen.:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. If one instead wishes to optimize toward (“fix”) a value that is not satisfied by the; initial structure, then the value is added to the end of the line. The following; corresponds to an optimization that will add additional forces to move the O-H bonds; to 1.70 au.; F 1 3; R 1 2 1.70; R 1 3 1.70; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; ",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:10509,Performance,optimiz,optimize,10509,"fied, and if present,; is used in subsequent optimizations. The lines below the simple internal coordinates; specify linear combinations of coordinates. In the simplest default case, the lines; above simply define combination coordinates which are identical to the simple internals.; If OPT_COORDINATES specifies delocalized coordinates, then the combinations; will be more complex.; Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen by adding an asterisk after the letter of the coordinate. The; asterisk results in that internal coordinate being frozen at its initial value. The; “intco” file below for water specifies an optimization with both O-H bonds frozen.:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. If one instead wishes to optimize toward (“fix”) a value that is not satisfied by the; initial structure, then the value is added to the end of the line. The following; corresponds to an optimization that will add additional forces to move the O-H bonds; to 1.70 au.; F 1 3; R 1 2 1.70; R 1 3 1.70; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in ",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:10671,Performance,optimiz,optimization,10671,"ations of coordinates. In the simplest default case, the lines; above simply define combination coordinates which are identical to the simple internals.; If OPT_COORDINATES specifies delocalized coordinates, then the combinations; will be more complex.; Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen by adding an asterisk after the letter of the coordinate. The; asterisk results in that internal coordinate being frozen at its initial value. The; “intco” file below for water specifies an optimization with both O-H bonds frozen.:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. If one instead wishes to optimize toward (“fix”) a value that is not satisfied by the; initial structure, then the value is added to the end of the line. The following; corresponds to an optimization that will add additional forces to move the O-H bonds; to 1.70 au.; F 1 3; R 1 2 1.70; R 1 3 1.70; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4¶. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE 4. \(4.5 \times 10^{-3}\); \(3.0 \times 10",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:10888,Performance,optimiz,optimization,10888," OPT_COORDINATES specifies delocalized coordinates, then the combinations; will be more complex.; Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen by adding an asterisk after the letter of the coordinate. The; asterisk results in that internal coordinate being frozen at its initial value. The; “intco” file below for water specifies an optimization with both O-H bonds frozen.:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. If one instead wishes to optimize toward (“fix”) a value that is not satisfied by the; initial structure, then the value is added to the end of the line. The following; corresponds to an optimization that will add additional forces to move the O-H bonds; to 1.70 au.; F 1 3; R 1 2 1.70; R 1 3 1.70; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4¶. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE 4. \(4.5 \times 10^{-3}\); \(3.0 \times 10^{-3}\); \(5.4 \times 10^{-3}\); \(3.6 \times 10^{-3}\). GAU_LOOSE 6. \(2.5 \times 10^{-3}\); \(1.7 \times 10^{-3}\); \(1.0 \times 10^{-2}\); \(6.7 \times ",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:11525,Performance,optimiz,optimization,11525,") a value that is not satisfied by the; initial structure, then the value is added to the end of the line. The following; corresponds to an optimization that will add additional forces to move the O-H bonds; to 1.70 au.; F 1 3; R 1 2 1.70; R 1 3 1.70; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4¶. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE 4. \(4.5 \times 10^{-3}\); \(3.0 \times 10^{-3}\); \(5.4 \times 10^{-3}\); \(3.6 \times 10^{-3}\). GAU_LOOSE 6. \(2.5 \times 10^{-3}\); \(1.7 \times 10^{-3}\); \(1.0 \times 10^{-2}\); \(6.7 \times 10^{-3}\). TURBOMOLE 4; \(1.0 \times 10^{-6}\); \(1.0 \times 10^{-3}\); \(5.0 \times 10^{-4}\); \(1.0 \times 10^{-3}\); \(5.0 \times 10^{-4}\). GAU 3 6. \(4.5 \times 10^{-4}\); \(3.0 \times 10^{-4}\); \(1.8 \times 10^{-3}\); \(1.2 \times 10^{-3}\). CFOUR 4. \(1.0 \times 10^{-4}\). QCHEM 1 5; \(1.0 \times 10^{-6}\); \(3.0 \times 10^{-4}\). \(1.2 \times 10^{-3}\). MOLPRO 2 5; \(1.0 \times 10^{-6}\); \(3.0 \times 10^{-4}\). \(3.0 \times 10^{-4}\). INTERFRAG_TIGHT 7; \(1.0 \times 10^{-6}\); \(1.5 \times 10^{-5}\); \(1.0 \times 10^{-5}\); \(6.0 \times 10^{-4}\); \(4.0 \times 10^{-4}\). GAU_TIGHT 3 6. \(1.5 \times 10^{-5}\); \(1.0 \times 10^{-5}\); \(6.0 \times 10^{-5}\); \(4.0 \tim",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:13887,Performance,optimiz,optimizer,13887,"gy or Max Disp are fulfilled. 6(1,2,3,4,5); Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100\(\times\)rms force is less; than RMS Force criterion. 7; Compensates for difficulties in converging geometry optmizations of supermolecular complexes; tightly, where large rms disp and max disp may result from flat potential surfaces even when; max force and/or rms force are small. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes 5 and 6; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Interface to GeomeTRIC¶; The GeomeTRIC optimizer developed by Wang and Song [Wang:2016:214108] may be used in place of; Psi4’s native Optking optimizer. GeomeTRIC uses a translation-rotation-internal coordinate (TRIC); system that works well for optimizing geometries of systems containing noncovalent interactions.; Use of the GeomeTRIC optimizer is specified with the engine argument to; optimize(). The optimization will respect the keywords G_CONVERGENCE; and GEOM_MAXITER. Any other GeomeTRIC-specific options (including constraints); may be specified with the optimizer_keywords argument to optimize().; Constraints may be placed on cartesian coordinates, bonds, angles, and dihedrals, and they can be; used to either freeze a coordinate or set it to a specific value. See the GeomeTRIC github; for more information on keywords and JSON specification of constraints. Optimize the water molecule using GeomeTRIC:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. optimize('hf/cc-pvdz', engine='geometric'). Optimize the water mole",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:13990,Performance,optimiz,optimizer,13990,"gy or Max Disp are fulfilled. 6(1,2,3,4,5); Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100\(\times\)rms force is less; than RMS Force criterion. 7; Compensates for difficulties in converging geometry optmizations of supermolecular complexes; tightly, where large rms disp and max disp may result from flat potential surfaces even when; max force and/or rms force are small. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes 5 and 6; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Interface to GeomeTRIC¶; The GeomeTRIC optimizer developed by Wang and Song [Wang:2016:214108] may be used in place of; Psi4’s native Optking optimizer. GeomeTRIC uses a translation-rotation-internal coordinate (TRIC); system that works well for optimizing geometries of systems containing noncovalent interactions.; Use of the GeomeTRIC optimizer is specified with the engine argument to; optimize(). The optimization will respect the keywords G_CONVERGENCE; and GEOM_MAXITER. Any other GeomeTRIC-specific options (including constraints); may be specified with the optimizer_keywords argument to optimize().; Constraints may be placed on cartesian coordinates, bonds, angles, and dihedrals, and they can be; used to either freeze a coordinate or set it to a specific value. See the GeomeTRIC github; for more information on keywords and JSON specification of constraints. Optimize the water molecule using GeomeTRIC:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. optimize('hf/cc-pvdz', engine='geometric'). Optimize the water mole",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:14094,Performance,optimiz,optimizing,14094,"To help with flat; potential surfaces, alternate convergence achieved when 100\(\times\)rms force is less; than RMS Force criterion. 7; Compensates for difficulties in converging geometry optmizations of supermolecular complexes; tightly, where large rms disp and max disp may result from flat potential surfaces even when; max force and/or rms force are small. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes 5 and 6; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Interface to GeomeTRIC¶; The GeomeTRIC optimizer developed by Wang and Song [Wang:2016:214108] may be used in place of; Psi4’s native Optking optimizer. GeomeTRIC uses a translation-rotation-internal coordinate (TRIC); system that works well for optimizing geometries of systems containing noncovalent interactions.; Use of the GeomeTRIC optimizer is specified with the engine argument to; optimize(). The optimization will respect the keywords G_CONVERGENCE; and GEOM_MAXITER. Any other GeomeTRIC-specific options (including constraints); may be specified with the optimizer_keywords argument to optimize().; Constraints may be placed on cartesian coordinates, bonds, angles, and dihedrals, and they can be; used to either freeze a coordinate or set it to a specific value. See the GeomeTRIC github; for more information on keywords and JSON specification of constraints. Optimize the water molecule using GeomeTRIC:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. optimize('hf/cc-pvdz', engine='geometric'). Optimize the water molecule using GeomeTRIC, with one of the two OH bonds constrained to 2.0 au; and the HOH angle constrained to 104.5 degrees:; molecule h2o {; O; H 1 1.0; H 1 1.0",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:14186,Performance,optimiz,optimizer,14186,"terion. 7; Compensates for difficulties in converging geometry optmizations of supermolecular complexes; tightly, where large rms disp and max disp may result from flat potential surfaces even when; max force and/or rms force are small. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes 5 and 6; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Interface to GeomeTRIC¶; The GeomeTRIC optimizer developed by Wang and Song [Wang:2016:214108] may be used in place of; Psi4’s native Optking optimizer. GeomeTRIC uses a translation-rotation-internal coordinate (TRIC); system that works well for optimizing geometries of systems containing noncovalent interactions.; Use of the GeomeTRIC optimizer is specified with the engine argument to; optimize(). The optimization will respect the keywords G_CONVERGENCE; and GEOM_MAXITER. Any other GeomeTRIC-specific options (including constraints); may be specified with the optimizer_keywords argument to optimize().; Constraints may be placed on cartesian coordinates, bonds, angles, and dihedrals, and they can be; used to either freeze a coordinate or set it to a specific value. See the GeomeTRIC github; for more information on keywords and JSON specification of constraints. Optimize the water molecule using GeomeTRIC:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. optimize('hf/cc-pvdz', engine='geometric'). Optimize the water molecule using GeomeTRIC, with one of the two OH bonds constrained to 2.0 au; and the HOH angle constrained to 104.5 degrees:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = {; 'coordsys' : 'tric',; 'constraints' : {; 'set",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:14238,Performance,optimiz,optimize,14238,"terion. 7; Compensates for difficulties in converging geometry optmizations of supermolecular complexes; tightly, where large rms disp and max disp may result from flat potential surfaces even when; max force and/or rms force are small. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes 5 and 6; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Interface to GeomeTRIC¶; The GeomeTRIC optimizer developed by Wang and Song [Wang:2016:214108] may be used in place of; Psi4’s native Optking optimizer. GeomeTRIC uses a translation-rotation-internal coordinate (TRIC); system that works well for optimizing geometries of systems containing noncovalent interactions.; Use of the GeomeTRIC optimizer is specified with the engine argument to; optimize(). The optimization will respect the keywords G_CONVERGENCE; and GEOM_MAXITER. Any other GeomeTRIC-specific options (including constraints); may be specified with the optimizer_keywords argument to optimize().; Constraints may be placed on cartesian coordinates, bonds, angles, and dihedrals, and they can be; used to either freeze a coordinate or set it to a specific value. See the GeomeTRIC github; for more information on keywords and JSON specification of constraints. Optimize the water molecule using GeomeTRIC:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. optimize('hf/cc-pvdz', engine='geometric'). Optimize the water molecule using GeomeTRIC, with one of the two OH bonds constrained to 2.0 au; and the HOH angle constrained to 104.5 degrees:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = {; 'coordsys' : 'tric',; 'constraints' : {; 'set",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:14254,Performance,optimiz,optimization,14254,"permolecular complexes; tightly, where large rms disp and max disp may result from flat potential surfaces even when; max force and/or rms force are small. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes 5 and 6; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Interface to GeomeTRIC¶; The GeomeTRIC optimizer developed by Wang and Song [Wang:2016:214108] may be used in place of; Psi4’s native Optking optimizer. GeomeTRIC uses a translation-rotation-internal coordinate (TRIC); system that works well for optimizing geometries of systems containing noncovalent interactions.; Use of the GeomeTRIC optimizer is specified with the engine argument to; optimize(). The optimization will respect the keywords G_CONVERGENCE; and GEOM_MAXITER. Any other GeomeTRIC-specific options (including constraints); may be specified with the optimizer_keywords argument to optimize().; Constraints may be placed on cartesian coordinates, bonds, angles, and dihedrals, and they can be; used to either freeze a coordinate or set it to a specific value. See the GeomeTRIC github; for more information on keywords and JSON specification of constraints. Optimize the water molecule using GeomeTRIC:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. optimize('hf/cc-pvdz', engine='geometric'). Optimize the water molecule using GeomeTRIC, with one of the two OH bonds constrained to 2.0 au; and the HOH angle constrained to 104.5 degrees:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = {; 'coordsys' : 'tric',; 'constraints' : {; 'set' : [{'type' : 'distance',; 'indices' : [0, 1],; 'value' : 2.0 },; {'type' : 'ang",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:14445,Performance,optimiz,optimize,14445,"ces even when; max force and/or rms force are small. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes 5 and 6; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Interface to GeomeTRIC¶; The GeomeTRIC optimizer developed by Wang and Song [Wang:2016:214108] may be used in place of; Psi4’s native Optking optimizer. GeomeTRIC uses a translation-rotation-internal coordinate (TRIC); system that works well for optimizing geometries of systems containing noncovalent interactions.; Use of the GeomeTRIC optimizer is specified with the engine argument to; optimize(). The optimization will respect the keywords G_CONVERGENCE; and GEOM_MAXITER. Any other GeomeTRIC-specific options (including constraints); may be specified with the optimizer_keywords argument to optimize().; Constraints may be placed on cartesian coordinates, bonds, angles, and dihedrals, and they can be; used to either freeze a coordinate or set it to a specific value. See the GeomeTRIC github; for more information on keywords and JSON specification of constraints. Optimize the water molecule using GeomeTRIC:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. optimize('hf/cc-pvdz', engine='geometric'). Optimize the water molecule using GeomeTRIC, with one of the two OH bonds constrained to 2.0 au; and the HOH angle constrained to 104.5 degrees:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = {; 'coordsys' : 'tric',; 'constraints' : {; 'set' : [{'type' : 'distance',; 'indices' : [0, 1],; 'value' : 2.0 },; {'type' : 'angle',; 'indices' : [1, 0, 2],; 'value' : 104.5 }]; }; }. optimize('hf/cc-pvdz', engine='geometric', optim",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:14857,Performance,optimiz,optimize,14857,"eomeTRIC optimizer developed by Wang and Song [Wang:2016:214108] may be used in place of; Psi4’s native Optking optimizer. GeomeTRIC uses a translation-rotation-internal coordinate (TRIC); system that works well for optimizing geometries of systems containing noncovalent interactions.; Use of the GeomeTRIC optimizer is specified with the engine argument to; optimize(). The optimization will respect the keywords G_CONVERGENCE; and GEOM_MAXITER. Any other GeomeTRIC-specific options (including constraints); may be specified with the optimizer_keywords argument to optimize().; Constraints may be placed on cartesian coordinates, bonds, angles, and dihedrals, and they can be; used to either freeze a coordinate or set it to a specific value. See the GeomeTRIC github; for more information on keywords and JSON specification of constraints. Optimize the water molecule using GeomeTRIC:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. optimize('hf/cc-pvdz', engine='geometric'). Optimize the water molecule using GeomeTRIC, with one of the two OH bonds constrained to 2.0 au; and the HOH angle constrained to 104.5 degrees:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = {; 'coordsys' : 'tric',; 'constraints' : {; 'set' : [{'type' : 'distance',; 'indices' : [0, 1],; 'value' : 2.0 },; {'type' : 'angle',; 'indices' : [1, 0, 2],; 'value' : 104.5 }]; }; }. optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords). Optimize the benzene/water dimer using GeomeTRIC, with the 6 carbon atoms of benzene frozen in; place:; molecule h2o {; C 0.833 1.221 -0.504; H 1.482 2.086 -0.518; C 1.379 -0.055 -0.486; H 2.453 -0.184 -0.483; C 0.546 -1.167 -0.474; H 0.971 -2.162 -0.466; C -0.833 -1.001 -0.475; H -1.482 -1.867 -0.468; C -1.379 0.275 -0.490; H -2.453 0.404 -0.491; C -0.546 1.386 -0.506; H -0.971 2.381 -0.524; --; O 0.000 0.147 3.265; H 0.000 -0.505 2.581; H 0.000 0",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:15343,Performance,optimiz,optimize,15343,"ts); may be specified with the optimizer_keywords argument to optimize().; Constraints may be placed on cartesian coordinates, bonds, angles, and dihedrals, and they can be; used to either freeze a coordinate or set it to a specific value. See the GeomeTRIC github; for more information on keywords and JSON specification of constraints. Optimize the water molecule using GeomeTRIC:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. optimize('hf/cc-pvdz', engine='geometric'). Optimize the water molecule using GeomeTRIC, with one of the two OH bonds constrained to 2.0 au; and the HOH angle constrained to 104.5 degrees:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = {; 'coordsys' : 'tric',; 'constraints' : {; 'set' : [{'type' : 'distance',; 'indices' : [0, 1],; 'value' : 2.0 },; {'type' : 'angle',; 'indices' : [1, 0, 2],; 'value' : 104.5 }]; }; }. optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords). Optimize the benzene/water dimer using GeomeTRIC, with the 6 carbon atoms of benzene frozen in; place:; molecule h2o {; C 0.833 1.221 -0.504; H 1.482 2.086 -0.518; C 1.379 -0.055 -0.486; H 2.453 -0.184 -0.483; C 0.546 -1.167 -0.474; H 0.971 -2.162 -0.466; C -0.833 -1.001 -0.475; H -1.482 -1.867 -0.468; C -1.379 0.275 -0.490; H -2.453 0.404 -0.491; C -0.546 1.386 -0.506; H -0.971 2.381 -0.524; --; O 0.000 0.147 3.265; H 0.000 -0.505 2.581; H 0.000 0.965 2.790; no_com; no_reorient; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = {; 'coordsys' : 'tric',; 'constraints' : {; 'freeze' : [{'type' : 'xyz',; 'indices' : [0, 2, 4, 6, 8, 10]}]; }; }. optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords). Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:16092,Performance,optimiz,optimize,16092,"; }. geometric_keywords = {; 'coordsys' : 'tric',; 'constraints' : {; 'set' : [{'type' : 'distance',; 'indices' : [0, 1],; 'value' : 2.0 },; {'type' : 'angle',; 'indices' : [1, 0, 2],; 'value' : 104.5 }]; }; }. optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords). Optimize the benzene/water dimer using GeomeTRIC, with the 6 carbon atoms of benzene frozen in; place:; molecule h2o {; C 0.833 1.221 -0.504; H 1.482 2.086 -0.518; C 1.379 -0.055 -0.486; H 2.453 -0.184 -0.483; C 0.546 -1.167 -0.474; H 0.971 -2.162 -0.466; C -0.833 -1.001 -0.475; H -1.482 -1.867 -0.468; C -1.379 0.275 -0.490; H -2.453 0.404 -0.491; C -0.546 1.386 -0.506; H -0.971 2.381 -0.524; --; O 0.000 0.147 3.265; H 0.000 -0.505 2.581; H 0.000 0.965 2.790; no_com; no_reorient; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = {; 'coordsys' : 'tric',; 'constraints' : {; 'freeze' : [{'type' : 'xyz',; 'indices' : [0, 2, 4, 6, 8, 10]}]; }; }. optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords). Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 ",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:16211,Performance,optimiz,optimization,16211,"ndices' : [0, 1],; 'value' : 2.0 },; {'type' : 'angle',; 'indices' : [1, 0, 2],; 'value' : 104.5 }]; }; }. optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords). Optimize the benzene/water dimer using GeomeTRIC, with the 6 carbon atoms of benzene frozen in; place:; molecule h2o {; C 0.833 1.221 -0.504; H 1.482 2.086 -0.518; C 1.379 -0.055 -0.486; H 2.453 -0.184 -0.483; C 0.546 -1.167 -0.474; H 0.971 -2.162 -0.466; C -0.833 -1.001 -0.475; H -1.482 -1.867 -0.468; C -1.379 0.275 -0.490; H -2.453 0.404 -0.491; C -0.546 1.386 -0.506; H -0.971 2.381 -0.524; --; O 0.000 0.147 3.265; H 0.000 -0.505 2.581; H 0.000 0.965 2.790; no_com; no_reorient; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = {; 'coordsys' : 'tric',; 'constraints' : {; 'freeze' : [{'type' : 'xyz',; 'indices' : [0, 2, 4, 6, 8, 10]}]; }; }. optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords). Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:17411,Performance,optimiz,optimizations,17411," engine='geometric', optimizer_keywords=geometric_keywords). Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). table of contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY; INTCOS_GENERATE_EXIT. Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Dealing with problematic optimizations; Direct manipulation of the optmization coordinates; Convergence Criteria; Interface to GeomeTRIC; Output. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; Geometry Optimization. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:17441,Performance,optimiz,optimize,17441," engine='geometric', optimizer_keywords=geometric_keywords). Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). table of contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY; INTCOS_GENERATE_EXIT. Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Dealing with problematic optimizations; Direct manipulation of the optmization coordinates; Convergence Criteria; Interface to GeomeTRIC; Output. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; Geometry Optimization. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:17719,Performance,optimiz,optimizations,17719," engine='geometric', optimizer_keywords=geometric_keywords). Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). table of contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY; INTCOS_GENERATE_EXIT. Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Dealing with problematic optimizations; Direct manipulation of the optmization coordinates; Convergence Criteria; Interface to GeomeTRIC; Output. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; Geometry Optimization. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:572,Safety,redund,redundant,572,"﻿. Geometry Optimization. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; Geometry Optimization. Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, an RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified directly. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension “.intco”. See the Optimizing Minima; section for more detail. Warning; The selection of a Z-matrix input, and in particular the inclusion; of dummy atoms, has no effect on the behavior of the optimizer, which begins; from a Cartesian rep",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:711,Safety,redund,redundant,711,"﻿. Geometry Optimization. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; Geometry Optimization. Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, an RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified directly. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension “.intco”. See the Optimizing Minima; section for more detail. Warning; The selection of a Z-matrix input, and in particular the inclusion; of dummy atoms, has no effect on the behavior of the optimizer, which begins; from a Cartesian rep",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:1022,Safety,redund,redundant,1022,"ptimization. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; Geometry Optimization. Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, an RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified directly. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension “.intco”. See the Optimizing Minima; section for more detail. Warning; The selection of a Z-matrix input, and in particular the inclusion; of dummy atoms, has no effect on the behavior of the optimizer, which begins; from a Cartesian representation o",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:8525,Safety,detect,detected,8525,"(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals. Direct manipulation of the optmization coordinates¶. Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3; C 1; 1 1.000000; C 1; 2 1.000000; C 1; 3 1.000000. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. Th",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:8893,Safety,redund,redundant,8893,"minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals. Direct manipulation of the optmization coordinates¶. Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3; C 1; 1 1.000000; C 1; 2 1.000000; C 1; 3 1.000000. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. The lines below the simple internal coordinates; specify linear combinations of coordinates. In the simplest default case, the lines; above simply define combination coordinates which are identical to the simple internals.; If OPT_COORDINATES specifies delocalized coordinates, then the combinations; will be more comple",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:13785,Safety,avoid,avoid,13785,"ved when all active criteria are fulfilled. 5(1,2,3); Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. 6(1,2,3,4,5); Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100\(\times\)rms force is less; than RMS Force criterion. 7; Compensates for difficulties in converging geometry optmizations of supermolecular complexes; tightly, where large rms disp and max disp may result from flat potential surfaces even when; max force and/or rms force are small. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes 5 and 6; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Interface to GeomeTRIC¶; The GeomeTRIC optimizer developed by Wang and Song [Wang:2016:214108] may be used in place of; Psi4’s native Optking optimizer. GeomeTRIC uses a translation-rotation-internal coordinate (TRIC); system that works well for optimizing geometries of systems containing noncovalent interactions.; Use of the GeomeTRIC optimizer is specified with the engine argument to; optimize(). The optimization will respect the keywords G_CONVERGENCE; and GEOM_MAXITER. Any other GeomeTRIC-specific options (including constraints); may be specified with the optimizer_keywords argument to optimize().; Constraints may be placed on cartesian coordinates, bonds, angles, and dihedrals, and they can be; used to either freeze a coordinate or set it to a specific value. See the GeomeTRIC github; for more information on keywords and JSON specification of constraints. Optimize the water molecule using GeomeTRIC:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }.",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:882,Testability,test,tested,882,"﻿. Geometry Optimization. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; Geometry Optimization. Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, an RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified directly. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension “.intco”. See the Optimizing Minima; section for more detail. Warning; The selection of a Z-matrix input, and in particular the inclusion; of dummy atoms, has no effect on the behavior of the optimizer, which begins; from a Cartesian rep",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:1284,Testability,test,testing,1284,"optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, an RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified directly. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension “.intco”. See the Optimizing Minima; section for more detail. Warning; The selection of a Z-matrix input, and in particular the inclusion; of dummy atoms, has no effect on the behavior of the optimizer, which begins; from a Cartesian representation of the system. The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:8233,Testability,test,test,8233,"veral fixed values; of the dihedral angle of HOOH. molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals. Direct manipulation of the optmization coordinates¶. Generate the internal coordinates and then stop:; set intcos_",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:5180,Usability,simpl,simple,5180,"ted. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:. set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:. set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Optimize a geometry (HOOH) ",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:9640,Usability,simpl,simple,9640,"allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals. Direct manipulation of the optmization coordinates¶. Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3; C 1; 1 1.000000; C 1; 2 1.000000; C 1; 3 1.000000. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. The lines below the simple internal coordinates; specify linear combinations of coordinates. In the simplest default case, the lines; above simply define combination coordinates which are identical to the simple internals.; If OPT_COORDINATES specifies delocalized coordinates, then the combinations; will be more complex.; Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen by adding an asterisk after the letter of the coordinate. The; asterisk results in that internal coordinate being frozen at its initial value. The; “intco” file below for water specifies an optimization with both O-H bonds frozen.:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. If one instead wishes to optimize toward (“fix”) a value that is not satisfied by the; initial structure, then the value is added to the end of the line. The following; corresponds t",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:9720,Usability,simpl,simplest,9720,"take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals. Direct manipulation of the optmization coordinates¶. Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3; C 1; 1 1.000000; C 1; 2 1.000000; C 1; 3 1.000000. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. The lines below the simple internal coordinates; specify linear combinations of coordinates. In the simplest default case, the lines; above simply define combination coordinates which are identical to the simple internals.; If OPT_COORDINATES specifies delocalized coordinates, then the combinations; will be more complex.; Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen by adding an asterisk after the letter of the coordinate. The; asterisk results in that internal coordinate being frozen at its initial value. The; “intco” file below for water specifies an optimization with both O-H bonds frozen.:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. If one instead wishes to optimize toward (“fix”) a value that is not satisfied by the; initial structure, then the value is added to the end of the line. The following; corresponds to an optimization that will add additional forces to move the O-H bonds; to 1.70 au.; F 1 3; R 1 2 1.70; R 1 3 ",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:9760,Usability,simpl,simply,9760,"take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals. Direct manipulation of the optmization coordinates¶. Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3; C 1; 1 1.000000; C 1; 2 1.000000; C 1; 3 1.000000. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. The lines below the simple internal coordinates; specify linear combinations of coordinates. In the simplest default case, the lines; above simply define combination coordinates which are identical to the simple internals.; If OPT_COORDINATES specifies delocalized coordinates, then the combinations; will be more complex.; Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen by adding an asterisk after the letter of the coordinate. The; asterisk results in that internal coordinate being frozen at its initial value. The; “intco” file below for water specifies an optimization with both O-H bonds frozen.:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. If one instead wishes to optimize toward (“fix”) a value that is not satisfied by the; initial structure, then the value is added to the end of the line. The following; corresponds to an optimization that will add additional forces to move the O-H bonds; to 1.70 au.; F 1 3; R 1 2 1.70; R 1 3 ",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/optking.html:9825,Usability,simpl,simple,9825,"take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals. Direct manipulation of the optmization coordinates¶. Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3; C 1; 1 1.000000; C 1; 2 1.000000; C 1; 3 1.000000. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. The lines below the simple internal coordinates; specify linear combinations of coordinates. In the simplest default case, the lines; above simply define combination coordinates which are identical to the simple internals.; If OPT_COORDINATES specifies delocalized coordinates, then the combinations; will be more complex.; Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen by adding an asterisk after the letter of the coordinate. The; asterisk results in that internal coordinate being frozen at its initial value. The; “intco” file below for water specifies an optimization with both O-H bonds frozen.:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. If one instead wishes to optimize toward (“fix”) a value that is not satisfied by the; initial structure, then the value is added to the end of the line. The following; corresponds to an optimization that will add additional forces to move the O-H bonds; to 1.70 au.; F 1 3; R 1 2 1.70; R 1 3 ",MatchSource.WIKI,psi4manual/1.6.x/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optking.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:547,Availability,down,downloads,547,"﻿. Interface to PCMSolver by R. Di Remigio. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to PCMSolver by R. Di Remigio. Interface to PCMSolver by R. Di Remigio¶; Code author: Roberto Di Remigio, T. Daniel Crawford, Andrew C. Simmonett; Section author: Roberto Di Remigio; Module: Keywords, PSI Variables, PCMSolver. PSI4 contains code to interface to the PCMSolver library developed; by R. Di Remigio and L. Frediani.; The PCMSolver library requires no additional licence, downloads, or; configuration. The library allows for calculations in solution with the; polarizable continuum model (PCM), a continuum solvation model [Tomasi:2005:2999]. Installation¶; Binary. PCMSolver is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, PCMSolver has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; PCMSolver can be obtained through conda install pcmsolver -c psi4.; Then enable it as a feature with ENABLE_PCMSolver,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect PCMSolver and activate dependent code. To remove a conda installation, conda remove pcmsolver. Source. If using PSI4 built from source and you want PCMSolver built from; from source also,; enable it as a feature with ENABLE_PCMSolver,; and let the build system fetch and build it and activate dependent code. Using the polarizable continuum model¶; The inclusion of a PCM description of the solvent into your calculation; is achieved by setting PCM true in your input file.; PSI4 understands the additional option PCM_SCF_TYPE with possible values total; (the default) or separate.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging.; For the calculation of verti",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:754,Availability,avail,available,754,"﻿. Interface to PCMSolver by R. Di Remigio. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to PCMSolver by R. Di Remigio. Interface to PCMSolver by R. Di Remigio¶; Code author: Roberto Di Remigio, T. Daniel Crawford, Andrew C. Simmonett; Section author: Roberto Di Remigio; Module: Keywords, PSI Variables, PCMSolver. PSI4 contains code to interface to the PCMSolver library developed; by R. Di Remigio and L. Frediani.; The PCMSolver library requires no additional licence, downloads, or; configuration. The library allows for calculations in solution with the; polarizable continuum model (PCM), a continuum solvation model [Tomasi:2005:2999]. Installation¶; Binary. PCMSolver is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, PCMSolver has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; PCMSolver can be obtained through conda install pcmsolver -c psi4.; Then enable it as a feature with ENABLE_PCMSolver,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect PCMSolver and activate dependent code. To remove a conda installation, conda remove pcmsolver. Source. If using PSI4 built from source and you want PCMSolver built from; from source also,; enable it as a feature with ENABLE_PCMSolver,; and let the build system fetch and build it and activate dependent code. Using the polarizable continuum model¶; The inclusion of a PCM description of the solvent into your calculation; is achieved by setting PCM true in your input file.; PSI4 understands the additional option PCM_SCF_TYPE with possible values total; (the default) or separate.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging.; For the calculation of verti",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:2454,Availability,avail,available,2454,"m source also,; enable it as a feature with ENABLE_PCMSolver,; and let the build system fetch and build it and activate dependent code. Using the polarizable continuum model¶; The inclusion of a PCM description of the solvent into your calculation; is achieved by setting PCM true in your input file.; PSI4 understands the additional option PCM_SCF_TYPE with possible values total; (the default) or separate.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging.; For the calculation of vertical excitation energies with PCM non-equilibrium solvation should be included with:; pcm = {; Medium {; Nonequilibrium = True; }; }. Note; At present PCM can only be used for energy calculations with SCF; wavefunctions and CC wavefunctions in the PTE approximation [Cammi:2009:164104].; All ERI algorithms (PK, OUT_OF_CORE, DIRECT, DF, CD) are supported. Note; linear response calculations (static polarisabilities, TD-SCF) are supported for RHF/UHF if available. Warning; The PCMSolver library cannot exploit molecular point group symmetry. Warning; ROHF with PCM is known not to work. See issue #999 on GitHub.; For the adventurous, a fix is available in pull request #953 on GitHub. Warning; Analytic gradients and Hessians are not available with PCM. Finite differences will be used; regardless of the dertype passed to the optimize function.; See pcmsolver/opt-fd for a sample input. The PCM model and molecular cavity are specified in a pcm section that has; to be explicitly typed in by the user. This additional section follows a syntax; that is slightly different from that of PSI4 and is fully documented; here; A typical input for a Hartree–Fock calculation with PCM would look like the following:; molecule NH3 {; symmetry c1; N -0.0000000001 -0.1040380466 0.0000000000; H -0.9015844116 0.4818470201 -1.5615900098; H -0.9015844116 0.4818470201 1.5615900098; H 1.8031688251 0.4818470204 0.000000000",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:2645,Availability,avail,available,2645,"ulation; is achieved by setting PCM true in your input file.; PSI4 understands the additional option PCM_SCF_TYPE with possible values total; (the default) or separate.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging.; For the calculation of vertical excitation energies with PCM non-equilibrium solvation should be included with:; pcm = {; Medium {; Nonequilibrium = True; }; }. Note; At present PCM can only be used for energy calculations with SCF; wavefunctions and CC wavefunctions in the PTE approximation [Cammi:2009:164104].; All ERI algorithms (PK, OUT_OF_CORE, DIRECT, DF, CD) are supported. Note; linear response calculations (static polarisabilities, TD-SCF) are supported for RHF/UHF if available. Warning; The PCMSolver library cannot exploit molecular point group symmetry. Warning; ROHF with PCM is known not to work. See issue #999 on GitHub.; For the adventurous, a fix is available in pull request #953 on GitHub. Warning; Analytic gradients and Hessians are not available with PCM. Finite differences will be used; regardless of the dertype passed to the optimize function.; See pcmsolver/opt-fd for a sample input. The PCM model and molecular cavity are specified in a pcm section that has; to be explicitly typed in by the user. This additional section follows a syntax; that is slightly different from that of PSI4 and is fully documented; here; A typical input for a Hartree–Fock calculation with PCM would look like the following:; molecule NH3 {; symmetry c1; N -0.0000000001 -0.1040380466 0.0000000000; H -0.9015844116 0.4818470201 -1.5615900098; H -0.9015844116 0.4818470201 1.5615900098; H 1.8031688251 0.4818470204 0.0000000000; units bohr; no_reorient; no_com; }. set {; basis STO-3G; scf_type pk; pcm true; pcm_scf_type total; }. pcm = {; Units = Angstrom; Medium {; SolverType = IEFPCM; Solvent = Water; }. Cavity {; RadiiSet = UFF; Type = GePol; Scaling = False;",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:2736,Availability,avail,available,2736,"rstands the additional option PCM_SCF_TYPE with possible values total; (the default) or separate.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging.; For the calculation of vertical excitation energies with PCM non-equilibrium solvation should be included with:; pcm = {; Medium {; Nonequilibrium = True; }; }. Note; At present PCM can only be used for energy calculations with SCF; wavefunctions and CC wavefunctions in the PTE approximation [Cammi:2009:164104].; All ERI algorithms (PK, OUT_OF_CORE, DIRECT, DF, CD) are supported. Note; linear response calculations (static polarisabilities, TD-SCF) are supported for RHF/UHF if available. Warning; The PCMSolver library cannot exploit molecular point group symmetry. Warning; ROHF with PCM is known not to work. See issue #999 on GitHub.; For the adventurous, a fix is available in pull request #953 on GitHub. Warning; Analytic gradients and Hessians are not available with PCM. Finite differences will be used; regardless of the dertype passed to the optimize function.; See pcmsolver/opt-fd for a sample input. The PCM model and molecular cavity are specified in a pcm section that has; to be explicitly typed in by the user. This additional section follows a syntax; that is slightly different from that of PSI4 and is fully documented; here; A typical input for a Hartree–Fock calculation with PCM would look like the following:; molecule NH3 {; symmetry c1; N -0.0000000001 -0.1040380466 0.0000000000; H -0.9015844116 0.4818470201 -1.5615900098; H -0.9015844116 0.4818470201 1.5615900098; H 1.8031688251 0.4818470204 0.0000000000; units bohr; no_reorient; no_com; }. set {; basis STO-3G; scf_type pk; pcm true; pcm_scf_type total; }. pcm = {; Units = Angstrom; Medium {; SolverType = IEFPCM; Solvent = Water; }. Cavity {; RadiiSet = UFF; Type = GePol; Scaling = False; Area = 0.3; Mode = Implicit; }; }. More examples can be found in the d",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:562,Deployability,configurat,configuration,562,"﻿. Interface to PCMSolver by R. Di Remigio. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to PCMSolver by R. Di Remigio. Interface to PCMSolver by R. Di Remigio¶; Code author: Roberto Di Remigio, T. Daniel Crawford, Andrew C. Simmonett; Section author: Roberto Di Remigio; Module: Keywords, PSI Variables, PCMSolver. PSI4 contains code to interface to the PCMSolver library developed; by R. Di Remigio and L. Frediani.; The PCMSolver library requires no additional licence, downloads, or; configuration. The library allows for calculations in solution with the; polarizable continuum model (PCM), a continuum solvation model [Tomasi:2005:2999]. Installation¶; Binary. PCMSolver is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, PCMSolver has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; PCMSolver can be obtained through conda install pcmsolver -c psi4.; Then enable it as a feature with ENABLE_PCMSolver,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect PCMSolver and activate dependent code. To remove a conda installation, conda remove pcmsolver. Source. If using PSI4 built from source and you want PCMSolver built from; from source also,; enable it as a feature with ENABLE_PCMSolver,; and let the build system fetch and build it and activate dependent code. Using the polarizable continuum model¶; The inclusion of a PCM description of the solvent into your calculation; is achieved by setting PCM true in your input file.; PSI4 understands the additional option PCM_SCF_TYPE with possible values total; (the default) or separate.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging.; For the calculation of verti",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:898,Deployability,install,installed,898,"﻿. Interface to PCMSolver by R. Di Remigio. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to PCMSolver by R. Di Remigio. Interface to PCMSolver by R. Di Remigio¶; Code author: Roberto Di Remigio, T. Daniel Crawford, Andrew C. Simmonett; Section author: Roberto Di Remigio; Module: Keywords, PSI Variables, PCMSolver. PSI4 contains code to interface to the PCMSolver library developed; by R. Di Remigio and L. Frediani.; The PCMSolver library requires no additional licence, downloads, or; configuration. The library allows for calculations in solution with the; polarizable continuum model (PCM), a continuum solvation model [Tomasi:2005:2999]. Installation¶; Binary. PCMSolver is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, PCMSolver has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; PCMSolver can be obtained through conda install pcmsolver -c psi4.; Then enable it as a feature with ENABLE_PCMSolver,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect PCMSolver and activate dependent code. To remove a conda installation, conda remove pcmsolver. Source. If using PSI4 built from source and you want PCMSolver built from; from source also,; enable it as a feature with ENABLE_PCMSolver,; and let the build system fetch and build it and activate dependent code. Using the polarizable continuum model¶; The inclusion of a PCM description of the solvent into your calculation; is achieved by setting PCM true in your input file.; PSI4 understands the additional option PCM_SCF_TYPE with possible values total; (the default) or separate.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging.; For the calculation of verti",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:997,Deployability,install,installed,997," PCMSolver by R. Di Remigio. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to PCMSolver by R. Di Remigio. Interface to PCMSolver by R. Di Remigio¶; Code author: Roberto Di Remigio, T. Daniel Crawford, Andrew C. Simmonett; Section author: Roberto Di Remigio; Module: Keywords, PSI Variables, PCMSolver. PSI4 contains code to interface to the PCMSolver library developed; by R. Di Remigio and L. Frediani.; The PCMSolver library requires no additional licence, downloads, or; configuration. The library allows for calculations in solution with the; polarizable continuum model (PCM), a continuum solvation model [Tomasi:2005:2999]. Installation¶; Binary. PCMSolver is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, PCMSolver has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; PCMSolver can be obtained through conda install pcmsolver -c psi4.; Then enable it as a feature with ENABLE_PCMSolver,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect PCMSolver and activate dependent code. To remove a conda installation, conda remove pcmsolver. Source. If using PSI4 built from source and you want PCMSolver built from; from source also,; enable it as a feature with ENABLE_PCMSolver,; and let the build system fetch and build it and activate dependent code. Using the polarizable continuum model¶; The inclusion of a PCM description of the solvent into your calculation; is achieved by setting PCM true in your input file.; PSI4 understands the additional option PCM_SCF_TYPE with possible values total; (the default) or separate.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging.; For the calculation of vertical excitation",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:1086,Deployability,install,install,1086," PCMSolver by R. Di Remigio. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to PCMSolver by R. Di Remigio. Interface to PCMSolver by R. Di Remigio¶; Code author: Roberto Di Remigio, T. Daniel Crawford, Andrew C. Simmonett; Section author: Roberto Di Remigio; Module: Keywords, PSI Variables, PCMSolver. PSI4 contains code to interface to the PCMSolver library developed; by R. Di Remigio and L. Frediani.; The PCMSolver library requires no additional licence, downloads, or; configuration. The library allows for calculations in solution with the; polarizable continuum model (PCM), a continuum solvation model [Tomasi:2005:2999]. Installation¶; Binary. PCMSolver is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, PCMSolver has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; PCMSolver can be obtained through conda install pcmsolver -c psi4.; Then enable it as a feature with ENABLE_PCMSolver,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect PCMSolver and activate dependent code. To remove a conda installation, conda remove pcmsolver. Source. If using PSI4 built from source and you want PCMSolver built from; from source also,; enable it as a feature with ENABLE_PCMSolver,; and let the build system fetch and build it and activate dependent code. Using the polarizable continuum model¶; The inclusion of a PCM description of the solvent into your calculation; is achieved by setting PCM true in your input file.; PSI4 understands the additional option PCM_SCF_TYPE with possible values total; (the default) or separate.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging.; For the calculation of vertical excitation",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:1293,Deployability,install,installation,1293,"monett; Section author: Roberto Di Remigio; Module: Keywords, PSI Variables, PCMSolver. PSI4 contains code to interface to the PCMSolver library developed; by R. Di Remigio and L. Frediani.; The PCMSolver library requires no additional licence, downloads, or; configuration. The library allows for calculations in solution with the; polarizable continuum model (PCM), a continuum solvation model [Tomasi:2005:2999]. Installation¶; Binary. PCMSolver is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, PCMSolver has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; PCMSolver can be obtained through conda install pcmsolver -c psi4.; Then enable it as a feature with ENABLE_PCMSolver,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect PCMSolver and activate dependent code. To remove a conda installation, conda remove pcmsolver. Source. If using PSI4 built from source and you want PCMSolver built from; from source also,; enable it as a feature with ENABLE_PCMSolver,; and let the build system fetch and build it and activate dependent code. Using the polarizable continuum model¶; The inclusion of a PCM description of the solvent into your calculation; is achieved by setting PCM true in your input file.; PSI4 understands the additional option PCM_SCF_TYPE with possible values total; (the default) or separate.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging.; For the calculation of vertical excitation energies with PCM non-equilibrium solvation should be included with:; pcm = {; Medium {; Nonequilibrium = True; }; }. Note; At present PCM can only be used for energy calculations with SCF; wavefunctions and CC wavefunctions in the PTE approximation [Cammi:2009:164104].; All ERI algori",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:4707,Deployability,install,installation,4707,"tories with PCM tests; pcmsolver/ccsd-pte,; pcmsolver/scf,; pcmsolver/opt-fd,; pcmsolver/dft, and; pcmsolver/dipole. Keywords for PCMSolver¶. PCM¶. PCM boolean for pcmsolver module. Type: boolean; Default: false. PCM_SCF_TYPE¶. Use total or separate potentials and charges in the PCM-SCF step. Type: string; Possible Values: TOTAL, SEPARATE; Default: TOTAL. PCM_CC_TYPE¶. PCM-CCSD algorithm type. Type: string; Possible Values: PTE; Default: PTE. How to configure PCMSolver for building Psi4¶; Role and Dependencies. Role — In PSI4, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) PCMSolver; Upstream Dependencies — PCMSolver \(\Leftarrow\) Fortran, zlib. CMake Variables. ENABLE_PCMSolver — CMake variable toggling whether Psi4 builds with PCMSolver; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing include/PCMSolver/pcmsolver.h; PCMSolver_DIR — CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing share/cmake/PCMSolver/PCMSolverConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_PCMSolver — CMake variable to force internal build of PCMSolver instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_PCMSolver — CMake variable to force detecting pre-built PCMSolver and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_PCMSolver=ON. Build without PCMSolver. >>> cmake. table of contents. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; PCM; PCM_SCF_TYPE; PCM_CC_TYPE. How to configure PCMSolver for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to PCMSolver by R. Di Remigio. © Copyright 2022, The Psi4 Project.; ",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:4861,Deployability,install,installation,4861,"pcmsolver/dft, and; pcmsolver/dipole. Keywords for PCMSolver¶. PCM¶. PCM boolean for pcmsolver module. Type: boolean; Default: false. PCM_SCF_TYPE¶. Use total or separate potentials and charges in the PCM-SCF step. Type: string; Possible Values: TOTAL, SEPARATE; Default: TOTAL. PCM_CC_TYPE¶. PCM-CCSD algorithm type. Type: string; Possible Values: PTE; Default: PTE. How to configure PCMSolver for building Psi4¶; Role and Dependencies. Role — In PSI4, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) PCMSolver; Upstream Dependencies — PCMSolver \(\Leftarrow\) Fortran, zlib. CMake Variables. ENABLE_PCMSolver — CMake variable toggling whether Psi4 builds with PCMSolver; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing include/PCMSolver/pcmsolver.h; PCMSolver_DIR — CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing share/cmake/PCMSolver/PCMSolverConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_PCMSolver — CMake variable to force internal build of PCMSolver instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_PCMSolver — CMake variable to force detecting pre-built PCMSolver and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_PCMSolver=ON. Build without PCMSolver. >>> cmake. table of contents. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; PCM; PCM_SCF_TYPE; PCM_CC_TYPE. How to configure PCMSolver for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to PCMSolver by R. Di Remigio. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:5730,Deployability,update,updated,5730,"pcmsolver/dft, and; pcmsolver/dipole. Keywords for PCMSolver¶. PCM¶. PCM boolean for pcmsolver module. Type: boolean; Default: false. PCM_SCF_TYPE¶. Use total or separate potentials and charges in the PCM-SCF step. Type: string; Possible Values: TOTAL, SEPARATE; Default: TOTAL. PCM_CC_TYPE¶. PCM-CCSD algorithm type. Type: string; Possible Values: PTE; Default: PTE. How to configure PCMSolver for building Psi4¶; Role and Dependencies. Role — In PSI4, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) PCMSolver; Upstream Dependencies — PCMSolver \(\Leftarrow\) Fortran, zlib. CMake Variables. ENABLE_PCMSolver — CMake variable toggling whether Psi4 builds with PCMSolver; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing include/PCMSolver/pcmsolver.h; PCMSolver_DIR — CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing share/cmake/PCMSolver/PCMSolverConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_PCMSolver — CMake variable to force internal build of PCMSolver instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_PCMSolver — CMake variable to force detecting pre-built PCMSolver and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_PCMSolver=ON. Build without PCMSolver. >>> cmake. table of contents. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; PCM; PCM_SCF_TYPE; PCM_CC_TYPE. How to configure PCMSolver for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to PCMSolver by R. Di Remigio. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:1928,Energy Efficiency,charge,charges,1928,"lver has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; PCMSolver can be obtained through conda install pcmsolver -c psi4.; Then enable it as a feature with ENABLE_PCMSolver,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect PCMSolver and activate dependent code. To remove a conda installation, conda remove pcmsolver. Source. If using PSI4 built from source and you want PCMSolver built from; from source also,; enable it as a feature with ENABLE_PCMSolver,; and let the build system fetch and build it and activate dependent code. Using the polarizable continuum model¶; The inclusion of a PCM description of the solvent into your calculation; is achieved by setting PCM true in your input file.; PSI4 understands the additional option PCM_SCF_TYPE with possible values total; (the default) or separate.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging.; For the calculation of vertical excitation energies with PCM non-equilibrium solvation should be included with:; pcm = {; Medium {; Nonequilibrium = True; }; }. Note; At present PCM can only be used for energy calculations with SCF; wavefunctions and CC wavefunctions in the PTE approximation [Cammi:2009:164104].; All ERI algorithms (PK, OUT_OF_CORE, DIRECT, DF, CD) are supported. Note; linear response calculations (static polarisabilities, TD-SCF) are supported for RHF/UHF if available. Warning; The PCMSolver library cannot exploit molecular point group symmetry. Warning; ROHF with PCM is known not to work. See issue #999 on GitHub.; For the adventurous, a fix is available in pull request #953 on GitHub. Warning; Analytic gradients and Hessians are not available with PCM. Finite differences will be used; regardless of the dertype passed to the optimize function.; See pcmsolver/opt-fd for a s",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:2176,Energy Efficiency,energy,energy,2176,"and rebuild PSI4 to detect PCMSolver and activate dependent code. To remove a conda installation, conda remove pcmsolver. Source. If using PSI4 built from source and you want PCMSolver built from; from source also,; enable it as a feature with ENABLE_PCMSolver,; and let the build system fetch and build it and activate dependent code. Using the polarizable continuum model¶; The inclusion of a PCM description of the solvent into your calculation; is achieved by setting PCM true in your input file.; PSI4 understands the additional option PCM_SCF_TYPE with possible values total; (the default) or separate.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging.; For the calculation of vertical excitation energies with PCM non-equilibrium solvation should be included with:; pcm = {; Medium {; Nonequilibrium = True; }; }. Note; At present PCM can only be used for energy calculations with SCF; wavefunctions and CC wavefunctions in the PTE approximation [Cammi:2009:164104].; All ERI algorithms (PK, OUT_OF_CORE, DIRECT, DF, CD) are supported. Note; linear response calculations (static polarisabilities, TD-SCF) are supported for RHF/UHF if available. Warning; The PCMSolver library cannot exploit molecular point group symmetry. Warning; ROHF with PCM is known not to work. See issue #999 on GitHub.; For the adventurous, a fix is available in pull request #953 on GitHub. Warning; Analytic gradients and Hessians are not available with PCM. Finite differences will be used; regardless of the dertype passed to the optimize function.; See pcmsolver/opt-fd for a sample input. The PCM model and molecular cavity are specified in a pcm section that has; to be explicitly typed in by the user. This additional section follows a syntax; that is slightly different from that of PSI4 and is fully documented; here; A typical input for a Hartree–Fock calculation with PCM would look like the following:;",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:3990,Energy Efficiency,charge,charges,3990,"ped in by the user. This additional section follows a syntax; that is slightly different from that of PSI4 and is fully documented; here; A typical input for a Hartree–Fock calculation with PCM would look like the following:; molecule NH3 {; symmetry c1; N -0.0000000001 -0.1040380466 0.0000000000; H -0.9015844116 0.4818470201 -1.5615900098; H -0.9015844116 0.4818470201 1.5615900098; H 1.8031688251 0.4818470204 0.0000000000; units bohr; no_reorient; no_com; }. set {; basis STO-3G; scf_type pk; pcm true; pcm_scf_type total; }. pcm = {; Units = Angstrom; Medium {; SolverType = IEFPCM; Solvent = Water; }. Cavity {; RadiiSet = UFF; Type = GePol; Scaling = False; Area = 0.3; Mode = Implicit; }; }. More examples can be found in the directories with PCM tests; pcmsolver/ccsd-pte,; pcmsolver/scf,; pcmsolver/opt-fd,; pcmsolver/dft, and; pcmsolver/dipole. Keywords for PCMSolver¶. PCM¶. PCM boolean for pcmsolver module. Type: boolean; Default: false. PCM_SCF_TYPE¶. Use total or separate potentials and charges in the PCM-SCF step. Type: string; Possible Values: TOTAL, SEPARATE; Default: TOTAL. PCM_CC_TYPE¶. PCM-CCSD algorithm type. Type: string; Possible Values: PTE; Default: PTE. How to configure PCMSolver for building Psi4¶; Role and Dependencies. Role — In PSI4, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) PCMSolver; Upstream Dependencies — PCMSolver \(\Leftarrow\) Fortran, zlib. CMake Variables. ENABLE_PCMSolver — CMake variable toggling whether Psi4 builds with PCMSolver; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing include/PCMSolver/pcmsolver.h; PCMSolver_DIR — CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing share/cmake/PCMSolver/PCMSolverConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_PCMSolver — CMake ",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:412,Integrability,interface,interface,412,"﻿. Interface to PCMSolver by R. Di Remigio. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to PCMSolver by R. Di Remigio. Interface to PCMSolver by R. Di Remigio¶; Code author: Roberto Di Remigio, T. Daniel Crawford, Andrew C. Simmonett; Section author: Roberto Di Remigio; Module: Keywords, PSI Variables, PCMSolver. PSI4 contains code to interface to the PCMSolver library developed; by R. Di Remigio and L. Frediani.; The PCMSolver library requires no additional licence, downloads, or; configuration. The library allows for calculations in solution with the; polarizable continuum model (PCM), a continuum solvation model [Tomasi:2005:2999]. Installation¶; Binary. PCMSolver is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, PCMSolver has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; PCMSolver can be obtained through conda install pcmsolver -c psi4.; Then enable it as a feature with ENABLE_PCMSolver,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect PCMSolver and activate dependent code. To remove a conda installation, conda remove pcmsolver. Source. If using PSI4 built from source and you want PCMSolver built from; from source also,; enable it as a feature with ENABLE_PCMSolver,; and let the build system fetch and build it and activate dependent code. Using the polarizable continuum model¶; The inclusion of a PCM description of the solvent into your calculation; is achieved by setting PCM true in your input file.; PSI4 understands the additional option PCM_SCF_TYPE with possible values total; (the default) or separate.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging.; For the calculation of verti",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:1259,Integrability,depend,dependent,1259," Interface to PCMSolver by R. Di Remigio¶; Code author: Roberto Di Remigio, T. Daniel Crawford, Andrew C. Simmonett; Section author: Roberto Di Remigio; Module: Keywords, PSI Variables, PCMSolver. PSI4 contains code to interface to the PCMSolver library developed; by R. Di Remigio and L. Frediani.; The PCMSolver library requires no additional licence, downloads, or; configuration. The library allows for calculations in solution with the; polarizable continuum model (PCM), a continuum solvation model [Tomasi:2005:2999]. Installation¶; Binary. PCMSolver is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, PCMSolver has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; PCMSolver can be obtained through conda install pcmsolver -c psi4.; Then enable it as a feature with ENABLE_PCMSolver,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect PCMSolver and activate dependent code. To remove a conda installation, conda remove pcmsolver. Source. If using PSI4 built from source and you want PCMSolver built from; from source also,; enable it as a feature with ENABLE_PCMSolver,; and let the build system fetch and build it and activate dependent code. Using the polarizable continuum model¶; The inclusion of a PCM description of the solvent into your calculation; is achieved by setting PCM true in your input file.; PSI4 understands the additional option PCM_SCF_TYPE with possible values total; (the default) or separate.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging.; For the calculation of vertical excitation energies with PCM non-equilibrium solvation should be included with:; pcm = {; Medium {; Nonequilibrium = True; }; }. Note; At present PCM can only be used for energy calculatio",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:1529,Integrability,depend,dependent,1529,"brary developed; by R. Di Remigio and L. Frediani.; The PCMSolver library requires no additional licence, downloads, or; configuration. The library allows for calculations in solution with the; polarizable continuum model (PCM), a continuum solvation model [Tomasi:2005:2999]. Installation¶; Binary. PCMSolver is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, PCMSolver has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; PCMSolver can be obtained through conda install pcmsolver -c psi4.; Then enable it as a feature with ENABLE_PCMSolver,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect PCMSolver and activate dependent code. To remove a conda installation, conda remove pcmsolver. Source. If using PSI4 built from source and you want PCMSolver built from; from source also,; enable it as a feature with ENABLE_PCMSolver,; and let the build system fetch and build it and activate dependent code. Using the polarizable continuum model¶; The inclusion of a PCM description of the solvent into your calculation; is achieved by setting PCM true in your input file.; PSI4 understands the additional option PCM_SCF_TYPE with possible values total; (the default) or separate.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging.; For the calculation of vertical excitation energies with PCM non-equilibrium solvation should be included with:; pcm = {; Medium {; Nonequilibrium = True; }; }. Note; At present PCM can only be used for energy calculations with SCF; wavefunctions and CC wavefunctions in the PTE approximation [Cammi:2009:164104].; All ERI algorithms (PK, OUT_OF_CORE, DIRECT, DF, CD) are supported. Note; linear response calculations (static polarisabilities, TD-SCF) are supported fo",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:4655,Integrability,depend,dependencies,4655,"Cavity {; RadiiSet = UFF; Type = GePol; Scaling = False; Area = 0.3; Mode = Implicit; }; }. More examples can be found in the directories with PCM tests; pcmsolver/ccsd-pte,; pcmsolver/scf,; pcmsolver/opt-fd,; pcmsolver/dft, and; pcmsolver/dipole. Keywords for PCMSolver¶. PCM¶. PCM boolean for pcmsolver module. Type: boolean; Default: false. PCM_SCF_TYPE¶. Use total or separate potentials and charges in the PCM-SCF step. Type: string; Possible Values: TOTAL, SEPARATE; Default: TOTAL. PCM_CC_TYPE¶. PCM-CCSD algorithm type. Type: string; Possible Values: PTE; Default: PTE. How to configure PCMSolver for building Psi4¶; Role and Dependencies. Role — In PSI4, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) PCMSolver; Upstream Dependencies — PCMSolver \(\Leftarrow\) Fortran, zlib. CMake Variables. ENABLE_PCMSolver — CMake variable toggling whether Psi4 builds with PCMSolver; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing include/PCMSolver/pcmsolver.h; PCMSolver_DIR — CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing share/cmake/PCMSolver/PCMSolverConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_PCMSolver — CMake variable to force internal build of PCMSolver instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_PCMSolver — CMake variable to force detecting pre-built PCMSolver and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_PCMSolver=ON. Build without PCMSolver. >>> cmake. table of contents. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; PCM; PCM_SCF_TYPE; PCM_CC_TYPE. How to configure PCMSolver for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6; ",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:562,Modifiability,config,configuration,562,"﻿. Interface to PCMSolver by R. Di Remigio. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to PCMSolver by R. Di Remigio. Interface to PCMSolver by R. Di Remigio¶; Code author: Roberto Di Remigio, T. Daniel Crawford, Andrew C. Simmonett; Section author: Roberto Di Remigio; Module: Keywords, PSI Variables, PCMSolver. PSI4 contains code to interface to the PCMSolver library developed; by R. Di Remigio and L. Frediani.; The PCMSolver library requires no additional licence, downloads, or; configuration. The library allows for calculations in solution with the; polarizable continuum model (PCM), a continuum solvation model [Tomasi:2005:2999]. Installation¶; Binary. PCMSolver is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, PCMSolver has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; PCMSolver can be obtained through conda install pcmsolver -c psi4.; Then enable it as a feature with ENABLE_PCMSolver,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect PCMSolver and activate dependent code. To remove a conda installation, conda remove pcmsolver. Source. If using PSI4 built from source and you want PCMSolver built from; from source also,; enable it as a feature with ENABLE_PCMSolver,; and let the build system fetch and build it and activate dependent code. Using the polarizable continuum model¶; The inclusion of a PCM description of the solvent into your calculation; is achieved by setting PCM true in your input file.; PSI4 understands the additional option PCM_SCF_TYPE with possible values total; (the default) or separate.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging.; For the calculation of verti",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:4179,Modifiability,config,configure,4179,"ng:; molecule NH3 {; symmetry c1; N -0.0000000001 -0.1040380466 0.0000000000; H -0.9015844116 0.4818470201 -1.5615900098; H -0.9015844116 0.4818470201 1.5615900098; H 1.8031688251 0.4818470204 0.0000000000; units bohr; no_reorient; no_com; }. set {; basis STO-3G; scf_type pk; pcm true; pcm_scf_type total; }. pcm = {; Units = Angstrom; Medium {; SolverType = IEFPCM; Solvent = Water; }. Cavity {; RadiiSet = UFF; Type = GePol; Scaling = False; Area = 0.3; Mode = Implicit; }; }. More examples can be found in the directories with PCM tests; pcmsolver/ccsd-pte,; pcmsolver/scf,; pcmsolver/opt-fd,; pcmsolver/dft, and; pcmsolver/dipole. Keywords for PCMSolver¶. PCM¶. PCM boolean for pcmsolver module. Type: boolean; Default: false. PCM_SCF_TYPE¶. Use total or separate potentials and charges in the PCM-SCF step. Type: string; Possible Values: TOTAL, SEPARATE; Default: TOTAL. PCM_CC_TYPE¶. PCM-CCSD algorithm type. Type: string; Possible Values: PTE; Default: PTE. How to configure PCMSolver for building Psi4¶; Role and Dependencies. Role — In PSI4, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) PCMSolver; Upstream Dependencies — PCMSolver \(\Leftarrow\) Fortran, zlib. CMake Variables. ENABLE_PCMSolver — CMake variable toggling whether Psi4 builds with PCMSolver; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing include/PCMSolver/pcmsolver.h; PCMSolver_DIR — CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing share/cmake/PCMSolver/PCMSolverConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_PCMSolver — CMake variable to force internal build of PCMSolver instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_PCMSolver — CMake variable to force detecting pre-built PCMSolver and not falling back on internal build. Examples. B",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:4534,Modifiability,variab,variable,4534,"Cavity {; RadiiSet = UFF; Type = GePol; Scaling = False; Area = 0.3; Mode = Implicit; }; }. More examples can be found in the directories with PCM tests; pcmsolver/ccsd-pte,; pcmsolver/scf,; pcmsolver/opt-fd,; pcmsolver/dft, and; pcmsolver/dipole. Keywords for PCMSolver¶. PCM¶. PCM boolean for pcmsolver module. Type: boolean; Default: false. PCM_SCF_TYPE¶. Use total or separate potentials and charges in the PCM-SCF step. Type: string; Possible Values: TOTAL, SEPARATE; Default: TOTAL. PCM_CC_TYPE¶. PCM-CCSD algorithm type. Type: string; Possible Values: PTE; Default: PTE. How to configure PCMSolver for building Psi4¶; Role and Dependencies. Role — In PSI4, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) PCMSolver; Upstream Dependencies — PCMSolver \(\Leftarrow\) Fortran, zlib. CMake Variables. ENABLE_PCMSolver — CMake variable toggling whether Psi4 builds with PCMSolver; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing include/PCMSolver/pcmsolver.h; PCMSolver_DIR — CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing share/cmake/PCMSolver/PCMSolverConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_PCMSolver — CMake variable to force internal build of PCMSolver instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_PCMSolver — CMake variable to force detecting pre-built PCMSolver and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_PCMSolver=ON. Build without PCMSolver. >>> cmake. table of contents. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; PCM; PCM_SCF_TYPE; PCM_CC_TYPE. How to configure PCMSolver for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6; ",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:4619,Modifiability,variab,variable,4619,"Cavity {; RadiiSet = UFF; Type = GePol; Scaling = False; Area = 0.3; Mode = Implicit; }; }. More examples can be found in the directories with PCM tests; pcmsolver/ccsd-pte,; pcmsolver/scf,; pcmsolver/opt-fd,; pcmsolver/dft, and; pcmsolver/dipole. Keywords for PCMSolver¶. PCM¶. PCM boolean for pcmsolver module. Type: boolean; Default: false. PCM_SCF_TYPE¶. Use total or separate potentials and charges in the PCM-SCF step. Type: string; Possible Values: TOTAL, SEPARATE; Default: TOTAL. PCM_CC_TYPE¶. PCM-CCSD algorithm type. Type: string; Possible Values: PTE; Default: PTE. How to configure PCMSolver for building Psi4¶; Role and Dependencies. Role — In PSI4, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) PCMSolver; Upstream Dependencies — PCMSolver \(\Leftarrow\) Fortran, zlib. CMake Variables. ENABLE_PCMSolver — CMake variable toggling whether Psi4 builds with PCMSolver; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing include/PCMSolver/pcmsolver.h; PCMSolver_DIR — CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing share/cmake/PCMSolver/PCMSolverConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_PCMSolver — CMake variable to force internal build of PCMSolver instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_PCMSolver — CMake variable to force detecting pre-built PCMSolver and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_PCMSolver=ON. Build without PCMSolver. >>> cmake. table of contents. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; PCM; PCM_SCF_TYPE; PCM_CC_TYPE. How to configure PCMSolver for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6; ",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:4794,Modifiability,variab,variable,4794,"pcmsolver/dft, and; pcmsolver/dipole. Keywords for PCMSolver¶. PCM¶. PCM boolean for pcmsolver module. Type: boolean; Default: false. PCM_SCF_TYPE¶. Use total or separate potentials and charges in the PCM-SCF step. Type: string; Possible Values: TOTAL, SEPARATE; Default: TOTAL. PCM_CC_TYPE¶. PCM-CCSD algorithm type. Type: string; Possible Values: PTE; Default: PTE. How to configure PCMSolver for building Psi4¶; Role and Dependencies. Role — In PSI4, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) PCMSolver; Upstream Dependencies — PCMSolver \(\Leftarrow\) Fortran, zlib. CMake Variables. ENABLE_PCMSolver — CMake variable toggling whether Psi4 builds with PCMSolver; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing include/PCMSolver/pcmsolver.h; PCMSolver_DIR — CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing share/cmake/PCMSolver/PCMSolverConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_PCMSolver — CMake variable to force internal build of PCMSolver instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_PCMSolver — CMake variable to force detecting pre-built PCMSolver and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_PCMSolver=ON. Build without PCMSolver. >>> cmake. table of contents. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; PCM; PCM_SCF_TYPE; PCM_CC_TYPE. How to configure PCMSolver for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to PCMSolver by R. Di Remigio. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:4985,Modifiability,variab,variable,4985,"pcmsolver/dft, and; pcmsolver/dipole. Keywords for PCMSolver¶. PCM¶. PCM boolean for pcmsolver module. Type: boolean; Default: false. PCM_SCF_TYPE¶. Use total or separate potentials and charges in the PCM-SCF step. Type: string; Possible Values: TOTAL, SEPARATE; Default: TOTAL. PCM_CC_TYPE¶. PCM-CCSD algorithm type. Type: string; Possible Values: PTE; Default: PTE. How to configure PCMSolver for building Psi4¶; Role and Dependencies. Role — In PSI4, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) PCMSolver; Upstream Dependencies — PCMSolver \(\Leftarrow\) Fortran, zlib. CMake Variables. ENABLE_PCMSolver — CMake variable toggling whether Psi4 builds with PCMSolver; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing include/PCMSolver/pcmsolver.h; PCMSolver_DIR — CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing share/cmake/PCMSolver/PCMSolverConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_PCMSolver — CMake variable to force internal build of PCMSolver instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_PCMSolver — CMake variable to force detecting pre-built PCMSolver and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_PCMSolver=ON. Build without PCMSolver. >>> cmake. table of contents. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; PCM; PCM_SCF_TYPE; PCM_CC_TYPE. How to configure PCMSolver for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to PCMSolver by R. Di Remigio. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:5107,Modifiability,variab,variable,5107,"pcmsolver/dft, and; pcmsolver/dipole. Keywords for PCMSolver¶. PCM¶. PCM boolean for pcmsolver module. Type: boolean; Default: false. PCM_SCF_TYPE¶. Use total or separate potentials and charges in the PCM-SCF step. Type: string; Possible Values: TOTAL, SEPARATE; Default: TOTAL. PCM_CC_TYPE¶. PCM-CCSD algorithm type. Type: string; Possible Values: PTE; Default: PTE. How to configure PCMSolver for building Psi4¶; Role and Dependencies. Role — In PSI4, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) PCMSolver; Upstream Dependencies — PCMSolver \(\Leftarrow\) Fortran, zlib. CMake Variables. ENABLE_PCMSolver — CMake variable toggling whether Psi4 builds with PCMSolver; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing include/PCMSolver/pcmsolver.h; PCMSolver_DIR — CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing share/cmake/PCMSolver/PCMSolverConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_PCMSolver — CMake variable to force internal build of PCMSolver instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_PCMSolver — CMake variable to force detecting pre-built PCMSolver and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_PCMSolver=ON. Build without PCMSolver. >>> cmake. table of contents. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; PCM; PCM_SCF_TYPE; PCM_CC_TYPE. How to configure PCMSolver for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to PCMSolver by R. Di Remigio. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:5465,Modifiability,config,configure,5465,"pcmsolver/dft, and; pcmsolver/dipole. Keywords for PCMSolver¶. PCM¶. PCM boolean for pcmsolver module. Type: boolean; Default: false. PCM_SCF_TYPE¶. Use total or separate potentials and charges in the PCM-SCF step. Type: string; Possible Values: TOTAL, SEPARATE; Default: TOTAL. PCM_CC_TYPE¶. PCM-CCSD algorithm type. Type: string; Possible Values: PTE; Default: PTE. How to configure PCMSolver for building Psi4¶; Role and Dependencies. Role — In PSI4, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) PCMSolver; Upstream Dependencies — PCMSolver \(\Leftarrow\) Fortran, zlib. CMake Variables. ENABLE_PCMSolver — CMake variable toggling whether Psi4 builds with PCMSolver; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing include/PCMSolver/pcmsolver.h; PCMSolver_DIR — CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing share/cmake/PCMSolver/PCMSolverConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_PCMSolver — CMake variable to force internal build of PCMSolver instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_PCMSolver — CMake variable to force detecting pre-built PCMSolver and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_PCMSolver=ON. Build without PCMSolver. >>> cmake. table of contents. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; PCM; PCM_SCF_TYPE; PCM_CC_TYPE. How to configure PCMSolver for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to PCMSolver by R. Di Remigio. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:2829,Performance,optimiz,optimize,2829,"lt) or separate.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging.; For the calculation of vertical excitation energies with PCM non-equilibrium solvation should be included with:; pcm = {; Medium {; Nonequilibrium = True; }; }. Note; At present PCM can only be used for energy calculations with SCF; wavefunctions and CC wavefunctions in the PTE approximation [Cammi:2009:164104].; All ERI algorithms (PK, OUT_OF_CORE, DIRECT, DF, CD) are supported. Note; linear response calculations (static polarisabilities, TD-SCF) are supported for RHF/UHF if available. Warning; The PCMSolver library cannot exploit molecular point group symmetry. Warning; ROHF with PCM is known not to work. See issue #999 on GitHub.; For the adventurous, a fix is available in pull request #953 on GitHub. Warning; Analytic gradients and Hessians are not available with PCM. Finite differences will be used; regardless of the dertype passed to the optimize function.; See pcmsolver/opt-fd for a sample input. The PCM model and molecular cavity are specified in a pcm section that has; to be explicitly typed in by the user. This additional section follows a syntax; that is slightly different from that of PSI4 and is fully documented; here; A typical input for a Hartree–Fock calculation with PCM would look like the following:; molecule NH3 {; symmetry c1; N -0.0000000001 -0.1040380466 0.0000000000; H -0.9015844116 0.4818470201 -1.5615900098; H -0.9015844116 0.4818470201 1.5615900098; H 1.8031688251 0.4818470204 0.0000000000; units bohr; no_reorient; no_com; }. set {; basis STO-3G; scf_type pk; pcm true; pcm_scf_type total; }. pcm = {; Units = Angstrom; Medium {; SolverType = IEFPCM; Solvent = Water; }. Cavity {; RadiiSet = UFF; Type = GePol; Scaling = False; Area = 0.3; Mode = Implicit; }; }. More examples can be found in the directories with PCM tests; pcmsolver/ccsd-pte,; pcmsolver/scf,; pcmsolver/opt-fd",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:1229,Safety,detect,detect,1229," Interface to PCMSolver by R. Di Remigio¶; Code author: Roberto Di Remigio, T. Daniel Crawford, Andrew C. Simmonett; Section author: Roberto Di Remigio; Module: Keywords, PSI Variables, PCMSolver. PSI4 contains code to interface to the PCMSolver library developed; by R. Di Remigio and L. Frediani.; The PCMSolver library requires no additional licence, downloads, or; configuration. The library allows for calculations in solution with the; polarizable continuum model (PCM), a continuum solvation model [Tomasi:2005:2999]. Installation¶; Binary. PCMSolver is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, PCMSolver has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; PCMSolver can be obtained through conda install pcmsolver -c psi4.; Then enable it as a feature with ENABLE_PCMSolver,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect PCMSolver and activate dependent code. To remove a conda installation, conda remove pcmsolver. Source. If using PSI4 built from source and you want PCMSolver built from; from source also,; enable it as a feature with ENABLE_PCMSolver,; and let the build system fetch and build it and activate dependent code. Using the polarizable continuum model¶; The inclusion of a PCM description of the solvent into your calculation; is achieved by setting PCM true in your input file.; PSI4 understands the additional option PCM_SCF_TYPE with possible values total; (the default) or separate.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging.; For the calculation of vertical excitation energies with PCM non-equilibrium solvation should be included with:; pcm = {; Medium {; Nonequilibrium = True; }; }. Note; At present PCM can only be used for energy calculatio",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:5042,Safety,detect,detecting,5042,"pcmsolver/dft, and; pcmsolver/dipole. Keywords for PCMSolver¶. PCM¶. PCM boolean for pcmsolver module. Type: boolean; Default: false. PCM_SCF_TYPE¶. Use total or separate potentials and charges in the PCM-SCF step. Type: string; Possible Values: TOTAL, SEPARATE; Default: TOTAL. PCM_CC_TYPE¶. PCM-CCSD algorithm type. Type: string; Possible Values: PTE; Default: PTE. How to configure PCMSolver for building Psi4¶; Role and Dependencies. Role — In PSI4, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) PCMSolver; Upstream Dependencies — PCMSolver \(\Leftarrow\) Fortran, zlib. CMake Variables. ENABLE_PCMSolver — CMake variable toggling whether Psi4 builds with PCMSolver; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing include/PCMSolver/pcmsolver.h; PCMSolver_DIR — CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing share/cmake/PCMSolver/PCMSolverConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_PCMSolver — CMake variable to force internal build of PCMSolver instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_PCMSolver — CMake variable to force detecting pre-built PCMSolver and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_PCMSolver=ON. Build without PCMSolver. >>> cmake. table of contents. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; PCM; PCM_SCF_TYPE; PCM_CC_TYPE. How to configure PCMSolver for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to PCMSolver by R. Di Remigio. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:5125,Safety,detect,detecting,5125,"pcmsolver/dft, and; pcmsolver/dipole. Keywords for PCMSolver¶. PCM¶. PCM boolean for pcmsolver module. Type: boolean; Default: false. PCM_SCF_TYPE¶. Use total or separate potentials and charges in the PCM-SCF step. Type: string; Possible Values: TOTAL, SEPARATE; Default: TOTAL. PCM_CC_TYPE¶. PCM-CCSD algorithm type. Type: string; Possible Values: PTE; Default: PTE. How to configure PCMSolver for building Psi4¶; Role and Dependencies. Role — In PSI4, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) PCMSolver; Upstream Dependencies — PCMSolver \(\Leftarrow\) Fortran, zlib. CMake Variables. ENABLE_PCMSolver — CMake variable toggling whether Psi4 builds with PCMSolver; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing include/PCMSolver/pcmsolver.h; PCMSolver_DIR — CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing share/cmake/PCMSolver/PCMSolverConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_PCMSolver — CMake variable to force internal build of PCMSolver instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_PCMSolver — CMake variable to force detecting pre-built PCMSolver and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_PCMSolver=ON. Build without PCMSolver. >>> cmake. table of contents. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; PCM; PCM_SCF_TYPE; PCM_CC_TYPE. How to configure PCMSolver for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to PCMSolver by R. Di Remigio. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pcmsolver.html:3741,Testability,test,tests,3741,"differences will be used; regardless of the dertype passed to the optimize function.; See pcmsolver/opt-fd for a sample input. The PCM model and molecular cavity are specified in a pcm section that has; to be explicitly typed in by the user. This additional section follows a syntax; that is slightly different from that of PSI4 and is fully documented; here; A typical input for a Hartree–Fock calculation with PCM would look like the following:; molecule NH3 {; symmetry c1; N -0.0000000001 -0.1040380466 0.0000000000; H -0.9015844116 0.4818470201 -1.5615900098; H -0.9015844116 0.4818470201 1.5615900098; H 1.8031688251 0.4818470204 0.0000000000; units bohr; no_reorient; no_com; }. set {; basis STO-3G; scf_type pk; pcm true; pcm_scf_type total; }. pcm = {; Units = Angstrom; Medium {; SolverType = IEFPCM; Solvent = Water; }. Cavity {; RadiiSet = UFF; Type = GePol; Scaling = False; Area = 0.3; Mode = Implicit; }; }. More examples can be found in the directories with PCM tests; pcmsolver/ccsd-pte,; pcmsolver/scf,; pcmsolver/opt-fd,; pcmsolver/dft, and; pcmsolver/dipole. Keywords for PCMSolver¶. PCM¶. PCM boolean for pcmsolver module. Type: boolean; Default: false. PCM_SCF_TYPE¶. Use total or separate potentials and charges in the PCM-SCF step. Type: string; Possible Values: TOTAL, SEPARATE; Default: TOTAL. PCM_CC_TYPE¶. PCM-CCSD algorithm type. Type: string; Possible Values: PTE; Default: PTE. How to configure PCMSolver for building Psi4¶; Role and Dependencies. Role — In PSI4, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) PCMSolver; Upstream Dependencies — PCMSolver \(\Leftarrow\) Fortran, zlib. CMake Variables. ENABLE_PCMSolver — CMake variable toggling whether Psi4 builds with PCMSolver; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing include/PCMSolver/pcms",MatchSource.WIKI,psi4manual/1.6.x/pcmsolver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html
https://psicode.org/psi4manual/1.6.x/pep0001.html:1525,Availability,down,down,1525,"oposal PEP1) protocol to organize; PSI4. Presently, topics are brought up on e-mail threads (where; discussion is very temporally localized and not everyone is aware of it; unless cc’d), are brought up at workshops (where people may be absent, no; record is left, and not everyone may have prepared a position on the; topic), or agreed between a couple people over g-chat (others remain; unaware of plans), or planned by someone (who may not have committed those; plans to a ticket or who wants general approval before restructuring the; code). Path of a PsiPEP¶. Someone creates a file doc/sphinxman/source/pepXXXX.rst modeled; on psi4/doc/sphinxman/source/pep0000model.rst and adds; it to STATICDOC in psi4/doc/sphinxman/CMakeLists.txt. The file; should have header fields modeled on another PsiPEP and a discussion of; the proposed change or practice.; Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out and the (possibly edited); results be pasted into the bottom of the reST file once the furor dies; down.; Comments can be simple statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history).; Once there’s agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include¶. Best practices or re-vamped best practices; Practices can be easily linked- or referred-to by number and can be; tagged as obsolete by a single label change months later. Request/present viewpoint on organization; Draw attention to organization needed in code outside one’s area of; expertise. Request interface for some structure (e.g., gradients) or; viewpoints on how that interface will behave to ensure compatibility.; Offer philosophy on how processes/definitions should be. Fair Warning: Proposal to change things up; ",MatchSource.WIKI,psi4manual/1.6.x/pep0001.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pep0001.html
https://psicode.org/psi4manual/1.6.x/pep0001.html:3192,Deployability,update,updated,3192,"ssion of; the proposed change or practice.; Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out and the (possibly edited); results be pasted into the bottom of the reST file once the furor dies; down.; Comments can be simple statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history).; Once there’s agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include¶. Best practices or re-vamped best practices; Practices can be easily linked- or referred-to by number and can be; tagged as obsolete by a single label change months later. Request/present viewpoint on organization; Draw attention to organization needed in code outside one’s area of; expertise. Request interface for some structure (e.g., gradients) or; viewpoints on how that interface will behave to ensure compatibility.; Offer philosophy on how processes/definitions should be. Fair Warning: Proposal to change things up; Announce plans to re-organize code structure or how something is; handled. List goals (may be conflicting) and how proposed scheme best; satisfies them. PsiPEP allows discussion before roll-out in case; proposal has deleterious side-effects. The contrast between a PsiPEP and a ticket is that for the latter, there’s; no question of whether the task is to be done as described. Comments¶; 04-Jul-2012, LAB. table of contents. PEP1: Proposing PsiPEP for PSI4; Path of a PsiPEP; Roles of a PsiPEP Include; Comments. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PsiPEP: Plans and Practices to Organize PSI4; PEP1: Proposing PsiPEP for PSI4. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/pep0001.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pep0001.html
https://psicode.org/psi4manual/1.6.x/pep0001.html:467,Integrability,protocol,protocol,467,"﻿. PEP1: Proposing PsiPEP for PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PsiPEP: Plans and Practices to Organize PSI4; PEP1: Proposing PsiPEP for PSI4. PEP1: Proposing PsiPEP for PSI4¶. PEP; 1. Title; Proposing PsiPEP for PSI4. Last-Modified; 04-Jul-2012. Author; Lori Burns. Content-Type; text/x-rst. Created; 04-Jul-2012. This document proposes using a (much more informal) version of Python’s; PEP (Python Enhancement Proposal PEP1) protocol to organize; PSI4. Presently, topics are brought up on e-mail threads (where; discussion is very temporally localized and not everyone is aware of it; unless cc’d), are brought up at workshops (where people may be absent, no; record is left, and not everyone may have prepared a position on the; topic), or agreed between a couple people over g-chat (others remain; unaware of plans), or planned by someone (who may not have committed those; plans to a ticket or who wants general approval before restructuring the; code). Path of a PsiPEP¶. Someone creates a file doc/sphinxman/source/pepXXXX.rst modeled; on psi4/doc/sphinxman/source/pep0000model.rst and adds; it to STATICDOC in psi4/doc/sphinxman/CMakeLists.txt. The file; should have header fields modeled on another PsiPEP and a discussion of; the proposed change or practice.; Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out and the (possibly edited); results be pasted into the bottom of the reST file once the furor dies; down.; Comments can be simple statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history).; Once there’s agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include¶. Best practices or re-vamped best practices; Practices can be easily lin",MatchSource.WIKI,psi4manual/1.6.x/pep0001.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pep0001.html
https://psicode.org/psi4manual/1.6.x/pep0001.html:2232,Integrability,interface,interface,2232,"ther PsiPEP and a discussion of; the proposed change or practice.; Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out and the (possibly edited); results be pasted into the bottom of the reST file once the furor dies; down.; Comments can be simple statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history).; Once there’s agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include¶. Best practices or re-vamped best practices; Practices can be easily linked- or referred-to by number and can be; tagged as obsolete by a single label change months later. Request/present viewpoint on organization; Draw attention to organization needed in code outside one’s area of; expertise. Request interface for some structure (e.g., gradients) or; viewpoints on how that interface will behave to ensure compatibility.; Offer philosophy on how processes/definitions should be. Fair Warning: Proposal to change things up; Announce plans to re-organize code structure or how something is; handled. List goals (may be conflicting) and how proposed scheme best; satisfies them. PsiPEP allows discussion before roll-out in case; proposal has deleterious side-effects. The contrast between a PsiPEP and a ticket is that for the latter, there’s; no question of whether the task is to be done as described. Comments¶; 04-Jul-2012, LAB. table of contents. PEP1: Proposing PsiPEP for PSI4; Path of a PsiPEP; Roles of a PsiPEP Include; Comments. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PsiPEP: Plans and Practices to Organize PSI4; PEP1: Proposing PsiPEP for PSI4. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created u",MatchSource.WIKI,psi4manual/1.6.x/pep0001.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pep0001.html
https://psicode.org/psi4manual/1.6.x/pep0001.html:2306,Integrability,interface,interface,2306,"ssion of; the proposed change or practice.; Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out and the (possibly edited); results be pasted into the bottom of the reST file once the furor dies; down.; Comments can be simple statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history).; Once there’s agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include¶. Best practices or re-vamped best practices; Practices can be easily linked- or referred-to by number and can be; tagged as obsolete by a single label change months later. Request/present viewpoint on organization; Draw attention to organization needed in code outside one’s area of; expertise. Request interface for some structure (e.g., gradients) or; viewpoints on how that interface will behave to ensure compatibility.; Offer philosophy on how processes/definitions should be. Fair Warning: Proposal to change things up; Announce plans to re-organize code structure or how something is; handled. List goals (may be conflicting) and how proposed scheme best; satisfies them. PsiPEP allows discussion before roll-out in case; proposal has deleterious side-effects. The contrast between a PsiPEP and a ticket is that for the latter, there’s; no question of whether the task is to be done as described. Comments¶; 04-Jul-2012, LAB. table of contents. PEP1: Proposing PsiPEP for PSI4; Path of a PsiPEP; Roles of a PsiPEP Include; Comments. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PsiPEP: Plans and Practices to Organize PSI4; PEP1: Proposing PsiPEP for PSI4. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/pep0001.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pep0001.html
https://psicode.org/psi4manual/1.6.x/pep0001.html:1548,Usability,simpl,simple,1548,"one is aware of it; unless cc’d), are brought up at workshops (where people may be absent, no; record is left, and not everyone may have prepared a position on the; topic), or agreed between a couple people over g-chat (others remain; unaware of plans), or planned by someone (who may not have committed those; plans to a ticket or who wants general approval before restructuring the; code). Path of a PsiPEP¶. Someone creates a file doc/sphinxman/source/pepXXXX.rst modeled; on psi4/doc/sphinxman/source/pep0000model.rst and adds; it to STATICDOC in psi4/doc/sphinxman/CMakeLists.txt. The file; should have header fields modeled on another PsiPEP and a discussion of; the proposed change or practice.; Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out and the (possibly edited); results be pasted into the bottom of the reST file once the furor dies; down.; Comments can be simple statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history).; Once there’s agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include¶. Best practices or re-vamped best practices; Practices can be easily linked- or referred-to by number and can be; tagged as obsolete by a single label change months later. Request/present viewpoint on organization; Draw attention to organization needed in code outside one’s area of; expertise. Request interface for some structure (e.g., gradients) or; viewpoints on how that interface will behave to ensure compatibility.; Offer philosophy on how processes/definitions should be. Fair Warning: Proposal to change things up; Announce plans to re-organize code structure or how something is; handled. List goals (may be conflicting) and how proposed scheme best; satisfies them.",MatchSource.WIKI,psi4manual/1.6.x/pep0001.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pep0001.html
https://psicode.org/psi4manual/1.6.x/plugins.html:2717,Availability,echo,echo,2717,"llowing commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin:. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Che",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:6432,Availability,avail,available,6432,"ticular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, ",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:7938,Availability,error,errors,7938,"y() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Updating the Users’ and Programmers’ Manual; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Creating New Plugins; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Creating New Plugins. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:2357,Deployability,install,installed,2357," cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin:. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rs",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:2537,Deployability,install,installing,2537,"ake; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin:. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial ca",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:3135,Deployability,install,install,3135,"-plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin:. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:4981,Deployability,install,installation,4981,"make; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input fi",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:5106,Deployability,install,installation,5106,"r: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, t",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:8680,Deployability,update,updated,8680,"y() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Updating the Users’ and Programmers’ Manual; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Creating New Plugins; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Creating New Plugins. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:6376,Energy Efficiency,energy,energy,6376,"rridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — D",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:6749,Energy Efficiency,energy,energy,6749,"ctory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any doc",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:6790,Energy Efficiency,energy,energy,6790,"ctory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any doc",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:4292,Integrability,depend,dependencies,4292,"as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache pa",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:7179,Integrability,depend,depends,7179," as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Updating the Users’ and Programmers’ Manual; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; er",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:654,Modifiability,plugin,plugin,654,"﻿. Creating New Plugins. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Creating New Plugins. Creating New Plugins¶. Modular Approach to Development¶; It is slightly cumbersome to the development cycle to recompile PSI4; every time a change is made to the C++ code.; It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-te",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:833,Modifiability,plugin,plugins,833,"﻿. Creating New Plugins. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Creating New Plugins. Creating New Plugins¶. Modular Approach to Development¶; It is slightly cumbersome to the development cycle to recompile PSI4; every time a change is made to the C++ code.; It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-te",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:933,Modifiability,plugin,plugins,933,"﻿. Creating New Plugins. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Creating New Plugins. Creating New Plugins¶. Modular Approach to Development¶; It is slightly cumbersome to the development cycle to recompile PSI4; every time a change is made to the C++ code.; It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-te",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:1031,Modifiability,plugin,plugin,1031," .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Creating New Plugins. Creating New Plugins¶. Modular Approach to Development¶; It is slightly cumbersome to the development cycle to recompile PSI4; every time a change is made to the C++ code.; It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-t",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:1188,Modifiability,plugin,plugin-name,1188,"nt¶; It is slightly cumbersome to the development cycle to recompile PSI4; every time a change is made to the C++ code.; It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; ",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:1278,Modifiability,plugin,plugin,1278," to recompile PSI4; every time a change is made to the C++ code.; It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both P",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:1535,Modifiability,plugin,plugin-compile,1535," problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; i",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:1780,Modifiability,plugin,plugin-name,1780,"reate basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> whic",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:1803,Modifiability,plugin,plugin-template,1803,"reate basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> whic",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:1843,Modifiability,plugin,plugin-name,1843,"reate basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> whic",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:1866,Modifiability,plugin,plugin-template,1866,"reate basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> whic",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:1906,Modifiability,plugin,plugin-name,1906,"reate basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> whic",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:1929,Modifiability,plugin,plugin-template,1929,"reate basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> whic",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:1969,Modifiability,plugin,plugin-name,1969,"reate basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> whic",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:1992,Modifiability,plugin,plugin-template,1992,"reate basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> whic",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:2033,Modifiability,plugin,plugin-name,2033,"reate basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> whic",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:2056,Modifiability,plugin,plugin-template,2056,"reate basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> whic",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:2088,Modifiability,plugin,plugin-name,2088,"reate basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> whic",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:2111,Modifiability,plugin,plugin-template,2111,"reate basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> whic",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:2197,Modifiability,plugin,plugins,2197,"PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin:. >>> psi4 --plugin-name testplu",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:3171,Modifiability,plugin,plugin,3171,"onda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin:. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Gener",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:3191,Modifiability,plugin,plugin-name,3191,"ated using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin:. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplu",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:3294,Modifiability,plugin,plugin,3294,"buntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin:. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencie",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:3383,Modifiability,plugin,plugin,3383,"self in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin:. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plug",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:3419,Modifiability,plugin,plugin,3419," (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin:. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testp",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:3458,Modifiability,config,configure,3458,"by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin:. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:3515,Modifiability,plugin,plugin-compile,3515,"by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin:. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:3872,Modifiability,plugin,plugin-compile,3872,"bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin:. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake fil",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:4240,Modifiability,plugin,plugin,4240,"asic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the com",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:4380,Modifiability,plugin,plugin,4380,", plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=va",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:4687,Modifiability,plugin,plugins,4687,"r identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any chang",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:4805,Modifiability,plugin,plugin,4805," files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add addi",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:4898,Modifiability,plugin,plugin,4898,"le` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to addi",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:4911,Modifiability,plugin,plugin,4911,"$PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; in",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:5064,Modifiability,plugin,plugin,5064,"r: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, t",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:5131,Modifiability,plugin,plugin-compile,5131," Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory m",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:5604,Modifiability,plugin,plugin,5604,"in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:5646,Modifiability,plugin,plugin,5646,"cution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function ",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:5688,Modifiability,plugin,plugin,5688,"cution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function ",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:5854,Modifiability,plugin,plugin,5854,"CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be pl",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:5978,Modifiability,plugin,plugin,5978,"tform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:6024,Modifiability,plugin,plugin,6024," plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python ",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:6073,Modifiability,plugin,plugin,6073," plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python ",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:6142,Modifiability,plugin,plugin,6142," Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on ",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:6319,Modifiability,plugin,plugin,6319,"rridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — D",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:6565,Modifiability,plugin,plugin,6565,"e build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build ",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:6639,Modifiability,plugin,plugin,6639,"ctory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any doc",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:6696,Modifiability,plugin,plugin,6696,"ctory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any doc",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:6923,Modifiability,plugin,plugin,6923,"at — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Updating the Users’ and Programmers’ Manual; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors whe",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:6960,Modifiability,plugin,plugin,6960,"at — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Updating the Users’ and Programmers’ Manual; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors whe",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:7086,Modifiability,plugin,plugin,7086," as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Updating the Users’ and Programmers’ Manual; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; er",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:7172,Modifiability,plugin,plugin,7172," as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Updating the Users’ and Programmers’ Manual; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; er",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:7209,Modifiability,plugin,plugin,7209,"s is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Updating the Users’ and Programmers’ Manual; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading t",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:7287,Modifiability,plugin,plugin,7287,"s is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Updating the Users’ and Programmers’ Manual; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading t",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:7323,Modifiability,plugin,plugin,7323,"s is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Updating the Users’ and Programmers’ Manual; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading t",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:7903,Modifiability,plugin,plugin,7903,"y() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Updating the Users’ and Programmers’ Manual; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Creating New Plugins; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Creating New Plugins. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:7955,Modifiability,plugin,plugin,7955,"y() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Updating the Users’ and Programmers’ Manual; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Creating New Plugins; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Creating New Plugins. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:8000,Modifiability,plugin,plugin,8000,"y() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Updating the Users’ and Programmers’ Manual; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Creating New Plugins; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Creating New Plugins. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:8021,Modifiability,plugin,plugin,8021,"y() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Updating the Users’ and Programmers’ Manual; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Creating New Plugins; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Creating New Plugins. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:8268,Modifiability,plugin,plugin,8268,"y() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Updating the Users’ and Programmers’ Manual; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Creating New Plugins; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Creating New Plugins. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:848,Performance,load,loaded,848,"﻿. Creating New Plugins. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Creating New Plugins. Creating New Plugins¶. Modular Approach to Development¶; It is slightly cumbersome to the development cycle to recompile PSI4; every time a change is made to the C++ code.; It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-te",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:3540,Performance,load,loading,3540,"by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin:. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:3556,Performance,cache,cache,3556,"by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin:. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:3895,Performance,load,loading,3895,"bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin:. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake fil",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:3911,Performance,cache,cache,3911,"bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin:. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake fil",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:5232,Performance,load,loading,5232,"in.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:6333,Performance,load,loaded,6333,"rridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — D",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:7965,Performance,load,loaded,7965,"y() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Updating the Users’ and Programmers’ Manual; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Creating New Plugins; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Creating New Plugins. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:8116,Performance,load,loading,8116,"y() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Updating the Users’ and Programmers’ Manual; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Creating New Plugins; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Creating New Plugins. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:8256,Performance,load,loading,8256,"y() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Updating the Users’ and Programmers’ Manual; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Creating New Plugins; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Creating New Plugins. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:6772,Security,access,accessed,6772,"ctory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any doc",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:3203,Testability,test,testplugin,3203,"ated using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin:. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplu",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:3228,Testability,test,testplugin,3228,"ated using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin:. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplu",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:3311,Testability,test,testplugin,3311,"buntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin:. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencie",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:3444,Testability,test,testplugin,3444," (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin:. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testp",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:3848,Testability,test,testplugin,3848,"bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin:. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake fil",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:4214,Testability,test,testplugin,4214,"-plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:4258,Testability,test,testplugin,4258,"asic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the com",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:4315,Testability,test,testplugin,4315,"as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache pa",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:4365,Testability,test,testplugin,4365,"as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache pa",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:4426,Testability,test,testplugin,4426," into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointi",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:4461,Testability,test,testplugin,4461,". # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probabl",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:6478,Testability,test,testfunction,6478,"E_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the u",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugins.html:374,Usability,learn,learn,374,"﻿. Creating New Plugins. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Creating New Plugins. Creating New Plugins¶. Modular Approach to Development¶; It is slightly cumbersome to the development cycle to recompile PSI4; every time a change is made to the C++ code.; It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-te",MatchSource.WIKI,psi4manual/1.6.x/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html
https://psicode.org/psi4manual/1.6.x/plugin_psi4fockci.html:1057,Availability,down,downloaded,1057,"; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA. Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA¶; Code author: Shannon E. Houck; Section author: Shannon E. Houck. This plugin is an implementation of the RAS-nSF-IP/EA approach detailed; in the paper by Houck et. al. [Houck:2019:2278].; This approach handles systems with both spin and spatial degeneracies; by combining the spin-flip (SF) [Krylov:2001:522]; and ionization potential/electron affinity (IP/EA) [Nooijen:1995:3629]; approaches.; The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization; potential (IP), and electron affinity (EA) calculations, as well as; combined RAS-SF-IP/EA calculations, through the DETCI (CI: Configuration Interaction) module. Installation¶. Download the plugin from the GitHub repository:; >>> git clone https://github.com/shannonhouck/psi4fockci.git. Once downloaded, the plugin can be installed as follows:; >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input¶; To run a CAS-nSF-IP/EA calculation, start with a molecule with the; correct charge and multiplicity for the reference state (i.e. some; state well-represented by a single reference). Then, run an energy; calculation, passing in the charge and multiplicity of the; desired state; the number of spin-flips and IP/EA will be automatically; determined based on this input. If additional excitations outside of the; RAS II space are desired, one can set the level of external; excitations using the conf_space keyword.; A sample input file for a RAS(h)-2SF-IP calculation is shown below:; molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""). Note that for calculations involving IP/EA, inclusion of hole (for IP) and; particle (for EA) excitations is strongly recommended. Additional keywords; can be found in the docum",MatchSource.WIKI,psi4manual/1.6.x/plugin_psi4fockci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_psi4fockci.html
https://psicode.org/psi4manual/1.6.x/plugin_psi4fockci.html:1087,Deployability,install,installed,1087,"; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA. Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA¶; Code author: Shannon E. Houck; Section author: Shannon E. Houck. This plugin is an implementation of the RAS-nSF-IP/EA approach detailed; in the paper by Houck et. al. [Houck:2019:2278].; This approach handles systems with both spin and spatial degeneracies; by combining the spin-flip (SF) [Krylov:2001:522]; and ionization potential/electron affinity (IP/EA) [Nooijen:1995:3629]; approaches.; The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization; potential (IP), and electron affinity (EA) calculations, as well as; combined RAS-SF-IP/EA calculations, through the DETCI (CI: Configuration Interaction) module. Installation¶. Download the plugin from the GitHub repository:; >>> git clone https://github.com/shannonhouck/psi4fockci.git. Once downloaded, the plugin can be installed as follows:; >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input¶; To run a CAS-nSF-IP/EA calculation, start with a molecule with the; correct charge and multiplicity for the reference state (i.e. some; state well-represented by a single reference). Then, run an energy; calculation, passing in the charge and multiplicity of the; desired state; the number of spin-flips and IP/EA will be automatically; determined based on this input. If additional excitations outside of the; RAS II space are desired, one can set the level of external; excitations using the conf_space keyword.; A sample input file for a RAS(h)-2SF-IP calculation is shown below:; molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""). Note that for calculations involving IP/EA, inclusion of hole (for IP) and; particle (for EA) excitations is strongly recommended. Additional keywords; can be found in the docum",MatchSource.WIKI,psi4manual/1.6.x/plugin_psi4fockci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_psi4fockci.html
https://psicode.org/psi4manual/1.6.x/plugin_psi4fockci.html:1169,Deployability,install,install,1169,"; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA. Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA¶; Code author: Shannon E. Houck; Section author: Shannon E. Houck. This plugin is an implementation of the RAS-nSF-IP/EA approach detailed; in the paper by Houck et. al. [Houck:2019:2278].; This approach handles systems with both spin and spatial degeneracies; by combining the spin-flip (SF) [Krylov:2001:522]; and ionization potential/electron affinity (IP/EA) [Nooijen:1995:3629]; approaches.; The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization; potential (IP), and electron affinity (EA) calculations, as well as; combined RAS-SF-IP/EA calculations, through the DETCI (CI: Configuration Interaction) module. Installation¶. Download the plugin from the GitHub repository:; >>> git clone https://github.com/shannonhouck/psi4fockci.git. Once downloaded, the plugin can be installed as follows:; >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input¶; To run a CAS-nSF-IP/EA calculation, start with a molecule with the; correct charge and multiplicity for the reference state (i.e. some; state well-represented by a single reference). Then, run an energy; calculation, passing in the charge and multiplicity of the; desired state; the number of spin-flips and IP/EA will be automatically; determined based on this input. If additional excitations outside of the; RAS II space are desired, one can set the level of external; excitations using the conf_space keyword.; A sample input file for a RAS(h)-2SF-IP calculation is shown below:; molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""). Note that for calculations involving IP/EA, inclusion of hole (for IP) and; particle (for EA) excitations is strongly recommended. Additional keywords; can be found in the docum",MatchSource.WIKI,psi4manual/1.6.x/plugin_psi4fockci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_psi4fockci.html
https://psicode.org/psi4manual/1.6.x/plugin_psi4fockci.html:2539,Deployability,update,updated,2539,"ization potential/electron affinity (IP/EA) [Nooijen:1995:3629]; approaches.; The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization; potential (IP), and electron affinity (EA) calculations, as well as; combined RAS-SF-IP/EA calculations, through the DETCI (CI: Configuration Interaction) module. Installation¶. Download the plugin from the GitHub repository:; >>> git clone https://github.com/shannonhouck/psi4fockci.git. Once downloaded, the plugin can be installed as follows:; >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input¶; To run a CAS-nSF-IP/EA calculation, start with a molecule with the; correct charge and multiplicity for the reference state (i.e. some; state well-represented by a single reference). Then, run an energy; calculation, passing in the charge and multiplicity of the; desired state; the number of spin-flips and IP/EA will be automatically; determined based on this input. If additional excitations outside of the; RAS II space are desired, one can set the level of external; excitations using the conf_space keyword.; A sample input file for a RAS(h)-2SF-IP calculation is shown below:; molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""). Note that for calculations involving IP/EA, inclusion of hole (for IP) and; particle (for EA) excitations is strongly recommended. Additional keywords; can be found in the documentation.; This input file can be run with Psi4:; >>> psi4 input.dat. table of contents. Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/plugin_psi4fockci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_psi4fockci.html
https://psicode.org/psi4manual/1.6.x/plugin_psi4fockci.html:1270,Energy Efficiency,charge,charge,1270,"eneral Fock-Space CI For Spin-Flip And IP/EA¶; Code author: Shannon E. Houck; Section author: Shannon E. Houck. This plugin is an implementation of the RAS-nSF-IP/EA approach detailed; in the paper by Houck et. al. [Houck:2019:2278].; This approach handles systems with both spin and spatial degeneracies; by combining the spin-flip (SF) [Krylov:2001:522]; and ionization potential/electron affinity (IP/EA) [Nooijen:1995:3629]; approaches.; The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization; potential (IP), and electron affinity (EA) calculations, as well as; combined RAS-SF-IP/EA calculations, through the DETCI (CI: Configuration Interaction) module. Installation¶. Download the plugin from the GitHub repository:; >>> git clone https://github.com/shannonhouck/psi4fockci.git. Once downloaded, the plugin can be installed as follows:; >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input¶; To run a CAS-nSF-IP/EA calculation, start with a molecule with the; correct charge and multiplicity for the reference state (i.e. some; state well-represented by a single reference). Then, run an energy; calculation, passing in the charge and multiplicity of the; desired state; the number of spin-flips and IP/EA will be automatically; determined based on this input. If additional excitations outside of the; RAS II space are desired, one can set the level of external; excitations using the conf_space keyword.; A sample input file for a RAS(h)-2SF-IP calculation is shown below:; molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""). Note that for calculations involving IP/EA, inclusion of hole (for IP) and; particle (for EA) excitations is strongly recommended. Additional keywords; can be found in the documentation.; This input file can be run with Psi4:; >>> psi4 input.dat. table of contents. Psi4FockCI: A General Fock-Space CI For Spin-F",MatchSource.WIKI,psi4manual/1.6.x/plugin_psi4fockci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_psi4fockci.html
https://psicode.org/psi4manual/1.6.x/plugin_psi4fockci.html:1390,Energy Efficiency,energy,energy,1390,"k:2019:2278].; This approach handles systems with both spin and spatial degeneracies; by combining the spin-flip (SF) [Krylov:2001:522]; and ionization potential/electron affinity (IP/EA) [Nooijen:1995:3629]; approaches.; The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization; potential (IP), and electron affinity (EA) calculations, as well as; combined RAS-SF-IP/EA calculations, through the DETCI (CI: Configuration Interaction) module. Installation¶. Download the plugin from the GitHub repository:; >>> git clone https://github.com/shannonhouck/psi4fockci.git. Once downloaded, the plugin can be installed as follows:; >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input¶; To run a CAS-nSF-IP/EA calculation, start with a molecule with the; correct charge and multiplicity for the reference state (i.e. some; state well-represented by a single reference). Then, run an energy; calculation, passing in the charge and multiplicity of the; desired state; the number of spin-flips and IP/EA will be automatically; determined based on this input. If additional excitations outside of the; RAS II space are desired, one can set the level of external; excitations using the conf_space keyword.; A sample input file for a RAS(h)-2SF-IP calculation is shown below:; molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""). Note that for calculations involving IP/EA, inclusion of hole (for IP) and; particle (for EA) excitations is strongly recommended. Additional keywords; can be found in the documentation.; This input file can be run with Psi4:; >>> psi4 input.dat. table of contents. Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Psi4FockCI: A General Fock-Space ",MatchSource.WIKI,psi4manual/1.6.x/plugin_psi4fockci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_psi4fockci.html
https://psicode.org/psi4manual/1.6.x/plugin_psi4fockci.html:1426,Energy Efficiency,charge,charge,1426,"k:2019:2278].; This approach handles systems with both spin and spatial degeneracies; by combining the spin-flip (SF) [Krylov:2001:522]; and ionization potential/electron affinity (IP/EA) [Nooijen:1995:3629]; approaches.; The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization; potential (IP), and electron affinity (EA) calculations, as well as; combined RAS-SF-IP/EA calculations, through the DETCI (CI: Configuration Interaction) module. Installation¶. Download the plugin from the GitHub repository:; >>> git clone https://github.com/shannonhouck/psi4fockci.git. Once downloaded, the plugin can be installed as follows:; >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input¶; To run a CAS-nSF-IP/EA calculation, start with a molecule with the; correct charge and multiplicity for the reference state (i.e. some; state well-represented by a single reference). Then, run an energy; calculation, passing in the charge and multiplicity of the; desired state; the number of spin-flips and IP/EA will be automatically; determined based on this input. If additional excitations outside of the; RAS II space are desired, one can set the level of external; excitations using the conf_space keyword.; A sample input file for a RAS(h)-2SF-IP calculation is shown below:; molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""). Note that for calculations involving IP/EA, inclusion of hole (for IP) and; particle (for EA) excitations is strongly recommended. Additional keywords; can be found in the documentation.; This input file can be run with Psi4:; >>> psi4 input.dat. table of contents. Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Psi4FockCI: A General Fock-Space ",MatchSource.WIKI,psi4manual/1.6.x/plugin_psi4fockci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_psi4fockci.html
https://psicode.org/psi4manual/1.6.x/plugin_psi4fockci.html:1866,Energy Efficiency,energy,energy,1866,"ization potential/electron affinity (IP/EA) [Nooijen:1995:3629]; approaches.; The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization; potential (IP), and electron affinity (EA) calculations, as well as; combined RAS-SF-IP/EA calculations, through the DETCI (CI: Configuration Interaction) module. Installation¶. Download the plugin from the GitHub repository:; >>> git clone https://github.com/shannonhouck/psi4fockci.git. Once downloaded, the plugin can be installed as follows:; >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input¶; To run a CAS-nSF-IP/EA calculation, start with a molecule with the; correct charge and multiplicity for the reference state (i.e. some; state well-represented by a single reference). Then, run an energy; calculation, passing in the charge and multiplicity of the; desired state; the number of spin-flips and IP/EA will be automatically; determined based on this input. If additional excitations outside of the; RAS II space are desired, one can set the level of external; excitations using the conf_space keyword.; A sample input file for a RAS(h)-2SF-IP calculation is shown below:; molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""). Note that for calculations involving IP/EA, inclusion of hole (for IP) and; particle (for EA) excitations is strongly recommended. Additional keywords; can be found in the documentation.; This input file can be run with Psi4:; >>> psi4 input.dat. table of contents. Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/plugin_psi4fockci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_psi4fockci.html
https://psicode.org/psi4manual/1.6.x/plugin_psi4fockci.html:366,Modifiability,plugin,plugin,366,"﻿. Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA. Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA¶; Code author: Shannon E. Houck; Section author: Shannon E. Houck. This plugin is an implementation of the RAS-nSF-IP/EA approach detailed; in the paper by Houck et. al. [Houck:2019:2278].; This approach handles systems with both spin and spatial degeneracies; by combining the spin-flip (SF) [Krylov:2001:522]; and ionization potential/electron affinity (IP/EA) [Nooijen:1995:3629]; approaches.; The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization; potential (IP), and electron affinity (EA) calculations, as well as; combined RAS-SF-IP/EA calculations, through the DETCI (CI: Configuration Interaction) module. Installation¶. Download the plugin from the GitHub repository:; >>> git clone https://github.com/shannonhouck/psi4fockci.git. Once downloaded, the plugin can be installed as follows:; >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input¶; To run a CAS-nSF-IP/EA calculation, start with a molecule with the; correct charge and multiplicity for the reference state (i.e. some; state well-represented by a single reference). Then, run an energy; calculation, passing in the charge and multiplicity of the; desired state; the number of spin-flips and IP/EA will be automatically; determined based on this input. If additional excitations outside of the; RAS II space are desired, one can set the level of external; excitations using the conf_space keyword.; A sample input file for a RAS(h)-2SF-IP calculation is shown below:; molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""). Note that for calculations involving IP/EA, inclusion of hole (",MatchSource.WIKI,psi4manual/1.6.x/plugin_psi4fockci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_psi4fockci.html
https://psicode.org/psi4manual/1.6.x/plugin_psi4fockci.html:706,Modifiability,plugin,plugin,706,"﻿. Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA. Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA¶; Code author: Shannon E. Houck; Section author: Shannon E. Houck. This plugin is an implementation of the RAS-nSF-IP/EA approach detailed; in the paper by Houck et. al. [Houck:2019:2278].; This approach handles systems with both spin and spatial degeneracies; by combining the spin-flip (SF) [Krylov:2001:522]; and ionization potential/electron affinity (IP/EA) [Nooijen:1995:3629]; approaches.; The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization; potential (IP), and electron affinity (EA) calculations, as well as; combined RAS-SF-IP/EA calculations, through the DETCI (CI: Configuration Interaction) module. Installation¶. Download the plugin from the GitHub repository:; >>> git clone https://github.com/shannonhouck/psi4fockci.git. Once downloaded, the plugin can be installed as follows:; >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input¶; To run a CAS-nSF-IP/EA calculation, start with a molecule with the; correct charge and multiplicity for the reference state (i.e. some; state well-represented by a single reference). Then, run an energy; calculation, passing in the charge and multiplicity of the; desired state; the number of spin-flips and IP/EA will be automatically; determined based on this input. If additional excitations outside of the; RAS II space are desired, one can set the level of external; excitations using the conf_space keyword.; A sample input file for a RAS(h)-2SF-IP calculation is shown below:; molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""). Note that for calculations involving IP/EA, inclusion of hole (",MatchSource.WIKI,psi4manual/1.6.x/plugin_psi4fockci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_psi4fockci.html
https://psicode.org/psi4manual/1.6.x/plugin_psi4fockci.html:954,Modifiability,plugin,plugin,954,"﻿. Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA. Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA¶; Code author: Shannon E. Houck; Section author: Shannon E. Houck. This plugin is an implementation of the RAS-nSF-IP/EA approach detailed; in the paper by Houck et. al. [Houck:2019:2278].; This approach handles systems with both spin and spatial degeneracies; by combining the spin-flip (SF) [Krylov:2001:522]; and ionization potential/electron affinity (IP/EA) [Nooijen:1995:3629]; approaches.; The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization; potential (IP), and electron affinity (EA) calculations, as well as; combined RAS-SF-IP/EA calculations, through the DETCI (CI: Configuration Interaction) module. Installation¶. Download the plugin from the GitHub repository:; >>> git clone https://github.com/shannonhouck/psi4fockci.git. Once downloaded, the plugin can be installed as follows:; >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input¶; To run a CAS-nSF-IP/EA calculation, start with a molecule with the; correct charge and multiplicity for the reference state (i.e. some; state well-represented by a single reference). Then, run an energy; calculation, passing in the charge and multiplicity of the; desired state; the number of spin-flips and IP/EA will be automatically; determined based on this input. If additional excitations outside of the; RAS II space are desired, one can set the level of external; excitations using the conf_space keyword.; A sample input file for a RAS(h)-2SF-IP calculation is shown below:; molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""). Note that for calculations involving IP/EA, inclusion of hole (",MatchSource.WIKI,psi4manual/1.6.x/plugin_psi4fockci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_psi4fockci.html
https://psicode.org/psi4manual/1.6.x/plugin_psi4fockci.html:1073,Modifiability,plugin,plugin,1073,"; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA. Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA¶; Code author: Shannon E. Houck; Section author: Shannon E. Houck. This plugin is an implementation of the RAS-nSF-IP/EA approach detailed; in the paper by Houck et. al. [Houck:2019:2278].; This approach handles systems with both spin and spatial degeneracies; by combining the spin-flip (SF) [Krylov:2001:522]; and ionization potential/electron affinity (IP/EA) [Nooijen:1995:3629]; approaches.; The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization; potential (IP), and electron affinity (EA) calculations, as well as; combined RAS-SF-IP/EA calculations, through the DETCI (CI: Configuration Interaction) module. Installation¶. Download the plugin from the GitHub repository:; >>> git clone https://github.com/shannonhouck/psi4fockci.git. Once downloaded, the plugin can be installed as follows:; >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input¶; To run a CAS-nSF-IP/EA calculation, start with a molecule with the; correct charge and multiplicity for the reference state (i.e. some; state well-represented by a single reference). Then, run an energy; calculation, passing in the charge and multiplicity of the; desired state; the number of spin-flips and IP/EA will be automatically; determined based on this input. If additional excitations outside of the; RAS II space are desired, one can set the level of external; excitations using the conf_space keyword.; A sample input file for a RAS(h)-2SF-IP calculation is shown below:; molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""). Note that for calculations involving IP/EA, inclusion of hole (for IP) and; particle (for EA) excitations is strongly recommended. Additional keywords; can be found in the docum",MatchSource.WIKI,psi4manual/1.6.x/plugin_psi4fockci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_psi4fockci.html
https://psicode.org/psi4manual/1.6.x/plugin_psi4fockci.html:727,Performance,perform,perform,727,"﻿. Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA. Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA¶; Code author: Shannon E. Houck; Section author: Shannon E. Houck. This plugin is an implementation of the RAS-nSF-IP/EA approach detailed; in the paper by Houck et. al. [Houck:2019:2278].; This approach handles systems with both spin and spatial degeneracies; by combining the spin-flip (SF) [Krylov:2001:522]; and ionization potential/electron affinity (IP/EA) [Nooijen:1995:3629]; approaches.; The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization; potential (IP), and electron affinity (EA) calculations, as well as; combined RAS-SF-IP/EA calculations, through the DETCI (CI: Configuration Interaction) module. Installation¶. Download the plugin from the GitHub repository:; >>> git clone https://github.com/shannonhouck/psi4fockci.git. Once downloaded, the plugin can be installed as follows:; >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input¶; To run a CAS-nSF-IP/EA calculation, start with a molecule with the; correct charge and multiplicity for the reference state (i.e. some; state well-represented by a single reference). Then, run an energy; calculation, passing in the charge and multiplicity of the; desired state; the number of spin-flips and IP/EA will be automatically; determined based on this input. If additional excitations outside of the; RAS II space are desired, one can set the level of external; excitations using the conf_space keyword.; A sample input file for a RAS(h)-2SF-IP calculation is shown below:; molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""). Note that for calculations involving IP/EA, inclusion of hole (",MatchSource.WIKI,psi4manual/1.6.x/plugin_psi4fockci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_psi4fockci.html
https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html:719,Availability,avail,available,719,"﻿. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw¶; Code author: D. E. Shaw Research; Section author: Shannon E. Houck. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (DF-MP2: Density-Fitted 2nd-Order Møller–Plesset Perturbation Theory) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, snsmp2 has already been installed alongside.; If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; Analysis of Intermolec",MatchSource.WIKI,psi4manual/1.6.x/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html
https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html:833,Deployability,install,installer,833,"﻿. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw¶; Code author: D. E. Shaw Research; Section author: Shannon E. Houck. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (DF-MP2: Density-Fitted 2nd-Order Møller–Plesset Perturbation Theory) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, snsmp2 has already been installed alongside.; If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; Analysis of Intermolec",MatchSource.WIKI,psi4manual/1.6.x/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html
https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html:868,Deployability,install,installed,868,"﻿. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw¶; Code author: D. E. Shaw Research; Section author: Shannon E. Houck. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (DF-MP2: Density-Fitted 2nd-Order Møller–Plesset Perturbation Theory) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, snsmp2 has already been installed alongside.; If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; Analysis of Intermolec",MatchSource.WIKI,psi4manual/1.6.x/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html
https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html:979,Deployability,install,install,979,"﻿. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw¶; Code author: D. E. Shaw Research; Section author: Shannon E. Houck. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (DF-MP2: Density-Fitted 2nd-Order Møller–Plesset Perturbation Theory) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, snsmp2 has already been installed alongside.; If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; Analysis of Intermolec",MatchSource.WIKI,psi4manual/1.6.x/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html
https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html:1011,Deployability,install,install,1011,"﻿. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw¶; Code author: D. E. Shaw Research; Section author: Shannon E. Houck. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (DF-MP2: Density-Fitted 2nd-Order Møller–Plesset Perturbation Theory) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, snsmp2 has already been installed alongside.; If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; Analysis of Intermolec",MatchSource.WIKI,psi4manual/1.6.x/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html
https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html:1115,Deployability,install,installed,1115,": Enhancing PSI4 Capabilities; Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw¶; Code author: D. E. Shaw Research; Section author: Shannon E. Houck. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (DF-MP2: Density-Fitted 2nd-Order Møller–Plesset Perturbation Theory) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, snsmp2 has already been installed alongside.; If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; Analysis of Intermolecular Interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 in",MatchSource.WIKI,psi4manual/1.6.x/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html
https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html:1201,Deployability,install,install,1201,": Enhancing PSI4 Capabilities; Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw¶; Code author: D. E. Shaw Research; Section author: Shannon E. Houck. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (DF-MP2: Density-Fitted 2nd-Order Møller–Plesset Perturbation Theory) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, snsmp2 has already been installed alongside.; If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; Analysis of Intermolecular Interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 in",MatchSource.WIKI,psi4manual/1.6.x/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html
https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html:1286,Deployability,install,installation,1286," Section author: Shannon E. Houck. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (DF-MP2: Density-Fitted 2nd-Order Møller–Plesset Perturbation Theory) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, snsmp2 has already been installed alongside.; If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; Analysis of Intermolecular Interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modul",MatchSource.WIKI,psi4manual/1.6.x/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html
https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html:1469,Deployability,install,installed,1469,"2: Density-Fitted 2nd-Order Møller–Plesset Perturbation Theory) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, snsmp2 has already been installed alongside.; If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; Analysis of Intermolecular Interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created u",MatchSource.WIKI,psi4manual/1.6.x/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html
https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html:1641,Deployability,install,install,1641,"Order Møller–Plesset Perturbation Theory) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, snsmp2 has already been installed alongside.; If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; Analysis of Intermolecular Interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html
https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html:2469,Deployability,update,updated,2469,"Order Møller–Plesset Perturbation Theory) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, snsmp2 has already been installed alongside.; If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; Analysis of Intermolecular Interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html
https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html:1687,Energy Efficiency,adapt,adapted,1687,"Order Møller–Plesset Perturbation Theory) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, snsmp2 has already been installed alongside.; If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; Analysis of Intermolecular Interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html
https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html:1832,Energy Efficiency,energy,energy,1832,"Order Møller–Plesset Perturbation Theory) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, snsmp2 has already been installed alongside.; If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; Analysis of Intermolecular Interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html
https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html:333,Modifiability,plugin,plugin,333,"﻿. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw¶; Code author: D. E. Shaw Research; Section author: Shannon E. Houck. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (DF-MP2: Density-Fitted 2nd-Order Møller–Plesset Perturbation Theory) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, snsmp2 has already been installed alongside.; If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; Analysis of Intermolec",MatchSource.WIKI,psi4manual/1.6.x/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html
https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html:632,Modifiability,plugin,plugin,632,"﻿. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw¶; Code author: D. E. Shaw Research; Section author: Shannon E. Houck. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (DF-MP2: Density-Fitted 2nd-Order Møller–Plesset Perturbation Theory) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, snsmp2 has already been installed alongside.; If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; Analysis of Intermolec",MatchSource.WIKI,psi4manual/1.6.x/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html
https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html:1342,Modifiability,plugin,plugin,1342," SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (DF-MP2: Density-Fitted 2nd-Order Møller–Plesset Perturbation Theory) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, snsmp2 has already been installed alongside.; If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; Analysis of Intermolecular Interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capa",MatchSource.WIKI,psi4manual/1.6.x/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html
https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html:1455,Modifiability,plugin,plugin,1455,"2: Density-Fitted 2nd-Order Møller–Plesset Perturbation Theory) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, snsmp2 has already been installed alongside.; If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; Analysis of Intermolecular Interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created u",MatchSource.WIKI,psi4manual/1.6.x/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html
https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html:1687,Modifiability,adapt,adapted,1687,"Order Møller–Plesset Perturbation Theory) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, snsmp2 has already been installed alongside.; If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; Analysis of Intermolecular Interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html
https://psicode.org/psi4manual/1.6.x/plugin_v2rdm_casscf.html:379,Availability,avail,available,379,"﻿. Plugin v2rdm_casscf by A. E. DePrince. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Plugin v2rdm_casscf by A. E. DePrince. Plugin v2rdm_casscf by A. E. DePrince¶; Code author: A. E. DePrince; Section author: Lori A. Burns. A variational 2-RDM-driven CASSCF plugin to PSI4. Installation¶; Binary. v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, v2rdm_casscf has already been installed alongside.; If using the PSI4 conda package, the v2rdm_casscf conda package can; be obtained through conda install v2rdm_casscf -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; v2rdm_casscf can be obtained through conda install v2rdm_casscf -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove v2rdm_casscf. Source. If using PSI4 built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with PYTHONPATH. table of contents. Plugin v2rdm_casscf by A. E. DePrince; Installation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Plugin v2rdm_casscf by A. E. DePrince. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/plugin_v2rdm_casscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_v2rdm_casscf.html
https://psicode.org/psi4manual/1.6.x/plugin_v2rdm_casscf.html:493,Deployability,install,installer,493,"﻿. Plugin v2rdm_casscf by A. E. DePrince. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Plugin v2rdm_casscf by A. E. DePrince. Plugin v2rdm_casscf by A. E. DePrince¶; Code author: A. E. DePrince; Section author: Lori A. Burns. A variational 2-RDM-driven CASSCF plugin to PSI4. Installation¶; Binary. v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, v2rdm_casscf has already been installed alongside.; If using the PSI4 conda package, the v2rdm_casscf conda package can; be obtained through conda install v2rdm_casscf -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; v2rdm_casscf can be obtained through conda install v2rdm_casscf -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove v2rdm_casscf. Source. If using PSI4 built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with PYTHONPATH. table of contents. Plugin v2rdm_casscf by A. E. DePrince; Installation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Plugin v2rdm_casscf by A. E. DePrince. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/plugin_v2rdm_casscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_v2rdm_casscf.html
https://psicode.org/psi4manual/1.6.x/plugin_v2rdm_casscf.html:534,Deployability,install,installed,534,"﻿. Plugin v2rdm_casscf by A. E. DePrince. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Plugin v2rdm_casscf by A. E. DePrince. Plugin v2rdm_casscf by A. E. DePrince¶; Code author: A. E. DePrince; Section author: Lori A. Burns. A variational 2-RDM-driven CASSCF plugin to PSI4. Installation¶; Binary. v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, v2rdm_casscf has already been installed alongside.; If using the PSI4 conda package, the v2rdm_casscf conda package can; be obtained through conda install v2rdm_casscf -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; v2rdm_casscf can be obtained through conda install v2rdm_casscf -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove v2rdm_casscf. Source. If using PSI4 built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with PYTHONPATH. table of contents. Plugin v2rdm_casscf by A. E. DePrince; Installation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Plugin v2rdm_casscf by A. E. DePrince. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/plugin_v2rdm_casscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_v2rdm_casscf.html
https://psicode.org/psi4manual/1.6.x/plugin_v2rdm_casscf.html:651,Deployability,install,install,651,"﻿. Plugin v2rdm_casscf by A. E. DePrince. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Plugin v2rdm_casscf by A. E. DePrince. Plugin v2rdm_casscf by A. E. DePrince¶; Code author: A. E. DePrince; Section author: Lori A. Burns. A variational 2-RDM-driven CASSCF plugin to PSI4. Installation¶; Binary. v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, v2rdm_casscf has already been installed alongside.; If using the PSI4 conda package, the v2rdm_casscf conda package can; be obtained through conda install v2rdm_casscf -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; v2rdm_casscf can be obtained through conda install v2rdm_casscf -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove v2rdm_casscf. Source. If using PSI4 built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with PYTHONPATH. table of contents. Plugin v2rdm_casscf by A. E. DePrince; Installation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Plugin v2rdm_casscf by A. E. DePrince. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/plugin_v2rdm_casscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_v2rdm_casscf.html
https://psicode.org/psi4manual/1.6.x/plugin_v2rdm_casscf.html:689,Deployability,install,install,689,"﻿. Plugin v2rdm_casscf by A. E. DePrince. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Plugin v2rdm_casscf by A. E. DePrince. Plugin v2rdm_casscf by A. E. DePrince¶; Code author: A. E. DePrince; Section author: Lori A. Burns. A variational 2-RDM-driven CASSCF plugin to PSI4. Installation¶; Binary. v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, v2rdm_casscf has already been installed alongside.; If using the PSI4 conda package, the v2rdm_casscf conda package can; be obtained through conda install v2rdm_casscf -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; v2rdm_casscf can be obtained through conda install v2rdm_casscf -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove v2rdm_casscf. Source. If using PSI4 built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with PYTHONPATH. table of contents. Plugin v2rdm_casscf by A. E. DePrince; Installation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Plugin v2rdm_casscf by A. E. DePrince. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/plugin_v2rdm_casscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_v2rdm_casscf.html
https://psicode.org/psi4manual/1.6.x/plugin_v2rdm_casscf.html:793,Deployability,install,installed,793,"﻿. Plugin v2rdm_casscf by A. E. DePrince. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Plugin v2rdm_casscf by A. E. DePrince. Plugin v2rdm_casscf by A. E. DePrince¶; Code author: A. E. DePrince; Section author: Lori A. Burns. A variational 2-RDM-driven CASSCF plugin to PSI4. Installation¶; Binary. v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, v2rdm_casscf has already been installed alongside.; If using the PSI4 conda package, the v2rdm_casscf conda package can; be obtained through conda install v2rdm_casscf -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; v2rdm_casscf can be obtained through conda install v2rdm_casscf -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove v2rdm_casscf. Source. If using PSI4 built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with PYTHONPATH. table of contents. Plugin v2rdm_casscf by A. E. DePrince; Installation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Plugin v2rdm_casscf by A. E. DePrince. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/plugin_v2rdm_casscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_v2rdm_casscf.html
https://psicode.org/psi4manual/1.6.x/plugin_v2rdm_casscf.html:885,Deployability,install,install,885,"﻿. Plugin v2rdm_casscf by A. E. DePrince. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Plugin v2rdm_casscf by A. E. DePrince. Plugin v2rdm_casscf by A. E. DePrince¶; Code author: A. E. DePrince; Section author: Lori A. Burns. A variational 2-RDM-driven CASSCF plugin to PSI4. Installation¶; Binary. v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, v2rdm_casscf has already been installed alongside.; If using the PSI4 conda package, the v2rdm_casscf conda package can; be obtained through conda install v2rdm_casscf -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; v2rdm_casscf can be obtained through conda install v2rdm_casscf -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove v2rdm_casscf. Source. If using PSI4 built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with PYTHONPATH. table of contents. Plugin v2rdm_casscf by A. E. DePrince; Installation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Plugin v2rdm_casscf by A. E. DePrince. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/plugin_v2rdm_casscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_v2rdm_casscf.html
https://psicode.org/psi4manual/1.6.x/plugin_v2rdm_casscf.html:976,Deployability,install,installation,976,"﻿. Plugin v2rdm_casscf by A. E. DePrince. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Plugin v2rdm_casscf by A. E. DePrince. Plugin v2rdm_casscf by A. E. DePrince¶; Code author: A. E. DePrince; Section author: Lori A. Burns. A variational 2-RDM-driven CASSCF plugin to PSI4. Installation¶; Binary. v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, v2rdm_casscf has already been installed alongside.; If using the PSI4 conda package, the v2rdm_casscf conda package can; be obtained through conda install v2rdm_casscf -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; v2rdm_casscf can be obtained through conda install v2rdm_casscf -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove v2rdm_casscf. Source. If using PSI4 built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with PYTHONPATH. table of contents. Plugin v2rdm_casscf by A. E. DePrince; Installation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Plugin v2rdm_casscf by A. E. DePrince. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/plugin_v2rdm_casscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_v2rdm_casscf.html
https://psicode.org/psi4manual/1.6.x/plugin_v2rdm_casscf.html:1460,Deployability,update,updated,1460,"﻿. Plugin v2rdm_casscf by A. E. DePrince. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Plugin v2rdm_casscf by A. E. DePrince. Plugin v2rdm_casscf by A. E. DePrince¶; Code author: A. E. DePrince; Section author: Lori A. Burns. A variational 2-RDM-driven CASSCF plugin to PSI4. Installation¶; Binary. v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, v2rdm_casscf has already been installed alongside.; If using the PSI4 conda package, the v2rdm_casscf conda package can; be obtained through conda install v2rdm_casscf -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; v2rdm_casscf can be obtained through conda install v2rdm_casscf -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove v2rdm_casscf. Source. If using PSI4 built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with PYTHONPATH. table of contents. Plugin v2rdm_casscf by A. E. DePrince; Installation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Plugin v2rdm_casscf by A. E. DePrince. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/plugin_v2rdm_casscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_v2rdm_casscf.html
https://psicode.org/psi4manual/1.6.x/plugin_v2rdm_casscf.html:324,Modifiability,plugin,plugin,324,"﻿. Plugin v2rdm_casscf by A. E. DePrince. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Plugin v2rdm_casscf by A. E. DePrince. Plugin v2rdm_casscf by A. E. DePrince¶; Code author: A. E. DePrince; Section author: Lori A. Burns. A variational 2-RDM-driven CASSCF plugin to PSI4. Installation¶; Binary. v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, v2rdm_casscf has already been installed alongside.; If using the PSI4 conda package, the v2rdm_casscf conda package can; be obtained through conda install v2rdm_casscf -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; v2rdm_casscf can be obtained through conda install v2rdm_casscf -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove v2rdm_casscf. Source. If using PSI4 built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with PYTHONPATH. table of contents. Plugin v2rdm_casscf by A. E. DePrince; Installation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Plugin v2rdm_casscf by A. E. DePrince. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/plugin_v2rdm_casscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_v2rdm_casscf.html
https://psicode.org/psi4manual/1.6.x/proc_py.html:4972,Availability,error,error,4972," Managed methods handle both these cases through the addition of a new; keyword QC_MODULE and a set of type keywords analogous to; MP2_TYPE: MP_TYPE,; CI_TYPE, CC_TYPE, which can have values CONV,; DF, and CD. These are all global keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We’re sticking with SCF_TYPE and; MP2_TYPE defaulting to DF, while everything higher defaults; to CONV. In psi4/psi4/driver/driver.py, a managed method calls a; “select” function rather than a “run” function.; procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dct' : run_dct,. Then in psi4/psi4/driver/procrouting/proc.py, the select function runs through; reference (always outer loop) and type (inner loop) to specify the proc; function to call for any able, non-default module (e.g., mtd_type ==; 'DETCI' ) or able, default module (e.g., mtd_typd == ['', 'FNOCC'] ).; Don’t worry about ‘else’ statements as anything that falls through will be; caught and a readable error generated.; def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type ",MatchSource.WIKI,psi4manual/1.6.x/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/proc_py.html
https://psicode.org/psi4manual/1.6.x/proc_py.html:6653,Availability,error,error,6653,"c/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; energy('mp3'). will run OCC, while; set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Adding Methods to Driver. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/proc_py.html
https://psicode.org/psi4manual/1.6.x/proc_py.html:6841,Availability,avail,available,6841,"c/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; energy('mp3'). will run OCC, while; set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Adding Methods to Driver. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/proc_py.html
https://psicode.org/psi4manual/1.6.x/proc_py.html:6885,Availability,avail,available,6885,"c/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; energy('mp3'). will run OCC, while; set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Adding Methods to Driver. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/proc_py.html
https://psicode.org/psi4manual/1.6.x/proc_py.html:6972,Availability,avail,available,6972,"c/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; energy('mp3'). will run OCC, while; set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Adding Methods to Driver. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/proc_py.html
https://psicode.org/psi4manual/1.6.x/proc_py.html:7249,Deployability,update,updated,7249,"c/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; energy('mp3'). will run OCC, while; set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Adding Methods to Driver. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/proc_py.html
https://psicode.org/psi4manual/1.6.x/proc_py.html:642,Energy Efficiency,energy,energy,642,"﻿. Adding Methods to Driver. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Adding Methods to Driver. Adding Methods to Driver¶. proc.py¶; This is concerned at present with normal methods added first to the; procedures table in driver.py that associates method names with functions; to run them located in proc.py .; The function should start with a declaration, as below. methodname is; never seen by users, so it’s good to be specific; if there’s lots of; modules that can run mp2, call methodname modulenamemethodname, perhaps.; The function must always take as arguments (name, **kwargs).; # energy method; def run_methodname(name, **kwargs):. # gradient method; def run_methodname_gradient(name, **kwargs):. If the function needs to test the identity of name several times, it; can be convenient to predefine the lowercase version of the variable. The; case of all other py-side options (in kwargs) has already been handled by; energy(), etc. in driver.py and need not be repeated here.; # include if convenient; lowername = name.lower(). # never include; kwargs = kwargs_lower(kwargs). It’s often necessary to The function often needs to set options for the; c-side modules it calls. In order that the state of the options set by the; user remains when control is returned to the user, an; OptionsState object is set up. See; LibOptions: globals, locals, has_changed and all that for details. All options set by the; function need to be included here, and only options set by the function; should be included. Most options should be associated with a particular; module, but a few (see below) are given without module.; # include if any options set; optstash = OptionsState(; # these and other basis options should have no associated module; ['BASIS'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['PUREAM'],; ['FREEZE_CORE'],; # all others should have an associated module; ['SCF', 'SCF_TYPE'],; ['SCF', 'GUESS'],; ['DFMP2', 'MP2_OS_SCALE'],; ). If opti",MatchSource.WIKI,psi4manual/1.6.x/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/proc_py.html
https://psicode.org/psi4manual/1.6.x/proc_py.html:979,Energy Efficiency,energy,energy,979,"﻿. Adding Methods to Driver. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Adding Methods to Driver. Adding Methods to Driver¶. proc.py¶; This is concerned at present with normal methods added first to the; procedures table in driver.py that associates method names with functions; to run them located in proc.py .; The function should start with a declaration, as below. methodname is; never seen by users, so it’s good to be specific; if there’s lots of; modules that can run mp2, call methodname modulenamemethodname, perhaps.; The function must always take as arguments (name, **kwargs).; # energy method; def run_methodname(name, **kwargs):. # gradient method; def run_methodname_gradient(name, **kwargs):. If the function needs to test the identity of name several times, it; can be convenient to predefine the lowercase version of the variable. The; case of all other py-side options (in kwargs) has already been handled by; energy(), etc. in driver.py and need not be repeated here.; # include if convenient; lowername = name.lower(). # never include; kwargs = kwargs_lower(kwargs). It’s often necessary to The function often needs to set options for the; c-side modules it calls. In order that the state of the options set by the; user remains when control is returned to the user, an; OptionsState object is set up. See; LibOptions: globals, locals, has_changed and all that for details. All options set by the; function need to be included here, and only options set by the function; should be included. Most options should be associated with a particular; module, but a few (see below) are given without module.; # include if any options set; optstash = OptionsState(; # these and other basis options should have no associated module; ['BASIS'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['PUREAM'],; ['FREEZE_CORE'],; # all others should have an associated module; ['SCF', 'SCF_TYPE'],; ['SCF', 'GUESS'],; ['DFMP2', 'MP2_OS_SCALE'],; ). If opti",MatchSource.WIKI,psi4manual/1.6.x/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/proc_py.html
https://psicode.org/psi4manual/1.6.x/proc_py.html:3581,Energy Efficiency,energy,energy,3581,"d. Also, add; the option to pass the reference wavefunction by pre-running scf,; then running the module with the ref_wfn kwarg. Also, if the full; two-electron integrals are necessary for the post-scf, compute them if; only the df integrals were run previously.; # Bypass the scf call if a reference wavefunction is given. ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # If the scf type is DF/CD, then the AO integrals were never written to disk; if psi4.get_option('SCF', 'SCF_TYPE') in ['DF', 'CD']:; psi4.MintsHelper(ref_wfn.basisset()).integrals(). Direct any post-scf modules to be run.; # include if further post-scf modules are needed; psi4.transqt2(); psi4.ccsort(); psi4.mp2(). If an OptionsState object was set up, those options; need to be returned to the original user state with the following.; # include if optstash = OptionsState( was set up previously; optstash.restore(). No function should return anything. CURRENT ENERGY will be set by; energy(), etc.; # never include; return returnvalue. Managed Methods¶; When functionality overlaps between modules, a pattern is needed to (1); access each route through the code without contrivances like ccsd2,; _ccsd, sdci and (2) apportion defaulting among the modules, taking; into account reference (RHF/UHF/ROHF) and calc type (CONV, DF, CD).; Managed methods handle both these cases through the addition of a new; keyword QC_MODULE and a set of type keywords analogous to; MP2_TYPE: MP_TYPE,; CI_TYPE, CC_TYPE, which can have values CONV,; DF, and CD. These are all global keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We’re sticking with SCF_TYPE and; MP2_TYPE defaulting to DF, while everything higher defaults; to CONV. In psi4/psi4/driver/driver.py, a managed method calls a; “select” function rather than a “run” function.; procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dct' : ru",MatchSource.WIKI,psi4manual/1.6.x/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/proc_py.html
https://psicode.org/psi4manual/1.6.x/proc_py.html:4511,Energy Efficiency,energy,energy,4511,"turn anything. CURRENT ENERGY will be set by; energy(), etc.; # never include; return returnvalue. Managed Methods¶; When functionality overlaps between modules, a pattern is needed to (1); access each route through the code without contrivances like ccsd2,; _ccsd, sdci and (2) apportion defaulting among the modules, taking; into account reference (RHF/UHF/ROHF) and calc type (CONV, DF, CD).; Managed methods handle both these cases through the addition of a new; keyword QC_MODULE and a set of type keywords analogous to; MP2_TYPE: MP_TYPE,; CI_TYPE, CC_TYPE, which can have values CONV,; DF, and CD. These are all global keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We’re sticking with SCF_TYPE and; MP2_TYPE defaulting to DF, while everything higher defaults; to CONV. In psi4/psi4/driver/driver.py, a managed method calls a; “select” function rather than a “run” function.; procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dct' : run_dct,. Then in psi4/psi4/driver/procrouting/proc.py, the select function runs through; reference (always outer loop) and type (inner loop) to specify the proc; function to call for any able, non-default module (e.g., mtd_type ==; 'DETCI' ) or able, default module (e.g., mtd_typd == ['', 'FNOCC'] ).; Don’t worry about ‘else’ statements as anything that falls through will be; caught and a readable error generated.; def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type ",MatchSource.WIKI,psi4manual/1.6.x/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/proc_py.html
https://psicode.org/psi4manual/1.6.x/proc_py.html:5069,Energy Efficiency,energy,energy,5069,"YPE: MP_TYPE,; CI_TYPE, CC_TYPE, which can have values CONV,; DF, and CD. These are all global keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We’re sticking with SCF_TYPE and; MP2_TYPE defaulting to DF, while everything higher defaults; to CONV. In psi4/psi4/driver/driver.py, a managed method calls a; “select” function rather than a “run” function.; procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dct' : run_dct,. Then in psi4/psi4/driver/procrouting/proc.py, the select function runs through; reference (always outer loop) and type (inner loop) to specify the proc; function to call for any able, non-default module (e.g., mtd_type ==; 'DETCI' ) or able, default module (e.g., mtd_typd == ['', 'FNOCC'] ).; Don’t worry about ‘else’ statements as anything that falls through will be; caught and a readable error generated.; def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_typ",MatchSource.WIKI,psi4manual/1.6.x/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/proc_py.html
https://psicode.org/psi4manual/1.6.x/proc_py.html:6321,Energy Efficiency,energy,energy,6321,"only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; energy('mp3'). will run OCC, while; set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Adding Methods to Driver. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using ",MatchSource.WIKI,psi4manual/1.6.x/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/proc_py.html
https://psicode.org/psi4manual/1.6.x/proc_py.html:6378,Energy Efficiency,energy,energy,6378,"c/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; energy('mp3'). will run OCC, while; set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Adding Methods to Driver. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/proc_py.html
https://psicode.org/psi4manual/1.6.x/proc_py.html:6613,Energy Efficiency,energy,energy,6613,"c/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; energy('mp3'). will run OCC, while; set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Adding Methods to Driver. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/proc_py.html
https://psicode.org/psi4manual/1.6.x/proc_py.html:6680,Energy Efficiency,energy,energy,6680,"c/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; energy('mp3'). will run OCC, while; set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Adding Methods to Driver. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/proc_py.html
https://psicode.org/psi4manual/1.6.x/proc_py.html:3737,Integrability,rout,route,3737,"e them if; only the df integrals were run previously.; # Bypass the scf call if a reference wavefunction is given. ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # If the scf type is DF/CD, then the AO integrals were never written to disk; if psi4.get_option('SCF', 'SCF_TYPE') in ['DF', 'CD']:; psi4.MintsHelper(ref_wfn.basisset()).integrals(). Direct any post-scf modules to be run.; # include if further post-scf modules are needed; psi4.transqt2(); psi4.ccsort(); psi4.mp2(). If an OptionsState object was set up, those options; need to be returned to the original user state with the following.; # include if optstash = OptionsState( was set up previously; optstash.restore(). No function should return anything. CURRENT ENERGY will be set by; energy(), etc.; # never include; return returnvalue. Managed Methods¶; When functionality overlaps between modules, a pattern is needed to (1); access each route through the code without contrivances like ccsd2,; _ccsd, sdci and (2) apportion defaulting among the modules, taking; into account reference (RHF/UHF/ROHF) and calc type (CONV, DF, CD).; Managed methods handle both these cases through the addition of a new; keyword QC_MODULE and a set of type keywords analogous to; MP2_TYPE: MP_TYPE,; CI_TYPE, CC_TYPE, which can have values CONV,; DF, and CD. These are all global keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We’re sticking with SCF_TYPE and; MP2_TYPE defaulting to DF, while everything higher defaults; to CONV. In psi4/psi4/driver/driver.py, a managed method calls a; “select” function rather than a “run” function.; procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dct' : run_dct,. Then in psi4/psi4/driver/procrouting/proc.py, the select function runs through; reference (always outer loop) and type (inner loop) to specify the proc; function to call for any able, non-default modul",MatchSource.WIKI,psi4manual/1.6.x/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/proc_py.html
https://psicode.org/psi4manual/1.6.x/proc_py.html:889,Modifiability,variab,variable,889,"﻿. Adding Methods to Driver. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Adding Methods to Driver. Adding Methods to Driver¶. proc.py¶; This is concerned at present with normal methods added first to the; procedures table in driver.py that associates method names with functions; to run them located in proc.py .; The function should start with a declaration, as below. methodname is; never seen by users, so it’s good to be specific; if there’s lots of; modules that can run mp2, call methodname modulenamemethodname, perhaps.; The function must always take as arguments (name, **kwargs).; # energy method; def run_methodname(name, **kwargs):. # gradient method; def run_methodname_gradient(name, **kwargs):. If the function needs to test the identity of name several times, it; can be convenient to predefine the lowercase version of the variable. The; case of all other py-side options (in kwargs) has already been handled by; energy(), etc. in driver.py and need not be repeated here.; # include if convenient; lowername = name.lower(). # never include; kwargs = kwargs_lower(kwargs). It’s often necessary to The function often needs to set options for the; c-side modules it calls. In order that the state of the options set by the; user remains when control is returned to the user, an; OptionsState object is set up. See; LibOptions: globals, locals, has_changed and all that for details. All options set by the; function need to be included here, and only options set by the function; should be included. Most options should be associated with a particular; module, but a few (see below) are given without module.; # include if any options set; optstash = OptionsState(; # these and other basis options should have no associated module; ['BASIS'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['PUREAM'],; ['FREEZE_CORE'],; # all others should have an associated module; ['SCF', 'SCF_TYPE'],; ['SCF', 'GUESS'],; ['DFMP2', 'MP2_OS_SCALE'],; ). If opti",MatchSource.WIKI,psi4manual/1.6.x/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/proc_py.html
https://psicode.org/psi4manual/1.6.x/proc_py.html:5117,Performance,perform,performance,5117,"YPE: MP_TYPE,; CI_TYPE, CC_TYPE, which can have values CONV,; DF, and CD. These are all global keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We’re sticking with SCF_TYPE and; MP2_TYPE defaulting to DF, while everything higher defaults; to CONV. In psi4/psi4/driver/driver.py, a managed method calls a; “select” function rather than a “run” function.; procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dct' : run_dct,. Then in psi4/psi4/driver/procrouting/proc.py, the select function runs through; reference (always outer loop) and type (inner loop) to specify the proc; function to call for any able, non-default module (e.g., mtd_type ==; 'DETCI' ) or able, default module (e.g., mtd_typd == ['', 'FNOCC'] ).; Don’t worry about ‘else’ statements as anything that falls through will be; caught and a readable error generated.; def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_typ",MatchSource.WIKI,psi4manual/1.6.x/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/proc_py.html
https://psicode.org/psi4manual/1.6.x/proc_py.html:3725,Security,access,access,3725,"e them if; only the df integrals were run previously.; # Bypass the scf call if a reference wavefunction is given. ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # If the scf type is DF/CD, then the AO integrals were never written to disk; if psi4.get_option('SCF', 'SCF_TYPE') in ['DF', 'CD']:; psi4.MintsHelper(ref_wfn.basisset()).integrals(). Direct any post-scf modules to be run.; # include if further post-scf modules are needed; psi4.transqt2(); psi4.ccsort(); psi4.mp2(). If an OptionsState object was set up, those options; need to be returned to the original user state with the following.; # include if optstash = OptionsState( was set up previously; optstash.restore(). No function should return anything. CURRENT ENERGY will be set by; energy(), etc.; # never include; return returnvalue. Managed Methods¶; When functionality overlaps between modules, a pattern is needed to (1); access each route through the code without contrivances like ccsd2,; _ccsd, sdci and (2) apportion defaulting among the modules, taking; into account reference (RHF/UHF/ROHF) and calc type (CONV, DF, CD).; Managed methods handle both these cases through the addition of a new; keyword QC_MODULE and a set of type keywords analogous to; MP2_TYPE: MP_TYPE,; CI_TYPE, CC_TYPE, which can have values CONV,; DF, and CD. These are all global keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We’re sticking with SCF_TYPE and; MP2_TYPE defaulting to DF, while everything higher defaults; to CONV. In psi4/psi4/driver/driver.py, a managed method calls a; “select” function rather than a “run” function.; procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dct' : run_dct,. Then in psi4/psi4/driver/procrouting/proc.py, the select function runs through; reference (always outer loop) and type (inner loop) to specify the proc; function to call for any able, non-default modul",MatchSource.WIKI,psi4manual/1.6.x/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/proc_py.html
https://psicode.org/psi4manual/1.6.x/proc_py.html:6544,Security,access,access,6544,"c/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; energy('mp3'). will run OCC, while; set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Adding Methods to Driver. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/proc_py.html
https://psicode.org/psi4manual/1.6.x/proc_py.html:784,Testability,test,test,784,"﻿. Adding Methods to Driver. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Adding Methods to Driver. Adding Methods to Driver¶. proc.py¶; This is concerned at present with normal methods added first to the; procedures table in driver.py that associates method names with functions; to run them located in proc.py .; The function should start with a declaration, as below. methodname is; never seen by users, so it’s good to be specific; if there’s lots of; modules that can run mp2, call methodname modulenamemethodname, perhaps.; The function must always take as arguments (name, **kwargs).; # energy method; def run_methodname(name, **kwargs):. # gradient method; def run_methodname_gradient(name, **kwargs):. If the function needs to test the identity of name several times, it; can be convenient to predefine the lowercase version of the variable. The; case of all other py-side options (in kwargs) has already been handled by; energy(), etc. in driver.py and need not be repeated here.; # include if convenient; lowername = name.lower(). # never include; kwargs = kwargs_lower(kwargs). It’s often necessary to The function often needs to set options for the; c-side modules it calls. In order that the state of the options set by the; user remains when control is returned to the user, an; OptionsState object is set up. See; LibOptions: globals, locals, has_changed and all that for details. All options set by the; function need to be included here, and only options set by the function; should be included. Most options should be associated with a particular; module, but a few (see below) are given without module.; # include if any options set; optstash = OptionsState(; # these and other basis options should have no associated module; ['BASIS'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['PUREAM'],; ['FREEZE_CORE'],; # all others should have an associated module; ['SCF', 'SCF_TYPE'],; ['SCF', 'GUESS'],; ['DFMP2', 'MP2_OS_SCALE'],; ). If opti",MatchSource.WIKI,psi4manual/1.6.x/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/proc_py.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:4677,Availability,recover,recovery,4677,"ubstitution (just as fast as DTRMV); DGER: Rank-1 update (not wrapped yet). BLAS3. DGEMM: General Matrix-Matrix product; DTRMM: General Triangular Matrix-General Matrix product; DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using lda = n in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower triangular matrix L such; that L L^T = A, but this is returned in column-major order, so the actual; recovery of the matrix A with the row-major BLAS wrappers effectively; involves L^T L = A. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a C_, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is double**). All routines return an int INFO with error and;",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:5614,Availability,error,error,5614,"covery of the matrix A with the row-major BLAS wrappers effectively; involves L^T L = A. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a C_, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is double**). All routines return an int INFO with error and; calculation information specific to the routine, In Fortran, this is the; last argument in all LAPACK calls, but should not be provided as an; argument here. For char arguments, case is insensitive. A Cholesky; transform example is shown:; // BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ...; int n = 100;. // Allocate A matrix;; double** A = block_matrix(n,n);. // Call the LAPACK DPOTRF to get the Cholesky factor; // Note this works in column-major order; // The result fills like:; // * * * *; // * * *; // * *; // *; // instead of the expected:; // *; // * *; // * * *; // * * * *; //; int info = C_DPOTRF('L', n, A[0], n);. // A bit painful, see below; fprintf(outfile, ""A:\n"");; print_mat(A,n,n,outfile);. // Block matrix should be free_blocked; free_block(A);. Important Lapack Routines¶. DSYEV: Eigenvalues and, optionally eigenvectors of a symmetric matrix. Eigenvectors take up to 10x longer than eigenvalues.; DGEEV: Eigenvalues and, optionally eigenvectors ",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:7844,Availability,error,errors,7844,"lar value decomposition.; DGETRF: LU decomposition.; DPOTRF: Cholesky decomposition (much more stable/faster); DGETRS: Solver, given LU decomposition by DGETRF; DPOTRS: Solver, given Cholesky decomposition by DPOTRF; DGETRI: Inverse, given LU decomposition by DGETRF (Warning: it’s faster and more stable just to solve with DGETRS); DPOTRI: Inverse, given Cholesky decomposition by DPOTRF (Warning: it’s faster and more stable just to solve with DPOTRS). How to use low-level BLAS/LAPACK with psi4.core.Matrix¶; Jet’s awesome new Matrix object has a lot of simple BLAS/LAPACK built in,; but you can just as easily use the double*** array underneath if you are; careful (the outer index is the submatrix for each irrep). Here’s an; example:; // BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // Matrix; #include ""psi4/libmints/matrix.h"". using namespace psi;; ...; int n = 100;. // Allocate A Matrix (new C1 convenience constructor);; shared_ptr<Matrix> A(new Matrix(""Still A, but way cooler"", n,n));; // Get the pointer to the 0 irrep (C1 for now, it errors if you ask for too high of an index); double** A_pointer = A->get_pointer(0);. // Call the LAPACK DPOTRF to get the Cholesky factor; // Note this works in column-major order; // The result fills like:; // * * * *; // * * *; // * *; // *; // instead of the expected:; // *; // * *; // * * *; // * * * *; //; int info = C_DPOTRF('L', n, A_pointer[0], n);. // Wow that's a lot easier; A->print();. // Don't free, it's shared_ptr!. How to name orbital bases (e.g., AO & SO)¶; Many different working bases (the internal linear algebraic basis, not the; name of the Gaussian basis) are used within PSI4, each with a unique; and important purpose. It is critical to keep them all distinct to prevent; weird results from occurring. AO (Atomic Orbitals): Cartesian Gaussians (6D, 10F, etc.),; (L + 1)(L + 2)/2 functions per shell of angular momentum L. The; ordering of Cartesian exponents for a given L is given by the standard; ordering below (MATLAB code)",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:11423,Availability,redundant,redundant,11423," specific.; OSO (Orthogonal Symmetry-Adapted Orbitals): USOs orthogonalized by; Symmetric or Canonical Orthogonalization. The number of OSOs may be; slightly smaller than the total number of USOs, due to removal of linear; dependencies via Canonical Orthogonalization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs.; MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal.; LO (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. How to name orbital dimensions¶; There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; nbf — The number of basis functions, which is the same as nso.; nmo — The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the st",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:520,Deployability,update,update,520,"﻿. Linear Algebra in PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Programming with the Core Libraries; Linear Algebra in PSI4. Linear Algebra in PSI4¶. How to call BLAS & LAPACK in PSI4¶; Computational chemistry is essentially linear algebra on molecular; systems, so using stable, portable, scalable, and efficient numerical; linear algebra methods in PSI4 is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers.; All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), ",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:3674,Deployability,update,update,3674,"n,n);; double** B = block_matrix(n,n);; double** C = block_matrix(n,n);. // Call the BLAS1 dot product between a and b; // n can be a ULI with the BLAS1 wrappers,; // All strides must be ints though; double dot = C_DDOT(n, a, 1, b, 1);. // Call the BLAS2 GEMV without transposition; // Note this works in row-major order; C_DGEMV('N', n, n, 1.0, A[0], n, a, 1, 0.0, b, 1);. // Call the BLAS3 GEMM without transposition; // Note this works in row-major order; C_DGEMM('N','N', n, n, n, 1.0, A[0], n, B[0], n, 0.0, C[0], n);. // Array's init'd with init_array must be free'd, not delete[]'d; free(a);; free(b);. // Block matrix should be free_blocked; free_block(A);; free_block(B);; free_block(C);. Important BLAS Routines¶. BLAS1. DDOT: dot product; DCOPY: efficient memory copy (with variable stride); DAXPY: y = y + alpha*x; DROT: Givens Rotation; DNRM2: Vector norm square. BLAS2. DGEMV: General Matrix-Vector product; DTRMV: Triangular Matrix-Vector product (2x faster, not wrapped yet); DTRSM: Triangular Matrix-Vector solution via back substitution (just as fast as DTRMV); DGER: Rank-1 update (not wrapped yet). BLAS3. DGEMM: General Matrix-Matrix product; DTRMM: General Triangular Matrix-General Matrix product; DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using lda = n in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower triang",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:15238,Deployability,update,updated,15238,"er of virtual orbitals. Multireference Dimensions¶; A orbital diagram of the nomenclature used for CI and MCSCF calculations.; Diagrammatically:; -----------------------------------------------; CI | RAS | CAS; -----------------------------------------------; | frozen_uocc | frozen_uocc; dropped_uocc | rstr_uocc | rstr_uocc; -----------------------------------------------; | RAS IV |; | RAS III |; active | | active; | RAS II |; | RAS I |; -----------------------------------------------; dropped_docc | rstr_docc | rstr_docc; | frozen_docc | frozen_dcc; -----------------------------------------------. Notation:. uocc — Unoccupied orbitals.; active — Variable occupation orbitals.; socc — Singly occupied orbitals.; docc — Doubly occupied orbitals. Orbital spaces:. frozen_uocc — Absolutely frozen virtual orbital.; rstr_uocc — Can have rotations, no excitations into.; dropped_uocc — rstr_uocc + frozen_uocc. —– end CI active —–. RAS IV — uocc, limited number of excitations into.; RAS III — uocc, limited number of excitations into.; RAS II — docc/socc/uocc, equivalent to active in CAS.; RAS I — docc/socc/uocc, limited excitations out of. —– start CI active —–. dropped_docc — rstr_docc + frozen_docc; rstr_docc — Can have rotations, no excitations from.; frozen_docc — Absolutely frozen core orbital. Orbitals are sorted by space, irrep, eigenvalue. table of contents. Linear Algebra in PSI4; How to call BLAS & LAPACK in PSI4; BLAS Wrappers; Important BLAS Routines; LAPACK Wrappers; Important Lapack Routines. How to use low-level BLAS/LAPACK with psi4.core.Matrix; How to name orbital bases (e.g., AO & SO); How to name orbital dimensions; How to name orbital spaces (e.g., docc); Multireference Dimensions. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Programming with the Core Libraries; Linear Algebra in PSI4. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:335,Energy Efficiency,efficient,efficient,335,"﻿. Linear Algebra in PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Programming with the Core Libraries; Linear Algebra in PSI4. Linear Algebra in PSI4¶. How to call BLAS & LAPACK in PSI4¶; Computational chemistry is essentially linear algebra on molecular; systems, so using stable, portable, scalable, and efficient numerical; linear algebra methods in PSI4 is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers.; All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), ",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:3338,Energy Efficiency,efficient,efficient,3338,"psi4/libciomr/libciomr.h"". using namespace psi;; ... // Allocate a,b vectors; int n = 100;; double* a = init_array(n);; double* b = init_array(n);. // Allocate A matrix;; double** A = block_matrix(n,n);; double** B = block_matrix(n,n);; double** C = block_matrix(n,n);. // Call the BLAS1 dot product between a and b; // n can be a ULI with the BLAS1 wrappers,; // All strides must be ints though; double dot = C_DDOT(n, a, 1, b, 1);. // Call the BLAS2 GEMV without transposition; // Note this works in row-major order; C_DGEMV('N', n, n, 1.0, A[0], n, a, 1, 0.0, b, 1);. // Call the BLAS3 GEMM without transposition; // Note this works in row-major order; C_DGEMM('N','N', n, n, n, 1.0, A[0], n, B[0], n, 0.0, C[0], n);. // Array's init'd with init_array must be free'd, not delete[]'d; free(a);; free(b);. // Block matrix should be free_blocked; free_block(A);; free_block(B);; free_block(C);. Important BLAS Routines¶. BLAS1. DDOT: dot product; DCOPY: efficient memory copy (with variable stride); DAXPY: y = y + alpha*x; DROT: Givens Rotation; DNRM2: Vector norm square. BLAS2. DGEMV: General Matrix-Vector product; DTRMV: Triangular Matrix-Vector product (2x faster, not wrapped yet); DTRSM: Triangular Matrix-Vector solution via back substitution (just as fast as DTRMV); DGER: Rank-1 update (not wrapped yet). BLAS3. DGEMM: General Matrix-Matrix product; DTRMM: General Triangular Matrix-General Matrix product; DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have t",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:10109,Energy Efficiency,adapt,adapted,10109,"s is typically the; first layer encountered, Libmints handles the transform from AO to SO; automatically. If Cartesian functions are used, the number of functions; per shell remains (L + 1)(L + 2)/2, and the ordering remains the same; as above. Note that the individual functions are not normalized for; angular momentum as in most codes: the self-overlap of a PSI4 Cartesian D; or higher function with more than one nonzero Cartesian exponent (e.g., lx; = 1, ly = 1, lz = 0) will be less than one. If Spherical Harmonics are; used, 2L + 1 real combinations of the spherical harmonics are built from; the (L+1)(L+2)/2 Cartesian Gaussians, according to H. Schlegel and M.; Frish, IJQC, 54, 83-87, 1995. Unlike Cartesian functions these functions; are all strictly normalized. Note that in PSI4, the real combinations of; spherical harmonic functions (see the paragraph below Eq. 15 in the; Schlegel paper) are ordered as: 0, 1+, 1-, 2+, 2-, ….; USO (Unique Symmetry-Adapted Orbitals): Spatial symmetry-adapted; combinations of SOs, blocked according to irrep. The total number of USOs; is the same as the number of SOs, but the number of USOs within each irrep; is usually much smaller, which can lead to significant performance; improvements. Note that this basis is sometimes unfortunately referred to; as the SO basis, so it’s a bit context specific.; OSO (Orthogonal Symmetry-Adapted Orbitals): USOs orthogonalized by; Symmetric or Canonical Orthogonalization. The number of OSOs may be; slightly smaller than the total number of USOs, due to removal of linear; dependencies via Canonical Orthogonalization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs.; MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal.; LO (Localized Orbitals): Localized occupied orbitals, a different; combination ",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:11740,Energy Efficiency,adapt,adapted,11740,"ization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs.; MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal.; LO (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. How to name orbital dimensions¶; There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; nbf — The number of basis functions, which is the same as nso.; nmo — The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the stack, and is named by augmenting the name above; with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is; always the singular nirrep, and that the index variable h is always used; in a for-loop traverse of irreps. How to name orbital spaces (e.g., ",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:12431,Energy Efficiency,allocate,allocated,12431,"ut they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; nbf — The number of basis functions, which is the same as nso.; nmo — The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the stack, and is named by augmenting the name above; with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is; always the singular nirrep, and that the index variable h is always used; in a for-loop traverse of irreps. How to name orbital spaces (e.g., docc)¶; As with basis sets, a number of names are used to refer to refer to the; quantity of electrons, virtuals, and active sub-quantities of a PSI4; calculation. All of these can be defined per irrep as above. Some common; conventions are:. nelec — The number of electrons, rarely used due to specialization of alphas and betas or soccs and doccs.; nalpha — The number of alpha electrons.; nbeta — The number of beta electrons; docc — The number of doubly-occupied orbitals; socc — The number of singly-occupied orbitals (Almost always alpha, we don’t like open-shell singlets much).; nvir — The number of virtual orbitals. Multireference Dimensions¶; A orbital diagram of the nomenclature used for CI and MCSCF calculations",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:821,Integrability,interface,interfaces,821,"﻿. Linear Algebra in PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Programming with the Core Libraries; Linear Algebra in PSI4. Linear Algebra in PSI4¶. How to call BLAS & LAPACK in PSI4¶; Computational chemistry is essentially linear algebra on molecular; systems, so using stable, portable, scalable, and efficient numerical; linear algebra methods in PSI4 is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers.; All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), ",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:896,Integrability,wrap,wrappers,896,"﻿. Linear Algebra in PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Programming with the Core Libraries; Linear Algebra in PSI4. Linear Algebra in PSI4¶. How to call BLAS & LAPACK in PSI4¶; Computational chemistry is essentially linear algebra on molecular; systems, so using stable, portable, scalable, and efficient numerical; linear algebra methods in PSI4 is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers.; All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), ",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:1164,Integrability,wrap,wrappers,1164,"ow to call BLAS & LAPACK in PSI4¶; Computational chemistry is essentially linear algebra on molecular; systems, so using stable, portable, scalable, and efficient numerical; linear algebra methods in PSI4 is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers.; All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is double**). BLAS1 routines occasionally; return values (DDOT for i",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:1262,Integrability,wrap,wrapped,1262," stable, portable, scalable, and efficient numerical; linear algebra methods in PSI4 is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers.; All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is double**). BLAS1 routines occasionally; return values (DDOT for instance), BLAS2 and BLAS3 always return void.; For char arguments, case is insensitive. A few examples are provided:; /",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:1401,Integrability,rout,routines,1401,"ike dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers.; All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is double**). BLAS1 routines occasionally; return values (DDOT for instance), BLAS2 and BLAS3 always return void.; For char arguments, case is insensitive. A few examples are provided:; // BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ... // Allocate a,b ve",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:1414,Integrability,wrap,wrapped,1414,"ike dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers.; All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is double**). BLAS1 routines occasionally; return values (DDOT for instance), BLAS2 and BLAS3 always return void.; For char arguments, case is insensitive. A few examples are provided:; // BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ... // Allocate a,b ve",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:1627,Integrability,rout,routines,1627,"; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers.; All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is double**). BLAS1 routines occasionally; return values (DDOT for instance), BLAS2 and BLAS3 always return void.; For char arguments, case is insensitive. A few examples are provided:; // BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ... // Allocate a,b vectors; int n = 100;; double* a = init_array(n);; double* b = init_array(n);. // Allocate A matrix;; double** A = block_matrix(n,n);; double** B = block_matrix(n,n);; double** C = bloc",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:1663,Integrability,rout,routine,1663,"; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers.; All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is double**). BLAS1 routines occasionally; return values (DDOT for instance), BLAS2 and BLAS3 always return void.; For char arguments, case is insensitive. A few examples are provided:; // BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ... // Allocate a,b vectors; int n = 100;; double* a = init_array(n);; double* b = init_array(n);. // Allocate A matrix;; double** A = block_matrix(n,n);; double** B = block_matrix(n,n);; double** C = block_matrix(n,n);. // Call the BLAS1 dot product between a and b; // n can be ",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:1740,Integrability,rout,routine,1740,"; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers.; All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is double**). BLAS1 routines occasionally; return values (DDOT for instance), BLAS2 and BLAS3 always return void.; For char arguments, case is insensitive. A few examples are provided:; // BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ... // Allocate a,b vectors; int n = 100;; double* a = init_array(n);; double* b = init_array(n);. // Allocate A matrix;; double** A = block_matrix(n,n);; double** B = block_matrix(n,n);; double** C = block_matrix(n,n);. // Call the BLAS1 dot product between a and b; // n can be ",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:2135,Integrability,rout,routines,2135,"urrently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers.; All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is double**). BLAS1 routines occasionally; return values (DDOT for instance), BLAS2 and BLAS3 always return void.; For char arguments, case is insensitive. A few examples are provided:; // BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ... // Allocate a,b vectors; int n = 100;; double* a = init_array(n);; double* b = init_array(n);. // Allocate A matrix;; double** A = block_matrix(n,n);; double** B = block_matrix(n,n);; double** C = block_matrix(n,n);. // Call the BLAS1 dot product between a and b; // n can be a ULI with the BLAS1 wrappers,; // All strides must be ints though; double dot = C_DDOT(n, a, 1, b, 1);. // Call the BLAS2 GEMV without transposition; // Note this works in row-major order; C_DGEMV('N', n, n, 1.0, A[0], n, a, 1, 0.0, b, 1);. // Call the BLAS3 GEMM without transposition; // Note this works in row-major order; C_DGEMM('N','N', n, n, n, 1.0, A[0], n, B[0], n, 0.0, C[0], n);. // Array's init'd with init_array must be free'd, not delete[]'d; free(a)",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:2734,Integrability,wrap,wrappers,2734," the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is double**). BLAS1 routines occasionally; return values (DDOT for instance), BLAS2 and BLAS3 always return void.; For char arguments, case is insensitive. A few examples are provided:; // BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ... // Allocate a,b vectors; int n = 100;; double* a = init_array(n);; double* b = init_array(n);. // Allocate A matrix;; double** A = block_matrix(n,n);; double** B = block_matrix(n,n);; double** C = block_matrix(n,n);. // Call the BLAS1 dot product between a and b; // n can be a ULI with the BLAS1 wrappers,; // All strides must be ints though; double dot = C_DDOT(n, a, 1, b, 1);. // Call the BLAS2 GEMV without transposition; // Note this works in row-major order; C_DGEMV('N', n, n, 1.0, A[0], n, a, 1, 0.0, b, 1);. // Call the BLAS3 GEMM without transposition; // Note this works in row-major order; C_DGEMM('N','N', n, n, n, 1.0, A[0], n, B[0], n, 0.0, C[0], n);. // Array's init'd with init_array must be free'd, not delete[]'d; free(a);; free(b);. // Block matrix should be free_blocked; free_block(A);; free_block(B);; free_block(C);. Important BLAS Routines¶. BLAS1. DDOT: dot product; DCOPY: efficient memory copy (with variable stride); DAXPY: y = y + alpha*x; DROT: Givens Rotation; DNRM2: Vector norm square. BLAS2. DGEMV: General Matrix-Vector product; DTRMV: Triangular Matrix-Vector product (2x faster, not wrapped yet); DTRSM: Triangular Matrix-Vector solution via back substitution (just as fast as DTRMV); DGER: Rank-1 update (not wrapped yet). BLAS3. DGEMM: General Matrix-Matrix",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:3559,Integrability,wrap,wrapped,3559,"n,n);; double** B = block_matrix(n,n);; double** C = block_matrix(n,n);. // Call the BLAS1 dot product between a and b; // n can be a ULI with the BLAS1 wrappers,; // All strides must be ints though; double dot = C_DDOT(n, a, 1, b, 1);. // Call the BLAS2 GEMV without transposition; // Note this works in row-major order; C_DGEMV('N', n, n, 1.0, A[0], n, a, 1, 0.0, b, 1);. // Call the BLAS3 GEMM without transposition; // Note this works in row-major order; C_DGEMM('N','N', n, n, n, 1.0, A[0], n, B[0], n, 0.0, C[0], n);. // Array's init'd with init_array must be free'd, not delete[]'d; free(a);; free(b);. // Block matrix should be free_blocked; free_block(A);; free_block(B);; free_block(C);. Important BLAS Routines¶. BLAS1. DDOT: dot product; DCOPY: efficient memory copy (with variable stride); DAXPY: y = y + alpha*x; DROT: Givens Rotation; DNRM2: Vector norm square. BLAS2. DGEMV: General Matrix-Vector product; DTRMV: Triangular Matrix-Vector product (2x faster, not wrapped yet); DTRSM: Triangular Matrix-Vector solution via back substitution (just as fast as DTRMV); DGER: Rank-1 update (not wrapped yet). BLAS3. DGEMM: General Matrix-Matrix product; DTRMM: General Triangular Matrix-General Matrix product; DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using lda = n in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower triang",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:3686,Integrability,wrap,wrapped,3686,"n,n);; double** B = block_matrix(n,n);; double** C = block_matrix(n,n);. // Call the BLAS1 dot product between a and b; // n can be a ULI with the BLAS1 wrappers,; // All strides must be ints though; double dot = C_DDOT(n, a, 1, b, 1);. // Call the BLAS2 GEMV without transposition; // Note this works in row-major order; C_DGEMV('N', n, n, 1.0, A[0], n, a, 1, 0.0, b, 1);. // Call the BLAS3 GEMM without transposition; // Note this works in row-major order; C_DGEMM('N','N', n, n, n, 1.0, A[0], n, B[0], n, 0.0, C[0], n);. // Array's init'd with init_array must be free'd, not delete[]'d; free(a);; free(b);. // Block matrix should be free_blocked; free_block(A);; free_block(B);; free_block(C);. Important BLAS Routines¶. BLAS1. DDOT: dot product; DCOPY: efficient memory copy (with variable stride); DAXPY: y = y + alpha*x; DROT: Givens Rotation; DNRM2: Vector norm square. BLAS2. DGEMV: General Matrix-Vector product; DTRMV: Triangular Matrix-Vector product (2x faster, not wrapped yet); DTRSM: Triangular Matrix-Vector solution via back substitution (just as fast as DTRMV); DGER: Rank-1 update (not wrapped yet). BLAS3. DGEMM: General Matrix-Matrix product; DTRMM: General Triangular Matrix-General Matrix product; DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using lda = n in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower triang",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:4226,Integrability,rout,routines,4226,"ed; free_block(A);; free_block(B);; free_block(C);. Important BLAS Routines¶. BLAS1. DDOT: dot product; DCOPY: efficient memory copy (with variable stride); DAXPY: y = y + alpha*x; DROT: Givens Rotation; DNRM2: Vector norm square. BLAS2. DGEMV: General Matrix-Vector product; DTRMV: Triangular Matrix-Vector product (2x faster, not wrapped yet); DTRSM: Triangular Matrix-Vector solution via back substitution (just as fast as DTRMV); DGER: Rank-1 update (not wrapped yet). BLAS3. DGEMM: General Matrix-Matrix product; DTRMM: General Triangular Matrix-General Matrix product; DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using lda = n in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower triangular matrix L such; that L L^T = A, but this is returned in column-major order, so the actual; recovery of the matrix A with the row-major BLAS wrappers effectively; involves L^T L = A. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a C_, followed by the standard Fortran name of; the routine, in capital letters. Input para",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:4726,Integrability,wrap,wrappers,4726,"ubstitution (just as fast as DTRMV); DGER: Rank-1 update (not wrapped yet). BLAS3. DGEMM: General Matrix-Matrix product; DTRMM: General Triangular Matrix-General Matrix product; DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using lda = n in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower triangular matrix L such; that L L^T = A, but this is returned in column-major order, so the actual; recovery of the matrix A with the row-major BLAS wrappers effectively; involves L^T L = A. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a C_, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is double**). All routines return an int INFO with error and;",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:5075,Integrability,rout,routines,5075,"; DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using lda = n in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower triangular matrix L such; that L L^T = A, but this is returned in column-major order, so the actual; recovery of the matrix A with the row-major BLAS wrappers effectively; involves L^T L = A. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a C_, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is double**). All routines return an int INFO with error and; calculation information specific to the routine, In Fortran, this is the; last argument in all LAPACK calls, but should not be provided as an; argument here. For char arguments, case is insensitive. A Cholesky; transform example is shown:; // BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ...; int n = 100;. // Allocate A matrix;; double** A = block_matrix(n,n);. // Call the LAP",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:5112,Integrability,rout,routine,5112,"ible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using lda = n in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower triangular matrix L such; that L L^T = A, but this is returned in column-major order, so the actual; recovery of the matrix A with the row-major BLAS wrappers effectively; involves L^T L = A. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a C_, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is double**). All routines return an int INFO with error and; calculation information specific to the routine, In Fortran, this is the; last argument in all LAPACK calls, but should not be provided as an; argument here. For char arguments, case is insensitive. A Cholesky; transform example is shown:; // BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ...; int n = 100;. // Allocate A matrix;; double** A = block_matrix(n,n);. // Call the LAPACK DPOTRF to get the Cholesky factor; // Note this works in column-major ",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:5189,Integrability,rout,routine,5189,"ible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using lda = n in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower triangular matrix L such; that L L^T = A, but this is returned in column-major order, so the actual; recovery of the matrix A with the row-major BLAS wrappers effectively; involves L^T L = A. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a C_, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is double**). All routines return an int INFO with error and; calculation information specific to the routine, In Fortran, this is the; last argument in all LAPACK calls, but should not be provided as an; argument here. For char arguments, case is insensitive. A Cholesky; transform example is shown:; // BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ...; int n = 100;. // Allocate A matrix;; double** A = block_matrix(n,n);. // Call the LAPACK DPOTRF to get the Cholesky factor; // Note this works in column-major ",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:5581,Integrability,rout,routines,5581,"covery of the matrix A with the row-major BLAS wrappers effectively; involves L^T L = A. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a C_, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is double**). All routines return an int INFO with error and; calculation information specific to the routine, In Fortran, this is the; last argument in all LAPACK calls, but should not be provided as an; argument here. For char arguments, case is insensitive. A Cholesky; transform example is shown:; // BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ...; int n = 100;. // Allocate A matrix;; double** A = block_matrix(n,n);. // Call the LAPACK DPOTRF to get the Cholesky factor; // Note this works in column-major order; // The result fills like:; // * * * *; // * * *; // * *; // *; // instead of the expected:; // *; // * *; // * * *; // * * * *; //; int info = C_DPOTRF('L', n, A[0], n);. // A bit painful, see below; fprintf(outfile, ""A:\n"");; print_mat(A,n,n,outfile);. // Block matrix should be free_blocked; free_block(A);. Important Lapack Routines¶. DSYEV: Eigenvalues and, optionally eigenvectors of a symmetric matrix. Eigenvectors take up to 10x longer than eigenvalues.; DGEEV: Eigenvalues and, optionally eigenvectors ",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:5665,Integrability,rout,routine,5665,"covery of the matrix A with the row-major BLAS wrappers effectively; involves L^T L = A. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a C_, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is double**). All routines return an int INFO with error and; calculation information specific to the routine, In Fortran, this is the; last argument in all LAPACK calls, but should not be provided as an; argument here. For char arguments, case is insensitive. A Cholesky; transform example is shown:; // BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ...; int n = 100;. // Allocate A matrix;; double** A = block_matrix(n,n);. // Call the LAPACK DPOTRF to get the Cholesky factor; // Note this works in column-major order; // The result fills like:; // * * * *; // * * *; // * *; // *; // instead of the expected:; // *; // * *; // * * *; // * * * *; //; int info = C_DPOTRF('L', n, A[0], n);. // A bit painful, see below; fprintf(outfile, ""A:\n"");; print_mat(A,n,n,outfile);. // Block matrix should be free_blocked; free_block(A);. Important Lapack Routines¶. DSYEV: Eigenvalues and, optionally eigenvectors of a symmetric matrix. Eigenvectors take up to 10x longer than eigenvalues.; DGEEV: Eigenvalues and, optionally eigenvectors ",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:10673,Integrability,depend,dependencies,10673,"+ 1 real combinations of the spherical harmonics are built from; the (L+1)(L+2)/2 Cartesian Gaussians, according to H. Schlegel and M.; Frish, IJQC, 54, 83-87, 1995. Unlike Cartesian functions these functions; are all strictly normalized. Note that in PSI4, the real combinations of; spherical harmonic functions (see the paragraph below Eq. 15 in the; Schlegel paper) are ordered as: 0, 1+, 1-, 2+, 2-, ….; USO (Unique Symmetry-Adapted Orbitals): Spatial symmetry-adapted; combinations of SOs, blocked according to irrep. The total number of USOs; is the same as the number of SOs, but the number of USOs within each irrep; is usually much smaller, which can lead to significant performance; improvements. Note that this basis is sometimes unfortunately referred to; as the SO basis, so it’s a bit context specific.; OSO (Orthogonal Symmetry-Adapted Orbitals): USOs orthogonalized by; Symmetric or Canonical Orthogonalization. The number of OSOs may be; slightly smaller than the total number of USOs, due to removal of linear; dependencies via Canonical Orthogonalization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs.; MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal.; LO (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. How to name orbital dimensions¶; There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; s",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:11828,Integrability,depend,dependent,11828,"ion of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal.; LO (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. How to name orbital dimensions¶; There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; nbf — The number of basis functions, which is the same as nso.; nmo — The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the stack, and is named by augmenting the name above; with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is; always the singular nirrep, and that the index variable h is always used; in a for-loop traverse of irreps. How to name orbital spaces (e.g., docc)¶; As with basis sets, a number of names are used to refer to refer to the; quantity of electrons, virtuals, and active s",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:311,Modifiability,portab,portable,311,"﻿. Linear Algebra in PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Programming with the Core Libraries; Linear Algebra in PSI4. Linear Algebra in PSI4¶. How to call BLAS & LAPACK in PSI4¶; Computational chemistry is essentially linear algebra on molecular; systems, so using stable, portable, scalable, and efficient numerical; linear algebra methods in PSI4 is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers.; All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), ",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:3366,Modifiability,variab,variable,3366,"psi4/libciomr/libciomr.h"". using namespace psi;; ... // Allocate a,b vectors; int n = 100;; double* a = init_array(n);; double* b = init_array(n);. // Allocate A matrix;; double** A = block_matrix(n,n);; double** B = block_matrix(n,n);; double** C = block_matrix(n,n);. // Call the BLAS1 dot product between a and b; // n can be a ULI with the BLAS1 wrappers,; // All strides must be ints though; double dot = C_DDOT(n, a, 1, b, 1);. // Call the BLAS2 GEMV without transposition; // Note this works in row-major order; C_DGEMV('N', n, n, 1.0, A[0], n, a, 1, 0.0, b, 1);. // Call the BLAS3 GEMM without transposition; // Note this works in row-major order; C_DGEMM('N','N', n, n, n, 1.0, A[0], n, B[0], n, 0.0, C[0], n);. // Array's init'd with init_array must be free'd, not delete[]'d; free(a);; free(b);. // Block matrix should be free_blocked; free_block(A);; free_block(B);; free_block(C);. Important BLAS Routines¶. BLAS1. DDOT: dot product; DCOPY: efficient memory copy (with variable stride); DAXPY: y = y + alpha*x; DROT: Givens Rotation; DNRM2: Vector norm square. BLAS2. DGEMV: General Matrix-Vector product; DTRMV: Triangular Matrix-Vector product (2x faster, not wrapped yet); DTRSM: Triangular Matrix-Vector solution via back substitution (just as fast as DTRMV); DGER: Rank-1 update (not wrapped yet). BLAS3. DGEMM: General Matrix-Matrix product; DTRMM: General Triangular Matrix-General Matrix product; DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have t",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:10109,Modifiability,adapt,adapted,10109,"s is typically the; first layer encountered, Libmints handles the transform from AO to SO; automatically. If Cartesian functions are used, the number of functions; per shell remains (L + 1)(L + 2)/2, and the ordering remains the same; as above. Note that the individual functions are not normalized for; angular momentum as in most codes: the self-overlap of a PSI4 Cartesian D; or higher function with more than one nonzero Cartesian exponent (e.g., lx; = 1, ly = 1, lz = 0) will be less than one. If Spherical Harmonics are; used, 2L + 1 real combinations of the spherical harmonics are built from; the (L+1)(L+2)/2 Cartesian Gaussians, according to H. Schlegel and M.; Frish, IJQC, 54, 83-87, 1995. Unlike Cartesian functions these functions; are all strictly normalized. Note that in PSI4, the real combinations of; spherical harmonic functions (see the paragraph below Eq. 15 in the; Schlegel paper) are ordered as: 0, 1+, 1-, 2+, 2-, ….; USO (Unique Symmetry-Adapted Orbitals): Spatial symmetry-adapted; combinations of SOs, blocked according to irrep. The total number of USOs; is the same as the number of SOs, but the number of USOs within each irrep; is usually much smaller, which can lead to significant performance; improvements. Note that this basis is sometimes unfortunately referred to; as the SO basis, so it’s a bit context specific.; OSO (Orthogonal Symmetry-Adapted Orbitals): USOs orthogonalized by; Symmetric or Canonical Orthogonalization. The number of OSOs may be; slightly smaller than the total number of USOs, due to removal of linear; dependencies via Canonical Orthogonalization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs.; MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal.; LO (Localized Orbitals): Localized occupied orbitals, a different; combination ",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:11149,Modifiability,enhance,enhances,11149,"ymmetry-adapted; combinations of SOs, blocked according to irrep. The total number of USOs; is the same as the number of SOs, but the number of USOs within each irrep; is usually much smaller, which can lead to significant performance; improvements. Note that this basis is sometimes unfortunately referred to; as the SO basis, so it’s a bit context specific.; OSO (Orthogonal Symmetry-Adapted Orbitals): USOs orthogonalized by; Symmetric or Canonical Orthogonalization. The number of OSOs may be; slightly smaller than the total number of USOs, due to removal of linear; dependencies via Canonical Orthogonalization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs.; MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal.; LO (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. How to name orbital dimensions¶; There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the ",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:11740,Modifiability,adapt,adapted,11740,"ization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs.; MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal.; LO (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. How to name orbital dimensions¶; There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; nbf — The number of basis functions, which is the same as nso.; nmo — The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the stack, and is named by augmenting the name above; with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is; always the singular nirrep, and that the index variable h is always used; in a for-loop traverse of irreps. How to name orbital spaces (e.g., ",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:12615,Modifiability,variab,variable,12615," dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; nbf — The number of basis functions, which is the same as nso.; nmo — The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the stack, and is named by augmenting the name above; with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is; always the singular nirrep, and that the index variable h is always used; in a for-loop traverse of irreps. How to name orbital spaces (e.g., docc)¶; As with basis sets, a number of names are used to refer to refer to the; quantity of electrons, virtuals, and active sub-quantities of a PSI4; calculation. All of these can be defined per irrep as above. Some common; conventions are:. nelec — The number of electrons, rarely used due to specialization of alphas and betas or soccs and doccs.; nalpha — The number of alpha electrons.; nbeta — The number of beta electrons; docc — The number of doubly-occupied orbitals; socc — The number of singly-occupied orbitals (Almost always alpha, we don’t like open-shell singlets much).; nvir — The number of virtual orbitals. Multireference Dimensions¶; A orbital diagram of the nomenclature used for CI and MCSCF calculations.; Diagrammatically:; -----------------------------------------------; CI | RAS | CAS; -----------------------------------------------; | frozen_uocc | frozen_uocc; dro",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:321,Performance,scalab,scalable,321,"﻿. Linear Algebra in PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Programming with the Core Libraries; Linear Algebra in PSI4. Linear Algebra in PSI4¶. How to call BLAS & LAPACK in PSI4¶; Computational chemistry is essentially linear algebra on molecular; systems, so using stable, portable, scalable, and efficient numerical; linear algebra methods in PSI4 is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers.; All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), ",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:715,Performance,perform,performance,715,"﻿. Linear Algebra in PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Programming with the Core Libraries; Linear Algebra in PSI4. Linear Algebra in PSI4¶. How to call BLAS & LAPACK in PSI4¶; Computational chemistry is essentially linear algebra on molecular; systems, so using stable, portable, scalable, and efficient numerical; linear algebra methods in PSI4 is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers.; All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), ",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:10324,Performance,perform,performance,10324,"of functions; per shell remains (L + 1)(L + 2)/2, and the ordering remains the same; as above. Note that the individual functions are not normalized for; angular momentum as in most codes: the self-overlap of a PSI4 Cartesian D; or higher function with more than one nonzero Cartesian exponent (e.g., lx; = 1, ly = 1, lz = 0) will be less than one. If Spherical Harmonics are; used, 2L + 1 real combinations of the spherical harmonics are built from; the (L+1)(L+2)/2 Cartesian Gaussians, according to H. Schlegel and M.; Frish, IJQC, 54, 83-87, 1995. Unlike Cartesian functions these functions; are all strictly normalized. Note that in PSI4, the real combinations of; spherical harmonic functions (see the paragraph below Eq. 15 in the; Schlegel paper) are ordered as: 0, 1+, 1-, 2+, 2-, ….; USO (Unique Symmetry-Adapted Orbitals): Spatial symmetry-adapted; combinations of SOs, blocked according to irrep. The total number of USOs; is the same as the number of SOs, but the number of USOs within each irrep; is usually much smaller, which can lead to significant performance; improvements. Note that this basis is sometimes unfortunately referred to; as the SO basis, so it’s a bit context specific.; OSO (Orthogonal Symmetry-Adapted Orbitals): USOs orthogonalized by; Symmetric or Canonical Orthogonalization. The number of OSOs may be; slightly smaller than the total number of USOs, due to removal of linear; dependencies via Canonical Orthogonalization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs.; MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal.; LO (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonor",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:4677,Safety,recover,recovery,4677,"ubstitution (just as fast as DTRMV); DGER: Rank-1 update (not wrapped yet). BLAS3. DGEMM: General Matrix-Matrix product; DTRMM: General Triangular Matrix-General Matrix product; DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using lda = n in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower triangular matrix L such; that L L^T = A, but this is returned in column-major order, so the actual; recovery of the matrix A with the row-major BLAS wrappers effectively; involves L^T L = A. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a C_, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is double**). All routines return an int INFO with error and;",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:11423,Safety,redund,redundant,11423," specific.; OSO (Orthogonal Symmetry-Adapted Orbitals): USOs orthogonalized by; Symmetric or Canonical Orthogonalization. The number of OSOs may be; slightly smaller than the total number of USOs, due to removal of linear; dependencies via Canonical Orthogonalization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs.; MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal.; LO (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. How to name orbital dimensions¶; There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; nbf — The number of basis functions, which is the same as nso.; nmo — The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the st",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:11896,Safety,redund,redundancies,11896,"ion of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal.; LO (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. How to name orbital dimensions¶; There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; nbf — The number of basis functions, which is the same as nso.; nmo — The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the stack, and is named by augmenting the name above; with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is; always the singular nirrep, and that the index variable h is always used; in a for-loop traverse of irreps. How to name orbital spaces (e.g., docc)¶; As with basis sets, a number of names are used to refer to refer to the; quantity of electrons, virtuals, and active s",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:12322,Safety,redund,redundancies,12322," name orbital dimensions¶; There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; nbf — The number of basis functions, which is the same as nso.; nmo — The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the stack, and is named by augmenting the name above; with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is; always the singular nirrep, and that the index variable h is always used; in a for-loop traverse of irreps. How to name orbital spaces (e.g., docc)¶; As with basis sets, a number of names are used to refer to refer to the; quantity of electrons, virtuals, and active sub-quantities of a PSI4; calculation. All of these can be defined per irrep as above. Some common; conventions are:. nelec — The number of electrons, rarely used due to specialization of alphas and betas or soccs and doccs.; nalpha — The number of alpha electrons.; nbeta — The number of beta electrons; docc — The number of doubly-occupied orbitals; socc — The number of singly-occupied orbitals (Almost always alpha, we don’t like open-shell singlets much).; nvir — T",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_blas.html:7356,Usability,simpl,simple,7356,",outfile);. // Block matrix should be free_blocked; free_block(A);. Important Lapack Routines¶. DSYEV: Eigenvalues and, optionally eigenvectors of a symmetric matrix. Eigenvectors take up to 10x longer than eigenvalues.; DGEEV: Eigenvalues and, optionally eigenvectors of a general matrix. Up to 10x slower than DSYEV.; DGESV: General solver (uses LU decomposition).; DGESVD: General singular value decomposition.; DGETRF: LU decomposition.; DPOTRF: Cholesky decomposition (much more stable/faster); DGETRS: Solver, given LU decomposition by DGETRF; DPOTRS: Solver, given Cholesky decomposition by DPOTRF; DGETRI: Inverse, given LU decomposition by DGETRF (Warning: it’s faster and more stable just to solve with DGETRS); DPOTRI: Inverse, given Cholesky decomposition by DPOTRF (Warning: it’s faster and more stable just to solve with DPOTRS). How to use low-level BLAS/LAPACK with psi4.core.Matrix¶; Jet’s awesome new Matrix object has a lot of simple BLAS/LAPACK built in,; but you can just as easily use the double*** array underneath if you are; careful (the outer index is the submatrix for each irrep). Here’s an; example:; // BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // Matrix; #include ""psi4/libmints/matrix.h"". using namespace psi;; ...; int n = 100;. // Allocate A Matrix (new C1 convenience constructor);; shared_ptr<Matrix> A(new Matrix(""Still A, but way cooler"", n,n));; // Get the pointer to the 0 irrep (C1 for now, it errors if you ask for too high of an index); double** A_pointer = A->get_pointer(0);. // Call the LAPACK DPOTRF to get the Cholesky factor; // Note this works in column-major order; // The result fills like:; // * * * *; // * * *; // * *; // *; // instead of the expected:; // *; // * *; // * * *; // * * * *; //; int info = C_DPOTRF('L', n, A_pointer[0], n);. // Wow that's a lot easier; A->print();. // Don't free, it's shared_ptr!. How to name orbital bases (e.g., AO & SO)¶; Many different working bases (the internal linear algebraic basis, not the; name of the",MatchSource.WIKI,psi4manual/1.6.x/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_blas.html
https://psicode.org/psi4manual/1.6.x/prog_conduct.html:398,Deployability,update,updated,398,"﻿. Community Code of Conduct. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Introduction to Programming in PSI4; Community Code of Conduct. Community Code of Conduct¶. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Introduction to Programming in PSI4; Community Code of Conduct. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prog_conduct.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_conduct.html
https://psicode.org/psi4manual/1.6.x/prog_corelibs.html:858,Deployability,update,updated,858,"﻿. Programming with the Core Libraries. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Programming with the Core Libraries. Programming with the Core Libraries¶. LibOptions: globals, locals, has_changed and all that; Declaring Options; What is has_changed ?; Reading Options in Module; Handling Options in Driver. Linear Algebra in PSI4; How to call BLAS & LAPACK in PSI4; BLAS Wrappers; Important BLAS Routines; LAPACK Wrappers; Important Lapack Routines. How to use low-level BLAS/LAPACK with psi4.core.Matrix; How to name orbital bases (e.g., AO & SO); How to name orbital dimensions; How to name orbital spaces (e.g., docc); Multireference Dimensions. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Programming with the Core Libraries. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prog_corelibs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_corelibs.html
https://psicode.org/psi4manual/1.6.x/prog_debug_profile.html:614,Deployability,update,updated,614,"﻿. Debugging and Profiling. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Debugging and Profiling. Debugging and Profiling¶. Debugging¶; Instructions on running Psi4 with a debugger. Profiling¶; Instructions on using Psi4 with a profiler, or/and discuss how timers work; in Psi4… they are hierarchical…. I think we have special timers for; parallel blocks. table of contents. Debugging and Profiling; Debugging; Profiling. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Debugging and Profiling. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prog_debug_profile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_debug_profile.html
https://psicode.org/psi4manual/1.6.x/prog_faq.html:815,Deployability,integrat,integrate,815,"﻿. Programmers FAQ. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Programmers FAQ. Programmers FAQ¶. C++ Style in PSI4¶. Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations; How to impose code style through your editor; How to impose code style through Git hooks; How to run code-style tools clang-format and yapf manually. Modules in PSI4¶. How to name keywords in psi4/src/read_options.cc; How to call BLAS & LAPACK in ; How to use low-level BLAS/LAPACK with psi4.core.Matrix; How to name orbital bases (e.g., AO & SO); How to name orbital dimensions; How to name orbital spaces (e.g., docc). Interfacing with PSI4¶. How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs. Versioning PSI4¶. How to bump a version; How to create and remove an annotated Git tag on a remote; What is the suggested GitHub workflow; What Psi4 version is running. Releasing PSI4¶. Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1). Workflow¶. How to use a local Add-On repository in the Psi4 build; What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi; How to use gdb and lldb with Psi4; How to locate non-ascii characters in the codebase; How to Ignore the Bots. Miscellaneous¶. Test Suite; Adding PSIthon Test Cases; Adding PsiAPI Test Cases; How to set up PSIthon tests to run through pytest; How to find tests without output.ref; How to do GitHub issue management and code review. table of contents. Programmers FAQ; C++ Style in PSI4; Modules in PSI4; Interfacing with PSI4; Versioning PSI4; Releasing PSI4; Workflow; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Programmers FAQ. © Copyright 2022, Th",MatchSource.WIKI,psi4manual/1.6.x/prog_faq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_faq.html
https://psicode.org/psi4manual/1.6.x/prog_faq.html:1243,Deployability,install,installed,1243,"w Code to PSI4; Programmers FAQ. Programmers FAQ¶. C++ Style in PSI4¶. Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations; How to impose code style through your editor; How to impose code style through Git hooks; How to run code-style tools clang-format and yapf manually. Modules in PSI4¶. How to name keywords in psi4/src/read_options.cc; How to call BLAS & LAPACK in ; How to use low-level BLAS/LAPACK with psi4.core.Matrix; How to name orbital bases (e.g., AO & SO); How to name orbital dimensions; How to name orbital spaces (e.g., docc). Interfacing with PSI4¶. How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs. Versioning PSI4¶. How to bump a version; How to create and remove an annotated Git tag on a remote; What is the suggested GitHub workflow; What Psi4 version is running. Releasing PSI4¶. Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1). Workflow¶. How to use a local Add-On repository in the Psi4 build; What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi; How to use gdb and lldb with Psi4; How to locate non-ascii characters in the codebase; How to Ignore the Bots. Miscellaneous¶. Test Suite; Adding PSIthon Test Cases; Adding PsiAPI Test Cases; How to set up PSIthon tests to run through pytest; How to find tests without output.ref; How to do GitHub issue management and code review. table of contents. Programmers FAQ; C++ Style in PSI4; Modules in PSI4; Interfacing with PSI4; Versioning PSI4; Releasing PSI4; Workflow; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Programmers FAQ. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prog_faq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_faq.html
https://psicode.org/psi4manual/1.6.x/prog_faq.html:2023,Deployability,update,updated,2023,"w Code to PSI4; Programmers FAQ. Programmers FAQ¶. C++ Style in PSI4¶. Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations; How to impose code style through your editor; How to impose code style through Git hooks; How to run code-style tools clang-format and yapf manually. Modules in PSI4¶. How to name keywords in psi4/src/read_options.cc; How to call BLAS & LAPACK in ; How to use low-level BLAS/LAPACK with psi4.core.Matrix; How to name orbital bases (e.g., AO & SO); How to name orbital dimensions; How to name orbital spaces (e.g., docc). Interfacing with PSI4¶. How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs. Versioning PSI4¶. How to bump a version; How to create and remove an annotated Git tag on a remote; What is the suggested GitHub workflow; What Psi4 version is running. Releasing PSI4¶. Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1). Workflow¶. How to use a local Add-On repository in the Psi4 build; What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi; How to use gdb and lldb with Psi4; How to locate non-ascii characters in the codebase; How to Ignore the Bots. Miscellaneous¶. Test Suite; Adding PSIthon Test Cases; Adding PsiAPI Test Cases; How to set up PSIthon tests to run through pytest; How to find tests without output.ref; How to do GitHub issue management and code review. table of contents. Programmers FAQ; C++ Style in PSI4; Modules in PSI4; Interfacing with PSI4; Versioning PSI4; Releasing PSI4; Workflow; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Programmers FAQ. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prog_faq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_faq.html
https://psicode.org/psi4manual/1.6.x/prog_faq.html:815,Integrability,integrat,integrate,815,"﻿. Programmers FAQ. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Programmers FAQ. Programmers FAQ¶. C++ Style in PSI4¶. Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations; How to impose code style through your editor; How to impose code style through Git hooks; How to run code-style tools clang-format and yapf manually. Modules in PSI4¶. How to name keywords in psi4/src/read_options.cc; How to call BLAS & LAPACK in ; How to use low-level BLAS/LAPACK with psi4.core.Matrix; How to name orbital bases (e.g., AO & SO); How to name orbital dimensions; How to name orbital spaces (e.g., docc). Interfacing with PSI4¶. How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs. Versioning PSI4¶. How to bump a version; How to create and remove an annotated Git tag on a remote; What is the suggested GitHub workflow; What Psi4 version is running. Releasing PSI4¶. Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1). Workflow¶. How to use a local Add-On repository in the Psi4 build; What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi; How to use gdb and lldb with Psi4; How to locate non-ascii characters in the codebase; How to Ignore the Bots. Miscellaneous¶. Test Suite; Adding PSIthon Test Cases; Adding PsiAPI Test Cases; How to set up PSIthon tests to run through pytest; How to find tests without output.ref; How to do GitHub issue management and code review. table of contents. Programmers FAQ; C++ Style in PSI4; Modules in PSI4; Interfacing with PSI4; Versioning PSI4; Releasing PSI4; Workflow; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Programmers FAQ. © Copyright 2022, Th",MatchSource.WIKI,psi4manual/1.6.x/prog_faq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_faq.html
https://psicode.org/psi4manual/1.6.x/prog_faq.html:847,Testability,test,testing,847,"﻿. Programmers FAQ. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Programmers FAQ. Programmers FAQ¶. C++ Style in PSI4¶. Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations; How to impose code style through your editor; How to impose code style through Git hooks; How to run code-style tools clang-format and yapf manually. Modules in PSI4¶. How to name keywords in psi4/src/read_options.cc; How to call BLAS & LAPACK in ; How to use low-level BLAS/LAPACK with psi4.core.Matrix; How to name orbital bases (e.g., AO & SO); How to name orbital dimensions; How to name orbital spaces (e.g., docc). Interfacing with PSI4¶. How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs. Versioning PSI4¶. How to bump a version; How to create and remove an annotated Git tag on a remote; What is the suggested GitHub workflow; What Psi4 version is running. Releasing PSI4¶. Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1). Workflow¶. How to use a local Add-On repository in the Psi4 build; What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi; How to use gdb and lldb with Psi4; How to locate non-ascii characters in the codebase; How to Ignore the Bots. Miscellaneous¶. Test Suite; Adding PSIthon Test Cases; Adding PsiAPI Test Cases; How to set up PSIthon tests to run through pytest; How to find tests without output.ref; How to do GitHub issue management and code review. table of contents. Programmers FAQ; C++ Style in PSI4; Modules in PSI4; Interfacing with PSI4; Versioning PSI4; Releasing PSI4; Workflow; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Programmers FAQ. © Copyright 2022, Th",MatchSource.WIKI,psi4manual/1.6.x/prog_faq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_faq.html
https://psicode.org/psi4manual/1.6.x/prog_faq.html:1566,Testability,test,tests,1566,"w Code to PSI4; Programmers FAQ. Programmers FAQ¶. C++ Style in PSI4¶. Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations; How to impose code style through your editor; How to impose code style through Git hooks; How to run code-style tools clang-format and yapf manually. Modules in PSI4¶. How to name keywords in psi4/src/read_options.cc; How to call BLAS & LAPACK in ; How to use low-level BLAS/LAPACK with psi4.core.Matrix; How to name orbital bases (e.g., AO & SO); How to name orbital dimensions; How to name orbital spaces (e.g., docc). Interfacing with PSI4¶. How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs. Versioning PSI4¶. How to bump a version; How to create and remove an annotated Git tag on a remote; What is the suggested GitHub workflow; What Psi4 version is running. Releasing PSI4¶. Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1). Workflow¶. How to use a local Add-On repository in the Psi4 build; What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi; How to use gdb and lldb with Psi4; How to locate non-ascii characters in the codebase; How to Ignore the Bots. Miscellaneous¶. Test Suite; Adding PSIthon Test Cases; Adding PsiAPI Test Cases; How to set up PSIthon tests to run through pytest; How to find tests without output.ref; How to do GitHub issue management and code review. table of contents. Programmers FAQ; C++ Style in PSI4; Modules in PSI4; Interfacing with PSI4; Versioning PSI4; Releasing PSI4; Workflow; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Programmers FAQ. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prog_faq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_faq.html
https://psicode.org/psi4manual/1.6.x/prog_faq.html:1607,Testability,test,tests,1607,"w Code to PSI4; Programmers FAQ. Programmers FAQ¶. C++ Style in PSI4¶. Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations; How to impose code style through your editor; How to impose code style through Git hooks; How to run code-style tools clang-format and yapf manually. Modules in PSI4¶. How to name keywords in psi4/src/read_options.cc; How to call BLAS & LAPACK in ; How to use low-level BLAS/LAPACK with psi4.core.Matrix; How to name orbital bases (e.g., AO & SO); How to name orbital dimensions; How to name orbital spaces (e.g., docc). Interfacing with PSI4¶. How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs. Versioning PSI4¶. How to bump a version; How to create and remove an annotated Git tag on a remote; What is the suggested GitHub workflow; What Psi4 version is running. Releasing PSI4¶. Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1). Workflow¶. How to use a local Add-On repository in the Psi4 build; What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi; How to use gdb and lldb with Psi4; How to locate non-ascii characters in the codebase; How to Ignore the Bots. Miscellaneous¶. Test Suite; Adding PSIthon Test Cases; Adding PsiAPI Test Cases; How to set up PSIthon tests to run through pytest; How to find tests without output.ref; How to do GitHub issue management and code review. table of contents. Programmers FAQ; C++ Style in PSI4; Modules in PSI4; Interfacing with PSI4; Versioning PSI4; Releasing PSI4; Workflow; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Programmers FAQ. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prog_faq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_faq.html
https://psicode.org/psi4manual/1.6.x/prog_full_integration.html:858,Deployability,update,updated,858,"﻿. Integrating New Features into PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Integrating New Features into PSI4. Integrating New Features into PSI4¶. Overview of Required Steps¶; Explain the different steps that are needed to add a few feature to; PSI4 (where to put the code, how to add user options (w/docs), where; to add targets to CMake files, adding test cases, adding a section; to the Users’ manual. Several of those steps are already documented; elsewhere, so just point to them in the appropriate places. table of contents. Integrating New Features into PSI4; Overview of Required Steps. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Integrating New Features into PSI4. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prog_full_integration.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_full_integration.html
https://psicode.org/psi4manual/1.6.x/prog_full_integration.html:411,Testability,test,test,411,"﻿. Integrating New Features into PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Integrating New Features into PSI4. Integrating New Features into PSI4¶. Overview of Required Steps¶; Explain the different steps that are needed to add a few feature to; PSI4 (where to put the code, how to add user options (w/docs), where; to add targets to CMake files, adding test cases, adding a section; to the Users’ manual. Several of those steps are already documented; elsewhere, so just point to them in the appropriate places. table of contents. Integrating New Features into PSI4; Overview of Required Steps. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Integrating New Features into PSI4. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prog_full_integration.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_full_integration.html
https://psicode.org/psi4manual/1.6.x/prog_help.html:755,Deployability,update,updated,755,"﻿. Where to Get Help. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Introduction to Programming in PSI4; Where to Get Help. Where to Get Help¶. Slack¶; PSI4 has an active Slack channel; for developers, and a friendly community willing to answer your questions. Reporting Bugs¶; Program bugs should be reported as Issues on GitHub,; here. Using PSI4¶; Questions about using PSI4, as opposed to programming for PSI4,; should be directed to the; Psi4 User Forum. table of contents. Where to Get Help; Slack; Reporting Bugs; Using PSI4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Introduction to Programming in PSI4; Where to Get Help. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prog_help.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_help.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:174,Availability,avail,available,174,"﻿. Integrals in PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Integrals in PSI4. Integrals in PSI4¶. Introduction¶; PSI4 has a number of backends available to compute integrals. In order to; accomodate these options, while providing a clean interface to the programmer,; an abstraction layer is implemented within Libmints. A recent upgrade to the; primary integral engine has seen some important changes to the way this; interface layer is used; this document is designed to aid new developers as; well as those familiar with the older calling conventions to ensure that the; most efficient calling conventions are applied. The older style¶; A very simple loop that does not use permutational symmetry might look; something like this in the old scheme:; auto sieve = std::make_shared<ERISieve>(basisset, cutoff);; auto factory= std::make_shared<IntegralFactory>(basisset);; int deriv_level = 0;; bool use_shell_pairs = true;; auto eri = factory->eri(deriv_level, use_shell_pairs);; const double* buffer = eri_->buffer();; for (int P = 0; P < basisset->nshell(); ++P) {; const auto& Pshell = basisset->shell(P);; for (int Q = 0; Q < basisset->nshell(); ++Q) {; const auto& Qshell = basisset->shell(Q);; for (int R = 0; R < basisset->nshell(); ++R) {; const auto& Rshell = basisset->shell(R);; for (int S = 0; S < basisset->nshell(); ++S) {; const auto& Sshell = basisset->shell(S);; if(sieve->shell_significant(P, Q, R, S) {; eri->compute_shell(P, Q, R, S);; // results are in buffer, do something with them..; }; }; }; }; }. An integral factory is used, which can then produce integral object for various; operator types and derivative levels. A sieve is also constructed; this allows; a quick determination of whether an integral shell quartet will be significant; in magnitude or not, potentially saving a lot of work. This simple scheme is; clean and easy to understand, and is still supported in the latest version of; PSI4 with only a small change to the sieve syntax",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:4006,Availability,redundant,redundant,4006," eri->first_RS_shell_block(blockPQ_idx);; for (int blockRS_idx = loop_start; blockRS_idx < blocksRS.size(); ++blockRS_idx) {; const auto& blockRS = blocksRS[blockRS_idx];. if (!eri->shell_block_significant(blockPQ_idx, blockRS_idx)) continue;. eri->compute_shell_blocks(blockPQ_idx, blockRS_idx);; const auto* block_start = buffers[0];. // Loop over all of the P,Q,R,S shells within the blocks. We have P>=Q, R>=S and PQ<=RS.; for (const auto& pairPQ : blockPQ) {; const auto &P = pairPQ.first;; const auto &Q = pairPQ.second;; const auto& Pshell = basisset->shell(P);; const auto& Qshell = basisset->shell(Q);; const auto Pam = Pshell.am();; const auto Qam = Qshell.am();; for (const auto& pairRS : blockRS) {; const auto &R = pairRS.first;; const auto &S = pairRS.second;; const auto& Rshell = basisset->shell(R);; const auto& Sshell = basisset->shell(S);; const auto Ram = Rshell.am();; const auto Sam = Sshell.am();. size_t block_size = Psize * Qsize * Rsize * Ssize;; // When there are chunks of shellpairs in RS, we need to make sure; // we filter out redundant combinations.; if (use_batching && Pam == Ram && Qam == Sam && ((P > R) || (P == R && Q > S))) {; block_start += block_size;; continue;; }; const double* int_ptr = block_start;; // Query P,Q,R,S shells for metadata and loop over that quartet; // as usual, getting the integrals from the int_ptr buffer.; block_start += block_size;; }; }; }; }. Although this looks more complex, it’s essentially doing the same thing. There; are a number of differences that we’ll highlight now. Sieving¶; This is one of two breaking changes to the old style syntax. Instead of; constructing a sieve object, the integral object should be queried directly; using the exact same syntax. Requests for whether a shell is significant or a; shell block is significant are both supported. A sieve object is created if; matching basis sets are found in either the bra or the ket. For a density; fitting integral (PQ|0A) where 0 is the null basis set and A is ",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:8974,Availability,redundant,redundant,8974,"her angular momentum; first. Therefore care must be taken to ensure that the missing permutations; are correctly accounted for when processing the integrals within the loop. See; the DirectJK code in libfock for an example of using this scheme for a Fock; matrix build. Using bra-ket symmetry¶; In cases where there is no batching performed, bra-ket symmetry can be; trivially enforced by ensuring that one of the block indices is greater than or; equal to the other. When batching is used, the situation is trickier; some ket; batches may contain a mixture of integrals that are bra-ket unique and those; that are not. To handle this we must do a coarse check at the top of the loop; to see if any integrals in the batch are needed, which is implemented by; asking the integral engine where to start looping in the ket via the call to; eri->first_RS_shell_block(PQpair_idx). This is followed by a more fine; grained check within the loops to filter individual integrals in the case where; bra and ket have the same angular momentum and there’s a possibility of a; handful of integrals coming from the ket that are redundant. Note that the bra; is not batched in any of our engines currently: only the ket is. For this; reason, density fitting integrals should be written as (A0|PQ) rather than; (PQ|A0) where possible, because we want the ket to contain more functions than; the bra for efficient blocking. Instantiating integral objects¶; With sieving being introduced in the new integral objects, the cost of their; construction has increased. Although significantly cheaper than computing; integrals themselves, construction of integral objects can be non-negligible,; especially if many threads are used. For example, this pattern can be found in; old versions of the code:; std::vector<std::shared_ptr<TwoBodyAOInt>> ints;; ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));; for (int thread = 1; thread < num_threads; thread++) {; ints.push_back(std::shared_ptr<TwoBodyAOInt>(facto",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:16243,Availability,avail,available,16243,"AO”) and computed / contracted all integrals in; this Cartesian basis, eliminating the need to transform to spherical harmonics; as the integrals are computed. This bottleneck no longer exists, so these; extra transformation steps have been removed as part of the switch to Libint2,; and the affected codes (PCM and CPPE interfaces) now compute the potential and; field integrals in the representation required by the basis set.; Also, note that the way external point charges are specified has changed.; Previously, a set of N external point charges would be specified by passing a; matrix with dimensions N rows and 4 columns – corresponding to charge, x, y, z; – to the set_charge_field() member of the potential integral class. The; same information is now passed using the more verbose; std::vector<std::pair<double, std::array<double, 3>>> type instead, to be; consistent with Libint2’s convention. New Operators Available¶; Libint2 provides a range of integrals that were previously not available in; PSI4, such as the Erfc attenuated nuclear potential integrals needed for; Ewald methods. If new integrals are added to Libint2 but are not yet; interfaced to PSI4, please open an issue on the PSI4 GitHub page to; alert the developers, who will be able to add the appropriate code.; Available integrals classes and parameters currently documented at; Libint2 C++11 Interface Wiki. Shell Pairs¶; To ensure consistency between one- and two-electron terms when screening, and; for efficiency reasons, shell pair lists should be used to iterate over pairs; of Gaussian shells. These lists contain integer pair numbers, corresponding to; the pairs of shells that have sufficient overlap to survive the screening; process. Iterating over these lists is simple:; const auto& shell_pairs = Vint->shellpairs();; size_t n_pairs = shell_pairs.size();; for (size_t p = 0; p < n_pairs; ++p) {; auto P = shell_pairs[p].first;; auto Q = shell_pairs[p].second;; // do something with shells P and Q; }. Note th",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:361,Deployability,upgrade,upgrade,361,"﻿. Integrals in PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Integrals in PSI4. Integrals in PSI4¶. Introduction¶; PSI4 has a number of backends available to compute integrals. In order to; accomodate these options, while providing a clean interface to the programmer,; an abstraction layer is implemented within Libmints. A recent upgrade to the; primary integral engine has seen some important changes to the way this; interface layer is used; this document is designed to aid new developers as; well as those familiar with the older calling conventions to ensure that the; most efficient calling conventions are applied. The older style¶; A very simple loop that does not use permutational symmetry might look; something like this in the old scheme:; auto sieve = std::make_shared<ERISieve>(basisset, cutoff);; auto factory= std::make_shared<IntegralFactory>(basisset);; int deriv_level = 0;; bool use_shell_pairs = true;; auto eri = factory->eri(deriv_level, use_shell_pairs);; const double* buffer = eri_->buffer();; for (int P = 0; P < basisset->nshell(); ++P) {; const auto& Pshell = basisset->shell(P);; for (int Q = 0; Q < basisset->nshell(); ++Q) {; const auto& Qshell = basisset->shell(Q);; for (int R = 0; R < basisset->nshell(); ++R) {; const auto& Rshell = basisset->shell(R);; for (int S = 0; S < basisset->nshell(); ++S) {; const auto& Sshell = basisset->shell(S);; if(sieve->shell_significant(P, Q, R, S) {; eri->compute_shell(P, Q, R, S);; // results are in buffer, do something with them..; }; }; }; }; }. An integral factory is used, which can then produce integral object for various; operator types and derivative levels. A sieve is also constructed; this allows; a quick determination of whether an integral shell quartet will be significant; in magnitude or not, potentially saving a lot of work. This simple scheme is; clean and easy to understand, and is still supported in the latest version of; PSI4 with only a small change to the sieve syntax",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:5990,Deployability,update,updated,5990," The old code copied integrals into a buffer owned by the integral object, whose; address remained constant and could be retrieved by the buffer() member; function. To avoid unnecessary copies, the new code instead uses the integrals; directly from the underlying integral engine’s memory, which may change with; each call to compute integrals. The integral engine provides a; std::vector<const double*> containing the pointers to the start of each; “chunk” of integrals. For first derivatives there are 12 such “chunks”, which; are ordered Px,Py,Pz,Qx,Qy,Qz,Rx,Ry,Rz,Sx,Sy,Sz, where the Px refers to the x; derivative with respect to the basis functions in shell P. Note that all; integral derivatives are provided by the new integral code, unlike the previous; version where only 9 of 12 were provided and the user was responsible for using; translation invariance relationships to fill in the rest. The addresses for; each chunk are updated in the vector after each call to compute integrals, so; the user should keep a const reference to that object, and query that for the; address of interest. Density Screening¶; The old code looked only at the integral to determine whether terms can be; avoided a priori. However, if the integral is to be contracted with a; density or a density-like quantity, the screening can be performed on the; product, which yields more sparsity. To enable this, simply call the integral; object’s update_density member, passing it a SharedMatrix holding the; current density (remember that it changes during each iteration of the SCF) and; the product will be considered during screening. If only coulomb-like terms; are to be computed, the needs_exchange argument to the integral object; constructor should be set to false, otherwise it should be true to correcly; account for products of the density and integrals that contribute to; exchange-like terms. Shell blocking¶; Each underlying integral engine knows whether it will use blocks, and will set up; the metada",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:19353,Deployability,update,updated,19353,"r case. One Electron Integral Algorithm Overview¶; The following table summarizes which implementation is used; for each type of one electron integral in PSI4. Algorithms used for One Electron Integrals¶. Integral; Class; Implementation; Comment. Three-Center Overlap; ThreeCenterOverlapInt; Libint2; using libint2::Operator::delta for 4-center integrals. Angular Momentum; AngularMomentumInt; M-D. Dipole; DipoleInt; Libint2; no derivatives supported. Electric Field; ElectricFieldInt; Libint2; using first derivative of libint2::Operator::nuclear. Coulomb Potential; ElectrostaticInt; Libint2; evaluated for a single origin and unity charge. Kinetic; KineticInt; Libint2. Multipole Potential; MultipolePotentialInt; M-D; arbitrary order derivative of 1/R supported. Multipole Moments; MultipoleInt; M-D; arbitrary order multipoles supported, including nuclear gradients. Nabla Operator; NablaInt; Libint2; using first derivative of libint2::Operator::overlap. Overlap; OverlapInt; Libint2. Nuclear Coulomb Potential; PotentialInt; Libint2; assumes nuclear centers/charges as the potential. PCM Potential; PCMPotentialInt; Libint2; parallelized over charge points. Quadrupole; QuadrupoleInt; Libint2. Traceless Quadrupole; TracelessQuadrupoleInt; Libint2. Relativistic Potential; RelPotentialInt; Libint2. table of contents. Integrals in PSI4; Introduction; The older style; The new syntax; Sieving; Buffer address; Density Screening; Shell blocking; Permutational symmetry; Using bra-ket symmetry; Instantiating integral objects. One Electron Integrals in PSI4; Calling compute_shell(int P, int Q); Accessing integrals; Derivative Integrals; Changes to External Potential Engines; New Operators Available; Shell Pairs; One Electron Integral Algorithm Overview. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Integrals in PSI4. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:610,Energy Efficiency,efficient,efficient,610,"﻿. Integrals in PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Integrals in PSI4. Integrals in PSI4¶. Introduction¶; PSI4 has a number of backends available to compute integrals. In order to; accomodate these options, while providing a clean interface to the programmer,; an abstraction layer is implemented within Libmints. A recent upgrade to the; primary integral engine has seen some important changes to the way this; interface layer is used; this document is designed to aid new developers as; well as those familiar with the older calling conventions to ensure that the; most efficient calling conventions are applied. The older style¶; A very simple loop that does not use permutational symmetry might look; something like this in the old scheme:; auto sieve = std::make_shared<ERISieve>(basisset, cutoff);; auto factory= std::make_shared<IntegralFactory>(basisset);; int deriv_level = 0;; bool use_shell_pairs = true;; auto eri = factory->eri(deriv_level, use_shell_pairs);; const double* buffer = eri_->buffer();; for (int P = 0; P < basisset->nshell(); ++P) {; const auto& Pshell = basisset->shell(P);; for (int Q = 0; Q < basisset->nshell(); ++Q) {; const auto& Qshell = basisset->shell(Q);; for (int R = 0; R < basisset->nshell(); ++R) {; const auto& Rshell = basisset->shell(R);; for (int S = 0; S < basisset->nshell(); ++S) {; const auto& Sshell = basisset->shell(S);; if(sieve->shell_significant(P, Q, R, S) {; eri->compute_shell(P, Q, R, S);; // results are in buffer, do something with them..; }; }; }; }; }. An integral factory is used, which can then produce integral object for various; operator types and derivative levels. A sieve is also constructed; this allows; a quick determination of whether an integral shell quartet will be significant; in magnitude or not, potentially saving a lot of work. This simple scheme is; clean and easy to understand, and is still supported in the latest version of; PSI4 with only a small change to the sieve syntax",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:7503,Energy Efficiency,efficient,efficient,7503,"object’s update_density member, passing it a SharedMatrix holding the; current density (remember that it changes during each iteration of the SCF) and; the product will be considered during screening. If only coulomb-like terms; are to be computed, the needs_exchange argument to the integral object; constructor should be set to false, otherwise it should be true to correcly; account for products of the density and integrals that contribute to; exchange-like terms. Shell blocking¶; Each underlying integral engine knows whether it will use blocks, and will set up; the metadata automatically. Instead of looping over individual shells, the; user should loop over blocks supplied by the integral object; these blocks will; be just a single shell quartet combination for the case where blocking is not; used. It is simple to loop over pairs within each block using C++11 syntax, as; demonstrated in the code snippet above. Only shell pairs with significant; overlap are included in the shell block information, making this an efficient; way to loop over non-negligible terms. Permutational symmetry¶; The pairs within each block are optimized for efficiency. First, they are; screened during the integral object’s creation to ensure that only terms with; appreciable overlap are stored. Second, only P,Q combinations that are; permutationally unique are stored, ordered with the higher angular momentum; first. Therefore care must be taken to ensure that the missing permutations; are correctly accounted for when processing the integrals within the loop. See; the DirectJK code in libfock for an example of using this scheme for a Fock; matrix build. Using bra-ket symmetry¶; In cases where there is no batching performed, bra-ket symmetry can be; trivially enforced by ensuring that one of the block indices is greater than or; equal to the other. When batching is used, the situation is trickier; some ket; batches may contain a mixture of integrals that are bra-ket unique and those; that are no",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:9247,Energy Efficiency,efficient,efficient,9247,"e there is no batching performed, bra-ket symmetry can be; trivially enforced by ensuring that one of the block indices is greater than or; equal to the other. When batching is used, the situation is trickier; some ket; batches may contain a mixture of integrals that are bra-ket unique and those; that are not. To handle this we must do a coarse check at the top of the loop; to see if any integrals in the batch are needed, which is implemented by; asking the integral engine where to start looping in the ket via the call to; eri->first_RS_shell_block(PQpair_idx). This is followed by a more fine; grained check within the loops to filter individual integrals in the case where; bra and ket have the same angular momentum and there’s a possibility of a; handful of integrals coming from the ket that are redundant. Note that the bra; is not batched in any of our engines currently: only the ket is. For this; reason, density fitting integrals should be written as (A0|PQ) rather than; (PQ|A0) where possible, because we want the ket to contain more functions than; the bra for efficient blocking. Instantiating integral objects¶; With sieving being introduced in the new integral objects, the cost of their; construction has increased. Although significantly cheaper than computing; integrals themselves, construction of integral objects can be non-negligible,; especially if many threads are used. For example, this pattern can be found in; old versions of the code:; std::vector<std::shared_ptr<TwoBodyAOInt>> ints;; ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));; for (int thread = 1; thread < num_threads; thread++) {; ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));; }. This builds many objects and the cost can add up. With the new scheme,; integral objects are forced to implement a clone() member that can be used as; follows:; std::vector<std::shared_ptr<TwoBodyAOInt>> ints;; ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));; for (int thread ",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:10612,Energy Efficiency,reduce,reduced,10612,",; especially if many threads are used. For example, this pattern can be found in; old versions of the code:; std::vector<std::shared_ptr<TwoBodyAOInt>> ints;; ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));; for (int thread = 1; thread < num_threads; thread++) {; ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));; }. This builds many objects and the cost can add up. With the new scheme,; integral objects are forced to implement a clone() member that can be used as; follows:; std::vector<std::shared_ptr<TwoBodyAOInt>> ints;; ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));; for (int thread = 1; thread < num_threads; thread++) {; ints.push_back(std::shared_ptr<TwoBodyAOInt>(ints[0]->clone()));; }. This method only incurs the cost of creating a single integral object, and; performs much cheaper cloning operations to create the other objects for each; thread. Moreover, if integral objects are created only in the initialization; of each code that uses them, and stored persistently, the cost of integral; object creation is further reduced. One Electron Integrals in PSI4¶; After version 1.5, we started transitioning the one electron integral code over to; use Libint2 instead of the old handwritten Obara-Saika code. There are a; number of reasons motivating this switch. For methods requiring; potentials and fields evaluated at many external sites, such as PCM and; polarizable embedding, the efficiency of the one electron integrals can be rate; limiting. We also started to introduce integral screening, and it is important; to balance the screening used for one- and two-electron terms carefully, so this; is a good opportunity to re-evaluate the code. Finally, given the complexity; of the OS recursion code, the switch to an external library leaves a more; compact codebase to maintain. The one electron integrals which are not provided by Libint2; are now handled by a new implementation of the McMurchie-Davidson (M-D) algorithm,; leading",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:15718,Energy Efficiency,charge,charges,15718,"he other; values. The Libint2 engine instead provides all integrals, so the caller; simply needs to loop over all of the buffers provided in the appropriate order. Changes to External Potential Engines¶; Benchmarking showed that early versions of the old code spent a non-negligible; amount of time performing the Cartesian to spherical harmonic transformation of; the integrals, which is needed for most modern basis sets. To improve; performance, we instead backtransformed the density to the Cartesian; representation (denoted “CartAO”) and computed / contracted all integrals in; this Cartesian basis, eliminating the need to transform to spherical harmonics; as the integrals are computed. This bottleneck no longer exists, so these; extra transformation steps have been removed as part of the switch to Libint2,; and the affected codes (PCM and CPPE interfaces) now compute the potential and; field integrals in the representation required by the basis set.; Also, note that the way external point charges are specified has changed.; Previously, a set of N external point charges would be specified by passing a; matrix with dimensions N rows and 4 columns – corresponding to charge, x, y, z; – to the set_charge_field() member of the potential integral class. The; same information is now passed using the more verbose; std::vector<std::pair<double, std::array<double, 3>>> type instead, to be; consistent with Libint2’s convention. New Operators Available¶; Libint2 provides a range of integrals that were previously not available in; PSI4, such as the Erfc attenuated nuclear potential integrals needed for; Ewald methods. If new integrals are added to Libint2 but are not yet; interfaced to PSI4, please open an issue on the PSI4 GitHub page to; alert the developers, who will be able to add the appropriate code.; Available integrals classes and parameters currently documented at; Libint2 C++11 Interface Wiki. Shell Pairs¶; To ensure consistency between one- and two-electron terms when s",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:15792,Energy Efficiency,charge,charges,15792,"iate order. Changes to External Potential Engines¶; Benchmarking showed that early versions of the old code spent a non-negligible; amount of time performing the Cartesian to spherical harmonic transformation of; the integrals, which is needed for most modern basis sets. To improve; performance, we instead backtransformed the density to the Cartesian; representation (denoted “CartAO”) and computed / contracted all integrals in; this Cartesian basis, eliminating the need to transform to spherical harmonics; as the integrals are computed. This bottleneck no longer exists, so these; extra transformation steps have been removed as part of the switch to Libint2,; and the affected codes (PCM and CPPE interfaces) now compute the potential and; field integrals in the representation required by the basis set.; Also, note that the way external point charges are specified has changed.; Previously, a set of N external point charges would be specified by passing a; matrix with dimensions N rows and 4 columns – corresponding to charge, x, y, z; – to the set_charge_field() member of the potential integral class. The; same information is now passed using the more verbose; std::vector<std::pair<double, std::array<double, 3>>> type instead, to be; consistent with Libint2’s convention. New Operators Available¶; Libint2 provides a range of integrals that were previously not available in; PSI4, such as the Erfc attenuated nuclear potential integrals needed for; Ewald methods. If new integrals are added to Libint2 but are not yet; interfaced to PSI4, please open an issue on the PSI4 GitHub page to; alert the developers, who will be able to add the appropriate code.; Available integrals classes and parameters currently documented at; Libint2 C++11 Interface Wiki. Shell Pairs¶; To ensure consistency between one- and two-electron terms when screening, and; for efficiency reasons, shell pair lists should be used to iterate over pairs; of Gaussian shells. These lists contain integer pair numb",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:15896,Energy Efficiency,charge,charge,15896,"iate order. Changes to External Potential Engines¶; Benchmarking showed that early versions of the old code spent a non-negligible; amount of time performing the Cartesian to spherical harmonic transformation of; the integrals, which is needed for most modern basis sets. To improve; performance, we instead backtransformed the density to the Cartesian; representation (denoted “CartAO”) and computed / contracted all integrals in; this Cartesian basis, eliminating the need to transform to spherical harmonics; as the integrals are computed. This bottleneck no longer exists, so these; extra transformation steps have been removed as part of the switch to Libint2,; and the affected codes (PCM and CPPE interfaces) now compute the potential and; field integrals in the representation required by the basis set.; Also, note that the way external point charges are specified has changed.; Previously, a set of N external point charges would be specified by passing a; matrix with dimensions N rows and 4 columns – corresponding to charge, x, y, z; – to the set_charge_field() member of the potential integral class. The; same information is now passed using the more verbose; std::vector<std::pair<double, std::array<double, 3>>> type instead, to be; consistent with Libint2’s convention. New Operators Available¶; Libint2 provides a range of integrals that were previously not available in; PSI4, such as the Erfc attenuated nuclear potential integrals needed for; Ewald methods. If new integrals are added to Libint2 but are not yet; interfaced to PSI4, please open an issue on the PSI4 GitHub page to; alert the developers, who will be able to add the appropriate code.; Available integrals classes and parameters currently documented at; Libint2 C++11 Interface Wiki. Shell Pairs¶; To ensure consistency between one- and two-electron terms when screening, and; for efficiency reasons, shell pair lists should be used to iterate over pairs; of Gaussian shells. These lists contain integer pair numb",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:18063,Energy Efficiency,charge,charge,18063," shell_pairs = Vint->shellpairs();; size_t n_pairs = shell_pairs.size();; for (size_t p = 0; p < n_pairs; ++p) {; auto P = shell_pairs[p].first;; auto Q = shell_pairs[p].second;; // do something with shells P and Q; }. Note that list considers all P,Q pairs if the two basis sets differ, but only; P>=Q if the basis sets are the same; the caller should account for this; restricted summation in the latter case. One Electron Integral Algorithm Overview¶; The following table summarizes which implementation is used; for each type of one electron integral in PSI4. Algorithms used for One Electron Integrals¶. Integral; Class; Implementation; Comment. Three-Center Overlap; ThreeCenterOverlapInt; Libint2; using libint2::Operator::delta for 4-center integrals. Angular Momentum; AngularMomentumInt; M-D. Dipole; DipoleInt; Libint2; no derivatives supported. Electric Field; ElectricFieldInt; Libint2; using first derivative of libint2::Operator::nuclear. Coulomb Potential; ElectrostaticInt; Libint2; evaluated for a single origin and unity charge. Kinetic; KineticInt; Libint2. Multipole Potential; MultipolePotentialInt; M-D; arbitrary order derivative of 1/R supported. Multipole Moments; MultipoleInt; M-D; arbitrary order multipoles supported, including nuclear gradients. Nabla Operator; NablaInt; Libint2; using first derivative of libint2::Operator::overlap. Overlap; OverlapInt; Libint2. Nuclear Coulomb Potential; PotentialInt; Libint2; assumes nuclear centers/charges as the potential. PCM Potential; PCMPotentialInt; Libint2; parallelized over charge points. Quadrupole; QuadrupoleInt; Libint2. Traceless Quadrupole; TracelessQuadrupoleInt; Libint2. Relativistic Potential; RelPotentialInt; Libint2. table of contents. Integrals in PSI4; Introduction; The older style; The new syntax; Sieving; Buffer address; Density Screening; Shell blocking; Permutational symmetry; Using bra-ket symmetry; Instantiating integral objects. One Electron Integrals in PSI4; Calling compute_shell(int P, int",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:18493,Energy Efficiency,charge,charges,18493,"r case. One Electron Integral Algorithm Overview¶; The following table summarizes which implementation is used; for each type of one electron integral in PSI4. Algorithms used for One Electron Integrals¶. Integral; Class; Implementation; Comment. Three-Center Overlap; ThreeCenterOverlapInt; Libint2; using libint2::Operator::delta for 4-center integrals. Angular Momentum; AngularMomentumInt; M-D. Dipole; DipoleInt; Libint2; no derivatives supported. Electric Field; ElectricFieldInt; Libint2; using first derivative of libint2::Operator::nuclear. Coulomb Potential; ElectrostaticInt; Libint2; evaluated for a single origin and unity charge. Kinetic; KineticInt; Libint2. Multipole Potential; MultipolePotentialInt; M-D; arbitrary order derivative of 1/R supported. Multipole Moments; MultipoleInt; M-D; arbitrary order multipoles supported, including nuclear gradients. Nabla Operator; NablaInt; Libint2; using first derivative of libint2::Operator::overlap. Overlap; OverlapInt; Libint2. Nuclear Coulomb Potential; PotentialInt; Libint2; assumes nuclear centers/charges as the potential. PCM Potential; PCMPotentialInt; Libint2; parallelized over charge points. Quadrupole; QuadrupoleInt; Libint2. Traceless Quadrupole; TracelessQuadrupoleInt; Libint2. Relativistic Potential; RelPotentialInt; Libint2. table of contents. Integrals in PSI4; Introduction; The older style; The new syntax; Sieving; Buffer address; Density Screening; Shell blocking; Permutational symmetry; Using bra-ket symmetry; Instantiating integral objects. One Electron Integrals in PSI4; Calling compute_shell(int P, int Q); Accessing integrals; Derivative Integrals; Changes to External Potential Engines; New Operators Available; Shell Pairs; One Electron Integral Algorithm Overview. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Integrals in PSI4. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:18578,Energy Efficiency,charge,charge,18578,"r case. One Electron Integral Algorithm Overview¶; The following table summarizes which implementation is used; for each type of one electron integral in PSI4. Algorithms used for One Electron Integrals¶. Integral; Class; Implementation; Comment. Three-Center Overlap; ThreeCenterOverlapInt; Libint2; using libint2::Operator::delta for 4-center integrals. Angular Momentum; AngularMomentumInt; M-D. Dipole; DipoleInt; Libint2; no derivatives supported. Electric Field; ElectricFieldInt; Libint2; using first derivative of libint2::Operator::nuclear. Coulomb Potential; ElectrostaticInt; Libint2; evaluated for a single origin and unity charge. Kinetic; KineticInt; Libint2. Multipole Potential; MultipolePotentialInt; M-D; arbitrary order derivative of 1/R supported. Multipole Moments; MultipoleInt; M-D; arbitrary order multipoles supported, including nuclear gradients. Nabla Operator; NablaInt; Libint2; using first derivative of libint2::Operator::overlap. Overlap; OverlapInt; Libint2. Nuclear Coulomb Potential; PotentialInt; Libint2; assumes nuclear centers/charges as the potential. PCM Potential; PCMPotentialInt; Libint2; parallelized over charge points. Quadrupole; QuadrupoleInt; Libint2. Traceless Quadrupole; TracelessQuadrupoleInt; Libint2. Relativistic Potential; RelPotentialInt; Libint2. table of contents. Integrals in PSI4; Introduction; The older style; The new syntax; Sieving; Buffer address; Density Screening; Shell blocking; Permutational symmetry; Using bra-ket symmetry; Instantiating integral objects. One Electron Integrals in PSI4; Calling compute_shell(int P, int Q); Accessing integrals; Derivative Integrals; Changes to External Potential Engines; New Operators Available; Shell Pairs; One Electron Integral Algorithm Overview. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Integrals in PSI4. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:269,Integrability,interface,interface,269,"﻿. Integrals in PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Integrals in PSI4. Integrals in PSI4¶. Introduction¶; PSI4 has a number of backends available to compute integrals. In order to; accomodate these options, while providing a clean interface to the programmer,; an abstraction layer is implemented within Libmints. A recent upgrade to the; primary integral engine has seen some important changes to the way this; interface layer is used; this document is designed to aid new developers as; well as those familiar with the older calling conventions to ensure that the; most efficient calling conventions are applied. The older style¶; A very simple loop that does not use permutational symmetry might look; something like this in the old scheme:; auto sieve = std::make_shared<ERISieve>(basisset, cutoff);; auto factory= std::make_shared<IntegralFactory>(basisset);; int deriv_level = 0;; bool use_shell_pairs = true;; auto eri = factory->eri(deriv_level, use_shell_pairs);; const double* buffer = eri_->buffer();; for (int P = 0; P < basisset->nshell(); ++P) {; const auto& Pshell = basisset->shell(P);; for (int Q = 0; Q < basisset->nshell(); ++Q) {; const auto& Qshell = basisset->shell(Q);; for (int R = 0; R < basisset->nshell(); ++R) {; const auto& Rshell = basisset->shell(R);; for (int S = 0; S < basisset->nshell(); ++S) {; const auto& Sshell = basisset->shell(S);; if(sieve->shell_significant(P, Q, R, S) {; eri->compute_shell(P, Q, R, S);; // results are in buffer, do something with them..; }; }; }; }; }. An integral factory is used, which can then produce integral object for various; operator types and derivative levels. A sieve is also constructed; this allows; a quick determination of whether an integral shell quartet will be significant; in magnitude or not, potentially saving a lot of work. This simple scheme is; clean and easy to understand, and is still supported in the latest version of; PSI4 with only a small change to the sieve syntax",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:450,Integrability,interface,interface,450,"﻿. Integrals in PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Integrals in PSI4. Integrals in PSI4¶. Introduction¶; PSI4 has a number of backends available to compute integrals. In order to; accomodate these options, while providing a clean interface to the programmer,; an abstraction layer is implemented within Libmints. A recent upgrade to the; primary integral engine has seen some important changes to the way this; interface layer is used; this document is designed to aid new developers as; well as those familiar with the older calling conventions to ensure that the; most efficient calling conventions are applied. The older style¶; A very simple loop that does not use permutational symmetry might look; something like this in the old scheme:; auto sieve = std::make_shared<ERISieve>(basisset, cutoff);; auto factory= std::make_shared<IntegralFactory>(basisset);; int deriv_level = 0;; bool use_shell_pairs = true;; auto eri = factory->eri(deriv_level, use_shell_pairs);; const double* buffer = eri_->buffer();; for (int P = 0; P < basisset->nshell(); ++P) {; const auto& Pshell = basisset->shell(P);; for (int Q = 0; Q < basisset->nshell(); ++Q) {; const auto& Qshell = basisset->shell(Q);; for (int R = 0; R < basisset->nshell(); ++R) {; const auto& Rshell = basisset->shell(R);; for (int S = 0; S < basisset->nshell(); ++S) {; const auto& Sshell = basisset->shell(S);; if(sieve->shell_significant(P, Q, R, S) {; eri->compute_shell(P, Q, R, S);; // results are in buffer, do something with them..; }; }; }; }; }. An integral factory is used, which can then produce integral object for various; operator types and derivative levels. A sieve is also constructed; this allows; a quick determination of whether an integral shell quartet will be significant; in magnitude or not, potentially saving a lot of work. This simple scheme is; clean and easy to understand, and is still supported in the latest version of; PSI4 with only a small change to the sieve syntax",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:2100,Integrability,interface,interfaced,2100,"r (int Q = 0; Q < basisset->nshell(); ++Q) {; const auto& Qshell = basisset->shell(Q);; for (int R = 0; R < basisset->nshell(); ++R) {; const auto& Rshell = basisset->shell(R);; for (int S = 0; S < basisset->nshell(); ++S) {; const auto& Sshell = basisset->shell(S);; if(sieve->shell_significant(P, Q, R, S) {; eri->compute_shell(P, Q, R, S);; // results are in buffer, do something with them..; }; }; }; }; }. An integral factory is used, which can then produce integral object for various; operator types and derivative levels. A sieve is also constructed; this allows; a quick determination of whether an integral shell quartet will be significant; in magnitude or not, potentially saving a lot of work. This simple scheme is; clean and easy to understand, and is still supported in the latest version of; PSI4 with only a small change to the sieve syntax and handling of buffer; addresses, noted below. The new syntax¶; The newer integral engines being interfaced to PSI4 may or may not require; a group of similar integrals to be computed together in a block using; vectorized instructions. To accomodate this possibility, a new syntax has been; introduced in Libmints:; auto blocksPQ = ints[0]->get_blocks12();; auto blocksRS = ints[0]->get_blocks34();. auto factory= std::make_shared<IntegralFactory>(basisset);; int deriv_level = 0;; bool use_shell_pairs = true;; bool needs_exchange = true;; auto eri = factory->eri(deriv_level, use_shell_pairs, needs_exchange);; const auto &buffers = eri->buffers();. eri->update_density(D);; bool use_batching = eri->maximum_block_size() > 1;. // loop over all the blocks of (P>=Q|; for (size_t blockPQ_idx = 0; blockPQ_idx < blocksPQ.size(); blockPQ_idx++) {; const auto& blockPQ = blocksPQ[blockPQ_idx];; // loop over all the blocks of |R>=S); size_t start = eri->first_RS_shell_block(blockPQ_idx);; for (int blockRS_idx = loop_start; blockRS_idx < blocksRS.size(); ++blockRS_idx) {; const auto& blockRS = blocksRS[blockRS_idx];. if (!eri->shell_block_si",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:6302,Integrability,contract,contracted,6302," may change with; each call to compute integrals. The integral engine provides a; std::vector<const double*> containing the pointers to the start of each; “chunk” of integrals. For first derivatives there are 12 such “chunks”, which; are ordered Px,Py,Pz,Qx,Qy,Qz,Rx,Ry,Rz,Sx,Sy,Sz, where the Px refers to the x; derivative with respect to the basis functions in shell P. Note that all; integral derivatives are provided by the new integral code, unlike the previous; version where only 9 of 12 were provided and the user was responsible for using; translation invariance relationships to fill in the rest. The addresses for; each chunk are updated in the vector after each call to compute integrals, so; the user should keep a const reference to that object, and query that for the; address of interest. Density Screening¶; The old code looked only at the integral to determine whether terms can be; avoided a priori. However, if the integral is to be contracted with a; density or a density-like quantity, the screening can be performed on the; product, which yields more sparsity. To enable this, simply call the integral; object’s update_density member, passing it a SharedMatrix holding the; current density (remember that it changes during each iteration of the SCF) and; the product will be considered during screening. If only coulomb-like terms; are to be computed, the needs_exchange argument to the integral object; constructor should be set to false, otherwise it should be true to correcly; account for products of the density and integrals that contribute to; exchange-like terms. Shell blocking¶; Each underlying integral engine knows whether it will use blocks, and will set up; the metadata automatically. Instead of looping over individual shells, the; user should loop over blocks supplied by the integral object; these blocks will; be just a single shell quartet combination for the case where blocking is not; used. It is simple to loop over pairs within each block using C++11 sy",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:11798,Integrability,interface,interface,11798,"aika code. There are a; number of reasons motivating this switch. For methods requiring; potentials and fields evaluated at many external sites, such as PCM and; polarizable embedding, the efficiency of the one electron integrals can be rate; limiting. We also started to introduce integral screening, and it is important; to balance the screening used for one- and two-electron terms carefully, so this; is a good opportunity to re-evaluate the code. Finally, given the complexity; of the OS recursion code, the switch to an external library leaves a more; compact codebase to maintain. The one electron integrals which are not provided by Libint2; are now handled by a new implementation of the McMurchie-Davidson (M-D) algorithm,; leading to removal of the OS code in version 1.6. An overview of the one electron integrals; is shown in table Algorithms used for One Electron Integrals, together with the implementation they use.; The tips below serve as a guide to what changed,; why it changed, and how to interface with PSI4’s one-electron integral; machinery now. Calling compute_shell(int P, int Q)¶; The hand-implemented OS recursion code also took care of the Cartesian->pure; transformation (if required by the basis set). The mechanism for handling this; was to provide a public facing compute_shell(int P, int Q) method for the; caller; this then looked up the appropriate GaussianShell objects that were; passed into the corresponding (private) compute_pair(GaussianShell &s1,; GaussianShell &s2) function that computed the integrals and transformed them; to the spherical harmonic basis, if needed. The switch to Libint2 integrals; preserves this mechanism, but the compute_shell(int P, int Q) simply looks; up the appropriate Libint2-compatible shells and hands them off to the; re-written, private compute_pair() routines, which call Libint2 directly.; Therefore, any calls to shell-pair level integral computations should look the; same as before the introduction of Libint2, however",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:12617,Integrability,rout,routines,12617,"ng to removal of the OS code in version 1.6. An overview of the one electron integrals; is shown in table Algorithms used for One Electron Integrals, together with the implementation they use.; The tips below serve as a guide to what changed,; why it changed, and how to interface with PSI4’s one-electron integral; machinery now. Calling compute_shell(int P, int Q)¶; The hand-implemented OS recursion code also took care of the Cartesian->pure; transformation (if required by the basis set). The mechanism for handling this; was to provide a public facing compute_shell(int P, int Q) method for the; caller; this then looked up the appropriate GaussianShell objects that were; passed into the corresponding (private) compute_pair(GaussianShell &s1,; GaussianShell &s2) function that computed the integrals and transformed them; to the spherical harmonic basis, if needed. The switch to Libint2 integrals; preserves this mechanism, but the compute_shell(int P, int Q) simply looks; up the appropriate Libint2-compatible shells and hands them off to the; re-written, private compute_pair() routines, which call Libint2 directly.; Therefore, any calls to shell-pair level integral computations should look the; same as before the introduction of Libint2, however access to the integrals has; changed, as described below. Accessing integrals¶; Before the Libint2 transition, one electron integrals were computed in a flat; array, internally called buffer_, which was accessed through the integral; object’s buffer() method. For integrals with multiple operators, e.g.,; dipole operators that have three distinct components, the buffer was simply; elongated by the appropriate amount and the caller was responsible for striding; through each resulting batch correctly. The Libint2 engines instead return a; list of pointers into each operator’s batch of integrals, the ordering of which; are detailed on the Libint2 wiki. For this reason, the call to buffer(); that returns a single buffer must be replac",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:14048,Integrability,depend,depends,14048,"tiple operators, e.g.,; dipole operators that have three distinct components, the buffer was simply; elongated by the appropriate amount and the caller was responsible for striding; through each resulting batch correctly. The Libint2 engines instead return a; list of pointers into each operator’s batch of integrals, the ordering of which; are detailed on the Libint2 wiki. For this reason, the call to buffer(); that returns a single buffer must be replaced with a call to buffer() to; get a list of pointers; we recommend that be assigned the type const auto; &. For simple integrals, such as overlap or kinetic, only the buffer; corresponding to the zeroth element of this array contains integrals. Derivative Integrals¶; The old one electron integral code used translational invariance relations to; minimze the number of integrals to be computed, leaving the caller with some; bookkeeping to do to compute all terms. For example, consider an overlap; integral: its value depends only on the relative separation of the two centers; and not their absolute positions in space. Therefore, the derivative with; respect to center A is the negative of the same derivative with respect to; center B, so one is trivially gleaned from the other. Extending this to second; derivatives, the same principle leads to the fact that double derivatives with; respect to center A are equal to double derivatives with respect to center B,; which are also equal to the negative of the mixed double derivatives with; respect to both center A and B. The old code only provided the double; derivative with respect to center A, leaving the caller to determine the other; values. The Libint2 engine instead provides all integrals, so the caller; simply needs to loop over all of the buffers provided in the appropriate order. Changes to External Potential Engines¶; Benchmarking showed that early versions of the old code spent a non-negligible; amount of time performing the Cartesian to spherical harmonic transformati",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:15269,Integrability,contract,contracted,15269,"one is trivially gleaned from the other. Extending this to second; derivatives, the same principle leads to the fact that double derivatives with; respect to center A are equal to double derivatives with respect to center B,; which are also equal to the negative of the mixed double derivatives with; respect to both center A and B. The old code only provided the double; derivative with respect to center A, leaving the caller to determine the other; values. The Libint2 engine instead provides all integrals, so the caller; simply needs to loop over all of the buffers provided in the appropriate order. Changes to External Potential Engines¶; Benchmarking showed that early versions of the old code spent a non-negligible; amount of time performing the Cartesian to spherical harmonic transformation of; the integrals, which is needed for most modern basis sets. To improve; performance, we instead backtransformed the density to the Cartesian; representation (denoted “CartAO”) and computed / contracted all integrals in; this Cartesian basis, eliminating the need to transform to spherical harmonics; as the integrals are computed. This bottleneck no longer exists, so these; extra transformation steps have been removed as part of the switch to Libint2,; and the affected codes (PCM and CPPE interfaces) now compute the potential and; field integrals in the representation required by the basis set.; Also, note that the way external point charges are specified has changed.; Previously, a set of N external point charges would be specified by passing a; matrix with dimensions N rows and 4 columns – corresponding to charge, x, y, z; – to the set_charge_field() member of the potential integral class. The; same information is now passed using the more verbose; std::vector<std::pair<double, std::array<double, 3>>> type instead, to be; consistent with Libint2’s convention. New Operators Available¶; Libint2 provides a range of integrals that were previously not available in; PSI4, such as th",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:15570,Integrability,interface,interfaces,15570,"mixed double derivatives with; respect to both center A and B. The old code only provided the double; derivative with respect to center A, leaving the caller to determine the other; values. The Libint2 engine instead provides all integrals, so the caller; simply needs to loop over all of the buffers provided in the appropriate order. Changes to External Potential Engines¶; Benchmarking showed that early versions of the old code spent a non-negligible; amount of time performing the Cartesian to spherical harmonic transformation of; the integrals, which is needed for most modern basis sets. To improve; performance, we instead backtransformed the density to the Cartesian; representation (denoted “CartAO”) and computed / contracted all integrals in; this Cartesian basis, eliminating the need to transform to spherical harmonics; as the integrals are computed. This bottleneck no longer exists, so these; extra transformation steps have been removed as part of the switch to Libint2,; and the affected codes (PCM and CPPE interfaces) now compute the potential and; field integrals in the representation required by the basis set.; Also, note that the way external point charges are specified has changed.; Previously, a set of N external point charges would be specified by passing a; matrix with dimensions N rows and 4 columns – corresponding to charge, x, y, z; – to the set_charge_field() member of the potential integral class. The; same information is now passed using the more verbose; std::vector<std::pair<double, std::array<double, 3>>> type instead, to be; consistent with Libint2’s convention. New Operators Available¶; Libint2 provides a range of integrals that were previously not available in; PSI4, such as the Erfc attenuated nuclear potential integrals needed for; Ewald methods. If new integrals are added to Libint2 but are not yet; interfaced to PSI4, please open an issue on the PSI4 GitHub page to; alert the developers, who will be able to add the appropriate code.; Avai",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:16401,Integrability,interface,interfaced,16401,", so these; extra transformation steps have been removed as part of the switch to Libint2,; and the affected codes (PCM and CPPE interfaces) now compute the potential and; field integrals in the representation required by the basis set.; Also, note that the way external point charges are specified has changed.; Previously, a set of N external point charges would be specified by passing a; matrix with dimensions N rows and 4 columns – corresponding to charge, x, y, z; – to the set_charge_field() member of the potential integral class. The; same information is now passed using the more verbose; std::vector<std::pair<double, std::array<double, 3>>> type instead, to be; consistent with Libint2’s convention. New Operators Available¶; Libint2 provides a range of integrals that were previously not available in; PSI4, such as the Erfc attenuated nuclear potential integrals needed for; Ewald methods. If new integrals are added to Libint2 but are not yet; interfaced to PSI4, please open an issue on the PSI4 GitHub page to; alert the developers, who will be able to add the appropriate code.; Available integrals classes and parameters currently documented at; Libint2 C++11 Interface Wiki. Shell Pairs¶; To ensure consistency between one- and two-electron terms when screening, and; for efficiency reasons, shell pair lists should be used to iterate over pairs; of Gaussian shells. These lists contain integer pair numbers, corresponding to; the pairs of shells that have sufficient overlap to survive the screening; process. Iterating over these lists is simple:; const auto& shell_pairs = Vint->shellpairs();; size_t n_pairs = shell_pairs.size();; for (size_t p = 0; p < n_pairs; ++p) {; auto P = shell_pairs[p].first;; auto Q = shell_pairs[p].second;; // do something with shells P and Q; }. Note that list considers all P,Q pairs if the two basis sets differ, but only; P>=Q if the basis sets are the same; the caller should account for this; restricted summation in the latter case. One El",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:6378,Performance,perform,performed,6378," may change with; each call to compute integrals. The integral engine provides a; std::vector<const double*> containing the pointers to the start of each; “chunk” of integrals. For first derivatives there are 12 such “chunks”, which; are ordered Px,Py,Pz,Qx,Qy,Qz,Rx,Ry,Rz,Sx,Sy,Sz, where the Px refers to the x; derivative with respect to the basis functions in shell P. Note that all; integral derivatives are provided by the new integral code, unlike the previous; version where only 9 of 12 were provided and the user was responsible for using; translation invariance relationships to fill in the rest. The addresses for; each chunk are updated in the vector after each call to compute integrals, so; the user should keep a const reference to that object, and query that for the; address of interest. Density Screening¶; The old code looked only at the integral to determine whether terms can be; avoided a priori. However, if the integral is to be contracted with a; density or a density-like quantity, the screening can be performed on the; product, which yields more sparsity. To enable this, simply call the integral; object’s update_density member, passing it a SharedMatrix holding the; current density (remember that it changes during each iteration of the SCF) and; the product will be considered during screening. If only coulomb-like terms; are to be computed, the needs_exchange argument to the integral object; constructor should be set to false, otherwise it should be true to correcly; account for products of the density and integrals that contribute to; exchange-like terms. Shell blocking¶; Each underlying integral engine knows whether it will use blocks, and will set up; the metadata automatically. Instead of looping over individual shells, the; user should loop over blocks supplied by the integral object; these blocks will; be just a single shell quartet combination for the case where blocking is not; used. It is simple to loop over pairs within each block using C++11 sy",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:7610,Performance,optimiz,optimized,7610,"g each iteration of the SCF) and; the product will be considered during screening. If only coulomb-like terms; are to be computed, the needs_exchange argument to the integral object; constructor should be set to false, otherwise it should be true to correcly; account for products of the density and integrals that contribute to; exchange-like terms. Shell blocking¶; Each underlying integral engine knows whether it will use blocks, and will set up; the metadata automatically. Instead of looping over individual shells, the; user should loop over blocks supplied by the integral object; these blocks will; be just a single shell quartet combination for the case where blocking is not; used. It is simple to loop over pairs within each block using C++11 syntax, as; demonstrated in the code snippet above. Only shell pairs with significant; overlap are included in the shell block information, making this an efficient; way to loop over non-negligible terms. Permutational symmetry¶; The pairs within each block are optimized for efficiency. First, they are; screened during the integral object’s creation to ensure that only terms with; appreciable overlap are stored. Second, only P,Q combinations that are; permutationally unique are stored, ordered with the higher angular momentum; first. Therefore care must be taken to ensure that the missing permutations; are correctly accounted for when processing the integrals within the loop. See; the DirectJK code in libfock for an example of using this scheme for a Fock; matrix build. Using bra-ket symmetry¶; In cases where there is no batching performed, bra-ket symmetry can be; trivially enforced by ensuring that one of the block indices is greater than or; equal to the other. When batching is used, the situation is trickier; some ket; batches may contain a mixture of integrals that are bra-ket unique and those; that are not. To handle this we must do a coarse check at the top of the loop; to see if any integrals in the batch are needed, w",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:8190,Performance,perform,performed,8190,"rtet combination for the case where blocking is not; used. It is simple to loop over pairs within each block using C++11 syntax, as; demonstrated in the code snippet above. Only shell pairs with significant; overlap are included in the shell block information, making this an efficient; way to loop over non-negligible terms. Permutational symmetry¶; The pairs within each block are optimized for efficiency. First, they are; screened during the integral object’s creation to ensure that only terms with; appreciable overlap are stored. Second, only P,Q combinations that are; permutationally unique are stored, ordered with the higher angular momentum; first. Therefore care must be taken to ensure that the missing permutations; are correctly accounted for when processing the integrals within the loop. See; the DirectJK code in libfock for an example of using this scheme for a Fock; matrix build. Using bra-ket symmetry¶; In cases where there is no batching performed, bra-ket symmetry can be; trivially enforced by ensuring that one of the block indices is greater than or; equal to the other. When batching is used, the situation is trickier; some ket; batches may contain a mixture of integrals that are bra-ket unique and those; that are not. To handle this we must do a coarse check at the top of the loop; to see if any integrals in the batch are needed, which is implemented by; asking the integral engine where to start looping in the ket via the call to; eri->first_RS_shell_block(PQpair_idx). This is followed by a more fine; grained check within the loops to filter individual integrals in the case where; bra and ket have the same angular momentum and there’s a possibility of a; handful of integrals coming from the ket that are redundant. Note that the bra; is not batched in any of our engines currently: only the ket is. For this; reason, density fitting integrals should be written as (A0|PQ) rather than; (PQ|A0) where possible, because we want the ket to contain more function",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:10352,Performance,perform,performs,10352,"s, the cost of their; construction has increased. Although significantly cheaper than computing; integrals themselves, construction of integral objects can be non-negligible,; especially if many threads are used. For example, this pattern can be found in; old versions of the code:; std::vector<std::shared_ptr<TwoBodyAOInt>> ints;; ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));; for (int thread = 1; thread < num_threads; thread++) {; ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));; }. This builds many objects and the cost can add up. With the new scheme,; integral objects are forced to implement a clone() member that can be used as; follows:; std::vector<std::shared_ptr<TwoBodyAOInt>> ints;; ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));; for (int thread = 1; thread < num_threads; thread++) {; ints.push_back(std::shared_ptr<TwoBodyAOInt>(ints[0]->clone()));; }. This method only incurs the cost of creating a single integral object, and; performs much cheaper cloning operations to create the other objects for each; thread. Moreover, if integral objects are created only in the initialization; of each code that uses them, and stored persistently, the cost of integral; object creation is further reduced. One Electron Integrals in PSI4¶; After version 1.5, we started transitioning the one electron integral code over to; use Libint2 instead of the old handwritten Obara-Saika code. There are a; number of reasons motivating this switch. For methods requiring; potentials and fields evaluated at many external sites, such as PCM and; polarizable embedding, the efficiency of the one electron integrals can be rate; limiting. We also started to introduce integral screening, and it is important; to balance the screening used for one- and two-electron terms carefully, so this; is a good opportunity to re-evaluate the code. Finally, given the complexity; of the OS recursion code, the switch to an external library leaves a more; compact cod",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:15013,Performance,perform,performing,15013,"consider an overlap; integral: its value depends only on the relative separation of the two centers; and not their absolute positions in space. Therefore, the derivative with; respect to center A is the negative of the same derivative with respect to; center B, so one is trivially gleaned from the other. Extending this to second; derivatives, the same principle leads to the fact that double derivatives with; respect to center A are equal to double derivatives with respect to center B,; which are also equal to the negative of the mixed double derivatives with; respect to both center A and B. The old code only provided the double; derivative with respect to center A, leaving the caller to determine the other; values. The Libint2 engine instead provides all integrals, so the caller; simply needs to loop over all of the buffers provided in the appropriate order. Changes to External Potential Engines¶; Benchmarking showed that early versions of the old code spent a non-negligible; amount of time performing the Cartesian to spherical harmonic transformation of; the integrals, which is needed for most modern basis sets. To improve; performance, we instead backtransformed the density to the Cartesian; representation (denoted “CartAO”) and computed / contracted all integrals in; this Cartesian basis, eliminating the need to transform to spherical harmonics; as the integrals are computed. This bottleneck no longer exists, so these; extra transformation steps have been removed as part of the switch to Libint2,; and the affected codes (PCM and CPPE interfaces) now compute the potential and; field integrals in the representation required by the basis set.; Also, note that the way external point charges are specified has changed.; Previously, a set of N external point charges would be specified by passing a; matrix with dimensions N rows and 4 columns – corresponding to charge, x, y, z; – to the set_charge_field() member of the potential integral class. The; same information is n",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:15150,Performance,perform,performance,15150,"one is trivially gleaned from the other. Extending this to second; derivatives, the same principle leads to the fact that double derivatives with; respect to center A are equal to double derivatives with respect to center B,; which are also equal to the negative of the mixed double derivatives with; respect to both center A and B. The old code only provided the double; derivative with respect to center A, leaving the caller to determine the other; values. The Libint2 engine instead provides all integrals, so the caller; simply needs to loop over all of the buffers provided in the appropriate order. Changes to External Potential Engines¶; Benchmarking showed that early versions of the old code spent a non-negligible; amount of time performing the Cartesian to spherical harmonic transformation of; the integrals, which is needed for most modern basis sets. To improve; performance, we instead backtransformed the density to the Cartesian; representation (denoted “CartAO”) and computed / contracted all integrals in; this Cartesian basis, eliminating the need to transform to spherical harmonics; as the integrals are computed. This bottleneck no longer exists, so these; extra transformation steps have been removed as part of the switch to Libint2,; and the affected codes (PCM and CPPE interfaces) now compute the potential and; field integrals in the representation required by the basis set.; Also, note that the way external point charges are specified has changed.; Previously, a set of N external point charges would be specified by passing a; matrix with dimensions N rows and 4 columns – corresponding to charge, x, y, z; – to the set_charge_field() member of the potential integral class. The; same information is now passed using the more verbose; std::vector<std::pair<double, std::array<double, 3>>> type instead, to be; consistent with Libint2’s convention. New Operators Available¶; Libint2 provides a range of integrals that were previously not available in; PSI4, such as th",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:15414,Performance,bottleneck,bottleneck,15414,"mixed double derivatives with; respect to both center A and B. The old code only provided the double; derivative with respect to center A, leaving the caller to determine the other; values. The Libint2 engine instead provides all integrals, so the caller; simply needs to loop over all of the buffers provided in the appropriate order. Changes to External Potential Engines¶; Benchmarking showed that early versions of the old code spent a non-negligible; amount of time performing the Cartesian to spherical harmonic transformation of; the integrals, which is needed for most modern basis sets. To improve; performance, we instead backtransformed the density to the Cartesian; representation (denoted “CartAO”) and computed / contracted all integrals in; this Cartesian basis, eliminating the need to transform to spherical harmonics; as the integrals are computed. This bottleneck no longer exists, so these; extra transformation steps have been removed as part of the switch to Libint2,; and the affected codes (PCM and CPPE interfaces) now compute the potential and; field integrals in the representation required by the basis set.; Also, note that the way external point charges are specified has changed.; Previously, a set of N external point charges would be specified by passing a; matrix with dimensions N rows and 4 columns – corresponding to charge, x, y, z; – to the set_charge_field() member of the potential integral class. The; same information is now passed using the more verbose; std::vector<std::pair<double, std::array<double, 3>>> type instead, to be; consistent with Libint2’s convention. New Operators Available¶; Libint2 provides a range of integrals that were previously not available in; PSI4, such as the Erfc attenuated nuclear potential integrals needed for; Ewald methods. If new integrals are added to Libint2 but are not yet; interfaced to PSI4, please open an issue on the PSI4 GitHub page to; alert the developers, who will be able to add the appropriate code.; Avai",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:4006,Safety,redund,redundant,4006," eri->first_RS_shell_block(blockPQ_idx);; for (int blockRS_idx = loop_start; blockRS_idx < blocksRS.size(); ++blockRS_idx) {; const auto& blockRS = blocksRS[blockRS_idx];. if (!eri->shell_block_significant(blockPQ_idx, blockRS_idx)) continue;. eri->compute_shell_blocks(blockPQ_idx, blockRS_idx);; const auto* block_start = buffers[0];. // Loop over all of the P,Q,R,S shells within the blocks. We have P>=Q, R>=S and PQ<=RS.; for (const auto& pairPQ : blockPQ) {; const auto &P = pairPQ.first;; const auto &Q = pairPQ.second;; const auto& Pshell = basisset->shell(P);; const auto& Qshell = basisset->shell(Q);; const auto Pam = Pshell.am();; const auto Qam = Qshell.am();; for (const auto& pairRS : blockRS) {; const auto &R = pairRS.first;; const auto &S = pairRS.second;; const auto& Rshell = basisset->shell(R);; const auto& Sshell = basisset->shell(S);; const auto Ram = Rshell.am();; const auto Sam = Sshell.am();. size_t block_size = Psize * Qsize * Rsize * Ssize;; // When there are chunks of shellpairs in RS, we need to make sure; // we filter out redundant combinations.; if (use_batching && Pam == Ram && Qam == Sam && ((P > R) || (P == R && Q > S))) {; block_start += block_size;; continue;; }; const double* int_ptr = block_start;; // Query P,Q,R,S shells for metadata and loop over that quartet; // as usual, getting the integrals from the int_ptr buffer.; block_start += block_size;; }; }; }; }. Although this looks more complex, it’s essentially doing the same thing. There; are a number of differences that we’ll highlight now. Sieving¶; This is one of two breaking changes to the old style syntax. Instead of; constructing a sieve object, the integral object should be queried directly; using the exact same syntax. Requests for whether a shell is significant or a; shell block is significant are both supported. A sieve object is created if; matching basis sets are found in either the bra or the ket. For a density; fitting integral (PQ|0A) where 0 is the null basis set and A is ",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:5222,Safety,avoid,avoid,5222,"tr buffer.; block_start += block_size;; }; }; }; }. Although this looks more complex, it’s essentially doing the same thing. There; are a number of differences that we’ll highlight now. Sieving¶; This is one of two breaking changes to the old style syntax. Instead of; constructing a sieve object, the integral object should be queried directly; using the exact same syntax. Requests for whether a shell is significant or a; shell block is significant are both supported. A sieve object is created if; matching basis sets are found in either the bra or the ket. For a density; fitting integral (PQ|0A) where 0 is the null basis set and A is an auxiliary; basis set the (PQ| pair will be used to construct all of the sieving data. Buffer address¶; The old code copied integrals into a buffer owned by the integral object, whose; address remained constant and could be retrieved by the buffer() member; function. To avoid unnecessary copies, the new code instead uses the integrals; directly from the underlying integral engine’s memory, which may change with; each call to compute integrals. The integral engine provides a; std::vector<const double*> containing the pointers to the start of each; “chunk” of integrals. For first derivatives there are 12 such “chunks”, which; are ordered Px,Py,Pz,Qx,Qy,Qz,Rx,Ry,Rz,Sx,Sy,Sz, where the Px refers to the x; derivative with respect to the basis functions in shell P. Note that all; integral derivatives are provided by the new integral code, unlike the previous; version where only 9 of 12 were provided and the user was responsible for using; translation invariance relationships to fill in the rest. The addresses for; each chunk are updated in the vector after each call to compute integrals, so; the user should keep a const reference to that object, and query that for the; address of interest. Density Screening¶; The old code looked only at the integral to determine whether terms can be; avoided a priori. However, if the integral is to be contra",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:6250,Safety,avoid,avoided,6250,"unction. To avoid unnecessary copies, the new code instead uses the integrals; directly from the underlying integral engine’s memory, which may change with; each call to compute integrals. The integral engine provides a; std::vector<const double*> containing the pointers to the start of each; “chunk” of integrals. For first derivatives there are 12 such “chunks”, which; are ordered Px,Py,Pz,Qx,Qy,Qz,Rx,Ry,Rz,Sx,Sy,Sz, where the Px refers to the x; derivative with respect to the basis functions in shell P. Note that all; integral derivatives are provided by the new integral code, unlike the previous; version where only 9 of 12 were provided and the user was responsible for using; translation invariance relationships to fill in the rest. The addresses for; each chunk are updated in the vector after each call to compute integrals, so; the user should keep a const reference to that object, and query that for the; address of interest. Density Screening¶; The old code looked only at the integral to determine whether terms can be; avoided a priori. However, if the integral is to be contracted with a; density or a density-like quantity, the screening can be performed on the; product, which yields more sparsity. To enable this, simply call the integral; object’s update_density member, passing it a SharedMatrix holding the; current density (remember that it changes during each iteration of the SCF) and; the product will be considered during screening. If only coulomb-like terms; are to be computed, the needs_exchange argument to the integral object; constructor should be set to false, otherwise it should be true to correcly; account for products of the density and integrals that contribute to; exchange-like terms. Shell blocking¶; Each underlying integral engine knows whether it will use blocks, and will set up; the metadata automatically. Instead of looping over individual shells, the; user should loop over blocks supplied by the integral object; these blocks will; be just a",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:8974,Safety,redund,redundant,8974,"her angular momentum; first. Therefore care must be taken to ensure that the missing permutations; are correctly accounted for when processing the integrals within the loop. See; the DirectJK code in libfock for an example of using this scheme for a Fock; matrix build. Using bra-ket symmetry¶; In cases where there is no batching performed, bra-ket symmetry can be; trivially enforced by ensuring that one of the block indices is greater than or; equal to the other. When batching is used, the situation is trickier; some ket; batches may contain a mixture of integrals that are bra-ket unique and those; that are not. To handle this we must do a coarse check at the top of the loop; to see if any integrals in the batch are needed, which is implemented by; asking the integral engine where to start looping in the ket via the call to; eri->first_RS_shell_block(PQpair_idx). This is followed by a more fine; grained check within the loops to filter individual integrals in the case where; bra and ket have the same angular momentum and there’s a possibility of a; handful of integrals coming from the ket that are redundant. Note that the bra; is not batched in any of our engines currently: only the ket is. For this; reason, density fitting integrals should be written as (A0|PQ) rather than; (PQ|A0) where possible, because we want the ket to contain more functions than; the bra for efficient blocking. Instantiating integral objects¶; With sieving being introduced in the new integral objects, the cost of their; construction has increased. Although significantly cheaper than computing; integrals themselves, construction of integral objects can be non-negligible,; especially if many threads are used. For example, this pattern can be found in; old versions of the code:; std::vector<std::shared_ptr<TwoBodyAOInt>> ints;; ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));; for (int thread = 1; thread < num_threads; thread++) {; ints.push_back(std::shared_ptr<TwoBodyAOInt>(facto",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:12789,Security,access,access,12789,"de to what changed,; why it changed, and how to interface with PSI4’s one-electron integral; machinery now. Calling compute_shell(int P, int Q)¶; The hand-implemented OS recursion code also took care of the Cartesian->pure; transformation (if required by the basis set). The mechanism for handling this; was to provide a public facing compute_shell(int P, int Q) method for the; caller; this then looked up the appropriate GaussianShell objects that were; passed into the corresponding (private) compute_pair(GaussianShell &s1,; GaussianShell &s2) function that computed the integrals and transformed them; to the spherical harmonic basis, if needed. The switch to Libint2 integrals; preserves this mechanism, but the compute_shell(int P, int Q) simply looks; up the appropriate Libint2-compatible shells and hands them off to the; re-written, private compute_pair() routines, which call Libint2 directly.; Therefore, any calls to shell-pair level integral computations should look the; same as before the introduction of Libint2, however access to the integrals has; changed, as described below. Accessing integrals¶; Before the Libint2 transition, one electron integrals were computed in a flat; array, internally called buffer_, which was accessed through the integral; object’s buffer() method. For integrals with multiple operators, e.g.,; dipole operators that have three distinct components, the buffer was simply; elongated by the appropriate amount and the caller was responsible for striding; through each resulting batch correctly. The Libint2 engines instead return a; list of pointers into each operator’s batch of integrals, the ordering of which; are detailed on the Libint2 wiki. For this reason, the call to buffer(); that returns a single buffer must be replaced with a call to buffer() to; get a list of pointers; we recommend that be assigned the type const auto; &. For simple integrals, such as overlap or kinetic, only the buffer; corresponding to the zeroth element of this arr",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:12992,Security,access,accessed,12992,"re of the Cartesian->pure; transformation (if required by the basis set). The mechanism for handling this; was to provide a public facing compute_shell(int P, int Q) method for the; caller; this then looked up the appropriate GaussianShell objects that were; passed into the corresponding (private) compute_pair(GaussianShell &s1,; GaussianShell &s2) function that computed the integrals and transformed them; to the spherical harmonic basis, if needed. The switch to Libint2 integrals; preserves this mechanism, but the compute_shell(int P, int Q) simply looks; up the appropriate Libint2-compatible shells and hands them off to the; re-written, private compute_pair() routines, which call Libint2 directly.; Therefore, any calls to shell-pair level integral computations should look the; same as before the introduction of Libint2, however access to the integrals has; changed, as described below. Accessing integrals¶; Before the Libint2 transition, one electron integrals were computed in a flat; array, internally called buffer_, which was accessed through the integral; object’s buffer() method. For integrals with multiple operators, e.g.,; dipole operators that have three distinct components, the buffer was simply; elongated by the appropriate amount and the caller was responsible for striding; through each resulting batch correctly. The Libint2 engines instead return a; list of pointers into each operator’s batch of integrals, the ordering of which; are detailed on the Libint2 wiki. For this reason, the call to buffer(); that returns a single buffer must be replaced with a call to buffer() to; get a list of pointers; we recommend that be assigned the type const auto; &. For simple integrals, such as overlap or kinetic, only the buffer; corresponding to the zeroth element of this array contains integrals. Derivative Integrals¶; The old one electron integral code used translational invariance relations to; minimze the number of integrals to be computed, leaving the caller with",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:678,Usability,simpl,simple,678,"grals in PSI4. Integrals in PSI4¶. Introduction¶; PSI4 has a number of backends available to compute integrals. In order to; accomodate these options, while providing a clean interface to the programmer,; an abstraction layer is implemented within Libmints. A recent upgrade to the; primary integral engine has seen some important changes to the way this; interface layer is used; this document is designed to aid new developers as; well as those familiar with the older calling conventions to ensure that the; most efficient calling conventions are applied. The older style¶; A very simple loop that does not use permutational symmetry might look; something like this in the old scheme:; auto sieve = std::make_shared<ERISieve>(basisset, cutoff);; auto factory= std::make_shared<IntegralFactory>(basisset);; int deriv_level = 0;; bool use_shell_pairs = true;; auto eri = factory->eri(deriv_level, use_shell_pairs);; const double* buffer = eri_->buffer();; for (int P = 0; P < basisset->nshell(); ++P) {; const auto& Pshell = basisset->shell(P);; for (int Q = 0; Q < basisset->nshell(); ++Q) {; const auto& Qshell = basisset->shell(Q);; for (int R = 0; R < basisset->nshell(); ++R) {; const auto& Rshell = basisset->shell(R);; for (int S = 0; S < basisset->nshell(); ++S) {; const auto& Sshell = basisset->shell(S);; if(sieve->shell_significant(P, Q, R, S) {; eri->compute_shell(P, Q, R, S);; // results are in buffer, do something with them..; }; }; }; }; }. An integral factory is used, which can then produce integral object for various; operator types and derivative levels. A sieve is also constructed; this allows; a quick determination of whether an integral shell quartet will be significant; in magnitude or not, potentially saving a lot of work. This simple scheme is; clean and easy to understand, and is still supported in the latest version of; PSI4 with only a small change to the sieve syntax and handling of buffer; addresses, noted below. The new syntax¶; The newer integral engines ",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:1855,Usability,simpl,simple,1855,"rue;; auto eri = factory->eri(deriv_level, use_shell_pairs);; const double* buffer = eri_->buffer();; for (int P = 0; P < basisset->nshell(); ++P) {; const auto& Pshell = basisset->shell(P);; for (int Q = 0; Q < basisset->nshell(); ++Q) {; const auto& Qshell = basisset->shell(Q);; for (int R = 0; R < basisset->nshell(); ++R) {; const auto& Rshell = basisset->shell(R);; for (int S = 0; S < basisset->nshell(); ++S) {; const auto& Sshell = basisset->shell(S);; if(sieve->shell_significant(P, Q, R, S) {; eri->compute_shell(P, Q, R, S);; // results are in buffer, do something with them..; }; }; }; }; }. An integral factory is used, which can then produce integral object for various; operator types and derivative levels. A sieve is also constructed; this allows; a quick determination of whether an integral shell quartet will be significant; in magnitude or not, potentially saving a lot of work. This simple scheme is; clean and easy to understand, and is still supported in the latest version of; PSI4 with only a small change to the sieve syntax and handling of buffer; addresses, noted below. The new syntax¶; The newer integral engines being interfaced to PSI4 may or may not require; a group of similar integrals to be computed together in a block using; vectorized instructions. To accomodate this possibility, a new syntax has been; introduced in Libmints:; auto blocksPQ = ints[0]->get_blocks12();; auto blocksRS = ints[0]->get_blocks34();. auto factory= std::make_shared<IntegralFactory>(basisset);; int deriv_level = 0;; bool use_shell_pairs = true;; bool needs_exchange = true;; auto eri = factory->eri(deriv_level, use_shell_pairs, needs_exchange);; const auto &buffers = eri->buffers();. eri->update_density(D);; bool use_batching = eri->maximum_block_size() > 1;. // loop over all the blocks of (P>=Q|; for (size_t blockPQ_idx = 0; blockPQ_idx < blocksPQ.size(); blockPQ_idx++) {; const auto& blockPQ = blocksPQ[blockPQ_idx];; // loop over all the blocks of |R>=S); size_t start = ",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:6449,Usability,simpl,simply,6449," are 12 such “chunks”, which; are ordered Px,Py,Pz,Qx,Qy,Qz,Rx,Ry,Rz,Sx,Sy,Sz, where the Px refers to the x; derivative with respect to the basis functions in shell P. Note that all; integral derivatives are provided by the new integral code, unlike the previous; version where only 9 of 12 were provided and the user was responsible for using; translation invariance relationships to fill in the rest. The addresses for; each chunk are updated in the vector after each call to compute integrals, so; the user should keep a const reference to that object, and query that for the; address of interest. Density Screening¶; The old code looked only at the integral to determine whether terms can be; avoided a priori. However, if the integral is to be contracted with a; density or a density-like quantity, the screening can be performed on the; product, which yields more sparsity. To enable this, simply call the integral; object’s update_density member, passing it a SharedMatrix holding the; current density (remember that it changes during each iteration of the SCF) and; the product will be considered during screening. If only coulomb-like terms; are to be computed, the needs_exchange argument to the integral object; constructor should be set to false, otherwise it should be true to correcly; account for products of the density and integrals that contribute to; exchange-like terms. Shell blocking¶; Each underlying integral engine knows whether it will use blocks, and will set up; the metadata automatically. Instead of looping over individual shells, the; user should loop over blocks supplied by the integral object; these blocks will; be just a single shell quartet combination for the case where blocking is not; used. It is simple to loop over pairs within each block using C++11 syntax, as; demonstrated in the code snippet above. Only shell pairs with significant; overlap are included in the shell block information, making this an efficient; way to loop over non-negligible terms. P",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:7292,Usability,simpl,simple,7292,"like quantity, the screening can be performed on the; product, which yields more sparsity. To enable this, simply call the integral; object’s update_density member, passing it a SharedMatrix holding the; current density (remember that it changes during each iteration of the SCF) and; the product will be considered during screening. If only coulomb-like terms; are to be computed, the needs_exchange argument to the integral object; constructor should be set to false, otherwise it should be true to correcly; account for products of the density and integrals that contribute to; exchange-like terms. Shell blocking¶; Each underlying integral engine knows whether it will use blocks, and will set up; the metadata automatically. Instead of looping over individual shells, the; user should loop over blocks supplied by the integral object; these blocks will; be just a single shell quartet combination for the case where blocking is not; used. It is simple to loop over pairs within each block using C++11 syntax, as; demonstrated in the code snippet above. Only shell pairs with significant; overlap are included in the shell block information, making this an efficient; way to loop over non-negligible terms. Permutational symmetry¶; The pairs within each block are optimized for efficiency. First, they are; screened during the integral object’s creation to ensure that only terms with; appreciable overlap are stored. Second, only P,Q combinations that are; permutationally unique are stored, ordered with the higher angular momentum; first. Therefore care must be taken to ensure that the missing permutations; are correctly accounted for when processing the integrals within the loop. See; the DirectJK code in libfock for an example of using this scheme for a Fock; matrix build. Using bra-ket symmetry¶; In cases where there is no batching performed, bra-ket symmetry can be; trivially enforced by ensuring that one of the block indices is greater than or; equal to the other. When batching i",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:11747,Usability,guid,guide,11747,"aika code. There are a; number of reasons motivating this switch. For methods requiring; potentials and fields evaluated at many external sites, such as PCM and; polarizable embedding, the efficiency of the one electron integrals can be rate; limiting. We also started to introduce integral screening, and it is important; to balance the screening used for one- and two-electron terms carefully, so this; is a good opportunity to re-evaluate the code. Finally, given the complexity; of the OS recursion code, the switch to an external library leaves a more; compact codebase to maintain. The one electron integrals which are not provided by Libint2; are now handled by a new implementation of the McMurchie-Davidson (M-D) algorithm,; leading to removal of the OS code in version 1.6. An overview of the one electron integrals; is shown in table Algorithms used for One Electron Integrals, together with the implementation they use.; The tips below serve as a guide to what changed,; why it changed, and how to interface with PSI4’s one-electron integral; machinery now. Calling compute_shell(int P, int Q)¶; The hand-implemented OS recursion code also took care of the Cartesian->pure; transformation (if required by the basis set). The mechanism for handling this; was to provide a public facing compute_shell(int P, int Q) method for the; caller; this then looked up the appropriate GaussianShell objects that were; passed into the corresponding (private) compute_pair(GaussianShell &s1,; GaussianShell &s2) function that computed the integrals and transformed them; to the spherical harmonic basis, if needed. The switch to Libint2 integrals; preserves this mechanism, but the compute_shell(int P, int Q) simply looks; up the appropriate Libint2-compatible shells and hands them off to the; re-written, private compute_pair() routines, which call Libint2 directly.; Therefore, any calls to shell-pair level integral computations should look the; same as before the introduction of Libint2, however",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:12496,Usability,simpl,simply,12496,"ng to removal of the OS code in version 1.6. An overview of the one electron integrals; is shown in table Algorithms used for One Electron Integrals, together with the implementation they use.; The tips below serve as a guide to what changed,; why it changed, and how to interface with PSI4’s one-electron integral; machinery now. Calling compute_shell(int P, int Q)¶; The hand-implemented OS recursion code also took care of the Cartesian->pure; transformation (if required by the basis set). The mechanism for handling this; was to provide a public facing compute_shell(int P, int Q) method for the; caller; this then looked up the appropriate GaussianShell objects that were; passed into the corresponding (private) compute_pair(GaussianShell &s1,; GaussianShell &s2) function that computed the integrals and transformed them; to the spherical harmonic basis, if needed. The switch to Libint2 integrals; preserves this mechanism, but the compute_shell(int P, int Q) simply looks; up the appropriate Libint2-compatible shells and hands them off to the; re-written, private compute_pair() routines, which call Libint2 directly.; Therefore, any calls to shell-pair level integral computations should look the; same as before the introduction of Libint2, however access to the integrals has; changed, as described below. Accessing integrals¶; Before the Libint2 transition, one electron integrals were computed in a flat; array, internally called buffer_, which was accessed through the integral; object’s buffer() method. For integrals with multiple operators, e.g.,; dipole operators that have three distinct components, the buffer was simply; elongated by the appropriate amount and the caller was responsible for striding; through each resulting batch correctly. The Libint2 engines instead return a; list of pointers into each operator’s batch of integrals, the ordering of which; are detailed on the Libint2 wiki. For this reason, the call to buffer(); that returns a single buffer must be replac",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:13164,Usability,simpl,simply,13164,"ts that were; passed into the corresponding (private) compute_pair(GaussianShell &s1,; GaussianShell &s2) function that computed the integrals and transformed them; to the spherical harmonic basis, if needed. The switch to Libint2 integrals; preserves this mechanism, but the compute_shell(int P, int Q) simply looks; up the appropriate Libint2-compatible shells and hands them off to the; re-written, private compute_pair() routines, which call Libint2 directly.; Therefore, any calls to shell-pair level integral computations should look the; same as before the introduction of Libint2, however access to the integrals has; changed, as described below. Accessing integrals¶; Before the Libint2 transition, one electron integrals were computed in a flat; array, internally called buffer_, which was accessed through the integral; object’s buffer() method. For integrals with multiple operators, e.g.,; dipole operators that have three distinct components, the buffer was simply; elongated by the appropriate amount and the caller was responsible for striding; through each resulting batch correctly. The Libint2 engines instead return a; list of pointers into each operator’s batch of integrals, the ordering of which; are detailed on the Libint2 wiki. For this reason, the call to buffer(); that returns a single buffer must be replaced with a call to buffer() to; get a list of pointers; we recommend that be assigned the type const auto; &. For simple integrals, such as overlap or kinetic, only the buffer; corresponding to the zeroth element of this array contains integrals. Derivative Integrals¶; The old one electron integral code used translational invariance relations to; minimze the number of integrals to be computed, leaving the caller with some; bookkeeping to do to compute all terms. For example, consider an overlap; integral: its value depends only on the relative separation of the two centers; and not their absolute positions in space. Therefore, the derivative with; respect t",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:13641,Usability,simpl,simple,13641,"al computations should look the; same as before the introduction of Libint2, however access to the integrals has; changed, as described below. Accessing integrals¶; Before the Libint2 transition, one electron integrals were computed in a flat; array, internally called buffer_, which was accessed through the integral; object’s buffer() method. For integrals with multiple operators, e.g.,; dipole operators that have three distinct components, the buffer was simply; elongated by the appropriate amount and the caller was responsible for striding; through each resulting batch correctly. The Libint2 engines instead return a; list of pointers into each operator’s batch of integrals, the ordering of which; are detailed on the Libint2 wiki. For this reason, the call to buffer(); that returns a single buffer must be replaced with a call to buffer() to; get a list of pointers; we recommend that be assigned the type const auto; &. For simple integrals, such as overlap or kinetic, only the buffer; corresponding to the zeroth element of this array contains integrals. Derivative Integrals¶; The old one electron integral code used translational invariance relations to; minimze the number of integrals to be computed, leaving the caller with some; bookkeeping to do to compute all terms. For example, consider an overlap; integral: its value depends only on the relative separation of the two centers; and not their absolute positions in space. Therefore, the derivative with; respect to center A is the negative of the same derivative with respect to; center B, so one is trivially gleaned from the other. Extending this to second; derivatives, the same principle leads to the fact that double derivatives with; respect to center A are equal to double derivatives with respect to center B,; which are also equal to the negative of the mixed double derivatives with; respect to both center A and B. The old code only provided the double; derivative with respect to center A, leaving the caller to de",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:14798,Usability,simpl,simply,14798," one electron integral code used translational invariance relations to; minimze the number of integrals to be computed, leaving the caller with some; bookkeeping to do to compute all terms. For example, consider an overlap; integral: its value depends only on the relative separation of the two centers; and not their absolute positions in space. Therefore, the derivative with; respect to center A is the negative of the same derivative with respect to; center B, so one is trivially gleaned from the other. Extending this to second; derivatives, the same principle leads to the fact that double derivatives with; respect to center A are equal to double derivatives with respect to center B,; which are also equal to the negative of the mixed double derivatives with; respect to both center A and B. The old code only provided the double; derivative with respect to center A, leaving the caller to determine the other; values. The Libint2 engine instead provides all integrals, so the caller; simply needs to loop over all of the buffers provided in the appropriate order. Changes to External Potential Engines¶; Benchmarking showed that early versions of the old code spent a non-negligible; amount of time performing the Cartesian to spherical harmonic transformation of; the integrals, which is needed for most modern basis sets. To improve; performance, we instead backtransformed the density to the Cartesian; representation (denoted “CartAO”) and computed / contracted all integrals in; this Cartesian basis, eliminating the need to transform to spherical harmonics; as the integrals are computed. This bottleneck no longer exists, so these; extra transformation steps have been removed as part of the switch to Libint2,; and the affected codes (PCM and CPPE interfaces) now compute the potential and; field integrals in the representation required by the basis set.; Also, note that the way external point charges are specified has changed.; Previously, a set of N external point charges woul",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_integrals.html:17003,Usability,simpl,simple,17003,"e verbose; std::vector<std::pair<double, std::array<double, 3>>> type instead, to be; consistent with Libint2’s convention. New Operators Available¶; Libint2 provides a range of integrals that were previously not available in; PSI4, such as the Erfc attenuated nuclear potential integrals needed for; Ewald methods. If new integrals are added to Libint2 but are not yet; interfaced to PSI4, please open an issue on the PSI4 GitHub page to; alert the developers, who will be able to add the appropriate code.; Available integrals classes and parameters currently documented at; Libint2 C++11 Interface Wiki. Shell Pairs¶; To ensure consistency between one- and two-electron terms when screening, and; for efficiency reasons, shell pair lists should be used to iterate over pairs; of Gaussian shells. These lists contain integer pair numbers, corresponding to; the pairs of shells that have sufficient overlap to survive the screening; process. Iterating over these lists is simple:; const auto& shell_pairs = Vint->shellpairs();; size_t n_pairs = shell_pairs.size();; for (size_t p = 0; p < n_pairs; ++p) {; auto P = shell_pairs[p].first;; auto Q = shell_pairs[p].second;; // do something with shells P and Q; }. Note that list considers all P,Q pairs if the two basis sets differ, but only; P>=Q if the basis sets are the same; the caller should account for this; restricted summation in the latter case. One Electron Integral Algorithm Overview¶; The following table summarizes which implementation is used; for each type of one electron integral in PSI4. Algorithms used for One Electron Integrals¶. Integral; Class; Implementation; Comment. Three-Center Overlap; ThreeCenterOverlapInt; Libint2; using libint2::Operator::delta for 4-center integrals. Angular Momentum; AngularMomentumInt; M-D. Dipole; DipoleInt; Libint2; no derivatives supported. Electric Field; ElectricFieldInt; Libint2; using first derivative of libint2::Operator::nuclear. Coulomb Potential; ElectrostaticInt; Libint2; evaluat",MatchSource.WIKI,psi4manual/1.6.x/prog_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html
https://psicode.org/psi4manual/1.6.x/prog_intro.html:712,Deployability,update,updated,712,"﻿. Introduction to Programming in PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Introduction to Programming in PSI4. Introduction to Programming in PSI4¶. Welcome to New Programmers; The PSI4 community. Community Code of Conduct; Setting Up Your Development Environment; Header. General layout of the core: where new C++ code should live; New integral operators; Completely new methods; Integral consuming technologies; Exposing C++ code to Python. Where to Get Help; Slack; Reporting Bugs; Using PSI4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Introduction to Programming in PSI4. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prog_intro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_intro.html
https://psicode.org/psi4manual/1.6.x/prog_newcode.html:1187,Deployability,update,updated,1187,"﻿. Adding New Code to PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4. Adding New Code to PSI4¶. Ways to Add Code: Psi4NumPy, Plugins, Full Integration; Easier and more rapid development; Rapid initial development using Psi4NumPy; Avoiding the need to modify Psi4, using plugins; Incorporating code into PSI4. Creating New Plugins; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. Integrating New Features into PSI4; Overview of Required Steps. Adding Methods to Driver; proc.py; Managed Methods. Python Style; How to Ignore the Bots. C++ Style; Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations; Mark virtual functions in derived classes with override; Prefer GiB for memory printing. FAQ; C++ Style in PSI4; Modules in PSI4; Interfacing with PSI4; Versioning PSI4; Releasing PSI4; Workflow; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prog_newcode.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_newcode.html
https://psicode.org/psi4manual/1.6.x/prog_newcode.html:321,Modifiability,plugin,plugins,321,"﻿. Adding New Code to PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4. Adding New Code to PSI4¶. Ways to Add Code: Psi4NumPy, Plugins, Full Integration; Easier and more rapid development; Rapid initial development using Psi4NumPy; Avoiding the need to modify Psi4, using plugins; Incorporating code into PSI4. Creating New Plugins; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. Integrating New Features into PSI4; Overview of Required Steps. Adding Methods to Driver; proc.py; Managed Methods. Python Style; How to Ignore the Bots. C++ Style; Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations; Mark virtual functions in derived classes with override; Prefer GiB for memory printing. FAQ; C++ Style in PSI4; Modules in PSI4; Interfacing with PSI4; Versioning PSI4; Releasing PSI4; Workflow; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prog_newcode.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_newcode.html
https://psicode.org/psi4manual/1.6.x/prog_setup.html:614,Deployability,update,updated,614,"﻿. Setting Up Your Development Environment. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Introduction to Programming in PSI4; Setting Up Your Development Environment. Setting Up Your Development Environment¶. Header¶; Instructions on getting the proper environment set up, cheatsheets for; this, etc. table of contents. Setting Up Your Development Environment; Header. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Introduction to Programming in PSI4; Setting Up Your Development Environment. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prog_setup.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_setup.html
https://psicode.org/psi4manual/1.6.x/prog_style_c.html:3644,Deployability,update,updated,3644,"variables. auto works like template type; deduction, hence the right-hand side of the declaration needs to have an; initializer:. int x1; // fine, but uninitialized :(; auto x2; // WON'T COMPILE!!!; auto x3 = 1; // fine and initialized. Problems with unintended type casts and type mismatches that are hard; to impossible to catch:. std::vector<int> v;; // !!! The size of a vector is of type std::vector<int>::size_type and is compiler- AND architecture-DEPENDENT; unsigned sz = v.size(); // might not be correct on some compiler/machines; auto size = v.size(); // size is ALWAYS of the correct type. Reference: Items 2 and 5 in [Effective Modern C++]. Mark virtual functions in derived classes with override¶; The override keyword introduced in C++11 is used to mark a function in a; derived class and guarantee that it is overloading a function with the same; signature in the base class. This behavior is checked at compile time. Prefer GiB for memory printing¶; As memory sizes get larger, we should work in giga (requires decimal printing to not round to zero) rather than mega units.; As it’s what we’re computing anyways, we should work in 1024-based (mebi, gibi, etc. https://en.wikipedia.org/wiki/Gibibyte) rather than 1000-based units.; As it’s a unit, put it in brackets.; Note that users can supply MiB, GB, bytes, or whatever; this guideline is for output printing.; outfile->Printf("" DFHelper Memory: AOs need %.3f [GiB]; user supplied %.3f [GiB]. "",; (required * 8 / (1024 * 1024 * 1024.0)),. table of contents. C++ Style; Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations; Mark virtual functions in derived classes with override; Prefer GiB for memory printing. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; C++ Style. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prog_style_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_style_c.html
https://psicode.org/psi4manual/1.6.x/prog_style_c.html:1451,Energy Efficiency,reduce,reduces,1451,"late; parameter will then be deduced. Using nullptr also makes the code more; readable, especially if auto is used consistently throughout.; Reference: Item 8 in [Effective Modern C++]. Prefer std::make_shared to direct use of new¶; Using std::make_shared:. Reduces code verbosity, especially when coupled with auto:. // Type information given 3 TIMES!!!; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));. // So much typing...; std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. // Much better!!!!; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. Ensures exception safety and prevents resource leaks.; Improves efficiency:. // Performs TWO allocations; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));. // Performs ONE allocation; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. Reference: Item 21 in [Effective Modern C++]. Prefer auto to explicit type declarations¶; Using auto reduces and/or avoids:. Verbosity in variable declarations:. std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // So much typing...; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // Much better!. Problems with uninitialized variables. auto works like template type; deduction, hence the right-hand side of the declaration needs to have an; initializer:. int x1; // fine, but uninitialized :(; auto x2; // WON'T COMPILE!!!; auto x3 = 1; // fine and initialized. Problems with unintended type casts and type mismatches that are hard; to impossible to catch:. std::vector<int> v;; // !!! The size of a vector is of type std::vector<int>::size_type and is compiler- AND architecture-DEPENDENT; unsigned sz = v.size(); // might not be correct on some compiler/machines; auto size = v.size(); // size is ALWAYS of the correct type. Reference: Items 2 and 5 in [Effective Modern C++]. Mark virtual functions in derived classes with override¶; The o",MatchSource.WIKI,psi4manual/1.6.x/prog_style_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_style_c.html
https://psicode.org/psi4manual/1.6.x/prog_style_c.html:1488,Modifiability,variab,variable,1488,"akes the code more; readable, especially if auto is used consistently throughout.; Reference: Item 8 in [Effective Modern C++]. Prefer std::make_shared to direct use of new¶; Using std::make_shared:. Reduces code verbosity, especially when coupled with auto:. // Type information given 3 TIMES!!!; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));. // So much typing...; std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. // Much better!!!!; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. Ensures exception safety and prevents resource leaks.; Improves efficiency:. // Performs TWO allocations; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));. // Performs ONE allocation; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. Reference: Item 21 in [Effective Modern C++]. Prefer auto to explicit type declarations¶; Using auto reduces and/or avoids:. Verbosity in variable declarations:. std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // So much typing...; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // Much better!. Problems with uninitialized variables. auto works like template type; deduction, hence the right-hand side of the declaration needs to have an; initializer:. int x1; // fine, but uninitialized :(; auto x2; // WON'T COMPILE!!!; auto x3 = 1; // fine and initialized. Problems with unintended type casts and type mismatches that are hard; to impossible to catch:. std::vector<int> v;; // !!! The size of a vector is of type std::vector<int>::size_type and is compiler- AND architecture-DEPENDENT; unsigned sz = v.size(); // might not be correct on some compiler/machines; auto size = v.size(); // size is ALWAYS of the correct type. Reference: Items 2 and 5 in [Effective Modern C++]. Mark virtual functions in derived classes with override¶; The override keyword introduced in C++11 is used to mark a func",MatchSource.WIKI,psi4manual/1.6.x/prog_style_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_style_c.html
https://psicode.org/psi4manual/1.6.x/prog_style_c.html:1718,Modifiability,variab,variables,1718,"bosity, especially when coupled with auto:. // Type information given 3 TIMES!!!; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));. // So much typing...; std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. // Much better!!!!; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. Ensures exception safety and prevents resource leaks.; Improves efficiency:. // Performs TWO allocations; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));. // Performs ONE allocation; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. Reference: Item 21 in [Effective Modern C++]. Prefer auto to explicit type declarations¶; Using auto reduces and/or avoids:. Verbosity in variable declarations:. std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // So much typing...; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // Much better!. Problems with uninitialized variables. auto works like template type; deduction, hence the right-hand side of the declaration needs to have an; initializer:. int x1; // fine, but uninitialized :(; auto x2; // WON'T COMPILE!!!; auto x3 = 1; // fine and initialized. Problems with unintended type casts and type mismatches that are hard; to impossible to catch:. std::vector<int> v;; // !!! The size of a vector is of type std::vector<int>::size_type and is compiler- AND architecture-DEPENDENT; unsigned sz = v.size(); // might not be correct on some compiler/machines; auto size = v.size(); // size is ALWAYS of the correct type. Reference: Items 2 and 5 in [Effective Modern C++]. Mark virtual functions in derived classes with override¶; The override keyword introduced in C++11 is used to mark a function in a; derived class and guarantee that it is overloading a function with the same; signature in the base class. This behavior is checked at compile time. Prefer GiB for memory printing¶; As memory sizes get larg",MatchSource.WIKI,psi4manual/1.6.x/prog_style_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_style_c.html
https://psicode.org/psi4manual/1.6.x/prog_style_c.html:1082,Safety,safe,safety,1082,"ew Code to PSI4; C++ Style. C++ Style¶. Prefer nullptr to 0 or NULL¶; 0 is an int not a pointer. Almost the same goes for NULL,; though implementations of the language can differ in the details. If you; want to overload on pointer types and/or use pointer types with templates,; use nullptr to signal the null pointer. The correct overload/template; parameter will then be deduced. Using nullptr also makes the code more; readable, especially if auto is used consistently throughout.; Reference: Item 8 in [Effective Modern C++]. Prefer std::make_shared to direct use of new¶; Using std::make_shared:. Reduces code verbosity, especially when coupled with auto:. // Type information given 3 TIMES!!!; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));. // So much typing...; std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. // Much better!!!!; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. Ensures exception safety and prevents resource leaks.; Improves efficiency:. // Performs TWO allocations; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));. // Performs ONE allocation; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. Reference: Item 21 in [Effective Modern C++]. Prefer auto to explicit type declarations¶; Using auto reduces and/or avoids:. Verbosity in variable declarations:. std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // So much typing...; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // Much better!. Problems with uninitialized variables. auto works like template type; deduction, hence the right-hand side of the declaration needs to have an; initializer:. int x1; // fine, but uninitialized :(; auto x2; // WON'T COMPILE!!!; auto x3 = 1; // fine and initialized. Problems with unintended type casts and type mismatches that are hard; to impossible to catch:. std::vector<int> v;; // !!! The size of",MatchSource.WIKI,psi4manual/1.6.x/prog_style_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_style_c.html
https://psicode.org/psi4manual/1.6.x/prog_style_c.html:1466,Safety,avoid,avoids,1466,"late; parameter will then be deduced. Using nullptr also makes the code more; readable, especially if auto is used consistently throughout.; Reference: Item 8 in [Effective Modern C++]. Prefer std::make_shared to direct use of new¶; Using std::make_shared:. Reduces code verbosity, especially when coupled with auto:. // Type information given 3 TIMES!!!; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));. // So much typing...; std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. // Much better!!!!; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. Ensures exception safety and prevents resource leaks.; Improves efficiency:. // Performs TWO allocations; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));. // Performs ONE allocation; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. Reference: Item 21 in [Effective Modern C++]. Prefer auto to explicit type declarations¶; Using auto reduces and/or avoids:. Verbosity in variable declarations:. std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // So much typing...; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // Much better!. Problems with uninitialized variables. auto works like template type; deduction, hence the right-hand side of the declaration needs to have an; initializer:. int x1; // fine, but uninitialized :(; auto x2; // WON'T COMPILE!!!; auto x3 = 1; // fine and initialized. Problems with unintended type casts and type mismatches that are hard; to impossible to catch:. std::vector<int> v;; // !!! The size of a vector is of type std::vector<int>::size_type and is compiler- AND architecture-DEPENDENT; unsigned sz = v.size(); // might not be correct on some compiler/machines; auto size = v.size(); // size is ALWAYS of the correct type. Reference: Items 2 and 5 in [Effective Modern C++]. Mark virtual functions in derived classes with override¶; The o",MatchSource.WIKI,psi4manual/1.6.x/prog_style_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_style_c.html
https://psicode.org/psi4manual/1.6.x/prog_style_c.html:3064,Usability,guid,guideline,3064,"variables. auto works like template type; deduction, hence the right-hand side of the declaration needs to have an; initializer:. int x1; // fine, but uninitialized :(; auto x2; // WON'T COMPILE!!!; auto x3 = 1; // fine and initialized. Problems with unintended type casts and type mismatches that are hard; to impossible to catch:. std::vector<int> v;; // !!! The size of a vector is of type std::vector<int>::size_type and is compiler- AND architecture-DEPENDENT; unsigned sz = v.size(); // might not be correct on some compiler/machines; auto size = v.size(); // size is ALWAYS of the correct type. Reference: Items 2 and 5 in [Effective Modern C++]. Mark virtual functions in derived classes with override¶; The override keyword introduced in C++11 is used to mark a function in a; derived class and guarantee that it is overloading a function with the same; signature in the base class. This behavior is checked at compile time. Prefer GiB for memory printing¶; As memory sizes get larger, we should work in giga (requires decimal printing to not round to zero) rather than mega units.; As it’s what we’re computing anyways, we should work in 1024-based (mebi, gibi, etc. https://en.wikipedia.org/wiki/Gibibyte) rather than 1000-based units.; As it’s a unit, put it in brackets.; Note that users can supply MiB, GB, bytes, or whatever; this guideline is for output printing.; outfile->Printf("" DFHelper Memory: AOs need %.3f [GiB]; user supplied %.3f [GiB]. "",; (required * 8 / (1024 * 1024 * 1024.0)),. table of contents. C++ Style; Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations; Mark virtual functions in derived classes with override; Prefer GiB for memory printing. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; C++ Style. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prog_style_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_style_c.html
https://psicode.org/psi4manual/1.6.x/prog_style_py.html:1154,Deployability,update,updated,1154,"﻿. Python Style. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Python Style. Python Style¶. How to Ignore the Bots¶; Formatting and analysis bots are great because it takes more effort; to defy them than to accept their criticism. Nevertheless, for code; clarity, they can be honestly wrong, so we need a way to specifically; clear their findings. Py Formatting (yapf) # yapf: disable (single line or block) # yapf: enable (resume); C++ Formatting (clang-format) // clang-format off (single line or block) // clang-format on (resume); Py Dynamic Analysis (coverage.py) # pragma: no cover; C++ Dynamic Analysis (gcov) https://stackoverflow.com/a/30078276 untested; Py Static Analysis (lgtm) # lgtm[py/not-named-self] (click on the “?” to get the “Query ID”); C++ Static Analysis (lgtm) // lgtm[cpp/wrong-type-format-argument] (click on the “?” to get the “Query ID”). table of contents. Python Style; How to Ignore the Bots. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Python Style. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prog_style_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_style_py.html
https://psicode.org/psi4manual/1.6.x/prog_style_py.html:373,Usability,clear,clear,373,"﻿. Python Style. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Python Style. Python Style¶. How to Ignore the Bots¶; Formatting and analysis bots are great because it takes more effort; to defy them than to accept their criticism. Nevertheless, for code; clarity, they can be honestly wrong, so we need a way to specifically; clear their findings. Py Formatting (yapf) # yapf: disable (single line or block) # yapf: enable (resume); C++ Formatting (clang-format) // clang-format off (single line or block) // clang-format on (resume); Py Dynamic Analysis (coverage.py) # pragma: no cover; C++ Dynamic Analysis (gcov) https://stackoverflow.com/a/30078276 untested; Py Static Analysis (lgtm) # lgtm[py/not-named-self] (click on the “?” to get the “Query ID”); C++ Static Analysis (lgtm) // lgtm[cpp/wrong-type-format-argument] (click on the “?” to get the “Query ID”). table of contents. Python Style; How to Ignore the Bots. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Python Style. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prog_style_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_style_py.html
https://psicode.org/psi4manual/1.6.x/prog_style_py.html:471,Usability,resume,resume,471,"﻿. Python Style. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Python Style. Python Style¶. How to Ignore the Bots¶; Formatting and analysis bots are great because it takes more effort; to defy them than to accept their criticism. Nevertheless, for code; clarity, they can be honestly wrong, so we need a way to specifically; clear their findings. Py Formatting (yapf) # yapf: disable (single line or block) # yapf: enable (resume); C++ Formatting (clang-format) // clang-format off (single line or block) // clang-format on (resume); Py Dynamic Analysis (coverage.py) # pragma: no cover; C++ Dynamic Analysis (gcov) https://stackoverflow.com/a/30078276 untested; Py Static Analysis (lgtm) # lgtm[py/not-named-self] (click on the “?” to get the “Query ID”); C++ Static Analysis (lgtm) // lgtm[cpp/wrong-type-format-argument] (click on the “?” to get the “Query ID”). table of contents. Python Style; How to Ignore the Bots. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Python Style. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prog_style_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_style_py.html
https://psicode.org/psi4manual/1.6.x/prog_style_py.html:573,Usability,resume,resume,573,"﻿. Python Style. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Python Style. Python Style¶. How to Ignore the Bots¶; Formatting and analysis bots are great because it takes more effort; to defy them than to accept their criticism. Nevertheless, for code; clarity, they can be honestly wrong, so we need a way to specifically; clear their findings. Py Formatting (yapf) # yapf: disable (single line or block) # yapf: enable (resume); C++ Formatting (clang-format) // clang-format off (single line or block) // clang-format on (resume); Py Dynamic Analysis (coverage.py) # pragma: no cover; C++ Dynamic Analysis (gcov) https://stackoverflow.com/a/30078276 untested; Py Static Analysis (lgtm) # lgtm[py/not-named-self] (click on the “?” to get the “Query ID”); C++ Static Analysis (lgtm) // lgtm[cpp/wrong-type-format-argument] (click on the “?” to get the “Query ID”). table of contents. Python Style; How to Ignore the Bots. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Python Style. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prog_style_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_style_py.html
https://psicode.org/psi4manual/1.6.x/prog_tour.html:1279,Availability,avail,available,1279,"de should live¶. New integral operators¶; Most of the heavy lifting in PSI4 is handled by libmints, which can be; found in the psi4/psi4/src/psi4/libmints directory. New types of one- and; two-electron integral operators should be added here. The Wavefunction class; psi4/psi4/src/psi4/libmints/wavefunction.h is also found here and is a key; part of the infrastructure. Every energy calculation is performed by a class; that derives from Wavefunction and is accessible as a return value in the; Python layer. The Wavefunction class contains all pertinent calculation; results, such as one-particle densities, molecular orbitals and gradients. Completely new methods¶; A new method that is not a modification of existing code belongs in its own; folder in psi4/psi4/src/psi4; see other folders in that exist in that; location for examples of setting up CMake, and make sure that the new folder is; added to psi4/psi4/src/psi4/CMakeLists.txt. There are also a number of; variables that can be exported to be available to the user, as detailed in; PSI Variables. To set these variables, the following member of; Wavefunction should be called:; set_variable(""Variable Name"", variable_value);. The new variable should also be documented in; psi4/doc/sphinxman/source/glossary_psivariables.rst. There are a; number of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies¶; The general philosophy in PSI4 is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (psi4/psi4/src/psi4/libfock) accomplishes. A number of integral; technologies – such as integral-direct, disk-based and ",MatchSource.WIKI,psi4manual/1.6.x/prog_tour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_tour.html
https://psicode.org/psi4manual/1.6.x/prog_tour.html:1744,Availability,avail,available,1744,"ython layer. The Wavefunction class contains all pertinent calculation; results, such as one-particle densities, molecular orbitals and gradients. Completely new methods¶; A new method that is not a modification of existing code belongs in its own; folder in psi4/psi4/src/psi4; see other folders in that exist in that; location for examples of setting up CMake, and make sure that the new folder is; added to psi4/psi4/src/psi4/CMakeLists.txt. There are also a number of; variables that can be exported to be available to the user, as detailed in; PSI Variables. To set these variables, the following member of; Wavefunction should be called:; set_variable(""Variable Name"", variable_value);. The new variable should also be documented in; psi4/doc/sphinxman/source/glossary_psivariables.rst. There are a; number of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies¶; The general philosophy in PSI4 is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (psi4/psi4/src/psi4/libfock) accomplishes. A number of integral; technologies – such as integral-direct, disk-based and density fitting – are; supported in libFock, making them generally available to all elements of the; code that use the generalized Fock matrix strategy. Exposing C++ code to Python¶; The recent push to move sections of the code that are not a bottleneck into the; Python layer requires that the C++ code is callable from Python and that its; results are accessible. The result accessibility is addressed by populating; the appropriate variables in the Wavefunction object. To make the code; calla",MatchSource.WIKI,psi4manual/1.6.x/prog_tour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_tour.html
https://psicode.org/psi4manual/1.6.x/prog_tour.html:2340,Availability,avail,available,2340,"led in; PSI Variables. To set these variables, the following member of; Wavefunction should be called:; set_variable(""Variable Name"", variable_value);. The new variable should also be documented in; psi4/doc/sphinxman/source/glossary_psivariables.rst. There are a; number of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies¶; The general philosophy in PSI4 is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (psi4/psi4/src/psi4/libfock) accomplishes. A number of integral; technologies – such as integral-direct, disk-based and density fitting – are; supported in libFock, making them generally available to all elements of the; code that use the generalized Fock matrix strategy. Exposing C++ code to Python¶; The recent push to move sections of the code that are not a bottleneck into the; Python layer requires that the C++ code is callable from Python and that its; results are accessible. The result accessibility is addressed by populating; the appropriate variables in the Wavefunction object. To make the code; callable from Python, we rely on the excellent PyBind11 library; to create the bindings. Existing code to export various PSI4 classes can; be found in psi4/psi4/src in the files whose name begins with export_.; The code to export functions that run entire calculations is usually found in; psi4/psi4/src/core.cc. table of contents. General layout of the core: where new C++ code should live; New integral operators; Completely new methods; Integral consuming technologies; Exposing C++ code to Python. «; hide menu. menu; sidebar; »; . Navigation",MatchSource.WIKI,psi4manual/1.6.x/prog_tour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_tour.html
https://psicode.org/psi4manual/1.6.x/prog_tour.html:3507,Deployability,update,updated,3507," of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies¶; The general philosophy in PSI4 is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (psi4/psi4/src/psi4/libfock) accomplishes. A number of integral; technologies – such as integral-direct, disk-based and density fitting – are; supported in libFock, making them generally available to all elements of the; code that use the generalized Fock matrix strategy. Exposing C++ code to Python¶; The recent push to move sections of the code that are not a bottleneck into the; Python layer requires that the C++ code is callable from Python and that its; results are accessible. The result accessibility is addressed by populating; the appropriate variables in the Wavefunction object. To make the code; callable from Python, we rely on the excellent PyBind11 library; to create the bindings. Existing code to export various PSI4 classes can; be found in psi4/psi4/src in the files whose name begins with export_.; The code to export functions that run entire calculations is usually found in; psi4/psi4/src/core.cc. table of contents. General layout of the core: where new C++ code should live; New integral operators; Completely new methods; Integral consuming technologies; Exposing C++ code to Python. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Introduction to Programming in PSI4; General layout of the core: where new C++ code should live. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prog_tour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_tour.html
https://psicode.org/psi4manual/1.6.x/prog_tour.html:649,Energy Efficiency,energy,energy,649,"﻿. General layout of the core: where new C++ code should live. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Introduction to Programming in PSI4; General layout of the core: where new C++ code should live. General layout of the core: where new C++ code should live¶. New integral operators¶; Most of the heavy lifting in PSI4 is handled by libmints, which can be; found in the psi4/psi4/src/psi4/libmints directory. New types of one- and; two-electron integral operators should be added here. The Wavefunction class; psi4/psi4/src/psi4/libmints/wavefunction.h is also found here and is a key; part of the infrastructure. Every energy calculation is performed by a class; that derives from Wavefunction and is accessible as a return value in the; Python layer. The Wavefunction class contains all pertinent calculation; results, such as one-particle densities, molecular orbitals and gradients. Completely new methods¶; A new method that is not a modification of existing code belongs in its own; folder in psi4/psi4/src/psi4; see other folders in that exist in that; location for examples of setting up CMake, and make sure that the new folder is; added to psi4/psi4/src/psi4/CMakeLists.txt. There are also a number of; variables that can be exported to be available to the user, as detailed in; PSI Variables. To set these variables, the following member of; Wavefunction should be called:; set_variable(""Variable Name"", variable_value);. The new variable should also be documented in; psi4/doc/sphinxman/source/glossary_psivariables.rst. There are a; number of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies¶; The general philosophy in PSI4 is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF i",MatchSource.WIKI,psi4manual/1.6.x/prog_tour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_tour.html
https://psicode.org/psi4manual/1.6.x/prog_tour.html:1242,Modifiability,variab,variables,1242,"de should live¶. New integral operators¶; Most of the heavy lifting in PSI4 is handled by libmints, which can be; found in the psi4/psi4/src/psi4/libmints directory. New types of one- and; two-electron integral operators should be added here. The Wavefunction class; psi4/psi4/src/psi4/libmints/wavefunction.h is also found here and is a key; part of the infrastructure. Every energy calculation is performed by a class; that derives from Wavefunction and is accessible as a return value in the; Python layer. The Wavefunction class contains all pertinent calculation; results, such as one-particle densities, molecular orbitals and gradients. Completely new methods¶; A new method that is not a modification of existing code belongs in its own; folder in psi4/psi4/src/psi4; see other folders in that exist in that; location for examples of setting up CMake, and make sure that the new folder is; added to psi4/psi4/src/psi4/CMakeLists.txt. There are also a number of; variables that can be exported to be available to the user, as detailed in; PSI Variables. To set these variables, the following member of; Wavefunction should be called:; set_variable(""Variable Name"", variable_value);. The new variable should also be documented in; psi4/doc/sphinxman/source/glossary_psivariables.rst. There are a; number of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies¶; The general philosophy in PSI4 is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (psi4/psi4/src/psi4/libfock) accomplishes. A number of integral; technologies – such as integral-direct, disk-based and ",MatchSource.WIKI,psi4manual/1.6.x/prog_tour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_tour.html
https://psicode.org/psi4manual/1.6.x/prog_tour.html:1346,Modifiability,variab,variables,1346,"he psi4/psi4/src/psi4/libmints directory. New types of one- and; two-electron integral operators should be added here. The Wavefunction class; psi4/psi4/src/psi4/libmints/wavefunction.h is also found here and is a key; part of the infrastructure. Every energy calculation is performed by a class; that derives from Wavefunction and is accessible as a return value in the; Python layer. The Wavefunction class contains all pertinent calculation; results, such as one-particle densities, molecular orbitals and gradients. Completely new methods¶; A new method that is not a modification of existing code belongs in its own; folder in psi4/psi4/src/psi4; see other folders in that exist in that; location for examples of setting up CMake, and make sure that the new folder is; added to psi4/psi4/src/psi4/CMakeLists.txt. There are also a number of; variables that can be exported to be available to the user, as detailed in; PSI Variables. To set these variables, the following member of; Wavefunction should be called:; set_variable(""Variable Name"", variable_value);. The new variable should also be documented in; psi4/doc/sphinxman/source/glossary_psivariables.rst. There are a; number of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies¶; The general philosophy in PSI4 is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (psi4/psi4/src/psi4/libfock) accomplishes. A number of integral; technologies – such as integral-direct, disk-based and density fitting – are; supported in libFock, making them generally available to all elements of the; code that use the gener",MatchSource.WIKI,psi4manual/1.6.x/prog_tour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_tour.html
https://psicode.org/psi4manual/1.6.x/prog_tour.html:1470,Modifiability,variab,variable,1470,"here. The Wavefunction class; psi4/psi4/src/psi4/libmints/wavefunction.h is also found here and is a key; part of the infrastructure. Every energy calculation is performed by a class; that derives from Wavefunction and is accessible as a return value in the; Python layer. The Wavefunction class contains all pertinent calculation; results, such as one-particle densities, molecular orbitals and gradients. Completely new methods¶; A new method that is not a modification of existing code belongs in its own; folder in psi4/psi4/src/psi4; see other folders in that exist in that; location for examples of setting up CMake, and make sure that the new folder is; added to psi4/psi4/src/psi4/CMakeLists.txt. There are also a number of; variables that can be exported to be available to the user, as detailed in; PSI Variables. To set these variables, the following member of; Wavefunction should be called:; set_variable(""Variable Name"", variable_value);. The new variable should also be documented in; psi4/doc/sphinxman/source/glossary_psivariables.rst. There are a; number of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies¶; The general philosophy in PSI4 is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (psi4/psi4/src/psi4/libfock) accomplishes. A number of integral; technologies – such as integral-direct, disk-based and density fitting – are; supported in libFock, making them generally available to all elements of the; code that use the generalized Fock matrix strategy. Exposing C++ code to Python¶; The recent push to move sections of the code that are",MatchSource.WIKI,psi4manual/1.6.x/prog_tour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_tour.html
https://psicode.org/psi4manual/1.6.x/prog_tour.html:2708,Modifiability,variab,variables,2708," of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies¶; The general philosophy in PSI4 is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (psi4/psi4/src/psi4/libfock) accomplishes. A number of integral; technologies – such as integral-direct, disk-based and density fitting – are; supported in libFock, making them generally available to all elements of the; code that use the generalized Fock matrix strategy. Exposing C++ code to Python¶; The recent push to move sections of the code that are not a bottleneck into the; Python layer requires that the C++ code is callable from Python and that its; results are accessible. The result accessibility is addressed by populating; the appropriate variables in the Wavefunction object. To make the code; callable from Python, we rely on the excellent PyBind11 library; to create the bindings. Existing code to export various PSI4 classes can; be found in psi4/psi4/src in the files whose name begins with export_.; The code to export functions that run entire calculations is usually found in; psi4/psi4/src/core.cc. table of contents. General layout of the core: where new C++ code should live; New integral operators; Completely new methods; Integral consuming technologies; Exposing C++ code to Python. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Introduction to Programming in PSI4; General layout of the core: where new C++ code should live. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prog_tour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_tour.html
https://psicode.org/psi4manual/1.6.x/prog_tour.html:671,Performance,perform,performed,671,"﻿. General layout of the core: where new C++ code should live. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Introduction to Programming in PSI4; General layout of the core: where new C++ code should live. General layout of the core: where new C++ code should live¶. New integral operators¶; Most of the heavy lifting in PSI4 is handled by libmints, which can be; found in the psi4/psi4/src/psi4/libmints directory. New types of one- and; two-electron integral operators should be added here. The Wavefunction class; psi4/psi4/src/psi4/libmints/wavefunction.h is also found here and is a key; part of the infrastructure. Every energy calculation is performed by a class; that derives from Wavefunction and is accessible as a return value in the; Python layer. The Wavefunction class contains all pertinent calculation; results, such as one-particle densities, molecular orbitals and gradients. Completely new methods¶; A new method that is not a modification of existing code belongs in its own; folder in psi4/psi4/src/psi4; see other folders in that exist in that; location for examples of setting up CMake, and make sure that the new folder is; added to psi4/psi4/src/psi4/CMakeLists.txt. There are also a number of; variables that can be exported to be available to the user, as detailed in; PSI Variables. To set these variables, the following member of; Wavefunction should be called:; set_variable(""Variable Name"", variable_value);. The new variable should also be documented in; psi4/doc/sphinxman/source/glossary_psivariables.rst. There are a; number of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies¶; The general philosophy in PSI4 is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF i",MatchSource.WIKI,psi4manual/1.6.x/prog_tour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_tour.html
https://psicode.org/psi4manual/1.6.x/prog_tour.html:2516,Performance,bottleneck,bottleneck,2516,"rce/glossary_psivariables.rst. There are a; number of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies¶; The general philosophy in PSI4 is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (psi4/psi4/src/psi4/libfock) accomplishes. A number of integral; technologies – such as integral-direct, disk-based and density fitting – are; supported in libFock, making them generally available to all elements of the; code that use the generalized Fock matrix strategy. Exposing C++ code to Python¶; The recent push to move sections of the code that are not a bottleneck into the; Python layer requires that the C++ code is callable from Python and that its; results are accessible. The result accessibility is addressed by populating; the appropriate variables in the Wavefunction object. To make the code; callable from Python, we rely on the excellent PyBind11 library; to create the bindings. Existing code to export various PSI4 classes can; be found in psi4/psi4/src in the files whose name begins with export_.; The code to export functions that run entire calculations is usually found in; psi4/psi4/src/core.cc. table of contents. General layout of the core: where new C++ code should live; New integral operators; Completely new methods; Integral consuming technologies; Exposing C++ code to Python. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Introduction to Programming in PSI4; General layout of the core: where new C++ code should live. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 M",MatchSource.WIKI,psi4manual/1.6.x/prog_tour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_tour.html
https://psicode.org/psi4manual/1.6.x/prog_tour.html:731,Security,access,accessible,731,"﻿. General layout of the core: where new C++ code should live. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Introduction to Programming in PSI4; General layout of the core: where new C++ code should live. General layout of the core: where new C++ code should live¶. New integral operators¶; Most of the heavy lifting in PSI4 is handled by libmints, which can be; found in the psi4/psi4/src/psi4/libmints directory. New types of one- and; two-electron integral operators should be added here. The Wavefunction class; psi4/psi4/src/psi4/libmints/wavefunction.h is also found here and is a key; part of the infrastructure. Every energy calculation is performed by a class; that derives from Wavefunction and is accessible as a return value in the; Python layer. The Wavefunction class contains all pertinent calculation; results, such as one-particle densities, molecular orbitals and gradients. Completely new methods¶; A new method that is not a modification of existing code belongs in its own; folder in psi4/psi4/src/psi4; see other folders in that exist in that; location for examples of setting up CMake, and make sure that the new folder is; added to psi4/psi4/src/psi4/CMakeLists.txt. There are also a number of; variables that can be exported to be available to the user, as detailed in; PSI Variables. To set these variables, the following member of; Wavefunction should be called:; set_variable(""Variable Name"", variable_value);. The new variable should also be documented in; psi4/doc/sphinxman/source/glossary_psivariables.rst. There are a; number of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies¶; The general philosophy in PSI4 is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF i",MatchSource.WIKI,psi4manual/1.6.x/prog_tour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_tour.html
https://psicode.org/psi4manual/1.6.x/prog_tour.html:2627,Security,access,accessible,2627,"rce/glossary_psivariables.rst. There are a; number of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies¶; The general philosophy in PSI4 is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (psi4/psi4/src/psi4/libfock) accomplishes. A number of integral; technologies – such as integral-direct, disk-based and density fitting – are; supported in libFock, making them generally available to all elements of the; code that use the generalized Fock matrix strategy. Exposing C++ code to Python¶; The recent push to move sections of the code that are not a bottleneck into the; Python layer requires that the C++ code is callable from Python and that its; results are accessible. The result accessibility is addressed by populating; the appropriate variables in the Wavefunction object. To make the code; callable from Python, we rely on the excellent PyBind11 library; to create the bindings. Existing code to export various PSI4 classes can; be found in psi4/psi4/src in the files whose name begins with export_.; The code to export functions that run entire calculations is usually found in; psi4/psi4/src/core.cc. table of contents. General layout of the core: where new C++ code should live; New integral operators; Completely new methods; Integral consuming technologies; Exposing C++ code to Python. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Introduction to Programming in PSI4; General layout of the core: where new C++ code should live. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 M",MatchSource.WIKI,psi4manual/1.6.x/prog_tour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_tour.html
https://psicode.org/psi4manual/1.6.x/prog_tour.html:2650,Security,access,accessibility,2650," of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies¶; The general philosophy in PSI4 is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (psi4/psi4/src/psi4/libfock) accomplishes. A number of integral; technologies – such as integral-direct, disk-based and density fitting – are; supported in libFock, making them generally available to all elements of the; code that use the generalized Fock matrix strategy. Exposing C++ code to Python¶; The recent push to move sections of the code that are not a bottleneck into the; Python layer requires that the C++ code is callable from Python and that its; results are accessible. The result accessibility is addressed by populating; the appropriate variables in the Wavefunction object. To make the code; callable from Python, we rely on the excellent PyBind11 library; to create the bindings. Existing code to export various PSI4 classes can; be found in psi4/psi4/src in the files whose name begins with export_.; The code to export functions that run entire calculations is usually found in; psi4/psi4/src/core.cc. table of contents. General layout of the core: where new C++ code should live; New integral operators; Completely new methods; Integral consuming technologies; Exposing C++ code to Python. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Introduction to Programming in PSI4; General layout of the core: where new C++ code should live. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prog_tour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_tour.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:1347,Availability,avail,available,1347,"; Fully-featured electronic structure programs are large and complex. However,; the PSI4 ecosystem provides a path for easier and more rapid development; of new features. The earliest versions of PSI4 were written by merging; individual executables that performed specific tasks into a unified C++; executable. By linking this C++ executable against the Python interpreter, the; individual modules could be called in any sequence, enabling a very diverse; range of tasks to be accomplished within a given input. Although Python-driven; model allowed for great flexibility from a user’s perspective, programming was; still relatively difficult because it required modifications to be made in C++; code.; Since those early days, the code has undergone some important structural; changes that have greatly simplified the development workflow. These changes; were motivated by the realization that only a few bottlenecks exist in a typical; calculation; by focusing on optimized C++ implementations of these bottlenecks; and making these C++ functions available in Python, most of the code to implement; the overall calculation can be written in simpler Python code. Python is far; better suited to management tasks such as directory navigation and retrieval,; making it a natural choice for overall calculation layout than C++. With the; emergence of NumPy as a standard tool for executing almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. Rapid initial development using Psi4NumPy¶; The Psi4NumPy project [Smith:2018:3504] is the recommended; mechanism for developing and prototyping new methods in Psi4. Because; NumPy provides such a rich set of features for efficient linear; algebra, Fourier transforms, and general tensor manipulations, a massive number; of methods can be easily implemented very easily using that library. ",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:2812,Availability,avail,available,2812,"simpler work flow for prototyping and; developing methods: this is detailed in the next section. Rapid initial development using Psi4NumPy¶; The Psi4NumPy project [Smith:2018:3504] is the recommended; mechanism for developing and prototyping new methods in Psi4. Because; NumPy provides such a rich set of features for efficient linear; algebra, Fourier transforms, and general tensor manipulations, a massive number; of methods can be easily implemented very easily using that library. To; facilitate this workflow, PSI4 exports key quantities such as integrals,; densities and molecular orbitals in NumPy format. From this point, the; programmer can simply call the appropriate PSI4 functions to compute the; desired input quantities, retrieve them in NumPy format, and then write the; remaining code using standard Python and/or NumPy syntax. This approach does; not require any recompilation of code, resulting in a particularly facile; development workflow. Detailed examples and tutorials are available in the; Psi4NumPy repository. Avoiding the need to modify Psi4, using plugins¶; In the early days when PSI4 was still primarily a C++ code, development; was very cumbersome due to a lengthy build process. To expedite development, a; plugin system was developed. This plugin machinery allows developers to access; the classes defined in the innards of PSI4, with only the small plugin; code requiring recompilation during development. The resulting lightweight; code can be maintained and distributed independently of PSI4, making this; a good strategy for development, especially in cases where tighter integration; of the new code with existing PSI4 machinery is required than that; afforded by the Numpy based strategy outlined in the Rapid initial development using Psi4NumPy; section. For details about how to write these plugins, see the; Creating New Plugins section. Incorporating code into PSI4¶; For features to be incorporated fully into the PSI4 ecosystem, changes to; the core ro",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:3982,Availability,down,downloads,3982,"ess. To expedite development, a; plugin system was developed. This plugin machinery allows developers to access; the classes defined in the innards of PSI4, with only the small plugin; code requiring recompilation during development. The resulting lightweight; code can be maintained and distributed independently of PSI4, making this; a good strategy for development, especially in cases where tighter integration; of the new code with existing PSI4 machinery is required than that; afforded by the Numpy based strategy outlined in the Rapid initial development using Psi4NumPy; section. For details about how to write these plugins, see the; Creating New Plugins section. Incorporating code into PSI4¶; For features to be incorporated fully into the PSI4 ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let’s; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in PSI4 already to perform tasks like these that are; required, e.g., for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the ",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:4997,Availability,avail,available,4997," some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in PSI4 already to perform tasks like these that are; required, e.g., for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in Exposing C++ code to Python. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths.; A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out embarrassingly parallel workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated.; In SCF, we have a number of sources of external embeddi",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:5078,Availability,avail,available,5078," some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in PSI4 already to perform tasks like these that are; required, e.g., for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in Exposing C++ code to Python. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths.; A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out embarrassingly parallel workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated.; In SCF, we have a number of sources of external embeddi",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:3425,Deployability,integrat,integration,3425," this point, the; programmer can simply call the appropriate PSI4 functions to compute the; desired input quantities, retrieve them in NumPy format, and then write the; remaining code using standard Python and/or NumPy syntax. This approach does; not require any recompilation of code, resulting in a particularly facile; development workflow. Detailed examples and tutorials are available in the; Psi4NumPy repository. Avoiding the need to modify Psi4, using plugins¶; In the early days when PSI4 was still primarily a C++ code, development; was very cumbersome due to a lengthy build process. To expedite development, a; plugin system was developed. This plugin machinery allows developers to access; the classes defined in the innards of PSI4, with only the small plugin; code requiring recompilation during development. The resulting lightweight; code can be maintained and distributed independently of PSI4, making this; a good strategy for development, especially in cases where tighter integration; of the new code with existing PSI4 machinery is required than that; afforded by the Numpy based strategy outlined in the Rapid initial development using Psi4NumPy; section. For details about how to write these plugins, see the; Creating New Plugins section. Incorporating code into PSI4¶; For features to be incorporated fully into the PSI4 ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let’s; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entir",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:6828,Deployability,update,updated,6828," in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in Exposing C++ code to Python. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths.; A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out embarrassingly parallel workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated.; In SCF, we have a number of sources of external embedding potentials that could; enter the calculation. Allowing Python to handle only the details of driving; the SCF iterations, such as external potentials and convergence acceleration; methods, but deferring to C++ to do the heavy lifting for building and; diagonalizing the Fock matrix also takes advantage of the two languages’; strengths and improves maintainability of the code. table of contents. Ways to Add Code: Psi4NumPy, Plugins, Full Integration; Easier and more rapid development; Rapid initial development using Psi4NumPy; Avoiding the need to modify Psi4, using plugins; Incorporating code into PSI4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Ways to Add Code: Psi4NumPy, Plugins, Full Integration. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:1721,Energy Efficiency,efficient,efficiently,1721,"sks to be accomplished within a given input. Although Python-driven; model allowed for great flexibility from a user’s perspective, programming was; still relatively difficult because it required modifications to be made in C++; code.; Since those early days, the code has undergone some important structural; changes that have greatly simplified the development workflow. These changes; were motivated by the realization that only a few bottlenecks exist in a typical; calculation; by focusing on optimized C++ implementations of these bottlenecks; and making these C++ functions available in Python, most of the code to implement; the overall calculation can be written in simpler Python code. Python is far; better suited to management tasks such as directory navigation and retrieval,; making it a natural choice for overall calculation layout than C++. With the; emergence of NumPy as a standard tool for executing almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. Rapid initial development using Psi4NumPy¶; The Psi4NumPy project [Smith:2018:3504] is the recommended; mechanism for developing and prototyping new methods in Psi4. Because; NumPy provides such a rich set of features for efficient linear; algebra, Fourier transforms, and general tensor manipulations, a massive number; of methods can be easily implemented very easily using that library. To; facilitate this workflow, PSI4 exports key quantities such as integrals,; densities and molecular orbitals in NumPy format. From this point, the; programmer can simply call the appropriate PSI4 functions to compute the; desired input quantities, retrieve them in NumPy format, and then write the; remaining code using standard Python and/or NumPy syntax. This approach does; not require any recompilation of code, resulting in a particularly facile; development ",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:2132,Energy Efficiency,efficient,efficient,2132," that only a few bottlenecks exist in a typical; calculation; by focusing on optimized C++ implementations of these bottlenecks; and making these C++ functions available in Python, most of the code to implement; the overall calculation can be written in simpler Python code. Python is far; better suited to management tasks such as directory navigation and retrieval,; making it a natural choice for overall calculation layout than C++. With the; emergence of NumPy as a standard tool for executing almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. Rapid initial development using Psi4NumPy¶; The Psi4NumPy project [Smith:2018:3504] is the recommended; mechanism for developing and prototyping new methods in Psi4. Because; NumPy provides such a rich set of features for efficient linear; algebra, Fourier transforms, and general tensor manipulations, a massive number; of methods can be easily implemented very easily using that library. To; facilitate this workflow, PSI4 exports key quantities such as integrals,; densities and molecular orbitals in NumPy format. From this point, the; programmer can simply call the appropriate PSI4 functions to compute the; desired input quantities, retrieve them in NumPy format, and then write the; remaining code using standard Python and/or NumPy syntax. This approach does; not require any recompilation of code, resulting in a particularly facile; development workflow. Detailed examples and tutorials are available in the; Psi4NumPy repository. Avoiding the need to modify Psi4, using plugins¶; In the early days when PSI4 was still primarily a C++ code, development; was very cumbersome due to a lengthy build process. To expedite development, a; plugin system was developed. This plugin machinery allows developers to access; the classes defined in the innards of PSI4, with onl",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:5496,Energy Efficiency,energy,energy,5496,"; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in PSI4 already to perform tasks like these that are; required, e.g., for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in Exposing C++ code to Python. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths.; A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out embarrassingly parallel workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated.; In SCF, we have a number of sources of external embedding potentials that could; enter the calculation. Allowing Python to handle only the details of driving; the SCF iterations, such as external potentials and convergence acceleration; methods, but deferring to C++ to do the heavy lifting for building and; diagonalizing the Fock matrix also takes advantage of the two languages’; strengths and improves maintainability of the code. table of contents. Ways to Add Code: Psi4NumPy, Plugins, Full Integration; Easier and more rapid development; Rapid initial development using Psi4NumPy; Avoiding the need to modify Psi4, using plugin",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:5667,Energy Efficiency,energy,energy,5667,"; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in PSI4 already to perform tasks like these that are; required, e.g., for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in Exposing C++ code to Python. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths.; A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out embarrassingly parallel workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated.; In SCF, we have a number of sources of external embedding potentials that could; enter the calculation. Allowing Python to handle only the details of driving; the SCF iterations, such as external potentials and convergence acceleration; methods, but deferring to C++ to do the heavy lifting for building and; diagonalizing the Fock matrix also takes advantage of the two languages’; strengths and improves maintainability of the code. table of contents. Ways to Add Code: Psi4NumPy, Plugins, Full Integration; Easier and more rapid development; Rapid initial development using Psi4NumPy; Avoiding the need to modify Psi4, using plugin",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:5896,Energy Efficiency,energy,energy,5896,"ired, e.g., for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in Exposing C++ code to Python. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths.; A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out embarrassingly parallel workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated.; In SCF, we have a number of sources of external embedding potentials that could; enter the calculation. Allowing Python to handle only the details of driving; the SCF iterations, such as external potentials and convergence acceleration; methods, but deferring to C++ to do the heavy lifting for building and; diagonalizing the Fock matrix also takes advantage of the two languages’; strengths and improves maintainability of the code. table of contents. Ways to Add Code: Psi4NumPy, Plugins, Full Integration; Easier and more rapid development; Rapid initial development using Psi4NumPy; Avoiding the need to modify Psi4, using plugins; Incorporating code into PSI4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Ways to Add Code: Psi4NumPy, Plugins, Full Integration. © Copyright 2022, The P",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:3425,Integrability,integrat,integration,3425," this point, the; programmer can simply call the appropriate PSI4 functions to compute the; desired input quantities, retrieve them in NumPy format, and then write the; remaining code using standard Python and/or NumPy syntax. This approach does; not require any recompilation of code, resulting in a particularly facile; development workflow. Detailed examples and tutorials are available in the; Psi4NumPy repository. Avoiding the need to modify Psi4, using plugins¶; In the early days when PSI4 was still primarily a C++ code, development; was very cumbersome due to a lengthy build process. To expedite development, a; plugin system was developed. This plugin machinery allows developers to access; the classes defined in the innards of PSI4, with only the small plugin; code requiring recompilation during development. The resulting lightweight; code can be maintained and distributed independently of PSI4, making this; a good strategy for development, especially in cases where tighter integration; of the new code with existing PSI4 machinery is required than that; afforded by the Numpy based strategy outlined in the Rapid initial development using Psi4NumPy; section. For details about how to write these plugins, see the; Creating New Plugins section. Incorporating code into PSI4¶; For features to be incorporated fully into the PSI4 ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let’s; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entir",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:3811,Integrability,rout,routines,3811," workflow. Detailed examples and tutorials are available in the; Psi4NumPy repository. Avoiding the need to modify Psi4, using plugins¶; In the early days when PSI4 was still primarily a C++ code, development; was very cumbersome due to a lengthy build process. To expedite development, a; plugin system was developed. This plugin machinery allows developers to access; the classes defined in the innards of PSI4, with only the small plugin; code requiring recompilation during development. The resulting lightweight; code can be maintained and distributed independently of PSI4, making this; a good strategy for development, especially in cases where tighter integration; of the new code with existing PSI4 machinery is required than that; afforded by the Numpy based strategy outlined in the Rapid initial development using Psi4NumPy; section. For details about how to write these plugins, see the; Creating New Plugins section. Incorporating code into PSI4¶; For features to be incorporated fully into the PSI4 ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let’s; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in PSI4 already",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:4343,Integrability,rout,routines,4343,"ng this; a good strategy for development, especially in cases where tighter integration; of the new code with existing PSI4 machinery is required than that; afforded by the Numpy based strategy outlined in the Rapid initial development using Psi4NumPy; section. For details about how to write these plugins, see the; Creating New Plugins section. Incorporating code into PSI4¶; For features to be incorporated fully into the PSI4 ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let’s; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in PSI4 already to perform tasks like these that are; required, e.g., for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in Exposing C++ code to Python. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that cater",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:4684,Integrability,rout,routines,4684,"4¶; For features to be incorporated fully into the PSI4 ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let’s; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in PSI4 already to perform tasks like these that are; required, e.g., for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in Exposing C++ code to Python. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths.; A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Pyth",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:4988,Integrability,rout,routines,4988," some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in PSI4 already to perform tasks like these that are; required, e.g., for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in Exposing C++ code to Python. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths.; A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out embarrassingly parallel workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated.; In SCF, we have a number of sources of external embeddi",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:2892,Modifiability,plugin,plugins,2892,"ing Psi4NumPy¶; The Psi4NumPy project [Smith:2018:3504] is the recommended; mechanism for developing and prototyping new methods in Psi4. Because; NumPy provides such a rich set of features for efficient linear; algebra, Fourier transforms, and general tensor manipulations, a massive number; of methods can be easily implemented very easily using that library. To; facilitate this workflow, PSI4 exports key quantities such as integrals,; densities and molecular orbitals in NumPy format. From this point, the; programmer can simply call the appropriate PSI4 functions to compute the; desired input quantities, retrieve them in NumPy format, and then write the; remaining code using standard Python and/or NumPy syntax. This approach does; not require any recompilation of code, resulting in a particularly facile; development workflow. Detailed examples and tutorials are available in the; Psi4NumPy repository. Avoiding the need to modify Psi4, using plugins¶; In the early days when PSI4 was still primarily a C++ code, development; was very cumbersome due to a lengthy build process. To expedite development, a; plugin system was developed. This plugin machinery allows developers to access; the classes defined in the innards of PSI4, with only the small plugin; code requiring recompilation during development. The resulting lightweight; code can be maintained and distributed independently of PSI4, making this; a good strategy for development, especially in cases where tighter integration; of the new code with existing PSI4 machinery is required than that; afforded by the Numpy based strategy outlined in the Rapid initial development using Psi4NumPy; section. For details about how to write these plugins, see the; Creating New Plugins section. Incorporating code into PSI4¶; For features to be incorporated fully into the PSI4 ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task i",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:3055,Modifiability,plugin,plugin,3055," new methods in Psi4. Because; NumPy provides such a rich set of features for efficient linear; algebra, Fourier transforms, and general tensor manipulations, a massive number; of methods can be easily implemented very easily using that library. To; facilitate this workflow, PSI4 exports key quantities such as integrals,; densities and molecular orbitals in NumPy format. From this point, the; programmer can simply call the appropriate PSI4 functions to compute the; desired input quantities, retrieve them in NumPy format, and then write the; remaining code using standard Python and/or NumPy syntax. This approach does; not require any recompilation of code, resulting in a particularly facile; development workflow. Detailed examples and tutorials are available in the; Psi4NumPy repository. Avoiding the need to modify Psi4, using plugins¶; In the early days when PSI4 was still primarily a C++ code, development; was very cumbersome due to a lengthy build process. To expedite development, a; plugin system was developed. This plugin machinery allows developers to access; the classes defined in the innards of PSI4, with only the small plugin; code requiring recompilation during development. The resulting lightweight; code can be maintained and distributed independently of PSI4, making this; a good strategy for development, especially in cases where tighter integration; of the new code with existing PSI4 machinery is required than that; afforded by the Numpy based strategy outlined in the Rapid initial development using Psi4NumPy; section. For details about how to write these plugins, see the; Creating New Plugins section. Incorporating code into PSI4¶; For features to be incorporated fully into the PSI4 ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let’s; consider a new feature that downloads some data from an external source and; then performs some kind ",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:3089,Modifiability,plugin,plugin,3089,"ansforms, and general tensor manipulations, a massive number; of methods can be easily implemented very easily using that library. To; facilitate this workflow, PSI4 exports key quantities such as integrals,; densities and molecular orbitals in NumPy format. From this point, the; programmer can simply call the appropriate PSI4 functions to compute the; desired input quantities, retrieve them in NumPy format, and then write the; remaining code using standard Python and/or NumPy syntax. This approach does; not require any recompilation of code, resulting in a particularly facile; development workflow. Detailed examples and tutorials are available in the; Psi4NumPy repository. Avoiding the need to modify Psi4, using plugins¶; In the early days when PSI4 was still primarily a C++ code, development; was very cumbersome due to a lengthy build process. To expedite development, a; plugin system was developed. This plugin machinery allows developers to access; the classes defined in the innards of PSI4, with only the small plugin; code requiring recompilation during development. The resulting lightweight; code can be maintained and distributed independently of PSI4, making this; a good strategy for development, especially in cases where tighter integration; of the new code with existing PSI4 machinery is required than that; afforded by the Numpy based strategy outlined in the Rapid initial development using Psi4NumPy; section. For details about how to write these plugins, see the; Creating New Plugins section. Incorporating code into PSI4¶; For features to be incorporated fully into the PSI4 ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let’s; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from exter",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:3199,Modifiability,plugin,plugin,3199,"ansforms, and general tensor manipulations, a massive number; of methods can be easily implemented very easily using that library. To; facilitate this workflow, PSI4 exports key quantities such as integrals,; densities and molecular orbitals in NumPy format. From this point, the; programmer can simply call the appropriate PSI4 functions to compute the; desired input quantities, retrieve them in NumPy format, and then write the; remaining code using standard Python and/or NumPy syntax. This approach does; not require any recompilation of code, resulting in a particularly facile; development workflow. Detailed examples and tutorials are available in the; Psi4NumPy repository. Avoiding the need to modify Psi4, using plugins¶; In the early days when PSI4 was still primarily a C++ code, development; was very cumbersome due to a lengthy build process. To expedite development, a; plugin system was developed. This plugin machinery allows developers to access; the classes defined in the innards of PSI4, with only the small plugin; code requiring recompilation during development. The resulting lightweight; code can be maintained and distributed independently of PSI4, making this; a good strategy for development, especially in cases where tighter integration; of the new code with existing PSI4 machinery is required than that; afforded by the Numpy based strategy outlined in the Rapid initial development using Psi4NumPy; section. For details about how to write these plugins, see the; Creating New Plugins section. Incorporating code into PSI4¶; For features to be incorporated fully into the PSI4 ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let’s; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from exter",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:3648,Modifiability,plugin,plugins,3648,"yntax. This approach does; not require any recompilation of code, resulting in a particularly facile; development workflow. Detailed examples and tutorials are available in the; Psi4NumPy repository. Avoiding the need to modify Psi4, using plugins¶; In the early days when PSI4 was still primarily a C++ code, development; was very cumbersome due to a lengthy build process. To expedite development, a; plugin system was developed. This plugin machinery allows developers to access; the classes defined in the innards of PSI4, with only the small plugin; code requiring recompilation during development. The resulting lightweight; code can be maintained and distributed independently of PSI4, making this; a good strategy for development, especially in cases where tighter integration; of the new code with existing PSI4 machinery is required than that; afforded by the Numpy based strategy outlined in the Rapid initial development using Psi4NumPy; section. For details about how to write these plugins, see the; Creating New Plugins section. Incorporating code into PSI4¶; For features to be incorporated fully into the PSI4 ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let’s; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possi",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:6342,Modifiability,maintainab,maintainability,6342," in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in Exposing C++ code to Python. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths.; A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out embarrassingly parallel workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated.; In SCF, we have a number of sources of external embedding potentials that could; enter the calculation. Allowing Python to handle only the details of driving; the SCF iterations, such as external potentials and convergence acceleration; methods, but deferring to C++ to do the heavy lifting for building and; diagonalizing the Fock matrix also takes advantage of the two languages’; strengths and improves maintainability of the code. table of contents. Ways to Add Code: Psi4NumPy, Plugins, Full Integration; Easier and more rapid development; Rapid initial development using Psi4NumPy; Avoiding the need to modify Psi4, using plugins; Incorporating code into PSI4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Ways to Add Code: Psi4NumPy, Plugins, Full Integration. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:6564,Modifiability,plugin,plugins,6564," in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in Exposing C++ code to Python. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths.; A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out embarrassingly parallel workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated.; In SCF, we have a number of sources of external embedding potentials that could; enter the calculation. Allowing Python to handle only the details of driving; the SCF iterations, such as external potentials and convergence acceleration; methods, but deferring to C++ to do the heavy lifting for building and; diagonalizing the Fock matrix also takes advantage of the two languages’; strengths and improves maintainability of the code. table of contents. Ways to Add Code: Psi4NumPy, Plugins, Full Integration; Easier and more rapid development; Rapid initial development using Psi4NumPy; Avoiding the need to modify Psi4, using plugins; Incorporating code into PSI4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Ways to Add Code: Psi4NumPy, Plugins, Full Integration. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:553,Performance,perform,performed,553,"﻿. Ways to Add Code: Psi4NumPy, Plugins, Full Integration. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Ways to Add Code: Psi4NumPy, Plugins, Full Integration. Ways to Add Code: Psi4NumPy, Plugins, Full Integration¶. Easier and more rapid development¶; Fully-featured electronic structure programs are large and complex. However,; the PSI4 ecosystem provides a path for easier and more rapid development; of new features. The earliest versions of PSI4 were written by merging; individual executables that performed specific tasks into a unified C++; executable. By linking this C++ executable against the Python interpreter, the; individual modules could be called in any sequence, enabling a very diverse; range of tasks to be accomplished within a given input. Although Python-driven; model allowed for great flexibility from a user’s perspective, programming was; still relatively difficult because it required modifications to be made in C++; code.; Since those early days, the code has undergone some important structural; changes that have greatly simplified the development workflow. These changes; were motivated by the realization that only a few bottlenecks exist in a typical; calculation; by focusing on optimized C++ implementations of these bottlenecks; and making these C++ functions available in Python, most of the code to implement; the overall calculation can be written in simpler Python code. Python is far; better suited to management tasks such as directory navigation and retrieval,; making it a natural choice for overall calculation layout than C++. With the; emergence of NumPy as a standard tool for executing almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. Rapid initial development using Psi4NumPy¶; The Psi4NumPy project [Smith:2018:3504] is the ",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:1204,Performance,bottleneck,bottlenecks,1204,"; Fully-featured electronic structure programs are large and complex. However,; the PSI4 ecosystem provides a path for easier and more rapid development; of new features. The earliest versions of PSI4 were written by merging; individual executables that performed specific tasks into a unified C++; executable. By linking this C++ executable against the Python interpreter, the; individual modules could be called in any sequence, enabling a very diverse; range of tasks to be accomplished within a given input. Although Python-driven; model allowed for great flexibility from a user’s perspective, programming was; still relatively difficult because it required modifications to be made in C++; code.; Since those early days, the code has undergone some important structural; changes that have greatly simplified the development workflow. These changes; were motivated by the realization that only a few bottlenecks exist in a typical; calculation; by focusing on optimized C++ implementations of these bottlenecks; and making these C++ functions available in Python, most of the code to implement; the overall calculation can be written in simpler Python code. Python is far; better suited to management tasks such as directory navigation and retrieval,; making it a natural choice for overall calculation layout than C++. With the; emergence of NumPy as a standard tool for executing almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. Rapid initial development using Psi4NumPy¶; The Psi4NumPy project [Smith:2018:3504] is the recommended; mechanism for developing and prototyping new methods in Psi4. Because; NumPy provides such a rich set of features for efficient linear; algebra, Fourier transforms, and general tensor manipulations, a massive number; of methods can be easily implemented very easily using that library. ",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:1264,Performance,optimiz,optimized,1264,"; Fully-featured electronic structure programs are large and complex. However,; the PSI4 ecosystem provides a path for easier and more rapid development; of new features. The earliest versions of PSI4 were written by merging; individual executables that performed specific tasks into a unified C++; executable. By linking this C++ executable against the Python interpreter, the; individual modules could be called in any sequence, enabling a very diverse; range of tasks to be accomplished within a given input. Although Python-driven; model allowed for great flexibility from a user’s perspective, programming was; still relatively difficult because it required modifications to be made in C++; code.; Since those early days, the code has undergone some important structural; changes that have greatly simplified the development workflow. These changes; were motivated by the realization that only a few bottlenecks exist in a typical; calculation; by focusing on optimized C++ implementations of these bottlenecks; and making these C++ functions available in Python, most of the code to implement; the overall calculation can be written in simpler Python code. Python is far; better suited to management tasks such as directory navigation and retrieval,; making it a natural choice for overall calculation layout than C++. With the; emergence of NumPy as a standard tool for executing almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. Rapid initial development using Psi4NumPy¶; The Psi4NumPy project [Smith:2018:3504] is the recommended; mechanism for developing and prototyping new methods in Psi4. Because; NumPy provides such a rich set of features for efficient linear; algebra, Fourier transforms, and general tensor manipulations, a massive number; of methods can be easily implemented very easily using that library. ",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:1303,Performance,bottleneck,bottlenecks,1303,"; Fully-featured electronic structure programs are large and complex. However,; the PSI4 ecosystem provides a path for easier and more rapid development; of new features. The earliest versions of PSI4 were written by merging; individual executables that performed specific tasks into a unified C++; executable. By linking this C++ executable against the Python interpreter, the; individual modules could be called in any sequence, enabling a very diverse; range of tasks to be accomplished within a given input. Although Python-driven; model allowed for great flexibility from a user’s perspective, programming was; still relatively difficult because it required modifications to be made in C++; code.; Since those early days, the code has undergone some important structural; changes that have greatly simplified the development workflow. These changes; were motivated by the realization that only a few bottlenecks exist in a typical; calculation; by focusing on optimized C++ implementations of these bottlenecks; and making these C++ functions available in Python, most of the code to implement; the overall calculation can be written in simpler Python code. Python is far; better suited to management tasks such as directory navigation and retrieval,; making it a natural choice for overall calculation layout than C++. With the; emergence of NumPy as a standard tool for executing almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. Rapid initial development using Psi4NumPy¶; The Psi4NumPy project [Smith:2018:3504] is the recommended; mechanism for developing and prototyping new methods in Psi4. Because; NumPy provides such a rich set of features for efficient linear; algebra, Fourier transforms, and general tensor manipulations, a massive number; of methods can be easily implemented very easily using that library. ",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:4036,Performance,perform,performs,4036,"ess. To expedite development, a; plugin system was developed. This plugin machinery allows developers to access; the classes defined in the innards of PSI4, with only the small plugin; code requiring recompilation during development. The resulting lightweight; code can be maintained and distributed independently of PSI4, making this; a good strategy for development, especially in cases where tighter integration; of the new code with existing PSI4 machinery is required than that; afforded by the Numpy based strategy outlined in the Rapid initial development using Psi4NumPy; section. For details about how to write these plugins, see the; Creating New Plugins section. Incorporating code into PSI4¶; For features to be incorporated fully into the PSI4 ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let’s; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in PSI4 already to perform tasks like these that are; required, e.g., for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the ",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:4769,Performance,perform,perform,4769,"4¶; For features to be incorporated fully into the PSI4 ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let’s; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in PSI4 already to perform tasks like these that are; required, e.g., for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in Exposing C++ code to Python. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths.; A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Pyth",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:4925,Performance,perform,performs,4925," some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in PSI4 already to perform tasks like these that are; required, e.g., for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in Exposing C++ code to Python. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths.; A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out embarrassingly parallel workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated.; In SCF, we have a number of sources of external embeddi",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:3127,Security,access,access,3127,"ansforms, and general tensor manipulations, a massive number; of methods can be easily implemented very easily using that library. To; facilitate this workflow, PSI4 exports key quantities such as integrals,; densities and molecular orbitals in NumPy format. From this point, the; programmer can simply call the appropriate PSI4 functions to compute the; desired input quantities, retrieve them in NumPy format, and then write the; remaining code using standard Python and/or NumPy syntax. This approach does; not require any recompilation of code, resulting in a particularly facile; development workflow. Detailed examples and tutorials are available in the; Psi4NumPy repository. Avoiding the need to modify Psi4, using plugins¶; In the early days when PSI4 was still primarily a C++ code, development; was very cumbersome due to a lengthy build process. To expedite development, a; plugin system was developed. This plugin machinery allows developers to access; the classes defined in the innards of PSI4, with only the small plugin; code requiring recompilation during development. The resulting lightweight; code can be maintained and distributed independently of PSI4, making this; a good strategy for development, especially in cases where tighter integration; of the new code with existing PSI4 machinery is required than that; afforded by the Numpy based strategy outlined in the Rapid initial development using Psi4NumPy; section. For details about how to write these plugins, see the; Creating New Plugins section. Incorporating code into PSI4¶; For features to be incorporated fully into the PSI4 ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let’s; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from exter",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:5520,Testability,log,logic,5520,"; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in PSI4 already to perform tasks like these that are; required, e.g., for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in Exposing C++ code to Python. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths.; A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out embarrassingly parallel workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated.; In SCF, we have a number of sources of external embedding potentials that could; enter the calculation. Allowing Python to handle only the details of driving; the SCF iterations, such as external potentials and convergence acceleration; methods, but deferring to C++ to do the heavy lifting for building and; diagonalizing the Fock matrix also takes advantage of the two languages’; strengths and improves maintainability of the code. table of contents. Ways to Add Code: Psi4NumPy, Plugins, Full Integration; Easier and more rapid development; Rapid initial development using Psi4NumPy; Avoiding the need to modify Psi4, using plugin",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:1102,Usability,simpl,simplified,1102,". Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Ways to Add Code: Psi4NumPy, Plugins, Full Integration. Ways to Add Code: Psi4NumPy, Plugins, Full Integration¶. Easier and more rapid development¶; Fully-featured electronic structure programs are large and complex. However,; the PSI4 ecosystem provides a path for easier and more rapid development; of new features. The earliest versions of PSI4 were written by merging; individual executables that performed specific tasks into a unified C++; executable. By linking this C++ executable against the Python interpreter, the; individual modules could be called in any sequence, enabling a very diverse; range of tasks to be accomplished within a given input. Although Python-driven; model allowed for great flexibility from a user’s perspective, programming was; still relatively difficult because it required modifications to be made in C++; code.; Since those early days, the code has undergone some important structural; changes that have greatly simplified the development workflow. These changes; were motivated by the realization that only a few bottlenecks exist in a typical; calculation; by focusing on optimized C++ implementations of these bottlenecks; and making these C++ functions available in Python, most of the code to implement; the overall calculation can be written in simpler Python code. Python is far; better suited to management tasks such as directory navigation and retrieval,; making it a natural choice for overall calculation layout than C++. With the; emergence of NumPy as a standard tool for executing almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. Rapid initial development using Psi4NumPy¶; The Psi4NumPy project [Smith:2018:3504] is the recommended; mechanism for developing and prototyping new methods in",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:1441,Usability,simpl,simpler,1441,"; Fully-featured electronic structure programs are large and complex. However,; the PSI4 ecosystem provides a path for easier and more rapid development; of new features. The earliest versions of PSI4 were written by merging; individual executables that performed specific tasks into a unified C++; executable. By linking this C++ executable against the Python interpreter, the; individual modules could be called in any sequence, enabling a very diverse; range of tasks to be accomplished within a given input. Although Python-driven; model allowed for great flexibility from a user’s perspective, programming was; still relatively difficult because it required modifications to be made in C++; code.; Since those early days, the code has undergone some important structural; changes that have greatly simplified the development workflow. These changes; were motivated by the realization that only a few bottlenecks exist in a typical; calculation; by focusing on optimized C++ implementations of these bottlenecks; and making these C++ functions available in Python, most of the code to implement; the overall calculation can be written in simpler Python code. Python is far; better suited to management tasks such as directory navigation and retrieval,; making it a natural choice for overall calculation layout than C++. With the; emergence of NumPy as a standard tool for executing almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. Rapid initial development using Psi4NumPy¶; The Psi4NumPy project [Smith:2018:3504] is the recommended; mechanism for developing and prototyping new methods in Psi4. Because; NumPy provides such a rich set of features for efficient linear; algebra, Fourier transforms, and general tensor manipulations, a massive number; of methods can be easily implemented very easily using that library. ",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:1813,Usability,simpl,simpler,1813,"sks to be accomplished within a given input. Although Python-driven; model allowed for great flexibility from a user’s perspective, programming was; still relatively difficult because it required modifications to be made in C++; code.; Since those early days, the code has undergone some important structural; changes that have greatly simplified the development workflow. These changes; were motivated by the realization that only a few bottlenecks exist in a typical; calculation; by focusing on optimized C++ implementations of these bottlenecks; and making these C++ functions available in Python, most of the code to implement; the overall calculation can be written in simpler Python code. Python is far; better suited to management tasks such as directory navigation and retrieval,; making it a natural choice for overall calculation layout than C++. With the; emergence of NumPy as a standard tool for executing almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. Rapid initial development using Psi4NumPy¶; The Psi4NumPy project [Smith:2018:3504] is the recommended; mechanism for developing and prototyping new methods in Psi4. Because; NumPy provides such a rich set of features for efficient linear; algebra, Fourier transforms, and general tensor manipulations, a massive number; of methods can be easily implemented very easily using that library. To; facilitate this workflow, PSI4 exports key quantities such as integrals,; densities and molecular orbitals in NumPy format. From this point, the; programmer can simply call the appropriate PSI4 functions to compute the; desired input quantities, retrieve them in NumPy format, and then write the; remaining code using standard Python and/or NumPy syntax. This approach does; not require any recompilation of code, resulting in a particularly facile; development ",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:2465,Usability,simpl,simply,2465,"d retrieval,; making it a natural choice for overall calculation layout than C++. With the; emergence of NumPy as a standard tool for executing almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. Rapid initial development using Psi4NumPy¶; The Psi4NumPy project [Smith:2018:3504] is the recommended; mechanism for developing and prototyping new methods in Psi4. Because; NumPy provides such a rich set of features for efficient linear; algebra, Fourier transforms, and general tensor manipulations, a massive number; of methods can be easily implemented very easily using that library. To; facilitate this workflow, PSI4 exports key quantities such as integrals,; densities and molecular orbitals in NumPy format. From this point, the; programmer can simply call the appropriate PSI4 functions to compute the; desired input quantities, retrieve them in NumPy format, and then write the; remaining code using standard Python and/or NumPy syntax. This approach does; not require any recompilation of code, resulting in a particularly facile; development workflow. Detailed examples and tutorials are available in the; Psi4NumPy repository. Avoiding the need to modify Psi4, using plugins¶; In the early days when PSI4 was still primarily a C++ code, development; was very cumbersome due to a lengthy build process. To expedite development, a; plugin system was developed. This plugin machinery allows developers to access; the classes defined in the innards of PSI4, with only the small plugin; code requiring recompilation during development. The resulting lightweight; code can be maintained and distributed independently of PSI4, making this; a good strategy for development, especially in cases where tighter integration; of the new code with existing PSI4 machinery is required than that; afforded by the Numpy based strategy ",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:4323,Usability,simpl,simply,4323,"ng this; a good strategy for development, especially in cases where tighter integration; of the new code with existing PSI4 machinery is required than that; afforded by the Numpy based strategy outlined in the Rapid initial development using Psi4NumPy; section. For details about how to write these plugins, see the; Creating New Plugins section. Incorporating code into PSI4¶; For features to be incorporated fully into the PSI4 ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let’s; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in PSI4 already to perform tasks like these that are; required, e.g., for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in Exposing C++ code to Python. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that cater",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:4620,Usability,clear,clear,4620,"outlined in the Rapid initial development using Psi4NumPy; section. For details about how to write these plugins, see the; Creating New Plugins section. Incorporating code into PSI4¶; For features to be incorporated fully into the PSI4 ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let’s; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in PSI4 already to perform tasks like these that are; required, e.g., for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in Exposing C++ code to Python. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths.; A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the ",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:4882,Usability,simpl,simple,4882," some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in PSI4 already to perform tasks like these that are; required, e.g., for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in Exposing C++ code to Python. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths.; A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out embarrassingly parallel workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated.; In SCF, we have a number of sources of external embeddi",MatchSource.WIKI,psi4manual/1.6.x/prog_ways_to_add.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html
https://psicode.org/psi4manual/1.6.x/prog_welcome.html:655,Deployability,update,updated,655,"﻿. Welcome to New Programmers. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Introduction to Programming in PSI4; Welcome to New Programmers. Welcome to New Programmers¶. The PSI4 community¶; PSI4 is an open-source project and welcomes contributions from; developers around the world. etc. We have annual meetings, we welcome; feedback, slack channel, etc. table of contents. Welcome to New Programmers; The PSI4 community. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Introduction to Programming in PSI4; Welcome to New Programmers. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prog_welcome.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_welcome.html
https://psicode.org/psi4manual/1.6.x/prog_welcome.html:349,Usability,feedback,feedback,349,"﻿. Welcome to New Programmers. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Introduction to Programming in PSI4; Welcome to New Programmers. Welcome to New Programmers¶. The PSI4 community¶; PSI4 is an open-source project and welcomes contributions from; developers around the world. etc. We have annual meetings, we welcome; feedback, slack channel, etc. table of contents. Welcome to New Programmers; The PSI4 community. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Introduction to Programming in PSI4; Welcome to New Programmers. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prog_welcome.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_welcome.html
https://psicode.org/psi4manual/1.6.x/prop.html:1758,Deployability,configurat,configurational,1758,"ole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples. >>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Property. © Copyright 2022, The Psi4 Project.; Last updated on Thur",MatchSource.WIKI,psi4manual/1.6.x/prop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prop.html
https://psicode.org/psi4manual/1.6.x/prop.html:2775,Deployability,update,updated,2775,"ster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples. >>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Property. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/prop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prop.html
https://psicode.org/psi4manual/1.6.x/prop.html:1758,Modifiability,config,configurational,1758,"ole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples. >>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Property. © Copyright 2022, The Psi4 Project.; Last updated on Thur",MatchSource.WIKI,psi4manual/1.6.x/prop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prop.html
https://psicode.org/psi4manual/1.6.x/prop.html:1034,Performance,optimiz,optimized,1034,"SI4. Psithon Functions: Invoking a Calculation; Property. Property¶. psi4.properties(name[, properties, molecule])[source]; Function to compute various properties. Aliases; prop(). Returns; none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters. name (str) – 'ccsd' || etc.; F",MatchSource.WIKI,psi4manual/1.6.x/prop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prop.html
https://psicode.org/psi4manual/1.6.x/prop.html:1149,Performance,optimiz,optimized,1149,"source]; Function to compute various properties. Aliases; prop(). Returns; none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (Lis",MatchSource.WIKI,psi4manual/1.6.x/prop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prop.html
https://psicode.org/psi4manual/1.6.x/prop.html:1265,Performance,optimiz,optimized,1265,"none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability'",MatchSource.WIKI,psi4manual/1.6.x/prop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prop.html
https://psicode.org/psi4manual/1.6.x/prop.html:1350,Performance,optimiz,optimized,1350," limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole an",MatchSource.WIKI,psi4manual/1.6.x/prop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prop.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:5754,Availability,avail,available,5754,"ep, restricted, ...); Write integrals to file in FCIDUMP format. finalize(); Called upon psi4 module exit to closes timers and I/O. flush_outfile(); Flushes the output file. fnocc(ref_wfn); Runs the FNO-CCSD(T)/QCISD(T)/MP4/CEPA energy code. get_active_molecule(); Returns the currently active molecule object. get_array_variable(key). Deprecated since version 1.4. get_array_variables(). Deprecated since version 1.4. get_atomic_point_charges(). Deprecated since version 1.4. get_datadir(); Returns the path to shared text resources, PSIDATADIR. get_global_option(key); Return keyword key value at global (all-module) scope. get_global_option_list(); Returns a list of all global options. get_gradient(). Deprecated since version 1.2. get_legacy_gradient(); Returns the global gradient as a (nat, 3) Matrix object. get_legacy_molecule(); Returns the currently active legacy molecule object. get_local_option(module, key); Return keyword key value at module scope. get_memory(); Returns the amount of memory available to Psi (in bytes). get_num_threads(); Returns the number of threads to use in SMP parallel computations. get_option(module, key); Return keyword key value used by module. get_options(); Get options. get_output_file(); Returns output file name (stem + suffix, no directory). get_variable(key). Deprecated since version 1.4. get_variables(). Deprecated since version 1.4. get_writer_file_prefix(molecule_name); Returns the prefix to use for writing files for external programs. git_version(). Deprecated since version 1.4. has_array_variable(key); Is the Matrix QCVariable key (case-insensitive) set? Prefer has_variable(). has_global_option_changed(key); Whether keyword key value has been touched at global (all-module) scope. has_local_option_changed(module, key); Whether keyword key value has been touched at module scope. has_option_changed(module, key); Whether keyword key value has been touched or is default. has_scalar_variable(key); Is the double QCVariable key (case-inse",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:10300,Availability,avail,available,10300,"tes a previously defined molecule in global memory so next computations use it. set_array_variable(key, value); Sets the requested (case-insensitive) Matrix QCVariable; prefer set_variable(). set_datadir(psidatadir); Sets the path to shared text resources, PSIDATADIR. set_global_option(*args, **kwargs); Overloaded function. set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_gradient(val). Deprecated since version 1.2. set_legacy_gradient(grad); Assigns the global gradient to the values in the (nat, 3) Matrix argument. set_legacy_molecule(molecule); Activates a previously defined molecule in global memory so next computations use it. set_legacy_wavefunction(wfn); Sets the current legacy_wavefunction object from the most recent computation. set_local_option(*args, **kwargs); Overloaded function. set_local_option_python(key, value); Sets value to Python keyword key scoped only to a single module. set_memory_bytes(memory[, quiet]); Sets the memory available to Psi (in bytes); prefer psi4.set_memory(). set_num_threads(nthread[, quiet]); Sets the number of threads to use in SMP parallel computations. set_output_file(*args, **kwargs); Overloaded function. set_psi_file_prefix(). Deprecated since version 1.4. set_scalar_variable(key, value); Sets the double QCVariable key (case-insensitive); prefer set_variable(). set_variable(key, val); Sets scalar or array QCVariable key to val in global memory. timer_off(label); Stop timer with label. timer_on(label); Start timer with label. triplet(A, B, C[, transA, transB, transC]); Returns the multiplication of three matrices, with options to transpose each beforehand. tstart(); Start module-level timer. tstop(); Stop module-level timer. variable(key); Return copy of scalar or array QCVariable key from global memory. variables([include_deprecated_keys]); Return all scalar or array QCVariables from global memory. version(). Deprecated since version 1.4. Classes¶. AOShellCombinationsIterator",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:17184,Availability,checkpoint,checkpoint,17184,"e2; docstring. psio_entry; docstring. Class Inheritance Diagram¶. psi4.driver Package¶. Functions¶. activate(mol); Function to set molecule object mol as the current active molecule. ancestor(dir[, n]); Get the nth ancestor of a directory. banner(text[, type, width, strNotOutfile]); Function to print text to output file in a banner of minimum width width and minimum three-line height for type = 1 or one-line height for type = 2. basis_helper(block[, name, key, set_option]); For PsiAPI mode, forms a basis specification function from block and associates it with keyword key under handle name. cbs(func, label, **kwargs); Function to define a multistage energy method from combinations of basis set extrapolations and delta corrections and condense the components into a minimum number of calculations. check_iwl_file_from_scf_type(scf_type, wfn); Ensures that a IWL file has been written based on input SCF type. compare_fchkfiles(expected, computed, ...); Comparison function for output data in FCHK (formatted checkpoint) file format. compare_fcidumps(expected, computed, label); Comparison function for FCIDUMP files. compare_moldenfiles(expected, computed[, ...]); Comparison function for output data in Molden file format. copy_file_from_scratch(filename, prefix, ...); Function to move file out of scratch with correct naming convention. copy_file_to_scratch(filename, prefix, ...); Function to move file into scratch with correct naming convention. create_plugin(name, template). rtype; None. cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. dynamic_variable_bind(cls); Function to dynamically add extra members to the core.Molecule class. energies_from_fcidump(intdump). energy(name, **kwargs); Function to compute the single-point electronic energy. fchk(wfn, filename, *[, debug, strict_label]); Function to write wavefunction information in wfn to filename in Gaussian FCHK format. fchkfile_to_string(fname); Load FCHK file into a string. fcidump(wfn[, ",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:20240,Availability,error,error,20240,"broker(LOT[, molecule, serverdata, options]); Run IPIBroker to connect to i-pi. join_path(prefix, *args). levenshtein(seq1, seq2); Compute the Levenshtein distance between two strings. mdi_run(scf_method, **kwargs); Begin functioning as an MDI engine. message_box([message, max_width, min_width]); put a message string into a box for extra attention. molden(wfn[, filename, density_a, ...]); Function to write wavefunction information in wfn to filename in molden format. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. optimize_geometric(name, **kwargs). pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout(stuff); Function to print stuff to standard output stream. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ref_wfn, ...); Builds the correct (R/U/RO/CU HF/KS) wavefunction from the provided information, sets relevant auxiliary basis sets on it, and prepares any empirical dispersion. set_memory(inputval[, execute, quiet]); Function to reset th",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:22201,Availability,avail,available,22201,", execute, quiet]); Function to reset the total memory allocation. set_module_options(module, options_dict); Sets Psi4 module options from a module specification and input dictionary. set_options(options_dict[, verbose]); Sets Psi4 options from an input dictionary. tdscf(wfn, **kwargs). temp_circular_import_blocker(). vibanal_wfn(wfn[, hess, irrep, molecule, ...]); Function to perform analysis of a hessian or hessian block, specifically. write_eigenvalues(eigs, mo_idx); Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file. Classes¶. AtomicComputer(**data); Computer for analytic single-geometry computations. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, iteration); Error called for problems with converging an iterative method. Dftd3Error(msg). EmpiricalDispersion(*[, name_hint, ...]); Lightweight unification of empirical dispersion calculation modes. ManagedMethodError(circs). MissingMethodError(msg); Error called when method not available. OptimizationConvergenceError(...); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(); Hold charges and psi4.core.ExternalPotential. QMMMbohr(); Hold charges and psi4.core.ExternalPotential. SCFConvergenceError(eqn_description, ...); Error called for problems with SCF iterations. TDSCFConvergenceError(iteration, wfn, what, ...); Error called for problems with TDSCF iterations. Table([rows, row_label_width, ...]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. UpgradeHelper(old, new, version, elaboration); Error called on",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:4369,Deployability,configurat,configuration,4369,"ian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ccresponse(ref_wfn); Runs the coupled cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. cctriples(ref_wfn); Runs the coupled cluster (T) energy code. clean(); Remove scratch files. clean_options(); Reset options to clean state. clean_timers(); Reinitialize timers for independent timer.dat entries. clean_variables(); Empties all double and Matrix QCVariables that have been set in global memory. close_outfile(); Closes the output file. dct(ref_wfn); Runs the density cumulant (functional) theory code. del_array_variable(key); Removes the Matrix QCVariable key (case-insensitive); prefer del_variable(). del_scalar_variable(key); Removes the double QCVariable key (case-insensitive); prefer del_variable(). del_variable(key); Removes scalar or array QCVariable key from global memory if present. detci(ref_wfn); Runs the determinant-based configuration interaction code. dfmp2(ref_wfn); Runs the DF-MP2 code. dfocc(ref_wfn); Runs the density-fitted orbital optimized CC codes. dlpno(arg0); Runs the DLPNO codes. dmrg(ref_wfn); Runs the CheMPS2 interface DMRG code. doublet(A, B[, transA, transB]); Returns the multiplication of two matrices A and B, with options to transpose each beforehand. fcidump_tei_helper(nirrep, restricted, ...); Write integrals to file in FCIDUMP format. finalize(); Called upon psi4 module exit to closes timers and I/O. flush_outfile(); Flushes the output file. fnocc(ref_wfn); Runs the FNO-CCSD(T)/QCISD(T)/MP4/CEPA energy code. get_active_molecule(); Returns the currently active molecule object. get_array_variable(key). Deprecated since version 1.4. get_array_variables(). Deprecated since version 1.4. get_atomic_point_charges(). Deprecated since version 1.4. get_datadir(); Returns the path to shared text resources, PSIDATADIR. get_global_option(key); Return keyword key value at global (all-module",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:23724,Deployability,update,updated,23724,"c single-geometry computations. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, iteration); Error called for problems with converging an iterative method. Dftd3Error(msg). EmpiricalDispersion(*[, name_hint, ...]); Lightweight unification of empirical dispersion calculation modes. ManagedMethodError(circs). MissingMethodError(msg); Error called when method not available. OptimizationConvergenceError(...); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(); Hold charges and psi4.core.ExternalPotential. QMMMbohr(); Hold charges and psi4.core.ExternalPotential. SCFConvergenceError(eqn_description, ...); Error called for problems with SCF iterations. TDSCFConvergenceError(iteration, wfn, what, ...); Error called for problems with TDSCF iterations. Table([rows, row_label_width, ...]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. UpgradeHelper(old, new, version, elaboration); Error called on previously valid syntax that now isn't and a simple syntax transition is possible. ValidationError(msg); Error called for problems with the input file. Class Inheritance Diagram¶. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Classes; Class Inheritance Diagram. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:3186,Energy Efficiency,energy,energy,3186," docstring. IDAMAX(arg0, arg1, arg2, arg3); docstring. adc(ref_wfn); Runs the ADC propagator code, for excited states. array_variable(key); Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). array_variables(); Returns dictionary of all Matrix QCVariables; prefer variables(). be_quiet(); Redirects output to /dev/null. benchmark_blas1(max_dim, min_time); Perform benchmark traverse of BLAS 1 routines. benchmark_blas2(max_dim, min_time); Perform benchmark traverse of BLAS 2 routines. benchmark_blas3(max_dim, min_time[, nthread]); Perform benchmark traverse of BLAS 3 routines. benchmark_disk(max_dim, min_time); Perform benchmark of PSIO disk performance. benchmark_integrals(max_am, min_time); Perform benchmark of psi integrals (of libmints type). benchmark_math(min_time); Perform benchmark of common double floating point operations including most of cmath. ccdensity(ref_wfn); Runs the code to compute coupled cluster density matrices. ccenergy(ref_wfn); Runs the coupled cluster energy code. cceom(ref_wfn); Runs the equation of motion coupled cluster code for excited states. cchbar(ref_wfn); Runs the code to generate the similarity transformed Hamiltonian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ccresponse(ref_wfn); Runs the coupled cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. cctriples(ref_wfn); Runs the coupled cluster (T) energy code. clean(); Remove scratch files. clean_options(); Reset options to clean state. clean_timers(); Reinitialize timers for independent timer.dat entries. clean_variables(); Empties all double and Matrix QCVariables that have been set in global memory. close_outfile(); Closes the output file. dct(ref_wfn); Runs the density cumulant (functional) theory code. del_array_variable(key); Removes the Matrix QCVariable key (case-insensitive); prefer del_variable(). del_scalar_variable(key); Removes th",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:3665,Energy Efficiency,energy,energy,3665,"enchmark traverse of BLAS 2 routines. benchmark_blas3(max_dim, min_time[, nthread]); Perform benchmark traverse of BLAS 3 routines. benchmark_disk(max_dim, min_time); Perform benchmark of PSIO disk performance. benchmark_integrals(max_am, min_time); Perform benchmark of psi integrals (of libmints type). benchmark_math(min_time); Perform benchmark of common double floating point operations including most of cmath. ccdensity(ref_wfn); Runs the code to compute coupled cluster density matrices. ccenergy(ref_wfn); Runs the coupled cluster energy code. cceom(ref_wfn); Runs the equation of motion coupled cluster code for excited states. cchbar(ref_wfn); Runs the code to generate the similarity transformed Hamiltonian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ccresponse(ref_wfn); Runs the coupled cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. cctriples(ref_wfn); Runs the coupled cluster (T) energy code. clean(); Remove scratch files. clean_options(); Reset options to clean state. clean_timers(); Reinitialize timers for independent timer.dat entries. clean_variables(); Empties all double and Matrix QCVariables that have been set in global memory. close_outfile(); Closes the output file. dct(ref_wfn); Runs the density cumulant (functional) theory code. del_array_variable(key); Removes the Matrix QCVariable key (case-insensitive); prefer del_variable(). del_scalar_variable(key); Removes the double QCVariable key (case-insensitive); prefer del_variable(). del_variable(key); Removes scalar or array QCVariable key from global memory if present. detci(ref_wfn); Runs the determinant-based configuration interaction code. dfmp2(ref_wfn); Runs the DF-MP2 code. dfocc(ref_wfn); Runs the density-fitted orbital optimized CC codes. dlpno(arg0); Runs the DLPNO codes. dmrg(ref_wfn); Runs the CheMPS2 interface DMRG code. doublet(A, B[, transA, transB]); Returns the multip",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:4975,Energy Efficiency,energy,energy,4975,"output file. dct(ref_wfn); Runs the density cumulant (functional) theory code. del_array_variable(key); Removes the Matrix QCVariable key (case-insensitive); prefer del_variable(). del_scalar_variable(key); Removes the double QCVariable key (case-insensitive); prefer del_variable(). del_variable(key); Removes scalar or array QCVariable key from global memory if present. detci(ref_wfn); Runs the determinant-based configuration interaction code. dfmp2(ref_wfn); Runs the DF-MP2 code. dfocc(ref_wfn); Runs the density-fitted orbital optimized CC codes. dlpno(arg0); Runs the DLPNO codes. dmrg(ref_wfn); Runs the CheMPS2 interface DMRG code. doublet(A, B[, transA, transB]); Returns the multiplication of two matrices A and B, with options to transpose each beforehand. fcidump_tei_helper(nirrep, restricted, ...); Write integrals to file in FCIDUMP format. finalize(); Called upon psi4 module exit to closes timers and I/O. flush_outfile(); Flushes the output file. fnocc(ref_wfn); Runs the FNO-CCSD(T)/QCISD(T)/MP4/CEPA energy code. get_active_molecule(); Returns the currently active molecule object. get_array_variable(key). Deprecated since version 1.4. get_array_variables(). Deprecated since version 1.4. get_atomic_point_charges(). Deprecated since version 1.4. get_datadir(); Returns the path to shared text resources, PSIDATADIR. get_global_option(key); Return keyword key value at global (all-module) scope. get_global_option_list(); Returns a list of all global options. get_gradient(). Deprecated since version 1.2. get_legacy_gradient(); Returns the global gradient as a (nat, 3) Matrix object. get_legacy_molecule(); Returns the currently active legacy molecule object. get_local_option(module, key); Return keyword key value at module scope. get_memory(); Returns the amount of memory available to Psi (in bytes). get_num_threads(); Returns the number of threads to use in SMP parallel computations. get_option(module, key); Return keyword key value used by module. get_options(); Get",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:8824,Energy Efficiency,adapt,adapted,8824,"oad the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. run_gdma(ref_wfn, datfilename); Runs the GDMA interface code. sapt(dimer_wfn, monoa_wfn, monob_wfn); Runs the symmetry adapted perturbation theory code. scalar_variable(key); Returns the double QCVariable key (case-insensitive); prefer variable(). scalar_variables(); Returns dictionary of all double QCVariables; prefer variables(). scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(ref_wfn); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(ref_wfn); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(molecule); Activates a previously defined molecule in global memory so next computations use it. set_array_variable(key, value); Sets the requested (case-insensitive) Matrix QCVariable; prefer set_variable(). set_datadir(psidatadir); Sets the path to shared text resources, PSIDATADIR. set_global_option(*args, **kwargs); Overloaded function. set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_gradient(val). Deprecated since version 1.2. set_legacy_gradient(grad); Assigns the global gr",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:11762,Energy Efficiency,adapt,adapted,11762,"l); Stop timer with label. timer_on(label); Start timer with label. triplet(A, B, C[, transA, transB, transC]); Returns the multiplication of three matrices, with options to transpose each beforehand. tstart(); Start module-level timer. tstop(); Stop module-level timer. variable(key); Return copy of scalar or array QCVariable key from global memory. variables([include_deprecated_keys]); Return all scalar or array QCVariables from global memory. version(). Deprecated since version 1.4. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CCWavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalc; Cartesian displacement SALC. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CharacterTable; Contains the character table of the point group. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFJCOSK; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor; docstring. Deriv; Computes gradients of wavefunctions. DerivCalcType; Members:. DiagonalizeOrder; Defines ordering of eigenvalues after diagonalization. Dimension; Initializes and defines Dimension Objects. DipoleInt; Computes dipole integrals. DirectJK; docstring. DiskSOMCSCF; docstring. Dispersion; docstring. ERI; Computes normal two electron repulsion integrals. ERISieve; docstring. ESPPropCalc; ESPPropCalc gives access to routines calculating the ESP on a grid. ElectricFieldInt; Computes electric field integrals. ElectrostaticInt; Computes electrostatic integrals. Exte",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:14327,Energy Efficiency,charge,charge,14327,"eometry. HF; docstring. IO; docstring. IOManager; PSIOManager is a class designed to be used as a static object to track all PSIO operations in a given PSI4 computation. IntVector; Class handling vectors with integer values. IntegralFactory; Computes integrals. IntegralTransform; IntegralTransform transforms one- and two-electron integrals within general spaces. IrreducibleRepresentation; An irreducible representation of the point group. JK; docstring. KineticInt; Computes kinetic integrals. LaplaceDenominator; docstring. LibXCFunctional; docstring. Localizer; Class containing orbital localization procedures. MOSpace; Defines orbital spaces in which to transform integrals. MOWriter; Writes the MOs. Matrix; Class for creating and manipulating matrices. MatrixFactory; Creates Matrix objects. MemDFJK; docstring. MintsHelper; Computes integrals. MoldenWriter; Writes wavefunction information in molden format. MolecularGrid; docstring. Molecule; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. MultipoleInt; Computes arbitrary-order multipole integrals. MultipoleSymmetry; docstring. NBOWriter; The Natural Bond Orbital Writer. NablaInt; Computes nabla integrals. OEProp; docstring. OneBodyAOInt; Basis class for all one-electron integrals. OneBodySOInt. Options; docstring. OrbitalSpace; Contains information about the orbitals. OverlapInt; Computes overlap integrals. PMLocalizer; Performs Pipek-Mezey orbital localization. PetiteList; Handles symmetry transformations. PointFunctions; docstring. PointGroup; Contains information about the point group. PotentialInt; Computes potential integrals. PrimitiveType; May be Normalized or Unnormalized. Prop; docstring. PsiReturnType; Return status. QuadrupoleInt; Computes quadrupole integrals. RHF; docstring. RKSFunctions; docstring. ROHF; docstring. SADGuess; docstring. SOBasisSet; An SOBasis object describes the transformation from an atomic orbital basis to a symmetry orbital basis",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:16825,Energy Efficiency,energy,energy,16825,"ctron repulsion integrals. UHF; docstring. UKSFunctions; docstring. VBase; docstring. Vector; Class for creating and manipulating vectors. Vector3; Class for vectors of length three, often Cartesian coordinate vectors, and their common operations. Wavefunction; docstring. dpdbuf4; docstring. dpdfile2; docstring. psio_entry; docstring. Class Inheritance Diagram¶. psi4.driver Package¶. Functions¶. activate(mol); Function to set molecule object mol as the current active molecule. ancestor(dir[, n]); Get the nth ancestor of a directory. banner(text[, type, width, strNotOutfile]); Function to print text to output file in a banner of minimum width width and minimum three-line height for type = 1 or one-line height for type = 2. basis_helper(block[, name, key, set_option]); For PsiAPI mode, forms a basis specification function from block and associates it with keyword key under handle name. cbs(func, label, **kwargs); Function to define a multistage energy method from combinations of basis set extrapolations and delta corrections and condense the components into a minimum number of calculations. check_iwl_file_from_scf_type(scf_type, wfn); Ensures that a IWL file has been written based on input SCF type. compare_fchkfiles(expected, computed, ...); Comparison function for output data in FCHK (formatted checkpoint) file format. compare_fcidumps(expected, computed, label); Comparison function for FCIDUMP files. compare_moldenfiles(expected, computed[, ...]); Comparison function for output data in Molden file format. copy_file_from_scratch(filename, prefix, ...); Function to move file out of scratch with correct naming convention. copy_file_to_scratch(filename, prefix, ...); Function to move file into scratch with correct naming convention. create_plugin(name, template). rtype; None. cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. dynamic_variable_bind(cls); Function to dynamically add extra members to the core.Molecule class. energies_from_fcidu",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:17882,Energy Efficiency,energy,energy,17882,"he components into a minimum number of calculations. check_iwl_file_from_scf_type(scf_type, wfn); Ensures that a IWL file has been written based on input SCF type. compare_fchkfiles(expected, computed, ...); Comparison function for output data in FCHK (formatted checkpoint) file format. compare_fcidumps(expected, computed, label); Comparison function for FCIDUMP files. compare_moldenfiles(expected, computed[, ...]); Comparison function for output data in Molden file format. copy_file_from_scratch(filename, prefix, ...); Function to move file out of scratch with correct naming convention. copy_file_to_scratch(filename, prefix, ...); Function to move file into scratch with correct naming convention. create_plugin(name, template). rtype; None. cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. dynamic_variable_bind(cls); Function to dynamically add extra members to the core.Molecule class. energies_from_fcidump(intdump). energy(name, **kwargs); Function to compute the single-point electronic energy. fchk(wfn, filename, *[, debug, strict_label]); Function to write wavefunction information in wfn to filename in Gaussian FCHK format. fchkfile_to_string(fname); Load FCHK file into a string. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. find_approximate_string_matches(seq1, ...); Find list of approximate (within max_distance) matches to string seq1 among options. free_atom_volumes(wfn, **kwargs); Computes free-atom volumes using MBIS density partitioning. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. frequency(name, **kwargs); Function to compute harmonic vibrational frequencies. gdma(wfn[, datafile]); Function to use wavefunction information in wfn and, if specified, additional commands in filename to run GDMA analysis. geomet",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:17954,Energy Efficiency,energy,energy,17954,"he components into a minimum number of calculations. check_iwl_file_from_scf_type(scf_type, wfn); Ensures that a IWL file has been written based on input SCF type. compare_fchkfiles(expected, computed, ...); Comparison function for output data in FCHK (formatted checkpoint) file format. compare_fcidumps(expected, computed, label); Comparison function for FCIDUMP files. compare_moldenfiles(expected, computed[, ...]); Comparison function for output data in Molden file format. copy_file_from_scratch(filename, prefix, ...); Function to move file out of scratch with correct naming convention. copy_file_to_scratch(filename, prefix, ...); Function to move file into scratch with correct naming convention. create_plugin(name, template). rtype; None. cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. dynamic_variable_bind(cls); Function to dynamically add extra members to the core.Molecule class. energies_from_fcidump(intdump). energy(name, **kwargs); Function to compute the single-point electronic energy. fchk(wfn, filename, *[, debug, strict_label]); Function to write wavefunction information in wfn to filename in Gaussian FCHK format. fchkfile_to_string(fname); Load FCHK file into a string. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. find_approximate_string_matches(seq1, ...); Find list of approximate (within max_distance) matches to string seq1 among options. free_atom_volumes(wfn, **kwargs); Computes free-atom volumes using MBIS density partitioning. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. frequency(name, **kwargs); Function to compute harmonic vibrational frequencies. gdma(wfn[, datafile]); Function to use wavefunction information in wfn and, if specified, additional commands in filename to run GDMA analysis. geomet",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:22634,Energy Efficiency,charge,charges,22634,"es(eigs, mo_idx); Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file. Classes¶. AtomicComputer(**data); Computer for analytic single-geometry computations. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, iteration); Error called for problems with converging an iterative method. Dftd3Error(msg). EmpiricalDispersion(*[, name_hint, ...]); Lightweight unification of empirical dispersion calculation modes. ManagedMethodError(circs). MissingMethodError(msg); Error called when method not available. OptimizationConvergenceError(...); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(); Hold charges and psi4.core.ExternalPotential. QMMMbohr(); Hold charges and psi4.core.ExternalPotential. SCFConvergenceError(eqn_description, ...); Error called for problems with SCF iterations. TDSCFConvergenceError(iteration, wfn, what, ...); Error called for problems with TDSCF iterations. Table([rows, row_label_width, ...]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. UpgradeHelper(old, new, version, elaboration); Error called on previously valid syntax that now isn't and a simple syntax transition is possible. ValidationError(msg); Error called for problems with the input file. Class Inheritance Diagram¶. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Classes; Class Inheritance Diagram. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:22692,Energy Efficiency,charge,charges,22692,"ticle eigenvalues to be written to the FCIDUMP file. Classes¶. AtomicComputer(**data); Computer for analytic single-geometry computations. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, iteration); Error called for problems with converging an iterative method. Dftd3Error(msg). EmpiricalDispersion(*[, name_hint, ...]); Lightweight unification of empirical dispersion calculation modes. ManagedMethodError(circs). MissingMethodError(msg); Error called when method not available. OptimizationConvergenceError(...); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(); Hold charges and psi4.core.ExternalPotential. QMMMbohr(); Hold charges and psi4.core.ExternalPotential. SCFConvergenceError(eqn_description, ...); Error called for problems with SCF iterations. TDSCFConvergenceError(iteration, wfn, what, ...); Error called for problems with TDSCF iterations. Table([rows, row_label_width, ...]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. UpgradeHelper(old, new, version, elaboration); Error called on previously valid syntax that now isn't and a simple syntax transition is possible. ValidationError(msg); Error called for problems with the input file. Class Inheritance Diagram¶. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Classes; Class Inheritance Diagram. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyrigh",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:2591,Integrability,rout,routines,2591,"3, arg4, arg5, ...); docstring. DSYR2(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYR2K(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYRK(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. IDAMAX(arg0, arg1, arg2, arg3); docstring. adc(ref_wfn); Runs the ADC propagator code, for excited states. array_variable(key); Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). array_variables(); Returns dictionary of all Matrix QCVariables; prefer variables(). be_quiet(); Redirects output to /dev/null. benchmark_blas1(max_dim, min_time); Perform benchmark traverse of BLAS 1 routines. benchmark_blas2(max_dim, min_time); Perform benchmark traverse of BLAS 2 routines. benchmark_blas3(max_dim, min_time[, nthread]); Perform benchmark traverse of BLAS 3 routines. benchmark_disk(max_dim, min_time); Perform benchmark of PSIO disk performance. benchmark_integrals(max_am, min_time); Perform benchmark of psi integrals (of libmints type). benchmark_math(min_time); Perform benchmark of common double floating point operations including most of cmath. ccdensity(ref_wfn); Runs the code to compute coupled cluster density matrices. ccenergy(ref_wfn); Runs the coupled cluster energy code. cceom(ref_wfn); Runs the equation of motion coupled cluster code for excited states. cchbar(ref_wfn); Runs the code to generate the similarity transformed Hamiltonian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ccresponse(ref_wfn); Runs the coupled cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and ",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:2674,Integrability,rout,routines,2674,"string. DSYR2K(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYRK(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. IDAMAX(arg0, arg1, arg2, arg3); docstring. adc(ref_wfn); Runs the ADC propagator code, for excited states. array_variable(key); Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). array_variables(); Returns dictionary of all Matrix QCVariables; prefer variables(). be_quiet(); Redirects output to /dev/null. benchmark_blas1(max_dim, min_time); Perform benchmark traverse of BLAS 1 routines. benchmark_blas2(max_dim, min_time); Perform benchmark traverse of BLAS 2 routines. benchmark_blas3(max_dim, min_time[, nthread]); Perform benchmark traverse of BLAS 3 routines. benchmark_disk(max_dim, min_time); Perform benchmark of PSIO disk performance. benchmark_integrals(max_am, min_time); Perform benchmark of psi integrals (of libmints type). benchmark_math(min_time); Perform benchmark of common double floating point operations including most of cmath. ccdensity(ref_wfn); Runs the code to compute coupled cluster density matrices. ccenergy(ref_wfn); Runs the coupled cluster energy code. cceom(ref_wfn); Runs the equation of motion coupled cluster code for excited states. cchbar(ref_wfn); Runs the code to generate the similarity transformed Hamiltonian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ccresponse(ref_wfn); Runs the coupled cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. cctriples(ref_wfn); Runs t",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:2768,Integrability,rout,routines,2768,"2, arg3, arg4, arg5, ...); docstring. DSYSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. IDAMAX(arg0, arg1, arg2, arg3); docstring. adc(ref_wfn); Runs the ADC propagator code, for excited states. array_variable(key); Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). array_variables(); Returns dictionary of all Matrix QCVariables; prefer variables(). be_quiet(); Redirects output to /dev/null. benchmark_blas1(max_dim, min_time); Perform benchmark traverse of BLAS 1 routines. benchmark_blas2(max_dim, min_time); Perform benchmark traverse of BLAS 2 routines. benchmark_blas3(max_dim, min_time[, nthread]); Perform benchmark traverse of BLAS 3 routines. benchmark_disk(max_dim, min_time); Perform benchmark of PSIO disk performance. benchmark_integrals(max_am, min_time); Perform benchmark of psi integrals (of libmints type). benchmark_math(min_time); Perform benchmark of common double floating point operations including most of cmath. ccdensity(ref_wfn); Runs the code to compute coupled cluster density matrices. ccenergy(ref_wfn); Runs the coupled cluster energy code. cceom(ref_wfn); Runs the equation of motion coupled cluster code for excited states. cchbar(ref_wfn); Runs the code to generate the similarity transformed Hamiltonian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ccresponse(ref_wfn); Runs the coupled cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. cctriples(ref_wfn); Runs the coupled cluster (T) energy code. clean(); Remove scratch files. clean_options(); Rese",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:4574,Integrability,interface,interface,4574," integrals for use in the coupled cluster codes. cctriples(ref_wfn); Runs the coupled cluster (T) energy code. clean(); Remove scratch files. clean_options(); Reset options to clean state. clean_timers(); Reinitialize timers for independent timer.dat entries. clean_variables(); Empties all double and Matrix QCVariables that have been set in global memory. close_outfile(); Closes the output file. dct(ref_wfn); Runs the density cumulant (functional) theory code. del_array_variable(key); Removes the Matrix QCVariable key (case-insensitive); prefer del_variable(). del_scalar_variable(key); Removes the double QCVariable key (case-insensitive); prefer del_variable(). del_variable(key); Removes scalar or array QCVariable key from global memory if present. detci(ref_wfn); Runs the determinant-based configuration interaction code. dfmp2(ref_wfn); Runs the DF-MP2 code. dfocc(ref_wfn); Runs the density-fitted orbital optimized CC codes. dlpno(arg0); Runs the DLPNO codes. dmrg(ref_wfn); Runs the CheMPS2 interface DMRG code. doublet(A, B[, transA, transB]); Returns the multiplication of two matrices A and B, with options to transpose each beforehand. fcidump_tei_helper(nirrep, restricted, ...); Write integrals to file in FCIDUMP format. finalize(); Called upon psi4 module exit to closes timers and I/O. flush_outfile(); Flushes the output file. fnocc(ref_wfn); Runs the FNO-CCSD(T)/QCISD(T)/MP4/CEPA energy code. get_active_molecule(); Returns the currently active molecule object. get_array_variable(key). Deprecated since version 1.4. get_array_variables(). Deprecated since version 1.4. get_atomic_point_charges(). Deprecated since version 1.4. get_datadir(); Returns the path to shared text resources, PSIDATADIR. get_global_option(key); Return keyword key value at global (all-module) scope. get_global_option_list(); Returns a list of all global options. get_gradient(). Deprecated since version 1.2. get_legacy_gradient(); Returns the global gradient as a (nat, 3) Matrix object. get_le",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:8751,Integrability,interface,interface,8751," name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. run_gdma(ref_wfn, datfilename); Runs the GDMA interface code. sapt(dimer_wfn, monoa_wfn, monob_wfn); Runs the symmetry adapted perturbation theory code. scalar_variable(key); Returns the double QCVariable key (case-insensitive); prefer variable(). scalar_variables(); Returns dictionary of all double QCVariables; prefer variables(). scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(ref_wfn); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(ref_wfn); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(molecule); Activates a previously defined molecule in global memory so next computations use it. set_array_variable(key, value); Sets the requested (case-insensitive) Matrix QCVariable; prefer set_variable(). set_datadir(psidatadir); Sets the path to shared text resources, PSIDATADIR. set_global_option(*args, **kwargs); Overloaded function. set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_gradient(val). D",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:12619,Integrability,rout,routines,12619," CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalc; Cartesian displacement SALC. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CharacterTable; Contains the character table of the point group. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFJCOSK; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor; docstring. Deriv; Computes gradients of wavefunctions. DerivCalcType; Members:. DiagonalizeOrder; Defines ordering of eigenvalues after diagonalization. Dimension; Initializes and defines Dimension Objects. DipoleInt; Computes dipole integrals. DirectJK; docstring. DiskSOMCSCF; docstring. Dispersion; docstring. ERI; Computes normal two electron repulsion integrals. ERISieve; docstring. ESPPropCalc; ESPPropCalc gives access to routines calculating the ESP on a grid. ElectricFieldInt; Computes electric field integrals. ElectrostaticInt; Computes electrostatic integrals. ExternalPotential; Stores external potential field, computes external potential matrix. FCHKWriter; Extracts information from a wavefunction object, and writes it to an FCHK file. FDDS_Dispersion; docstring. FISAPT; A Fragment-SAPT Wavefunction. FittedSlaterCorrelationFactor; docstring. FittingMetric; docstring. FragmentType; Fragment activation status. Functional; docstring. GaussianShell; Class containing information about basis functions. GaussianType; 0 if Cartesian, 1 if Pure. GeometryUnits; The units used to define the geometry. HF; docstring. IO; docstring. IOManager; PSIOManager is a class designed to be used as a static object to track all PSIO operations in a given PSI4 computation. IntVector; Class handling vectors with integer values. IntegralFactory; Computes integrals. IntegralTransform; IntegralTransform transforms one- and two",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:19482,Integrability,message,message,19482,"partitioning. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. frequency(name, **kwargs); Function to compute harmonic vibrational frequencies. gdma(wfn[, datafile]); Function to use wavefunction information in wfn and, if specified, additional commands in filename to run GDMA analysis. geometry(geom[, name]); Function to create a molecule object of name name from the geometry in string geom. get_memory(); Function to return the total memory allocation. gradient(name, **kwargs); Function complementary to optimize(). hessian(name, **kwargs); Function complementary to frequency(). ipi_broker(LOT[, molecule, serverdata, options]); Run IPIBroker to connect to i-pi. join_path(prefix, *args). levenshtein(seq1, seq2); Compute the Levenshtein distance between two strings. mdi_run(scf_method, **kwargs); Begin functioning as an MDI engine. message_box([message, max_width, min_width]); put a message string into a box for extra attention. molden(wfn[, filename, density_a, ...]); Function to write wavefunction information in wfn to filename in molden format. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. optimize_geometric(name, **kwargs). pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout(stuff); Function to print stuff to standard output stream. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. prop(*args,",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:19521,Integrability,message,message,19521,"partitioning. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. frequency(name, **kwargs); Function to compute harmonic vibrational frequencies. gdma(wfn[, datafile]); Function to use wavefunction information in wfn and, if specified, additional commands in filename to run GDMA analysis. geometry(geom[, name]); Function to create a molecule object of name name from the geometry in string geom. get_memory(); Function to return the total memory allocation. gradient(name, **kwargs); Function complementary to optimize(). hessian(name, **kwargs); Function complementary to frequency(). ipi_broker(LOT[, molecule, serverdata, options]); Run IPIBroker to connect to i-pi. join_path(prefix, *args). levenshtein(seq1, seq2); Compute the Levenshtein distance between two strings. mdi_run(scf_method, **kwargs); Begin functioning as an MDI engine. message_box([message, max_width, min_width]); put a message string into a box for extra attention. molden(wfn[, filename, density_a, ...]); Function to write wavefunction information in wfn to filename in molden format. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. optimize_geometric(name, **kwargs). pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout(stuff); Function to print stuff to standard output stream. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. prop(*args,",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:22607,Integrability,depend,dependencies,22607,"ssian or hessian block, specifically. write_eigenvalues(eigs, mo_idx); Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file. Classes¶. AtomicComputer(**data); Computer for analytic single-geometry computations. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, iteration); Error called for problems with converging an iterative method. Dftd3Error(msg). EmpiricalDispersion(*[, name_hint, ...]); Lightweight unification of empirical dispersion calculation modes. ManagedMethodError(circs). MissingMethodError(msg); Error called when method not available. OptimizationConvergenceError(...); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(); Hold charges and psi4.core.ExternalPotential. QMMMbohr(); Hold charges and psi4.core.ExternalPotential. SCFConvergenceError(eqn_description, ...); Error called for problems with SCF iterations. TDSCFConvergenceError(iteration, wfn, what, ...); Error called for problems with TDSCF iterations. Table([rows, row_label_width, ...]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. UpgradeHelper(old, new, version, elaboration); Error called on previously valid syntax that now isn't and a simple syntax transition is possible. ValidationError(msg); Error called for problems with the input file. Class Inheritance Diagram¶. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Classes; Class Inheritance Diagram. «; hide menu. menu; sidebar; »; . Nav",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:2378,Modifiability,variab,variable,2378,"rg5); docstring. DSYEV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYMM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYR(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYR2(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYR2K(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYRK(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. IDAMAX(arg0, arg1, arg2, arg3); docstring. adc(ref_wfn); Runs the ADC propagator code, for excited states. array_variable(key); Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). array_variables(); Returns dictionary of all Matrix QCVariables; prefer variables(). be_quiet(); Redirects output to /dev/null. benchmark_blas1(max_dim, min_time); Perform benchmark traverse of BLAS 1 routines. benchmark_blas2(max_dim, min_time); Perform benchmark traverse of BLAS 2 routines. benchmark_blas3(max_dim, min_time[, nthread]); Perform benchmark traverse of BLAS 3 routines. benchmark_disk(max_dim, min_time); Perform benchmark of PSIO disk performance. benchmark_integrals(max_am, min_time); Perform benchmark of psi integrals (of libmints type). benchmark_math(min_time); Perform benchmark of common double floating point operations including most of cmath. ccdensity(ref_wfn); Runs the code to compute coupled cluster density matrices. ccenergy(ref_wfn); Runs the coupled cluster energy code. cceom(ref_wfn); Runs the equation of motion coupled cluster code for excited states. cchbar(ref_wfn); Runs the code to generate the similar",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:2462,Modifiability,variab,variables,2462," arg2, arg3, arg4, arg5, ...); docstring. DSYMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYR(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYR2(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYR2K(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYRK(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. IDAMAX(arg0, arg1, arg2, arg3); docstring. adc(ref_wfn); Runs the ADC propagator code, for excited states. array_variable(key); Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). array_variables(); Returns dictionary of all Matrix QCVariables; prefer variables(). be_quiet(); Redirects output to /dev/null. benchmark_blas1(max_dim, min_time); Perform benchmark traverse of BLAS 1 routines. benchmark_blas2(max_dim, min_time); Perform benchmark traverse of BLAS 2 routines. benchmark_blas3(max_dim, min_time[, nthread]); Perform benchmark traverse of BLAS 3 routines. benchmark_disk(max_dim, min_time); Perform benchmark of PSIO disk performance. benchmark_integrals(max_am, min_time); Perform benchmark of psi integrals (of libmints type). benchmark_math(min_time); Perform benchmark of common double floating point operations including most of cmath. ccdensity(ref_wfn); Runs the code to compute coupled cluster density matrices. ccenergy(ref_wfn); Runs the coupled cluster energy code. cceom(ref_wfn); Runs the equation of motion coupled cluster code for excited states. cchbar(ref_wfn); Runs the code to generate the similarity transformed Hamiltonian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:4369,Modifiability,config,configuration,4369,"ian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ccresponse(ref_wfn); Runs the coupled cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. cctriples(ref_wfn); Runs the coupled cluster (T) energy code. clean(); Remove scratch files. clean_options(); Reset options to clean state. clean_timers(); Reinitialize timers for independent timer.dat entries. clean_variables(); Empties all double and Matrix QCVariables that have been set in global memory. close_outfile(); Closes the output file. dct(ref_wfn); Runs the density cumulant (functional) theory code. del_array_variable(key); Removes the Matrix QCVariable key (case-insensitive); prefer del_variable(). del_scalar_variable(key); Removes the double QCVariable key (case-insensitive); prefer del_variable(). del_variable(key); Removes scalar or array QCVariable key from global memory if present. detci(ref_wfn); Runs the determinant-based configuration interaction code. dfmp2(ref_wfn); Runs the DF-MP2 code. dfocc(ref_wfn); Runs the density-fitted orbital optimized CC codes. dlpno(arg0); Runs the DLPNO codes. dmrg(ref_wfn); Runs the CheMPS2 interface DMRG code. doublet(A, B[, transA, transB]); Returns the multiplication of two matrices A and B, with options to transpose each beforehand. fcidump_tei_helper(nirrep, restricted, ...); Write integrals to file in FCIDUMP format. finalize(); Called upon psi4 module exit to closes timers and I/O. flush_outfile(); Flushes the output file. fnocc(ref_wfn); Runs the FNO-CCSD(T)/QCISD(T)/MP4/CEPA energy code. get_active_molecule(); Returns the currently active molecule object. get_array_variable(key). Deprecated since version 1.4. get_array_variables(). Deprecated since version 1.4. get_atomic_point_charges(). Deprecated since version 1.4. get_datadir(); Returns the path to shared text resources, PSIDATADIR. get_global_option(key); Return keyword key value at global (all-module",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:7646,Modifiability,plugin,plugin,7646,"s default. has_scalar_variable(key); Is the double QCVariable key (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set in global memory. initialize(); Called upon psi4 module import to initialize timers, singletons, and I/O. legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay's MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay's MRCC code. occ(ref_wfn); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer's scratch files. option_exists_in_module(module, key); Whether keyword key is a valid keyword for module. options_to_python(arg0); Get dictionary of whether options of module have changed. optking(); Runs the geometry optimization code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched statu",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:7675,Modifiability,plugin,plugin,7675,"s default. has_scalar_variable(key); Is the double QCVariable key (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set in global memory. initialize(); Called upon psi4 module import to initialize timers, singletons, and I/O. legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay's MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay's MRCC code. occ(ref_wfn); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer's scratch files. option_exists_in_module(module, key); Whether keyword key is a valid keyword for module. options_to_python(arg0); Get dictionary of whether options of module have changed. optking(); Runs the geometry optimization code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched statu",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:7726,Modifiability,plugin,plugin,7726," QCVariable key (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set in global memory. initialize(); Called upon psi4 module import to initialize timers, singletons, and I/O. legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay's MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay's MRCC code. occ(ref_wfn); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer's scratch files. option_exists_in_module(module, key); Whether keyword key is a valid keyword for module. options_to_python(arg0); Get dictionary of whether options of module have changed. optking(); Runs the geometry optimization code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. run_gdma(ref_wfn",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:7782,Modifiability,plugin,plugins,7782,"as_variable(). has_variable(key); Whether scalar or array QCVariable key has been set in global memory. initialize(); Called upon psi4 module import to initialize timers, singletons, and I/O. legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay's MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay's MRCC code. occ(ref_wfn); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer's scratch files. option_exists_in_module(module, key); Whether keyword key is a valid keyword for module. options_to_python(arg0); Get dictionary of whether options of module have changed. optking(); Runs the geometry optimization code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. run_gdma(ref_wfn, datfilename); Runs the GDMA interface code. s",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:7819,Modifiability,plugin,plugin,7819,"ar or array QCVariable key has been set in global memory. initialize(); Called upon psi4 module import to initialize timers, singletons, and I/O. legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay's MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay's MRCC code. occ(ref_wfn); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer's scratch files. option_exists_in_module(module, key); Whether keyword key is a valid keyword for module. options_to_python(arg0); Get dictionary of whether options of module have changed. optking(); Runs the geometry optimization code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. run_gdma(ref_wfn, datfilename); Runs the GDMA interface code. sapt(dimer_wfn, monoa_wfn, monob_wfn); Runs the ",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:7948,Modifiability,plugin,plugin,7948,"4 module import to initialize timers, singletons, and I/O. legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay's MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay's MRCC code. occ(ref_wfn); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer's scratch files. option_exists_in_module(module, key); Whether keyword key is a valid keyword for module. options_to_python(arg0); Get dictionary of whether options of module have changed. optking(); Runs the geometry optimization code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. run_gdma(ref_wfn, datfilename); Runs the GDMA interface code. sapt(dimer_wfn, monoa_wfn, monob_wfn); Runs the symmetry adapted perturbation theory code. scalar_variable(key); Returns the double QC",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:8824,Modifiability,adapt,adapted,8824,"oad the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. run_gdma(ref_wfn, datfilename); Runs the GDMA interface code. sapt(dimer_wfn, monoa_wfn, monob_wfn); Runs the symmetry adapted perturbation theory code. scalar_variable(key); Returns the double QCVariable key (case-insensitive); prefer variable(). scalar_variables(); Returns dictionary of all double QCVariables; prefer variables(). scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(ref_wfn); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(ref_wfn); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(molecule); Activates a previously defined molecule in global memory so next computations use it. set_array_variable(key, value); Sets the requested (case-insensitive) Matrix QCVariable; prefer set_variable(). set_datadir(psidatadir); Sets the path to shared text resources, PSIDATADIR. set_global_option(*args, **kwargs); Overloaded function. set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_gradient(val). Deprecated since version 1.2. set_legacy_gradient(grad); Assigns the global gr",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:8941,Modifiability,variab,variable,8941," return options pertaining to the module or plugin name (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. run_gdma(ref_wfn, datfilename); Runs the GDMA interface code. sapt(dimer_wfn, monoa_wfn, monob_wfn); Runs the symmetry adapted perturbation theory code. scalar_variable(key); Returns the double QCVariable key (case-insensitive); prefer variable(). scalar_variables(); Returns dictionary of all double QCVariables; prefer variables(). scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(ref_wfn); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(ref_wfn); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(molecule); Activates a previously defined molecule in global memory so next computations use it. set_array_variable(key, value); Sets the requested (case-insensitive) Matrix QCVariable; prefer set_variable(). set_datadir(psidatadir); Sets the path to shared text resources, PSIDATADIR. set_global_option(*args, **kwargs); Overloaded function. set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_gradient(val). Deprecated since version 1.2. set_legacy_gradient(grad); Assigns the global gradient to the values in the (nat, 3) Matrix argument. set_legacy_molecule(molecule); Activate",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:9026,Modifiability,variab,variables,9026,"s the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. run_gdma(ref_wfn, datfilename); Runs the GDMA interface code. sapt(dimer_wfn, monoa_wfn, monob_wfn); Runs the symmetry adapted perturbation theory code. scalar_variable(key); Returns the double QCVariable key (case-insensitive); prefer variable(). scalar_variables(); Returns dictionary of all double QCVariables; prefer variables(). scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(ref_wfn); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(ref_wfn); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(molecule); Activates a previously defined molecule in global memory so next computations use it. set_array_variable(key, value); Sets the requested (case-insensitive) Matrix QCVariable; prefer set_variable(). set_datadir(psidatadir); Sets the path to shared text resources, PSIDATADIR. set_global_option(*args, **kwargs); Overloaded function. set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_gradient(val). Deprecated since version 1.2. set_legacy_gradient(grad); Assigns the global gradient to the values in the (nat, 3) Matrix argument. set_legacy_molecule(molecule); Activates a previously defined molecule in global memory so next computations use it. set_legacy_w",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:11039,Modifiability,variab,variable,11039,"computation. set_local_option(*args, **kwargs); Overloaded function. set_local_option_python(key, value); Sets value to Python keyword key scoped only to a single module. set_memory_bytes(memory[, quiet]); Sets the memory available to Psi (in bytes); prefer psi4.set_memory(). set_num_threads(nthread[, quiet]); Sets the number of threads to use in SMP parallel computations. set_output_file(*args, **kwargs); Overloaded function. set_psi_file_prefix(). Deprecated since version 1.4. set_scalar_variable(key, value); Sets the double QCVariable key (case-insensitive); prefer set_variable(). set_variable(key, val); Sets scalar or array QCVariable key to val in global memory. timer_off(label); Stop timer with label. timer_on(label); Start timer with label. triplet(A, B, C[, transA, transB, transC]); Returns the multiplication of three matrices, with options to transpose each beforehand. tstart(); Start module-level timer. tstop(); Stop module-level timer. variable(key); Return copy of scalar or array QCVariable key from global memory. variables([include_deprecated_keys]); Return all scalar or array QCVariables from global memory. version(). Deprecated since version 1.4. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CCWavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalc; Cartesian displacement SALC. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CharacterTable; Contains the character table of the point group. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagat",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:11120,Modifiability,variab,variables,11120,"hon(key, value); Sets value to Python keyword key scoped only to a single module. set_memory_bytes(memory[, quiet]); Sets the memory available to Psi (in bytes); prefer psi4.set_memory(). set_num_threads(nthread[, quiet]); Sets the number of threads to use in SMP parallel computations. set_output_file(*args, **kwargs); Overloaded function. set_psi_file_prefix(). Deprecated since version 1.4. set_scalar_variable(key, value); Sets the double QCVariable key (case-insensitive); prefer set_variable(). set_variable(key, val); Sets scalar or array QCVariable key to val in global memory. timer_off(label); Stop timer with label. timer_on(label); Start timer with label. triplet(A, B, C[, transA, transB, transC]); Returns the multiplication of three matrices, with options to transpose each beforehand. tstart(); Start module-level timer. tstop(); Stop module-level timer. variable(key); Return copy of scalar or array QCVariable key from global memory. variables([include_deprecated_keys]); Return all scalar or array QCVariables from global memory. version(). Deprecated since version 1.4. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CCWavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalc; Cartesian displacement SALC. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CharacterTable; Contains the character table of the point group. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFJCOSK; docstring. DFSOMCSCF; docstring. DFTGrid; ",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:11762,Modifiability,adapt,adapted,11762,"l); Stop timer with label. timer_on(label); Start timer with label. triplet(A, B, C[, transA, transB, transC]); Returns the multiplication of three matrices, with options to transpose each beforehand. tstart(); Start module-level timer. tstop(); Stop module-level timer. variable(key); Return copy of scalar or array QCVariable key from global memory. variables([include_deprecated_keys]); Return all scalar or array QCVariables from global memory. version(). Deprecated since version 1.4. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CCWavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalc; Cartesian displacement SALC. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CharacterTable; Contains the character table of the point group. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFJCOSK; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor; docstring. Deriv; Computes gradients of wavefunctions. DerivCalcType; Members:. DiagonalizeOrder; Defines ordering of eigenvalues after diagonalization. Dimension; Initializes and defines Dimension Objects. DipoleInt; Computes dipole integrals. DirectJK; docstring. DiskSOMCSCF; docstring. Dispersion; docstring. ERI; Computes normal two electron repulsion integrals. ERISieve; docstring. ESPPropCalc; ESPPropCalc gives access to routines calculating the ESP on a grid. ElectricFieldInt; Computes electric field integrals. ElectrostaticInt; Computes electrostatic integrals. Exte",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:22976,Modifiability,flexible,flexible,22976,"c single-geometry computations. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, iteration); Error called for problems with converging an iterative method. Dftd3Error(msg). EmpiricalDispersion(*[, name_hint, ...]); Lightweight unification of empirical dispersion calculation modes. ManagedMethodError(circs). MissingMethodError(msg); Error called when method not available. OptimizationConvergenceError(...); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(); Hold charges and psi4.core.ExternalPotential. QMMMbohr(); Hold charges and psi4.core.ExternalPotential. SCFConvergenceError(eqn_description, ...); Error called for problems with SCF iterations. TDSCFConvergenceError(iteration, wfn, what, ...); Error called for problems with TDSCF iterations. Table([rows, row_label_width, ...]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. UpgradeHelper(old, new, version, elaboration); Error called on previously valid syntax that now isn't and a simple syntax transition is possible. ValidationError(msg); Error called for problems with the input file. Class Inheritance Diagram¶. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Classes; Class Inheritance Diagram. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:2844,Performance,perform,performance,2844,"docstring. DTBMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. IDAMAX(arg0, arg1, arg2, arg3); docstring. adc(ref_wfn); Runs the ADC propagator code, for excited states. array_variable(key); Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). array_variables(); Returns dictionary of all Matrix QCVariables; prefer variables(). be_quiet(); Redirects output to /dev/null. benchmark_blas1(max_dim, min_time); Perform benchmark traverse of BLAS 1 routines. benchmark_blas2(max_dim, min_time); Perform benchmark traverse of BLAS 2 routines. benchmark_blas3(max_dim, min_time[, nthread]); Perform benchmark traverse of BLAS 3 routines. benchmark_disk(max_dim, min_time); Perform benchmark of PSIO disk performance. benchmark_integrals(max_am, min_time); Perform benchmark of psi integrals (of libmints type). benchmark_math(min_time); Perform benchmark of common double floating point operations including most of cmath. ccdensity(ref_wfn); Runs the code to compute coupled cluster density matrices. ccenergy(ref_wfn); Runs the coupled cluster energy code. cceom(ref_wfn); Runs the equation of motion coupled cluster code for excited states. cchbar(ref_wfn); Runs the code to generate the similarity transformed Hamiltonian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ccresponse(ref_wfn); Runs the coupled cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. cctriples(ref_wfn); Runs the coupled cluster (T) energy code. clean(); Remove scratch files. clean_options(); Reset options to clean state. clean_timers(); Reinitialize timers for independent timer.dat",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:4487,Performance,optimiz,optimized,4487,"cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. cctriples(ref_wfn); Runs the coupled cluster (T) energy code. clean(); Remove scratch files. clean_options(); Reset options to clean state. clean_timers(); Reinitialize timers for independent timer.dat entries. clean_variables(); Empties all double and Matrix QCVariables that have been set in global memory. close_outfile(); Closes the output file. dct(ref_wfn); Runs the density cumulant (functional) theory code. del_array_variable(key); Removes the Matrix QCVariable key (case-insensitive); prefer del_variable(). del_scalar_variable(key); Removes the double QCVariable key (case-insensitive); prefer del_variable(). del_variable(key); Removes scalar or array QCVariable key from global memory if present. detci(ref_wfn); Runs the determinant-based configuration interaction code. dfmp2(ref_wfn); Runs the DF-MP2 code. dfocc(ref_wfn); Runs the density-fitted orbital optimized CC codes. dlpno(arg0); Runs the DLPNO codes. dmrg(ref_wfn); Runs the CheMPS2 interface DMRG code. doublet(A, B[, transA, transB]); Returns the multiplication of two matrices A and B, with options to transpose each beforehand. fcidump_tei_helper(nirrep, restricted, ...); Write integrals to file in FCIDUMP format. finalize(); Called upon psi4 module exit to closes timers and I/O. flush_outfile(); Flushes the output file. fnocc(ref_wfn); Runs the FNO-CCSD(T)/QCISD(T)/MP4/CEPA energy code. get_active_molecule(); Returns the currently active molecule object. get_array_variable(key). Deprecated since version 1.4. get_array_variables(). Deprecated since version 1.4. get_atomic_point_charges(). Deprecated since version 1.4. get_datadir(); Returns the path to shared text resources, PSIDATADIR. get_global_option(key); Return keyword key value at global (all-module) scope. get_global_option_list(); Returns a list of all global options. get_gradient(). Deprecated since ver",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:7299,Performance,optimiz,optimized,7299,"ay_variable(key); Is the Matrix QCVariable key (case-insensitive) set? Prefer has_variable(). has_global_option_changed(key); Whether keyword key value has been touched at global (all-module) scope. has_local_option_changed(module, key); Whether keyword key value has been touched at module scope. has_option_changed(module, key); Whether keyword key value has been touched or is default. has_scalar_variable(key); Is the double QCVariable key (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set in global memory. initialize(); Called upon psi4 module import to initialize timers, singletons, and I/O. legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay's MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay's MRCC code. occ(ref_wfn); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer's scratch files. option_exists_in_module(module, key); Whether keyword key is a valid keyword for module. options_to_python(arg0); Get dictionary of whether options of module have changed. optking(); Runs the geometry optimization code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVari",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:7346,Performance,optimiz,optimizer,7346,"insensitive) set? Prefer has_variable(). has_global_option_changed(key); Whether keyword key value has been touched at global (all-module) scope. has_local_option_changed(module, key); Whether keyword key value has been touched at module scope. has_option_changed(module, key); Whether keyword key value has been touched or is default. has_scalar_variable(key); Is the double QCVariable key (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set in global memory. initialize(); Called upon psi4 module import to initialize timers, singletons, and I/O. legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay's MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay's MRCC code. occ(ref_wfn); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer's scratch files. option_exists_in_module(module, key); Whether keyword key is a valid keyword for module. options_to_python(arg0); Get dictionary of whether options of module have changed. optking(); Runs the geometry optimization code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_s",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:7574,Performance,optimiz,optimization,7574,"ched at module scope. has_option_changed(module, key); Whether keyword key value has been touched or is default. has_scalar_variable(key); Is the double QCVariable key (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set in global memory. initialize(); Called upon psi4 module import to initialize timers, singletons, and I/O. legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay's MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay's MRCC code. occ(ref_wfn); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer's scratch files. option_exists_in_module(module, key); Whether keyword key is a valid keyword for module. options_to_python(arg0); Get dictionary of whether options of module have changed. optking(); Runs the geometry optimization code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keywo",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:19137,Performance,optimiz,optimize,19137,"name); Load FCHK file into a string. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. find_approximate_string_matches(seq1, ...); Find list of approximate (within max_distance) matches to string seq1 among options. free_atom_volumes(wfn, **kwargs); Computes free-atom volumes using MBIS density partitioning. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. frequency(name, **kwargs); Function to compute harmonic vibrational frequencies. gdma(wfn[, datafile]); Function to use wavefunction information in wfn and, if specified, additional commands in filename to run GDMA analysis. geometry(geom[, name]); Function to create a molecule object of name name from the geometry in string geom. get_memory(); Function to return the total memory allocation. gradient(name, **kwargs); Function complementary to optimize(). hessian(name, **kwargs); Function complementary to frequency(). ipi_broker(LOT[, molecule, serverdata, options]); Run IPIBroker to connect to i-pi. join_path(prefix, *args). levenshtein(seq1, seq2); Compute the Levenshtein distance between two strings. mdi_run(scf_method, **kwargs); Begin functioning as an MDI engine. message_box([message, max_width, min_width]); put a message string into a box for extra attention. molden(wfn[, filename, density_a, ...]); Function to write wavefunction information in wfn to filename in molden format. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. optimize_geometric(name, **kwargs). pcm",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:19973,Performance,perform,perform,19973,"ect of name name from the geometry in string geom. get_memory(); Function to return the total memory allocation. gradient(name, **kwargs); Function complementary to optimize(). hessian(name, **kwargs); Function complementary to frequency(). ipi_broker(LOT[, molecule, serverdata, options]); Run IPIBroker to connect to i-pi. join_path(prefix, *args). levenshtein(seq1, seq2); Compute the Levenshtein distance between two strings. mdi_run(scf_method, **kwargs); Begin functioning as an MDI engine. message_box([message, max_width, min_width]); put a message string into a box for extra attention. molden(wfn[, filename, density_a, ...]); Function to write wavefunction information in wfn to filename in molden format. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. optimize_geometric(name, **kwargs). pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout(stuff); Function to print stuff to standard output stream. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_facto",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:19992,Performance,optimiz,optimization,19992,"ect of name name from the geometry in string geom. get_memory(); Function to return the total memory allocation. gradient(name, **kwargs); Function complementary to optimize(). hessian(name, **kwargs); Function complementary to frequency(). ipi_broker(LOT[, molecule, serverdata, options]); Run IPIBroker to connect to i-pi. join_path(prefix, *args). levenshtein(seq1, seq2); Compute the Levenshtein distance between two strings. mdi_run(scf_method, **kwargs); Begin functioning as an MDI engine. message_box([message, max_width, min_width]); put a message string into a box for extra attention. molden(wfn[, filename, density_a, ...]); Function to write wavefunction information in wfn to filename in molden format. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. optimize_geometric(name, **kwargs). pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout(stuff); Function to print stuff to standard output stream. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_facto",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:20006,Performance,optimiz,optimize,20006,"ction to return the total memory allocation. gradient(name, **kwargs); Function complementary to optimize(). hessian(name, **kwargs); Function complementary to frequency(). ipi_broker(LOT[, molecule, serverdata, options]); Run IPIBroker to connect to i-pi. join_path(prefix, *args). levenshtein(seq1, seq2); Compute the Levenshtein distance between two strings. mdi_run(scf_method, **kwargs); Begin functioning as an MDI engine. message_box([message, max_width, min_width]); put a message string into a box for extra attention. molden(wfn[, filename, density_a, ...]); Function to write wavefunction information in wfn to filename in molden format. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. optimize_geometric(name, **kwargs). pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout(stuff); Function to print stuff to standard output stream. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ref_wfn, ...); Builds the correct (R/U/RO/CU HF/KS) wavefunc",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:20044,Performance,perform,perform,20044,"ction to return the total memory allocation. gradient(name, **kwargs); Function complementary to optimize(). hessian(name, **kwargs); Function complementary to frequency(). ipi_broker(LOT[, molecule, serverdata, options]); Run IPIBroker to connect to i-pi. join_path(prefix, *args). levenshtein(seq1, seq2); Compute the Levenshtein distance between two strings. mdi_run(scf_method, **kwargs); Begin functioning as an MDI engine. message_box([message, max_width, min_width]); put a message string into a box for extra attention. molden(wfn[, filename, density_a, ...]); Function to write wavefunction information in wfn to filename in molden format. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. optimize_geometric(name, **kwargs). pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout(stuff); Function to print stuff to standard output stream. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ref_wfn, ...); Builds the correct (R/U/RO/CU HF/KS) wavefunc",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:20063,Performance,optimiz,optimization,20063,"ction to return the total memory allocation. gradient(name, **kwargs); Function complementary to optimize(). hessian(name, **kwargs); Function complementary to frequency(). ipi_broker(LOT[, molecule, serverdata, options]); Run IPIBroker to connect to i-pi. join_path(prefix, *args). levenshtein(seq1, seq2); Compute the Levenshtein distance between two strings. mdi_run(scf_method, **kwargs); Begin functioning as an MDI engine. message_box([message, max_width, min_width]); put a message string into a box for extra attention. molden(wfn[, filename, density_a, ...]); Function to write wavefunction information in wfn to filename in molden format. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. optimize_geometric(name, **kwargs). pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout(stuff); Function to print stuff to standard output stream. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ref_wfn, ...); Builds the correct (R/U/RO/CU HF/KS) wavefunc",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:21558,Performance,perform,perform,21558,"(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ref_wfn, ...); Builds the correct (R/U/RO/CU HF/KS) wavefunction from the provided information, sets relevant auxiliary basis sets on it, and prepares any empirical dispersion. set_memory(inputval[, execute, quiet]); Function to reset the total memory allocation. set_module_options(module, options_dict); Sets Psi4 module options from a module specification and input dictionary. set_options(options_dict[, verbose]); Sets Psi4 options from an input dictionary. tdscf(wfn, **kwargs). temp_circular_import_blocker(). vibanal_wfn(wfn[, hess, irrep, molecule, ...]); Function to perform analysis of a hessian or hessian block, specifically. write_eigenvalues(eigs, mo_idx); Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file. Classes¶. AtomicComputer(**data); Computer for analytic single-geometry computations. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, iteration); Error called for problems with converging an iterative method. Dftd3Error(msg). EmpiricalDispersion(*[, name_hint, ...]); Lightweight unification of empirical dispersion calculation modes. ManagedMethodError(circs). MissingMethodError(msg); Error called when method not available. OptimizationConvergenceError(...); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called f",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:22287,Performance,optimiz,optimizer,22287,", options_dict); Sets Psi4 module options from a module specification and input dictionary. set_options(options_dict[, verbose]); Sets Psi4 options from an input dictionary. tdscf(wfn, **kwargs). temp_circular_import_blocker(). vibanal_wfn(wfn[, hess, irrep, molecule, ...]); Function to perform analysis of a hessian or hessian block, specifically. write_eigenvalues(eigs, mo_idx); Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file. Classes¶. AtomicComputer(**data); Computer for analytic single-geometry computations. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, iteration); Error called for problems with converging an iterative method. Dftd3Error(msg). EmpiricalDispersion(*[, name_hint, ...]); Lightweight unification of empirical dispersion calculation modes. ManagedMethodError(circs). MissingMethodError(msg); Error called when method not available. OptimizationConvergenceError(...); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(); Hold charges and psi4.core.ExternalPotential. QMMMbohr(); Hold charges and psi4.core.ExternalPotential. SCFConvergenceError(eqn_description, ...); Error called for problems with SCF iterations. TDSCFConvergenceError(iteration, wfn, what, ...); Error called for problems with TDSCF iterations. Table([rows, row_label_width, ...]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. UpgradeHelper(old, new, version, elaboration); Error called on previously valid syntax that now isn't and a simple syntax transition is possible. Validati",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:12609,Security,access,access,12609," CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalc; Cartesian displacement SALC. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CharacterTable; Contains the character table of the point group. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFJCOSK; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor; docstring. Deriv; Computes gradients of wavefunctions. DerivCalcType; Members:. DiagonalizeOrder; Defines ordering of eigenvalues after diagonalization. Dimension; Initializes and defines Dimension Objects. DipoleInt; Computes dipole integrals. DirectJK; docstring. DiskSOMCSCF; docstring. Dispersion; docstring. ERI; Computes normal two electron repulsion integrals. ERISieve; docstring. ESPPropCalc; ESPPropCalc gives access to routines calculating the ESP on a grid. ElectricFieldInt; Computes electric field integrals. ElectrostaticInt; Computes electrostatic integrals. ExternalPotential; Stores external potential field, computes external potential matrix. FCHKWriter; Extracts information from a wavefunction object, and writes it to an FCHK file. FDDS_Dispersion; docstring. FISAPT; A Fragment-SAPT Wavefunction. FittedSlaterCorrelationFactor; docstring. FittingMetric; docstring. FragmentType; Fragment activation status. Functional; docstring. GaussianShell; Class containing information about basis functions. GaussianType; 0 if Cartesian, 1 if Pure. GeometryUnits; The units used to define the geometry. HF; docstring. IO; docstring. IOManager; PSIOManager is a class designed to be used as a static object to track all PSIO operations in a given PSI4 computation. IntVector; Class handling vectors with integer values. IntegralFactory; Computes integrals. IntegralTransform; IntegralTransform transforms one- and two",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:20444,Security,validat,validate,20444,"ethod, **kwargs); Begin functioning as an MDI engine. message_box([message, max_width, min_width]); put a message string into a box for extra attention. molden(wfn[, filename, density_a, ...]); Function to write wavefunction information in wfn to filename in molden format. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. optimize_geometric(name, **kwargs). pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout(stuff); Function to print stuff to standard output stream. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ref_wfn, ...); Builds the correct (R/U/RO/CU HF/KS) wavefunction from the provided information, sets relevant auxiliary basis sets on it, and prepares any empirical dispersion. set_memory(inputval[, execute, quiet]); Function to reset the total memory allocation. set_module_options(module, options_dict); Sets Psi4 module options from a module specification and input dictionary. set_options(options_dict[, verbose]); Sets Psi4 option",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:2562,Testability,benchmark,benchmark,2562,"3, arg4, arg5, ...); docstring. DSYR2(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYR2K(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYRK(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. IDAMAX(arg0, arg1, arg2, arg3); docstring. adc(ref_wfn); Runs the ADC propagator code, for excited states. array_variable(key); Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). array_variables(); Returns dictionary of all Matrix QCVariables; prefer variables(). be_quiet(); Redirects output to /dev/null. benchmark_blas1(max_dim, min_time); Perform benchmark traverse of BLAS 1 routines. benchmark_blas2(max_dim, min_time); Perform benchmark traverse of BLAS 2 routines. benchmark_blas3(max_dim, min_time[, nthread]); Perform benchmark traverse of BLAS 3 routines. benchmark_disk(max_dim, min_time); Perform benchmark of PSIO disk performance. benchmark_integrals(max_am, min_time); Perform benchmark of psi integrals (of libmints type). benchmark_math(min_time); Perform benchmark of common double floating point operations including most of cmath. ccdensity(ref_wfn); Runs the code to compute coupled cluster density matrices. ccenergy(ref_wfn); Runs the coupled cluster energy code. cceom(ref_wfn); Runs the equation of motion coupled cluster code for excited states. cchbar(ref_wfn); Runs the code to generate the similarity transformed Hamiltonian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ccresponse(ref_wfn); Runs the coupled cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and ",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:2645,Testability,benchmark,benchmark,2645,"string. DSYR2K(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYRK(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. IDAMAX(arg0, arg1, arg2, arg3); docstring. adc(ref_wfn); Runs the ADC propagator code, for excited states. array_variable(key); Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). array_variables(); Returns dictionary of all Matrix QCVariables; prefer variables(). be_quiet(); Redirects output to /dev/null. benchmark_blas1(max_dim, min_time); Perform benchmark traverse of BLAS 1 routines. benchmark_blas2(max_dim, min_time); Perform benchmark traverse of BLAS 2 routines. benchmark_blas3(max_dim, min_time[, nthread]); Perform benchmark traverse of BLAS 3 routines. benchmark_disk(max_dim, min_time); Perform benchmark of PSIO disk performance. benchmark_integrals(max_am, min_time); Perform benchmark of psi integrals (of libmints type). benchmark_math(min_time); Perform benchmark of common double floating point operations including most of cmath. ccdensity(ref_wfn); Runs the code to compute coupled cluster density matrices. ccenergy(ref_wfn); Runs the coupled cluster energy code. cceom(ref_wfn); Runs the equation of motion coupled cluster code for excited states. cchbar(ref_wfn); Runs the code to generate the similarity transformed Hamiltonian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ccresponse(ref_wfn); Runs the coupled cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. cctriples(ref_wfn); Runs t",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:2739,Testability,benchmark,benchmark,2739,"2, arg3, arg4, arg5, ...); docstring. DSYSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. IDAMAX(arg0, arg1, arg2, arg3); docstring. adc(ref_wfn); Runs the ADC propagator code, for excited states. array_variable(key); Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). array_variables(); Returns dictionary of all Matrix QCVariables; prefer variables(). be_quiet(); Redirects output to /dev/null. benchmark_blas1(max_dim, min_time); Perform benchmark traverse of BLAS 1 routines. benchmark_blas2(max_dim, min_time); Perform benchmark traverse of BLAS 2 routines. benchmark_blas3(max_dim, min_time[, nthread]); Perform benchmark traverse of BLAS 3 routines. benchmark_disk(max_dim, min_time); Perform benchmark of PSIO disk performance. benchmark_integrals(max_am, min_time); Perform benchmark of psi integrals (of libmints type). benchmark_math(min_time); Perform benchmark of common double floating point operations including most of cmath. ccdensity(ref_wfn); Runs the code to compute coupled cluster density matrices. ccenergy(ref_wfn); Runs the coupled cluster energy code. cceom(ref_wfn); Runs the equation of motion coupled cluster code for excited states. cchbar(ref_wfn); Runs the code to generate the similarity transformed Hamiltonian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ccresponse(ref_wfn); Runs the coupled cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. cctriples(ref_wfn); Runs the coupled cluster (T) energy code. clean(); Remove scratch files. clean_options(); Rese",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:2821,Testability,benchmark,benchmark,2821,"docstring. DTBMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. IDAMAX(arg0, arg1, arg2, arg3); docstring. adc(ref_wfn); Runs the ADC propagator code, for excited states. array_variable(key); Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). array_variables(); Returns dictionary of all Matrix QCVariables; prefer variables(). be_quiet(); Redirects output to /dev/null. benchmark_blas1(max_dim, min_time); Perform benchmark traverse of BLAS 1 routines. benchmark_blas2(max_dim, min_time); Perform benchmark traverse of BLAS 2 routines. benchmark_blas3(max_dim, min_time[, nthread]); Perform benchmark traverse of BLAS 3 routines. benchmark_disk(max_dim, min_time); Perform benchmark of PSIO disk performance. benchmark_integrals(max_am, min_time); Perform benchmark of psi integrals (of libmints type). benchmark_math(min_time); Perform benchmark of common double floating point operations including most of cmath. ccdensity(ref_wfn); Runs the code to compute coupled cluster density matrices. ccenergy(ref_wfn); Runs the coupled cluster energy code. cceom(ref_wfn); Runs the equation of motion coupled cluster code for excited states. cchbar(ref_wfn); Runs the code to generate the similarity transformed Hamiltonian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ccresponse(ref_wfn); Runs the coupled cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. cctriples(ref_wfn); Runs the coupled cluster (T) energy code. clean(); Remove scratch files. clean_options(); Reset options to clean state. clean_timers(); Reinitialize timers for independent timer.dat",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:2904,Testability,benchmark,benchmark,2904," arg2, arg3, arg4, arg5, ...); docstring. DTRMM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. IDAMAX(arg0, arg1, arg2, arg3); docstring. adc(ref_wfn); Runs the ADC propagator code, for excited states. array_variable(key); Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). array_variables(); Returns dictionary of all Matrix QCVariables; prefer variables(). be_quiet(); Redirects output to /dev/null. benchmark_blas1(max_dim, min_time); Perform benchmark traverse of BLAS 1 routines. benchmark_blas2(max_dim, min_time); Perform benchmark traverse of BLAS 2 routines. benchmark_blas3(max_dim, min_time[, nthread]); Perform benchmark traverse of BLAS 3 routines. benchmark_disk(max_dim, min_time); Perform benchmark of PSIO disk performance. benchmark_integrals(max_am, min_time); Perform benchmark of psi integrals (of libmints type). benchmark_math(min_time); Perform benchmark of common double floating point operations including most of cmath. ccdensity(ref_wfn); Runs the code to compute coupled cluster density matrices. ccenergy(ref_wfn); Runs the coupled cluster energy code. cceom(ref_wfn); Runs the equation of motion coupled cluster code for excited states. cchbar(ref_wfn); Runs the code to generate the similarity transformed Hamiltonian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ccresponse(ref_wfn); Runs the coupled cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. cctriples(ref_wfn); Runs the coupled cluster (T) energy code. clean(); Remove scratch files. clean_options(); Reset options to clean state. clean_timers(); Reinitialize timers for independent timer.dat entries. clean_variables(); Empties all double and Matrix QCVariables that have been ",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:2985,Testability,benchmark,benchmark,2985,"RMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. IDAMAX(arg0, arg1, arg2, arg3); docstring. adc(ref_wfn); Runs the ADC propagator code, for excited states. array_variable(key); Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). array_variables(); Returns dictionary of all Matrix QCVariables; prefer variables(). be_quiet(); Redirects output to /dev/null. benchmark_blas1(max_dim, min_time); Perform benchmark traverse of BLAS 1 routines. benchmark_blas2(max_dim, min_time); Perform benchmark traverse of BLAS 2 routines. benchmark_blas3(max_dim, min_time[, nthread]); Perform benchmark traverse of BLAS 3 routines. benchmark_disk(max_dim, min_time); Perform benchmark of PSIO disk performance. benchmark_integrals(max_am, min_time); Perform benchmark of psi integrals (of libmints type). benchmark_math(min_time); Perform benchmark of common double floating point operations including most of cmath. ccdensity(ref_wfn); Runs the code to compute coupled cluster density matrices. ccenergy(ref_wfn); Runs the coupled cluster energy code. cceom(ref_wfn); Runs the equation of motion coupled cluster code for excited states. cchbar(ref_wfn); Runs the code to generate the similarity transformed Hamiltonian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ccresponse(ref_wfn); Runs the coupled cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. cctriples(ref_wfn); Runs the coupled cluster (T) energy code. clean(); Remove scratch files. clean_options(); Reset options to clean state. clean_timers(); Reinitialize timers for independent timer.dat entries. clean_variables(); Empties all double and Matrix QCVariables that have been set in global memory. close_outfile(); Closes the output file. dct(ref_wfn); Runs the density cumulant ",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:23062,Testability,test,test,23062,"c single-geometry computations. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, iteration); Error called for problems with converging an iterative method. Dftd3Error(msg). EmpiricalDispersion(*[, name_hint, ...]); Lightweight unification of empirical dispersion calculation modes. ManagedMethodError(circs). MissingMethodError(msg); Error called when method not available. OptimizationConvergenceError(...); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(); Hold charges and psi4.core.ExternalPotential. QMMMbohr(); Hold charges and psi4.core.ExternalPotential. SCFConvergenceError(eqn_description, ...); Error called for problems with SCF iterations. TDSCFConvergenceError(iteration, wfn, what, ...); Error called for problems with TDSCF iterations. Table([rows, row_label_width, ...]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. UpgradeHelper(old, new, version, elaboration); Error called on previously valid syntax that now isn't and a simple syntax transition is possible. ValidationError(msg); Error called for problems with the input file. Class Inheritance Diagram¶. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Classes; Class Inheritance Diagram. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psi4api.html:23225,Usability,simpl,simple,23225,"c single-geometry computations. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, iteration); Error called for problems with converging an iterative method. Dftd3Error(msg). EmpiricalDispersion(*[, name_hint, ...]); Lightweight unification of empirical dispersion calculation modes. ManagedMethodError(circs). MissingMethodError(msg); Error called when method not available. OptimizationConvergenceError(...); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(); Hold charges and psi4.core.ExternalPotential. QMMMbohr(); Hold charges and psi4.core.ExternalPotential. SCFConvergenceError(eqn_description, ...); Error called for problems with SCF iterations. TDSCFConvergenceError(iteration, wfn, what, ...); Error called for problems with TDSCF iterations. Table([rows, row_label_width, ...]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. UpgradeHelper(old, new, version, elaboration); Error called on previously valid syntax that now isn't and a simple syntax transition is possible. ValidationError(msg); Error called for problems with the input file. Class Inheritance Diagram¶. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Classes; Class Inheritance Diagram. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:837,Availability,avail,available,837,"﻿. PsiAPI Tutorial: Using Psi4 as a Python Module. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. A PSI4 Tutorial; PsiAPI Tutorial: Using Psi4 as a Python Module. PsiAPI Tutorial: Using Psi4 as a Python Module¶; transcribed by D. A. Sirianni. Note: Psithon and PsiAPI refer to two modes of interacting with Psi4. In Psithon mode, you write an input file in our domain-specific language (not quite Python) where commands don’t have psi4. in front, then submit it to the executable psi4 which processes the Psithon into pure Python and runs it internally. In PsiAPI mode, you write a pure Python script with import psi4 at the top, and commands are behind the psi4. namespace, then submit it to the python interpreter.; Both modes are equally powerful. This tutorial covers the PsiAPI mode. Note: PsiAPI mode has been available since late 2016 and the v1.1 release. While we aim to provide deprecation warnings and upgrade helpers, the API should not be considered completely stable. Most importantly, as we someday deprecate the last of the global variables, options will be added to the method calls (e.g., energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after compilation or How to run Psi4 as a Python module from conda installation for assistance in setting up Psi4. Here, we will explore the basics of using Psi4 in the interactive PsiAPI style where it is loaded directly as a Python module by reproducing the section A Psi4 Tutorial from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your path, feel free to execute each cell as you read along by pressing Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python environment:. [1]:. # Ignore this block -- it's for the documentation build; try:; import os, sys; sys.path.insert(1, os.path.abspath('/home/runner/work/psi4/psi4/code",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:2822,Availability,avail,available,2822," environment:. [1]:. # Ignore this block -- it's for the documentation build; try:; import os, sys; sys.path.insert(1, os.path.abspath('/home/runner/work/psi4/psi4/code/objdir/stage//usr/local/psi4/lib/')); except ImportError:; pass. # This is the important part; import psi4. Psi4 is now able to be controlled directly from Python. By default, Psi4 will print any output to the screen; this can be changed by giving a file name (with path if not in the current working directory) to the function psi4.core.set_output_file() :psicode:[API] <psi4manual/master/api/psi4.core.set_output_file> , as a string:. [2]:. psi4.core.set_output_file('output.dat', False). Additionally, output may be suppressed by instead setting psi4.core.be_quiet() :psicode:[API] <psi4manual/master/api/psi4.core.be_quiet> . II. Running a Basic Hartree-Fock Calculation¶; In our first example, we will consider a Hartree-Fock SCF computation for the water molecule using a cc-pVDZ basis set. First, we will set the available memory for Psi4 to use with the psi4.set_memory() API function, which takes either a string like '30 GB' (with units!) or an integer number of bytes of memory as its argument. Next, our molecular geometry is passed as a string into; psi4.geometry() API. We may input this geometry in either Z-matrix or Cartesian format; to allow the string to break over multiple lines, use Python’s triple-quote """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF energy with the cc-pVDZ basis set by passing the method/basis set as a string ('scf/cc-pvdz') into the function psi4.energy(); API:. [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). [3]:. -76.02663273488399. If everything goes well, the computation should complete and should report a final restricted Hartree-Fock energy in the output file output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:7621,Availability,down,downhill,7621,"mputations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization complete!. As indicated in the following table (printed by the optimizer at the end of the computation and grep-able with ~), the energy decreases with each step, and the maximum force on each atom also decreases with each step (in; principle, these numbers could increase in some iterations, but here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946     ",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:9836,Availability,error,errors,9836,"----------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s important to keep in mind that the values of the vibrational frequencies are a function of the molecular geometry. Therefore, it’s important to obtain the vibrational frequencies AT THE OPTIMIZED GEOMETRY. Luckily, Psi4 updates the molecule with optimized geometry as it is being optimized. So, the optimized geometry for H\(_2\)O is stored inside the h2o molecule object, which we can access! To compute the frequencies, all we need to do; is to again pass the molecule=h2o argument to the psi4.frequency() API function:. [6]:. scf_e, scf_wfn = psi4.frequency('scf/cc-pvdz', molecule=h2o, return_wfn=True). 6 displacements needed.; 1 2 3 4 5 6. Executing this cell will prompt Psi4 to compute the Hessian (second derivative matrix) of the electronic energy with respect to nuclear displacements. From this, it can obtain the harmonic vibrational frequencies, given below (roundoff errors of around \(0.1\) cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2). The program also print out the normal modes in terms of Cartesian coordinates of each atom. For example, the normal mode at \(1776\) cm\(^{-1}\) is:; Frequency: 1775.65; Force constant: 0.1193; X Y Z mass; O 0.000 0.000 -0.068 15.994915; H 0.000 0.416 0.536 1.007825; H 0.000 -0.416 0.536 1.007825. where the table shows the displacements in the X, Y, and Z dimensions for each atom along the normal mode coordinate. (This information could be used to animate the vibrational frequency using visualization software.); Because the vibrational frequencies are available, a thermodynamics analysis is automatically performed at the end of the computation. You can see this in",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:10690,Availability,avail,available,10690,"h respect to nuclear displacements. From this, it can obtain the harmonic vibrational frequencies, given below (roundoff errors of around \(0.1\) cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2). The program also print out the normal modes in terms of Cartesian coordinates of each atom. For example, the normal mode at \(1776\) cm\(^{-1}\) is:; Frequency: 1775.65; Force constant: 0.1193; X Y Z mass; O 0.000 0.000 -0.068 15.994915; H 0.000 0.416 0.536 1.007825; H 0.000 -0.416 0.536 1.007825. where the table shows the displacements in the X, Y, and Z dimensions for each atom along the normal mode coordinate. (This information could be used to animate the vibrational frequency using visualization software.); Because the vibrational frequencies are available, a thermodynamics analysis is automatically performed at the end of the computation. You can see this in the next section of the output file output.dat. The vibrational frequencies are sufficient to obtain vibrational contributions to enthalpy (H), entropy (S), and Gibbs free energy (G). Similarly, the molecular geometry is used to obtain rotational constants, which are then used to obtain rotational contributions to H, S, and G.; Note: Psi4 has several synonyms for the functions called in this example. For instance, psi4.frequency() API will compute molecular vibrational frequencies, and psi4.optimize() API will perform a geometry optimization. IV. Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. Psi4 contains code to analyze the nature of intermolecular interactions between two molecules, via symmetry-adapted perturbation theory (SAPT) (Jeziorski:1994:1887). This kind of analysis gives a lot of insight into the nature of intermolecular interactions, a",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:13523,Availability,error,error,13523," 'true'}). psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). [8]:. -0.0022355825227244703. All of the options we have currently set using psi4.set_options() API are “global” options (meaning that they are visible to all parts of the program). Most common Psi4 options can be set like this. If an option needs to be visible only to one part of the program (e.g., we only want to increase the energy convergence in the SCF code, but not the rest of the code), it can be set by with the; psi4.set_module_options() API function, psi4.set_module_options('scf', {'e_convergence': '1e-8'}).; Note: The arguments to the functions we’ve used so far, like psi4.set_options() API, psi4.set_module_options() API, psi4.energy() API, psi4.optimize(); API, psi4.frequency() API, etc., are case-insensitive.; Back to our SAPT example, we have found that for basic-level SAPT computations (i.e., SAPT0), a good error cancellation is found (Hohenstein:2012:WIREs) with the jun-cc-pVDZ basis (this is the usual aug-cc-pVDZ basis, but without diffuse functions on hydrogen and without diffuse \(d\) functions on heavy atoms) (Papajak:2011:10). So,; we’ll use that as our standard basis set. The SAPT code is designed to use density fitting techniques, because they introduce minimal errors while providing much faster computations (Hohenstein:2010:184111,Hohenstein:2010:014101). Since we’re using density fitting for the SAPT, we might as well also use it for the Hartree-Fock; computations that are performed as part of the SAPT. We can specify that by adding 'scf_type': 'df' to the dictionary passed to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that pair with the primary basis set. Fortunately, Psi4 is usually smart enough to figure out what auxiliary basis sets are needed for a given computation. In this case, jun-cc-pVDZ is a standard enough basis set (just a simple truncation of the very popular aug-cc-pVDZ basis set) that Psi4 correctly guesses that we want th",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:13892,Availability,error,errors,13892,"ons can be set like this. If an option needs to be visible only to one part of the program (e.g., we only want to increase the energy convergence in the SCF code, but not the rest of the code), it can be set by with the; psi4.set_module_options() API function, psi4.set_module_options('scf', {'e_convergence': '1e-8'}).; Note: The arguments to the functions we’ve used so far, like psi4.set_options() API, psi4.set_module_options() API, psi4.energy() API, psi4.optimize(); API, psi4.frequency() API, etc., are case-insensitive.; Back to our SAPT example, we have found that for basic-level SAPT computations (i.e., SAPT0), a good error cancellation is found (Hohenstein:2012:WIREs) with the jun-cc-pVDZ basis (this is the usual aug-cc-pVDZ basis, but without diffuse functions on hydrogen and without diffuse \(d\) functions on heavy atoms) (Papajak:2011:10). So,; we’ll use that as our standard basis set. The SAPT code is designed to use density fitting techniques, because they introduce minimal errors while providing much faster computations (Hohenstein:2010:184111,Hohenstein:2010:014101). Since we’re using density fitting for the SAPT, we might as well also use it for the Hartree-Fock; computations that are performed as part of the SAPT. We can specify that by adding 'scf_type': 'df' to the dictionary passed to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that pair with the primary basis set. Fortunately, Psi4 is usually smart enough to figure out what auxiliary basis sets are needed for a given computation. In this case, jun-cc-pVDZ is a standard enough basis set (just a simple truncation of the very popular aug-cc-pVDZ basis set) that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the SAPT; procedure.; To speed up the computation a little, we also tell the SAPT procedure to freeze the core electrons by adding 'freeze_core': 'true' to the dictionary",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:876,Deployability,release,release,876,"﻿. PsiAPI Tutorial: Using Psi4 as a Python Module. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. A PSI4 Tutorial; PsiAPI Tutorial: Using Psi4 as a Python Module. PsiAPI Tutorial: Using Psi4 as a Python Module¶; transcribed by D. A. Sirianni. Note: Psithon and PsiAPI refer to two modes of interacting with Psi4. In Psithon mode, you write an input file in our domain-specific language (not quite Python) where commands don’t have psi4. in front, then submit it to the executable psi4 which processes the Psithon into pure Python and runs it internally. In PsiAPI mode, you write a pure Python script with import psi4 at the top, and commands are behind the psi4. namespace, then submit it to the python interpreter.; Both modes are equally powerful. This tutorial covers the PsiAPI mode. Note: PsiAPI mode has been available since late 2016 and the v1.1 release. While we aim to provide deprecation warnings and upgrade helpers, the API should not be considered completely stable. Most importantly, as we someday deprecate the last of the global variables, options will be added to the method calls (e.g., energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after compilation or How to run Psi4 as a Python module from conda installation for assistance in setting up Psi4. Here, we will explore the basics of using Psi4 in the interactive PsiAPI style where it is loaded directly as a Python module by reproducing the section A Psi4 Tutorial from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your path, feel free to execute each cell as you read along by pressing Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python environment:. [1]:. # Ignore this block -- it's for the documentation build; try:; import os, sys; sys.path.insert(1, os.path.abspath('/home/runner/work/psi4/psi4/code",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:934,Deployability,upgrade,upgrade,934,"﻿. PsiAPI Tutorial: Using Psi4 as a Python Module. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. A PSI4 Tutorial; PsiAPI Tutorial: Using Psi4 as a Python Module. PsiAPI Tutorial: Using Psi4 as a Python Module¶; transcribed by D. A. Sirianni. Note: Psithon and PsiAPI refer to two modes of interacting with Psi4. In Psithon mode, you write an input file in our domain-specific language (not quite Python) where commands don’t have psi4. in front, then submit it to the executable psi4 which processes the Psithon into pure Python and runs it internally. In PsiAPI mode, you write a pure Python script with import psi4 at the top, and commands are behind the psi4. namespace, then submit it to the python interpreter.; Both modes are equally powerful. This tutorial covers the PsiAPI mode. Note: PsiAPI mode has been available since late 2016 and the v1.1 release. While we aim to provide deprecation warnings and upgrade helpers, the API should not be considered completely stable. Most importantly, as we someday deprecate the last of the global variables, options will be added to the method calls (e.g., energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after compilation or How to run Psi4 as a Python module from conda installation for assistance in setting up Psi4. Here, we will explore the basics of using Psi4 in the interactive PsiAPI style where it is loaded directly as a Python module by reproducing the section A Psi4 Tutorial from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your path, feel free to execute each cell as you read along by pressing Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python environment:. [1]:. # Ignore this block -- it's for the documentation build; try:; import os, sys; sys.path.insert(1, os.path.abspath('/home/runner/work/psi4/psi4/code",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:1285,Deployability,install,installation,1285,"e¶; transcribed by D. A. Sirianni. Note: Psithon and PsiAPI refer to two modes of interacting with Psi4. In Psithon mode, you write an input file in our domain-specific language (not quite Python) where commands don’t have psi4. in front, then submit it to the executable psi4 which processes the Psithon into pure Python and runs it internally. In PsiAPI mode, you write a pure Python script with import psi4 at the top, and commands are behind the psi4. namespace, then submit it to the python interpreter.; Both modes are equally powerful. This tutorial covers the PsiAPI mode. Note: PsiAPI mode has been available since late 2016 and the v1.1 release. While we aim to provide deprecation warnings and upgrade helpers, the API should not be considered completely stable. Most importantly, as we someday deprecate the last of the global variables, options will be added to the method calls (e.g., energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after compilation or How to run Psi4 as a Python module from conda installation for assistance in setting up Psi4. Here, we will explore the basics of using Psi4 in the interactive PsiAPI style where it is loaded directly as a Python module by reproducing the section A Psi4 Tutorial from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your path, feel free to execute each cell as you read along by pressing Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python environment:. [1]:. # Ignore this block -- it's for the documentation build; try:; import os, sys; sys.path.insert(1, os.path.abspath('/home/runner/work/psi4/psi4/code/objdir/stage//usr/local/psi4/lib/')); except ImportError:; pass. # This is the important part; import psi4. Psi4 is now able to be controlled directly from Python. By default, Psi4 will print any output to the screen; this can ",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:4088,Deployability,install,installation,4088," or Cartesian format; to allow the string to break over multiple lines, use Python’s triple-quote """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF energy with the cc-pVDZ basis set by passing the method/basis set as a string ('scf/cc-pvdz') into the function psi4.energy(); API:. [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). [3]:. -76.02663273488399. If everything goes well, the computation should complete and should report a final restricted Hartree-Fock energy in the output file output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about \(1.0\times 10^{-6}\), so agreement is only expected for about the first 6 digits after the decimal. If the computation does not complete, there is probably a problem with the compilation or installation of the program (see the installation instructions in the main Psi4 manual section :psicode:[Compiling and Installing from Source] <psi4manual/master/build_planning.html> .; This very simple input is sufficient to run the requested information. Notice we didn’t tell the program some otherwise useful information like the charge of the molecule (0, it’s neutral), the spin multiplicity (1 for a closed-shell molecule with all electrons paired), or the reference wavefunction to use (restricted Hartree-Fock, or RHF, is usually appropriate for a closed-shell molecule). The program correctly guessed all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not all the electrons are paired. For example, let’s run a computation on methylene (\(\text{CH}_2\)), whose ground electronic state has two unpaired electrons (triplet electronic state, or a spin multiplicity \(2S + 1 = 3\)). In this case, the default spin multiplicity ",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:4125,Deployability,install,installation,4125," or Cartesian format; to allow the string to break over multiple lines, use Python’s triple-quote """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF energy with the cc-pVDZ basis set by passing the method/basis set as a string ('scf/cc-pvdz') into the function psi4.energy(); API:. [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). [3]:. -76.02663273488399. If everything goes well, the computation should complete and should report a final restricted Hartree-Fock energy in the output file output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about \(1.0\times 10^{-6}\), so agreement is only expected for about the first 6 digits after the decimal. If the computation does not complete, there is probably a problem with the compilation or installation of the program (see the installation instructions in the main Psi4 manual section :psicode:[Compiling and Installing from Source] <psi4manual/master/build_planning.html> .; This very simple input is sufficient to run the requested information. Notice we didn’t tell the program some otherwise useful information like the charge of the molecule (0, it’s neutral), the spin multiplicity (1 for a closed-shell molecule with all electrons paired), or the reference wavefunction to use (restricted Hartree-Fock, or RHF, is usually appropriate for a closed-shell molecule). The program correctly guessed all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not all the electrons are paired. For example, let’s run a computation on methylene (\(\text{CH}_2\)), whose ground electronic state has two unpaired electrons (triplet electronic state, or a spin multiplicity \(2S + 1 = 3\)). In this case, the default spin multiplicity ",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:9174,Deployability,update,updates,9174,"------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s important to keep in mind that the values of the vibrational frequencies are a function of the molecular geometry. Therefore, it’s important to obtain the vibrational frequencies AT THE OPTIMIZED GEOMETRY. Luckily, Psi4 updates the molecule with optimized geometry as it is being optimized. So, the optimized geometry for H\(_2\)O is stored inside the h2o molecule object, which we can access! To compute the frequencies, all we need to do; is to again pass the molecule=h2o argument to the psi4.frequency() API function:. [6]:. scf_e, scf_wfn = psi4.frequency('scf/cc-pvdz', molecule=h2o, return_wfn=True). 6 displacements needed.; 1 2 3 4 5 6. Executing this cell will prompt Psi4 to compute the Hessian (second derivative matrix) of the electronic energy with respect to nuclear displacements. From this, it can obtain the harmonic vibrational frequencies, given below (roundoff errors of around \(0.1\) cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2). The program also print out the normal modes in terms of Cartesian coor",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:23955,Deployability,update,updated,23955,"ith fragments (1, 2) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (1, 2), basis = (1, 2): -257.41867403127321); ...; ==> N-Body: Counterpoise Corrected (CP) energies <==. n-Body Total Energy [Eh] I.E. [kcal/mol] Delta [kcal/mol]; 1 -257.418648109779 0.000000000000 0.000000000000; 2 -257.418674031273 -0.016265984132 -0.016265984132. And that’s it! The only remaining part of the example is a little table of the different R values and the CP-corrected CCSD(T) energies, converted from atomic units (Hartree) to kcal mol\(^{-1}\) by multiplying by the automatically-defined conversion factor psi4.constants.hartree2kcalmol. Psi4 provides several built-in physical constants and conversion factors, as described in the Psi4 manual section Physical; Constants. The table can be printed either to the screen, by using standard Python ``print()` syntax <https://docs.python.org/3/whatsnew/3.0.html#print-is-a-function>`__, or to the designated output file output.dat using Psi4’s built-in function psi4.core.print_out() :psicode:[API] <psi4manual/master/api/psi4.core.print_out> (C style printing).; As we’ve seen so far, the combination of Psi4 and Python creates a unique, interactive approach to quantum chemistry. The next section will explore this synergistic relationship in greater detail, describing how even very complex tasks can be done very easily with Psi4. [ ]:. table of contents. PsiAPI Tutorial: Using Psi4 as a Python Module; I. Basic Input Structure; II. Running a Basic Hartree-Fock Calculation; III. Geometry Optimization and Vibrational Frequency Analysis; IV. Analysis of Intermolecular Interactions; V. Potential Surface Scans and Counterpoise Correction Made Easy. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. A PSI4 Tutorial; PsiAPI Tutorial: Using Psi4 as a Python Module. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:762,Energy Efficiency,power,powerful,762,"﻿. PsiAPI Tutorial: Using Psi4 as a Python Module. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. A PSI4 Tutorial; PsiAPI Tutorial: Using Psi4 as a Python Module. PsiAPI Tutorial: Using Psi4 as a Python Module¶; transcribed by D. A. Sirianni. Note: Psithon and PsiAPI refer to two modes of interacting with Psi4. In Psithon mode, you write an input file in our domain-specific language (not quite Python) where commands don’t have psi4. in front, then submit it to the executable psi4 which processes the Psithon into pure Python and runs it internally. In PsiAPI mode, you write a pure Python script with import psi4 at the top, and commands are behind the psi4. namespace, then submit it to the python interpreter.; Both modes are equally powerful. This tutorial covers the PsiAPI mode. Note: PsiAPI mode has been available since late 2016 and the v1.1 release. While we aim to provide deprecation warnings and upgrade helpers, the API should not be considered completely stable. Most importantly, as we someday deprecate the last of the global variables, options will be added to the method calls (e.g., energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after compilation or How to run Psi4 as a Python module from conda installation for assistance in setting up Psi4. Here, we will explore the basics of using Psi4 in the interactive PsiAPI style where it is loaded directly as a Python module by reproducing the section A Psi4 Tutorial from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your path, feel free to execute each cell as you read along by pressing Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python environment:. [1]:. # Ignore this block -- it's for the documentation build; try:; import os, sys; sys.path.insert(1, os.path.abspath('/home/runner/work/psi4/psi4/code",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:1128,Energy Efficiency,energy,energy,1128,"e¶; transcribed by D. A. Sirianni. Note: Psithon and PsiAPI refer to two modes of interacting with Psi4. In Psithon mode, you write an input file in our domain-specific language (not quite Python) where commands don’t have psi4. in front, then submit it to the executable psi4 which processes the Psithon into pure Python and runs it internally. In PsiAPI mode, you write a pure Python script with import psi4 at the top, and commands are behind the psi4. namespace, then submit it to the python interpreter.; Both modes are equally powerful. This tutorial covers the PsiAPI mode. Note: PsiAPI mode has been available since late 2016 and the v1.1 release. While we aim to provide deprecation warnings and upgrade helpers, the API should not be considered completely stable. Most importantly, as we someday deprecate the last of the global variables, options will be added to the method calls (e.g., energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after compilation or How to run Psi4 as a Python module from conda installation for assistance in setting up Psi4. Here, we will explore the basics of using Psi4 in the interactive PsiAPI style where it is loaded directly as a Python module by reproducing the section A Psi4 Tutorial from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your path, feel free to execute each cell as you read along by pressing Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python environment:. [1]:. # Ignore this block -- it's for the documentation build; try:; import os, sys; sys.path.insert(1, os.path.abspath('/home/runner/work/psi4/psi4/code/objdir/stage//usr/local/psi4/lib/')); except ImportError:; pass. # This is the important part; import psi4. Psi4 is now able to be controlled directly from Python. By default, Psi4 will print any output to the screen; this can ",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:3296,Energy Efficiency,energy,energy,3296,"si4.core.set_output_file() :psicode:[API] <psi4manual/master/api/psi4.core.set_output_file> , as a string:. [2]:. psi4.core.set_output_file('output.dat', False). Additionally, output may be suppressed by instead setting psi4.core.be_quiet() :psicode:[API] <psi4manual/master/api/psi4.core.be_quiet> . II. Running a Basic Hartree-Fock Calculation¶; In our first example, we will consider a Hartree-Fock SCF computation for the water molecule using a cc-pVDZ basis set. First, we will set the available memory for Psi4 to use with the psi4.set_memory() API function, which takes either a string like '30 GB' (with units!) or an integer number of bytes of memory as its argument. Next, our molecular geometry is passed as a string into; psi4.geometry() API. We may input this geometry in either Z-matrix or Cartesian format; to allow the string to break over multiple lines, use Python’s triple-quote """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF energy with the cc-pVDZ basis set by passing the method/basis set as a string ('scf/cc-pvdz') into the function psi4.energy(); API:. [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). [3]:. -76.02663273488399. If everything goes well, the computation should complete and should report a final restricted Hartree-Fock energy in the output file output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about \(1.0\times 10^{-6}\), so agreement is only expected for about the first 6 digits after the decimal. If the computation does not complete, there is probably a problem with the compilation or installation of the program (see the installation instructions in the main Psi4 manual section :psicode:[Compiling and Installing from Source] <psi4manual/master/build_planning.html> .; This very simple input is sufficient to run the requested",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:3413,Energy Efficiency,energy,energy,3413,"e> , as a string:. [2]:. psi4.core.set_output_file('output.dat', False). Additionally, output may be suppressed by instead setting psi4.core.be_quiet() :psicode:[API] <psi4manual/master/api/psi4.core.be_quiet> . II. Running a Basic Hartree-Fock Calculation¶; In our first example, we will consider a Hartree-Fock SCF computation for the water molecule using a cc-pVDZ basis set. First, we will set the available memory for Psi4 to use with the psi4.set_memory() API function, which takes either a string like '30 GB' (with units!) or an integer number of bytes of memory as its argument. Next, our molecular geometry is passed as a string into; psi4.geometry() API. We may input this geometry in either Z-matrix or Cartesian format; to allow the string to break over multiple lines, use Python’s triple-quote """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF energy with the cc-pVDZ basis set by passing the method/basis set as a string ('scf/cc-pvdz') into the function psi4.energy(); API:. [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). [3]:. -76.02663273488399. If everything goes well, the computation should complete and should report a final restricted Hartree-Fock energy in the output file output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about \(1.0\times 10^{-6}\), so agreement is only expected for about the first 6 digits after the decimal. If the computation does not complete, there is probably a problem with the compilation or installation of the program (see the installation instructions in the main Psi4 manual section :psicode:[Compiling and Installing from Source] <psi4manual/master/build_planning.html> .; This very simple input is sufficient to run the requested information. Notice we didn’t tell the program some otherwise useful information like the",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:3567,Energy Efficiency,energy,energy,3567,"de:[API] <psi4manual/master/api/psi4.core.be_quiet> . II. Running a Basic Hartree-Fock Calculation¶; In our first example, we will consider a Hartree-Fock SCF computation for the water molecule using a cc-pVDZ basis set. First, we will set the available memory for Psi4 to use with the psi4.set_memory() API function, which takes either a string like '30 GB' (with units!) or an integer number of bytes of memory as its argument. Next, our molecular geometry is passed as a string into; psi4.geometry() API. We may input this geometry in either Z-matrix or Cartesian format; to allow the string to break over multiple lines, use Python’s triple-quote """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF energy with the cc-pVDZ basis set by passing the method/basis set as a string ('scf/cc-pvdz') into the function psi4.energy(); API:. [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). [3]:. -76.02663273488399. If everything goes well, the computation should complete and should report a final restricted Hartree-Fock energy in the output file output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about \(1.0\times 10^{-6}\), so agreement is only expected for about the first 6 digits after the decimal. If the computation does not complete, there is probably a problem with the compilation or installation of the program (see the installation instructions in the main Psi4 manual section :psicode:[Compiling and Installing from Source] <psi4manual/master/build_planning.html> .; This very simple input is sufficient to run the requested information. Notice we didn’t tell the program some otherwise useful information like the charge of the molecule (0, it’s neutral), the spin multiplicity (1 for a closed-shell molecule with all electrons paired), or the reference wavefunction to ",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:3723,Energy Efficiency,energy,energy,3723," first example, we will consider a Hartree-Fock SCF computation for the water molecule using a cc-pVDZ basis set. First, we will set the available memory for Psi4 to use with the psi4.set_memory() API function, which takes either a string like '30 GB' (with units!) or an integer number of bytes of memory as its argument. Next, our molecular geometry is passed as a string into; psi4.geometry() API. We may input this geometry in either Z-matrix or Cartesian format; to allow the string to break over multiple lines, use Python’s triple-quote """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF energy with the cc-pVDZ basis set by passing the method/basis set as a string ('scf/cc-pvdz') into the function psi4.energy(); API:. [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). [3]:. -76.02663273488399. If everything goes well, the computation should complete and should report a final restricted Hartree-Fock energy in the output file output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about \(1.0\times 10^{-6}\), so agreement is only expected for about the first 6 digits after the decimal. If the computation does not complete, there is probably a problem with the compilation or installation of the program (see the installation instructions in the main Psi4 manual section :psicode:[Compiling and Installing from Source] <psi4manual/master/build_planning.html> .; This very simple input is sufficient to run the requested information. Notice we didn’t tell the program some otherwise useful information like the charge of the molecule (0, it’s neutral), the spin multiplicity (1 for a closed-shell molecule with all electrons paired), or the reference wavefunction to use (restricted Hartree-Fock, or RHF, is usually appropriate for a closed-shell molecule). The program corre",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:3861,Energy Efficiency,energy,energy,3861,"_memory() API function, which takes either a string like '30 GB' (with units!) or an integer number of bytes of memory as its argument. Next, our molecular geometry is passed as a string into; psi4.geometry() API. We may input this geometry in either Z-matrix or Cartesian format; to allow the string to break over multiple lines, use Python’s triple-quote """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF energy with the cc-pVDZ basis set by passing the method/basis set as a string ('scf/cc-pvdz') into the function psi4.energy(); API:. [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). [3]:. -76.02663273488399. If everything goes well, the computation should complete and should report a final restricted Hartree-Fock energy in the output file output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about \(1.0\times 10^{-6}\), so agreement is only expected for about the first 6 digits after the decimal. If the computation does not complete, there is probably a problem with the compilation or installation of the program (see the installation instructions in the main Psi4 manual section :psicode:[Compiling and Installing from Source] <psi4manual/master/build_planning.html> .; This very simple input is sufficient to run the requested information. Notice we didn’t tell the program some otherwise useful information like the charge of the molecule (0, it’s neutral), the spin multiplicity (1 for a closed-shell molecule with all electrons paired), or the reference wavefunction to use (restricted Hartree-Fock, or RHF, is usually appropriate for a closed-shell molecule). The program correctly guessed all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not all the e",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:4422,Energy Efficiency,charge,charge,4422,"psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). [3]:. -76.02663273488399. If everything goes well, the computation should complete and should report a final restricted Hartree-Fock energy in the output file output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about \(1.0\times 10^{-6}\), so agreement is only expected for about the first 6 digits after the decimal. If the computation does not complete, there is probably a problem with the compilation or installation of the program (see the installation instructions in the main Psi4 manual section :psicode:[Compiling and Installing from Source] <psi4manual/master/build_planning.html> .; This very simple input is sufficient to run the requested information. Notice we didn’t tell the program some otherwise useful information like the charge of the molecule (0, it’s neutral), the spin multiplicity (1 for a closed-shell molecule with all electrons paired), or the reference wavefunction to use (restricted Hartree-Fock, or RHF, is usually appropriate for a closed-shell molecule). The program correctly guessed all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not all the electrons are paired. For example, let’s run a computation on methylene (\(\text{CH}_2\)), whose ground electronic state has two unpaired electrons (triplet electronic state, or a spin multiplicity \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is not correct, so we need to tell the program the true value (3). Like many programs, Psi4 can get the charge and multiplicity as the first two; integers in the Z-matrix (note the line with 0 3 at the beginning of the molecule specification below). In this example, we will also specify the bond length and bond angle as variables (\(R\) and \(A\)), whose values are fir",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:5239,Energy Efficiency,charge,charge,5239,"nput is sufficient to run the requested information. Notice we didn’t tell the program some otherwise useful information like the charge of the molecule (0, it’s neutral), the spin multiplicity (1 for a closed-shell molecule with all electrons paired), or the reference wavefunction to use (restricted Hartree-Fock, or RHF, is usually appropriate for a closed-shell molecule). The program correctly guessed all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not all the electrons are paired. For example, let’s run a computation on methylene (\(\text{CH}_2\)), whose ground electronic state has two unpaired electrons (triplet electronic state, or a spin multiplicity \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is not correct, so we need to tell the program the true value (3). Like many programs, Psi4 can get the charge and multiplicity as the first two; integers in the Z-matrix (note the line with 0 3 at the beginning of the molecule specification below). In this example, we will also specify the bond length and bond angle as variables (\(R\) and \(A\)), whose values are first stored and then inserted into the geometry specification using Python 3 string formatting. [4]:. #! Sample UHF/6-31G** CH2 Computation. R = 1.075; A = 133.93. ch2 = psi4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). [4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options() API, to the input. This function takes a Python dictionary as its argument, which is a key-value list which associates a Psi4 keyword with its user-defined value. For open shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree-Fock, or UHF) or restricted orbitals (restricted open-shell",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:5791,Energy Efficiency,energy,energy,5791,"nsider what we would do for an open-shell molecule, where not all the electrons are paired. For example, let’s run a computation on methylene (\(\text{CH}_2\)), whose ground electronic state has two unpaired electrons (triplet electronic state, or a spin multiplicity \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is not correct, so we need to tell the program the true value (3). Like many programs, Psi4 can get the charge and multiplicity as the first two; integers in the Z-matrix (note the line with 0 3 at the beginning of the molecule specification below). In this example, we will also specify the bond length and bond angle as variables (\(R\) and \(A\)), whose values are first stored and then inserted into the geometry specification using Python 3 string formatting. [4]:. #! Sample UHF/6-31G** CH2 Computation. R = 1.075; A = 133.93. ch2 = psi4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). [4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options() API, to the input. This function takes a Python dictionary as its argument, which is a key-value list which associates a Psi4 keyword with its user-defined value. For open shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree-Fock, or UHF) or restricted orbitals (restricted open-shell Hartree-Fock, or ROHF). Usually, UHF is a little easier to converge (although it may be more susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as specified by the psi4.energy() API function). Of course there are other kinds of computations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; ",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:5884,Energy Efficiency,energy,energy,5884,"s are paired. For example, let’s run a computation on methylene (\(\text{CH}_2\)), whose ground electronic state has two unpaired electrons (triplet electronic state, or a spin multiplicity \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is not correct, so we need to tell the program the true value (3). Like many programs, Psi4 can get the charge and multiplicity as the first two; integers in the Z-matrix (note the line with 0 3 at the beginning of the molecule specification below). In this example, we will also specify the bond length and bond angle as variables (\(R\) and \(A\)), whose values are first stored and then inserted into the geometry specification using Python 3 string formatting. [4]:. #! Sample UHF/6-31G** CH2 Computation. R = 1.075; A = 133.93. ch2 = psi4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). [4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options() API, to the input. This function takes a Python dictionary as its argument, which is a key-value list which associates a Psi4 keyword with its user-defined value. For open shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree-Fock, or UHF) or restricted orbitals (restricted open-shell Hartree-Fock, or ROHF). Usually, UHF is a little easier to converge (although it may be more susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as specified by the psi4.energy() API function). Of course there are other kinds of computations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look a",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:6541,Energy Efficiency,energy,energy,6541,"red and then inserted into the geometry specification using Python 3 string formatting. [4]:. #! Sample UHF/6-31G** CH2 Computation. R = 1.075; A = 133.93. ch2 = psi4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). [4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options() API, to the input. This function takes a Python dictionary as its argument, which is a key-value list which associates a Psi4 keyword with its user-defined value. For open shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree-Fock, or UHF) or restricted orbitals (restricted open-shell Hartree-Fock, or ROHF). Usually, UHF is a little easier to converge (although it may be more susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as specified by the psi4.energy() API function). Of course there are other kinds of computations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:.",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:6587,Energy Efficiency,energy,energy,6587,". [4]:. #! Sample UHF/6-31G** CH2 Computation. R = 1.075; A = 133.93. ch2 = psi4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). [4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options() API, to the input. This function takes a Python dictionary as its argument, which is a key-value list which associates a Psi4 keyword with its user-defined value. For open shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree-Fock, or UHF) or restricted orbitals (restricted open-shell Hartree-Fock, or ROHF). Usually, UHF is a little easier to converge (although it may be more susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as specified by the psi4.energy() API function). Of course there are other kinds of computations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradien",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:6783,Energy Efficiency,energy,energy,6783,"gy('scf/6-31g**'). [4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options() API, to the input. This function takes a Python dictionary as its argument, which is a key-value list which associates a Psi4 keyword with its user-defined value. For open shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree-Fock, or UHF) or restricted orbitals (restricted open-shell Hartree-Fock, or ROHF). Usually, UHF is a little easier to converge (although it may be more susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as specified by the psi4.energy() API function). Of course there are other kinds of computations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization com",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:7067,Energy Efficiency,energy,energy,7067,"ich is a key-value list which associates a Psi4 keyword with its user-defined value. For open shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree-Fock, or UHF) or restricted orbitals (restricted open-shell Hartree-Fock, or ROHF). Usually, UHF is a little easier to converge (although it may be more susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as specified by the psi4.energy() API function). Of course there are other kinds of computations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization complete!. As indicated in the following table (printed by the optimizer at the end of the computation and grep-able with ~), the energy decreases with each step, and the maximum force on each atom also decreases with each step (in; principle, these numbers could inc",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:7633,Energy Efficiency,energy,energy,7633,"mputations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization complete!. As indicated in the following table (printed by the optimizer at the end of the computation and grep-able with ~), the energy decreases with each step, and the maximum force on each atom also decreases with each step (in; principle, these numbers could increase in some iterations, but here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946     ",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:7922,Energy Efficiency,energy,energy,7922,"a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization complete!. As indicated in the following table (printed by the optimizer at the end of the computation and grep-able with ~), the energy decreases with each step, and the maximum force on each atom also decreases with each step (in; principle, these numbers could increase in some iterations, but here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s i",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:9705,Energy Efficiency,energy,energy,9705,"8  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s important to keep in mind that the values of the vibrational frequencies are a function of the molecular geometry. Therefore, it’s important to obtain the vibrational frequencies AT THE OPTIMIZED GEOMETRY. Luckily, Psi4 updates the molecule with optimized geometry as it is being optimized. So, the optimized geometry for H\(_2\)O is stored inside the h2o molecule object, which we can access! To compute the frequencies, all we need to do; is to again pass the molecule=h2o argument to the psi4.frequency() API function:. [6]:. scf_e, scf_wfn = psi4.frequency('scf/cc-pvdz', molecule=h2o, return_wfn=True). 6 displacements needed.; 1 2 3 4 5 6. Executing this cell will prompt Psi4 to compute the Hessian (second derivative matrix) of the electronic energy with respect to nuclear displacements. From this, it can obtain the harmonic vibrational frequencies, given below (roundoff errors of around \(0.1\) cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2). The program also print out the normal modes in terms of Cartesian coordinates of each atom. For example, the normal mode at \(1776\) cm\(^{-1}\) is:; Frequency: 1775.65; Force constant: 0.1193; X Y Z mass; O 0.000 0.000 -0.068 15.994915; H 0.000 0.416 0.536 1.007825; H 0.000 -0.416 0.536 1.007825. where the table shows the displacements in the X, Y, and Z dimensions for each atom along the normal mode coordinate. (This information could be used to animate the vibrational frequency using visualization software.); Because the vibrational f",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:10977,Energy Efficiency,energy,energy,10977,"-----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2). The program also print out the normal modes in terms of Cartesian coordinates of each atom. For example, the normal mode at \(1776\) cm\(^{-1}\) is:; Frequency: 1775.65; Force constant: 0.1193; X Y Z mass; O 0.000 0.000 -0.068 15.994915; H 0.000 0.416 0.536 1.007825; H 0.000 -0.416 0.536 1.007825. where the table shows the displacements in the X, Y, and Z dimensions for each atom along the normal mode coordinate. (This information could be used to animate the vibrational frequency using visualization software.); Because the vibrational frequencies are available, a thermodynamics analysis is automatically performed at the end of the computation. You can see this in the next section of the output file output.dat. The vibrational frequencies are sufficient to obtain vibrational contributions to enthalpy (H), entropy (S), and Gibbs free energy (G). Similarly, the molecular geometry is used to obtain rotational constants, which are then used to obtain rotational contributions to H, S, and G.; Note: Psi4 has several synonyms for the functions called in this example. For instance, psi4.frequency() API will compute molecular vibrational frequencies, and psi4.optimize() API will perform a geometry optimization. IV. Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. Psi4 contains code to analyze the nature of intermolecular interactions between two molecules, via symmetry-adapted perturbation theory (SAPT) (Jeziorski:1994:1887). This kind of analysis gives a lot of insight into the nature of intermolecular interactions, and Psi4 makes these computations easier than ever.; For a SAPT computation, the input needs to provide information on two distinct molecules. This is very easy, we just give a Z-matrix or set of Cartesian",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:11564,Energy Efficiency,adapt,adapted,11564,"oordinate. (This information could be used to animate the vibrational frequency using visualization software.); Because the vibrational frequencies are available, a thermodynamics analysis is automatically performed at the end of the computation. You can see this in the next section of the output file output.dat. The vibrational frequencies are sufficient to obtain vibrational contributions to enthalpy (H), entropy (S), and Gibbs free energy (G). Similarly, the molecular geometry is used to obtain rotational constants, which are then used to obtain rotational contributions to H, S, and G.; Note: Psi4 has several synonyms for the functions called in this example. For instance, psi4.frequency() API will compute molecular vibrational frequencies, and psi4.optimize() API will perform a geometry optimization. IV. Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. Psi4 contains code to analyze the nature of intermolecular interactions between two molecules, via symmetry-adapted perturbation theory (SAPT) (Jeziorski:1994:1887). This kind of analysis gives a lot of insight into the nature of intermolecular interactions, and Psi4 makes these computations easier than ever.; For a SAPT computation, the input needs to provide information on two distinct molecules. This is very easy, we just give a Z-matrix or set of Cartesian coordinates for each molecule, and separate the two with two dashes, like this:. [7]:. # Example SAPT computation for ethene*ethyne (*i.e.*, ethylene*acetylene).; # Test case 16 from S22 Database. dimer = psi4.geometry(""""""; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; units angstrom; """"""). Here’s the second half of the input, where we ",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:12645,Energy Efficiency,energy,energy,12645,"into the nature of intermolecular interactions, and Psi4 makes these computations easier than ever.; For a SAPT computation, the input needs to provide information on two distinct molecules. This is very easy, we just give a Z-matrix or set of Cartesian coordinates for each molecule, and separate the two with two dashes, like this:. [7]:. # Example SAPT computation for ethene*ethyne (*i.e.*, ethylene*acetylene).; # Test case 16 from S22 Database. dimer = psi4.geometry(""""""; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; units angstrom; """"""). Here’s the second half of the input, where we specify the computation options:. [8]:. psi4.set_options({'scf_type': 'df',; 'freeze_core': 'true'}). psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). [8]:. -0.0022355825227244703. All of the options we have currently set using psi4.set_options() API are “global” options (meaning that they are visible to all parts of the program). Most common Psi4 options can be set like this. If an option needs to be visible only to one part of the program (e.g., we only want to increase the energy convergence in the SCF code, but not the rest of the code), it can be set by with the; psi4.set_module_options() API function, psi4.set_module_options('scf', {'e_convergence': '1e-8'}).; Note: The arguments to the functions we’ve used so far, like psi4.set_options() API, psi4.set_module_options() API, psi4.energy() API, psi4.optimize(); API, psi4.frequency() API, etc., are case-insensitive.; Back to our SAPT example, we have found that for basic-level SAPT computations (i.e., SAPT0), a good error cancellation is found (Hohenstein:2012:WIREs) with the jun-cc-pVDZ basis (this is the usual aug-cc-pVDZ basis, but without diffuse functio",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:13020,Energy Efficiency,energy,energy,13020,"*i.e.*, ethylene*acetylene).; # Test case 16 from S22 Database. dimer = psi4.geometry(""""""; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; units angstrom; """"""). Here’s the second half of the input, where we specify the computation options:. [8]:. psi4.set_options({'scf_type': 'df',; 'freeze_core': 'true'}). psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). [8]:. -0.0022355825227244703. All of the options we have currently set using psi4.set_options() API are “global” options (meaning that they are visible to all parts of the program). Most common Psi4 options can be set like this. If an option needs to be visible only to one part of the program (e.g., we only want to increase the energy convergence in the SCF code, but not the rest of the code), it can be set by with the; psi4.set_module_options() API function, psi4.set_module_options('scf', {'e_convergence': '1e-8'}).; Note: The arguments to the functions we’ve used so far, like psi4.set_options() API, psi4.set_module_options() API, psi4.energy() API, psi4.optimize(); API, psi4.frequency() API, etc., are case-insensitive.; Back to our SAPT example, we have found that for basic-level SAPT computations (i.e., SAPT0), a good error cancellation is found (Hohenstein:2012:WIREs) with the jun-cc-pVDZ basis (this is the usual aug-cc-pVDZ basis, but without diffuse functions on hydrogen and without diffuse \(d\) functions on heavy atoms) (Papajak:2011:10). So,; we’ll use that as our standard basis set. The SAPT code is designed to use density fitting techniques, because they introduce minimal errors while providing much faster computations (Hohenstein:2010:184111,Hohenstein:2010:014101). Since we’re using density fitting for the SAPT, we might as well ",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:13335,Energy Efficiency,energy,energy,13335," 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; units angstrom; """"""). Here’s the second half of the input, where we specify the computation options:. [8]:. psi4.set_options({'scf_type': 'df',; 'freeze_core': 'true'}). psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). [8]:. -0.0022355825227244703. All of the options we have currently set using psi4.set_options() API are “global” options (meaning that they are visible to all parts of the program). Most common Psi4 options can be set like this. If an option needs to be visible only to one part of the program (e.g., we only want to increase the energy convergence in the SCF code, but not the rest of the code), it can be set by with the; psi4.set_module_options() API function, psi4.set_module_options('scf', {'e_convergence': '1e-8'}).; Note: The arguments to the functions we’ve used so far, like psi4.set_options() API, psi4.set_module_options() API, psi4.energy() API, psi4.optimize(); API, psi4.frequency() API, etc., are case-insensitive.; Back to our SAPT example, we have found that for basic-level SAPT computations (i.e., SAPT0), a good error cancellation is found (Hohenstein:2012:WIREs) with the jun-cc-pVDZ basis (this is the usual aug-cc-pVDZ basis, but without diffuse functions on hydrogen and without diffuse \(d\) functions on heavy atoms) (Papajak:2011:10). So,; we’ll use that as our standard basis set. The SAPT code is designed to use density fitting techniques, because they introduce minimal errors while providing much faster computations (Hohenstein:2010:184111,Hohenstein:2010:014101). Since we’re using density fitting for the SAPT, we might as well also use it for the Hartree-Fock; computations that are performed as part of the SAPT. We can specify that by adding 'scf_type': 'df' to the dictionary passed to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that pair with the primary basis set. For",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:14963,Energy Efficiency,energy,energy,14963,"1). Since we’re using density fitting for the SAPT, we might as well also use it for the Hartree-Fock; computations that are performed as part of the SAPT. We can specify that by adding 'scf_type': 'df' to the dictionary passed to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that pair with the primary basis set. Fortunately, Psi4 is usually smart enough to figure out what auxiliary basis sets are needed for a given computation. In this case, jun-cc-pVDZ is a standard enough basis set (just a simple truncation of the very popular aug-cc-pVDZ basis set) that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the SAPT; procedure.; To speed up the computation a little, we also tell the SAPT procedure to freeze the core electrons by adding 'freeze_core': 'true' to the dictionary passed to psi4.set_options(). The SAPT procedure is invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here, Psi4 knows to automatically run two monomer computations and a dimer computation and then use these results to perform the SAPT analysis. The various energy components are printed at the end of the output, in addition to; the total SAPT0 interaction energy. An explanation of the various energy components can be found in the review by Jeziorski, Moszynski, and Szalewicz (Jeziorski:1994:1887), and this is discussed in more detail in the SAPT section of the Psi4 manual.; For now, we’ll note that most of the SAPT energy components are negative; this means those are attractive contributions (the zero of energy in a SAPT computation is defined as non-interacting monomers). The exchange contributions are positive (repulsive). In this example, the most attractive contribution between ethylene and acetylene is an electrostatic term of \(-2.12\) kcal/mol (Elst10,r where the 1 indicates the first-order perturbation theory result with respect to the; intermolecular int",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:15164,Energy Efficiency,energy,energy,15164,"d to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that pair with the primary basis set. Fortunately, Psi4 is usually smart enough to figure out what auxiliary basis sets are needed for a given computation. In this case, jun-cc-pVDZ is a standard enough basis set (just a simple truncation of the very popular aug-cc-pVDZ basis set) that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the SAPT; procedure.; To speed up the computation a little, we also tell the SAPT procedure to freeze the core electrons by adding 'freeze_core': 'true' to the dictionary passed to psi4.set_options(). The SAPT procedure is invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here, Psi4 knows to automatically run two monomer computations and a dimer computation and then use these results to perform the SAPT analysis. The various energy components are printed at the end of the output, in addition to; the total SAPT0 interaction energy. An explanation of the various energy components can be found in the review by Jeziorski, Moszynski, and Szalewicz (Jeziorski:1994:1887), and this is discussed in more detail in the SAPT section of the Psi4 manual.; For now, we’ll note that most of the SAPT energy components are negative; this means those are attractive contributions (the zero of energy in a SAPT computation is defined as non-interacting monomers). The exchange contributions are positive (repulsive). In this example, the most attractive contribution between ethylene and acetylene is an electrostatic term of \(-2.12\) kcal/mol (Elst10,r where the 1 indicates the first-order perturbation theory result with respect to the; intermolecular interaction, and the 0 indicates zeroth-order with respect to the intramolecular electron correlation). The next most attractive contribution is the Disp20 term (second order intermolecular dispersion, which looks like MP2 in whi",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:15264,Energy Efficiency,energy,energy,15264,"d to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that pair with the primary basis set. Fortunately, Psi4 is usually smart enough to figure out what auxiliary basis sets are needed for a given computation. In this case, jun-cc-pVDZ is a standard enough basis set (just a simple truncation of the very popular aug-cc-pVDZ basis set) that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the SAPT; procedure.; To speed up the computation a little, we also tell the SAPT procedure to freeze the core electrons by adding 'freeze_core': 'true' to the dictionary passed to psi4.set_options(). The SAPT procedure is invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here, Psi4 knows to automatically run two monomer computations and a dimer computation and then use these results to perform the SAPT analysis. The various energy components are printed at the end of the output, in addition to; the total SAPT0 interaction energy. An explanation of the various energy components can be found in the review by Jeziorski, Moszynski, and Szalewicz (Jeziorski:1994:1887), and this is discussed in more detail in the SAPT section of the Psi4 manual.; For now, we’ll note that most of the SAPT energy components are negative; this means those are attractive contributions (the zero of energy in a SAPT computation is defined as non-interacting monomers). The exchange contributions are positive (repulsive). In this example, the most attractive contribution between ethylene and acetylene is an electrostatic term of \(-2.12\) kcal/mol (Elst10,r where the 1 indicates the first-order perturbation theory result with respect to the; intermolecular interaction, and the 0 indicates zeroth-order with respect to the intramolecular electron correlation). The next most attractive contribution is the Disp20 term (second order intermolecular dispersion, which looks like MP2 in whi",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:15302,Energy Efficiency,energy,energy,15302,"nough to figure out what auxiliary basis sets are needed for a given computation. In this case, jun-cc-pVDZ is a standard enough basis set (just a simple truncation of the very popular aug-cc-pVDZ basis set) that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the SAPT; procedure.; To speed up the computation a little, we also tell the SAPT procedure to freeze the core electrons by adding 'freeze_core': 'true' to the dictionary passed to psi4.set_options(). The SAPT procedure is invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here, Psi4 knows to automatically run two monomer computations and a dimer computation and then use these results to perform the SAPT analysis. The various energy components are printed at the end of the output, in addition to; the total SAPT0 interaction energy. An explanation of the various energy components can be found in the review by Jeziorski, Moszynski, and Szalewicz (Jeziorski:1994:1887), and this is discussed in more detail in the SAPT section of the Psi4 manual.; For now, we’ll note that most of the SAPT energy components are negative; this means those are attractive contributions (the zero of energy in a SAPT computation is defined as non-interacting monomers). The exchange contributions are positive (repulsive). In this example, the most attractive contribution between ethylene and acetylene is an electrostatic term of \(-2.12\) kcal/mol (Elst10,r where the 1 indicates the first-order perturbation theory result with respect to the; intermolecular interaction, and the 0 indicates zeroth-order with respect to the intramolecular electron correlation). The next most attractive contribution is the Disp20 term (second order intermolecular dispersion, which looks like MP2 in which one excitation is placed on each monomer), contributing an attraction of \(-1.21\) kcal/mol. It is not surprising that the electrostatic contribution is dominant, b",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:15529,Energy Efficiency,energy,energy,15529,"hat Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the SAPT; procedure.; To speed up the computation a little, we also tell the SAPT procedure to freeze the core electrons by adding 'freeze_core': 'true' to the dictionary passed to psi4.set_options(). The SAPT procedure is invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here, Psi4 knows to automatically run two monomer computations and a dimer computation and then use these results to perform the SAPT analysis. The various energy components are printed at the end of the output, in addition to; the total SAPT0 interaction energy. An explanation of the various energy components can be found in the review by Jeziorski, Moszynski, and Szalewicz (Jeziorski:1994:1887), and this is discussed in more detail in the SAPT section of the Psi4 manual.; For now, we’ll note that most of the SAPT energy components are negative; this means those are attractive contributions (the zero of energy in a SAPT computation is defined as non-interacting monomers). The exchange contributions are positive (repulsive). In this example, the most attractive contribution between ethylene and acetylene is an electrostatic term of \(-2.12\) kcal/mol (Elst10,r where the 1 indicates the first-order perturbation theory result with respect to the; intermolecular interaction, and the 0 indicates zeroth-order with respect to the intramolecular electron correlation). The next most attractive contribution is the Disp20 term (second order intermolecular dispersion, which looks like MP2 in which one excitation is placed on each monomer), contributing an attraction of \(-1.21\) kcal/mol. It is not surprising that the electrostatic contribution is dominant, because the geometry chosen for this example has the acetylene perpendicular to; the ethylene, with the acetylene hydrogen pointing directly at the double bond in ethylene; this will be attractive because the H",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:15620,Energy Efficiency,energy,energy,15620,"hat Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the SAPT; procedure.; To speed up the computation a little, we also tell the SAPT procedure to freeze the core electrons by adding 'freeze_core': 'true' to the dictionary passed to psi4.set_options(). The SAPT procedure is invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here, Psi4 knows to automatically run two monomer computations and a dimer computation and then use these results to perform the SAPT analysis. The various energy components are printed at the end of the output, in addition to; the total SAPT0 interaction energy. An explanation of the various energy components can be found in the review by Jeziorski, Moszynski, and Szalewicz (Jeziorski:1994:1887), and this is discussed in more detail in the SAPT section of the Psi4 manual.; For now, we’ll note that most of the SAPT energy components are negative; this means those are attractive contributions (the zero of energy in a SAPT computation is defined as non-interacting monomers). The exchange contributions are positive (repulsive). In this example, the most attractive contribution between ethylene and acetylene is an electrostatic term of \(-2.12\) kcal/mol (Elst10,r where the 1 indicates the first-order perturbation theory result with respect to the; intermolecular interaction, and the 0 indicates zeroth-order with respect to the intramolecular electron correlation). The next most attractive contribution is the Disp20 term (second order intermolecular dispersion, which looks like MP2 in which one excitation is placed on each monomer), contributing an attraction of \(-1.21\) kcal/mol. It is not surprising that the electrostatic contribution is dominant, because the geometry chosen for this example has the acetylene perpendicular to; the ethylene, with the acetylene hydrogen pointing directly at the double bond in ethylene; this will be attractive because the H",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:16631,Energy Efficiency,charge,charge,16631,"most of the SAPT energy components are negative; this means those are attractive contributions (the zero of energy in a SAPT computation is defined as non-interacting monomers). The exchange contributions are positive (repulsive). In this example, the most attractive contribution between ethylene and acetylene is an electrostatic term of \(-2.12\) kcal/mol (Elst10,r where the 1 indicates the first-order perturbation theory result with respect to the; intermolecular interaction, and the 0 indicates zeroth-order with respect to the intramolecular electron correlation). The next most attractive contribution is the Disp20 term (second order intermolecular dispersion, which looks like MP2 in which one excitation is placed on each monomer), contributing an attraction of \(-1.21\) kcal/mol. It is not surprising that the electrostatic contribution is dominant, because the geometry chosen for this example has the acetylene perpendicular to; the ethylene, with the acetylene hydrogen pointing directly at the double bond in ethylene; this will be attractive because the H atoms in acetylene bear a partial positive charge, while the electron rich double bond in ethylene bears a partial negative charge. At the same time, the dispersion interaction should be smaller because the perpendicular geometry does not allow much overlap between the monomers. Hence, the SAPT analysis helps clarify (and quantify) our physical understanding about the; interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as computing the interaction energy between two neon atoms at various interatomic distances. One simple but unappealing way to do this is to generate separate geometries for each distance to be studied. Instead, we can leverage Python loops and string f",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:16712,Energy Efficiency,charge,charge,16712,"most of the SAPT energy components are negative; this means those are attractive contributions (the zero of energy in a SAPT computation is defined as non-interacting monomers). The exchange contributions are positive (repulsive). In this example, the most attractive contribution between ethylene and acetylene is an electrostatic term of \(-2.12\) kcal/mol (Elst10,r where the 1 indicates the first-order perturbation theory result with respect to the; intermolecular interaction, and the 0 indicates zeroth-order with respect to the intramolecular electron correlation). The next most attractive contribution is the Disp20 term (second order intermolecular dispersion, which looks like MP2 in which one excitation is placed on each monomer), contributing an attraction of \(-1.21\) kcal/mol. It is not surprising that the electrostatic contribution is dominant, because the geometry chosen for this example has the acetylene perpendicular to; the ethylene, with the acetylene hydrogen pointing directly at the double bond in ethylene; this will be attractive because the H atoms in acetylene bear a partial positive charge, while the electron rich double bond in ethylene bears a partial negative charge. At the same time, the dispersion interaction should be smaller because the perpendicular geometry does not allow much overlap between the monomers. Hence, the SAPT analysis helps clarify (and quantify) our physical understanding about the; interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as computing the interaction energy between two neon atoms at various interatomic distances. One simple but unappealing way to do this is to generate separate geometries for each distance to be studied. Instead, we can leverage Python loops and string f",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:17234,Energy Efficiency,energy,energy,17234,"an attraction of \(-1.21\) kcal/mol. It is not surprising that the electrostatic contribution is dominant, because the geometry chosen for this example has the acetylene perpendicular to; the ethylene, with the acetylene hydrogen pointing directly at the double bond in ethylene; this will be attractive because the H atoms in acetylene bear a partial positive charge, while the electron rich double bond in ethylene bears a partial negative charge. At the same time, the dispersion interaction should be smaller because the perpendicular geometry does not allow much overlap between the monomers. Hence, the SAPT analysis helps clarify (and quantify) our physical understanding about the; interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as computing the interaction energy between two neon atoms at various interatomic distances. One simple but unappealing way to do this is to generate separate geometries for each distance to be studied. Instead, we can leverage Python loops and string formatting to make our lives simpler. Additionally, let’s suppose you want to do counterpoise (CP) correction to compute interaction energies. Counterpoise correction involves; computing the dimer energy and then subtracting out the energies of the two monomers, each evaluated in the dimer basis. Again, each of these computations could be run in a separate input file, but because counterpoise correction is a fairly standard procedure for intermolecular interactions, Psi4 knows about it and has a built-in routine to perform counterpoise correction. It only needs to know what method you want to do the couterpoise correction on (here, let’s consider CCSD(T)), and it needs; to know what’s monomer A and what’s monomer B. This last issue of specifying the",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:17289,Energy Efficiency,energy,energy,17289,"an attraction of \(-1.21\) kcal/mol. It is not surprising that the electrostatic contribution is dominant, because the geometry chosen for this example has the acetylene perpendicular to; the ethylene, with the acetylene hydrogen pointing directly at the double bond in ethylene; this will be attractive because the H atoms in acetylene bear a partial positive charge, while the electron rich double bond in ethylene bears a partial negative charge. At the same time, the dispersion interaction should be smaller because the perpendicular geometry does not allow much overlap between the monomers. Hence, the SAPT analysis helps clarify (and quantify) our physical understanding about the; interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as computing the interaction energy between two neon atoms at various interatomic distances. One simple but unappealing way to do this is to generate separate geometries for each distance to be studied. Instead, we can leverage Python loops and string formatting to make our lives simpler. Additionally, let’s suppose you want to do counterpoise (CP) correction to compute interaction energies. Counterpoise correction involves; computing the dimer energy and then subtracting out the energies of the two monomers, each evaluated in the dimer basis. Again, each of these computations could be run in a separate input file, but because counterpoise correction is a fairly standard procedure for intermolecular interactions, Psi4 knows about it and has a built-in routine to perform counterpoise correction. It only needs to know what method you want to do the couterpoise correction on (here, let’s consider CCSD(T)), and it needs; to know what’s monomer A and what’s monomer B. This last issue of specifying the",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:17709,Energy Efficiency,energy,energy,17709," time, the dispersion interaction should be smaller because the perpendicular geometry does not allow much overlap between the monomers. Hence, the SAPT analysis helps clarify (and quantify) our physical understanding about the; interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as computing the interaction energy between two neon atoms at various interatomic distances. One simple but unappealing way to do this is to generate separate geometries for each distance to be studied. Instead, we can leverage Python loops and string formatting to make our lives simpler. Additionally, let’s suppose you want to do counterpoise (CP) correction to compute interaction energies. Counterpoise correction involves; computing the dimer energy and then subtracting out the energies of the two monomers, each evaluated in the dimer basis. Again, each of these computations could be run in a separate input file, but because counterpoise correction is a fairly standard procedure for intermolecular interactions, Psi4 knows about it and has a built-in routine to perform counterpoise correction. It only needs to know what method you want to do the couterpoise correction on (here, let’s consider CCSD(T)), and it needs; to know what’s monomer A and what’s monomer B. This last issue of specifying the monomers separately was already dealt with in the previous SAPT example, where we saw that two dashes in the psi4.geometry() string can be used to separate monomers.; So, we’re going to do counterpoise-corrected CCSD(T) energies for Ne\(_2\) at a series of different interatomic distances. And let’s print out a table of the interatomic distances we’ve considered, and the CP-corrected CCSD(T) interaction energies (in kcal/mol) at each geometry:. [9]:. #! Exa",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:18747,Energy Efficiency,energy,energy,18747,"e two monomers, each evaluated in the dimer basis. Again, each of these computations could be run in a separate input file, but because counterpoise correction is a fairly standard procedure for intermolecular interactions, Psi4 knows about it and has a built-in routine to perform counterpoise correction. It only needs to know what method you want to do the couterpoise correction on (here, let’s consider CCSD(T)), and it needs; to know what’s monomer A and what’s monomer B. This last issue of specifying the monomers separately was already dealt with in the previous SAPT example, where we saw that two dashes in the psi4.geometry() string can be used to separate monomers.; So, we’re going to do counterpoise-corrected CCSD(T) energies for Ne\(_2\) at a series of different interatomic distances. And let’s print out a table of the interatomic distances we’ve considered, and the CP-corrected CCSD(T) interaction energies (in kcal/mol) at each geometry:. [9]:. #! Example potential energy surface scan and CP-correction for Ne2. ne2_geometry = """"""; Ne; --; Ne 1 {0}; """""". Rvals = [2.5, 3.0, 4.0]. psi4.set_options({'freeze_core': 'true'}). # Initialize a blank dictionary of counterpoise corrected energies; # (Need this for the syntax below to work). ecp = {}. for R in Rvals:; ne2 = psi4.geometry(ne2_geometry.format(R)); ecp[R] = psi4.energy('ccsd(t)/aug-cc-pvdz', bsse_type='cp', molecule=ne2). # Prints to screen; print(""CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies\n\n""); print("" R [Ang] E_int [kcal/mol] ""); print(""---------------------------------------------------------""); for R in Rvals:; e = ecp[R] * psi4.constants.hartree2kcalmol; print("" {:3.1f} {:1.6f}"".format(R, e)). # Prints to output.dat; psi4.core.print_out(""CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies\n\n""); psi4.core.print_out("" R [Ang] E_int [kcal/mol] \n""); psi4.core.print_out(""---------------------------------------------------------\n""); for R in Rvals:; e = ecp[R] * psi4.constants.hartree2kcal",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:19103,Energy Efficiency,energy,energy,19103,"rrection on (here, let’s consider CCSD(T)), and it needs; to know what’s monomer A and what’s monomer B. This last issue of specifying the monomers separately was already dealt with in the previous SAPT example, where we saw that two dashes in the psi4.geometry() string can be used to separate monomers.; So, we’re going to do counterpoise-corrected CCSD(T) energies for Ne\(_2\) at a series of different interatomic distances. And let’s print out a table of the interatomic distances we’ve considered, and the CP-corrected CCSD(T) interaction energies (in kcal/mol) at each geometry:. [9]:. #! Example potential energy surface scan and CP-correction for Ne2. ne2_geometry = """"""; Ne; --; Ne 1 {0}; """""". Rvals = [2.5, 3.0, 4.0]. psi4.set_options({'freeze_core': 'true'}). # Initialize a blank dictionary of counterpoise corrected energies; # (Need this for the syntax below to work). ecp = {}. for R in Rvals:; ne2 = psi4.geometry(ne2_geometry.format(R)); ecp[R] = psi4.energy('ccsd(t)/aug-cc-pvdz', bsse_type='cp', molecule=ne2). # Prints to screen; print(""CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies\n\n""); print("" R [Ang] E_int [kcal/mol] ""); print(""---------------------------------------------------------""); for R in Rvals:; e = ecp[R] * psi4.constants.hartree2kcalmol; print("" {:3.1f} {:1.6f}"".format(R, e)). # Prints to output.dat; psi4.core.print_out(""CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies\n\n""); psi4.core.print_out("" R [Ang] E_int [kcal/mol] \n""); psi4.core.print_out(""---------------------------------------------------------\n""); for R in Rvals:; e = ecp[R] * psi4.constants.hartree2kcalmol; psi4.core.print_out("" {:3.1f} {:1.6f}\n"".format(R, e)). CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies. R [Ang] E_int [kcal/mol]; ---------------------------------------------------------; 2.5 0.758605; 3.0 0.015968; 4.0 -0.016215. First, you can see the geometry string ne2_geometry has a two dashes to separate the monomers from each other. Also note we’ve use",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:20394,Energy Efficiency,energy,energy,20394,"ants.hartree2kcalmol; print("" {:3.1f} {:1.6f}"".format(R, e)). # Prints to output.dat; psi4.core.print_out(""CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies\n\n""); psi4.core.print_out("" R [Ang] E_int [kcal/mol] \n""); psi4.core.print_out(""---------------------------------------------------------\n""); for R in Rvals:; e = ecp[R] * psi4.constants.hartree2kcalmol; psi4.core.print_out("" {:3.1f} {:1.6f}\n"".format(R, e)). CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies. R [Ang] E_int [kcal/mol]; ---------------------------------------------------------; 2.5 0.758605; 3.0 0.015968; 4.0 -0.016215. First, you can see the geometry string ne2_geometry has a two dashes to separate the monomers from each other. Also note we’ve used a Z-matrix to specify the geometry, and we’ve used a variable (R) as the interatomic distance. We have not specified the value of R in the ne2_geometry string like we normally would. That’s because we are going to vary it during the scan across the potential energy surface, by using a Python loop over the list of interatomic distances Rvals.; Before we are able to pass our molecule to Psi4, we need to do two things. First, we must set the value of the intermolecular separation in our Z-matrix (by using Python 3 string formatting) to the particular value of R. Second, we need to turn the Z-matrix string into a Psi4 molecule, by passing it to `psi4.geometry() <http://psicode.org/psi4manual/master/api/psi4.driver.geometry.html#psi4.driver.geometry>`__. The; argument bsse_type='cp' tells Psi4 to perform counterpoise (CP) correction on the dimer to compute the CCSD(T)/aug-cc-pVDZ interaction energy, which is stored in our ecp dictionary at each iteration of our Python loop. Note that we didn’t need to specify ghost atoms, and we didn’t need to call the monomer and dimer computations separately. Psi4 does it all for us, automatically.; Near the very end of the output file output.dat, the counterpoise correction Python function will print a nice summ",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:21035,Energy Efficiency,energy,energy,21035,"st, you can see the geometry string ne2_geometry has a two dashes to separate the monomers from each other. Also note we’ve used a Z-matrix to specify the geometry, and we’ve used a variable (R) as the interatomic distance. We have not specified the value of R in the ne2_geometry string like we normally would. That’s because we are going to vary it during the scan across the potential energy surface, by using a Python loop over the list of interatomic distances Rvals.; Before we are able to pass our molecule to Psi4, we need to do two things. First, we must set the value of the intermolecular separation in our Z-matrix (by using Python 3 string formatting) to the particular value of R. Second, we need to turn the Z-matrix string into a Psi4 molecule, by passing it to `psi4.geometry() <http://psicode.org/psi4manual/master/api/psi4.driver.geometry.html#psi4.driver.geometry>`__. The; argument bsse_type='cp' tells Psi4 to perform counterpoise (CP) correction on the dimer to compute the CCSD(T)/aug-cc-pVDZ interaction energy, which is stored in our ecp dictionary at each iteration of our Python loop. Note that we didn’t need to specify ghost atoms, and we didn’t need to call the monomer and dimer computations separately. Psi4 does it all for us, automatically.; Near the very end of the output file output.dat, the counterpoise correction Python function will print a nice summary of the results of the counterpoise computation (the energies of the dimer, of monomer 1 with the ghost functions of monomer 2, of monomer 2 with the ghost functions of monomer 1, and the overall counterpoise corrected interaction energy):; N-Body: Computing complex (1/2) with fragments (2,) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (2,), basis = (1, 2): -128.70932405488924); ...; N-Body: Computing complex (2/2) with fragments (1,) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (1,), basis = (1, 2): -128.70932405488935); ...; N-Body: Co",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:21632,Energy Efficiency,energy,energy,21632,", we need to do two things. First, we must set the value of the intermolecular separation in our Z-matrix (by using Python 3 string formatting) to the particular value of R. Second, we need to turn the Z-matrix string into a Psi4 molecule, by passing it to `psi4.geometry() <http://psicode.org/psi4manual/master/api/psi4.driver.geometry.html#psi4.driver.geometry>`__. The; argument bsse_type='cp' tells Psi4 to perform counterpoise (CP) correction on the dimer to compute the CCSD(T)/aug-cc-pVDZ interaction energy, which is stored in our ecp dictionary at each iteration of our Python loop. Note that we didn’t need to specify ghost atoms, and we didn’t need to call the monomer and dimer computations separately. Psi4 does it all for us, automatically.; Near the very end of the output file output.dat, the counterpoise correction Python function will print a nice summary of the results of the counterpoise computation (the energies of the dimer, of monomer 1 with the ghost functions of monomer 2, of monomer 2 with the ghost functions of monomer 1, and the overall counterpoise corrected interaction energy):; N-Body: Computing complex (1/2) with fragments (2,) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (2,), basis = (1, 2): -128.70932405488924); ...; N-Body: Computing complex (2/2) with fragments (1,) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (1,), basis = (1, 2): -128.70932405488935); ...; N-Body: Computing complex (1/1) with fragments (1, 2) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (1, 2), basis = (1, 2): -257.41867403127321); ...; ==> N-Body: Counterpoise Corrected (CP) energies <==. n-Body Total Energy [Eh] I.E. [kcal/mol] Delta [kcal/mol]; 1 -257.418648109779 0.000000000000 0.000000000000; 2 -257.418674031273 -0.016265984132 -0.016265984132. And that’s it! The only remaining part of the example is a little table of the different R values and the CP-corrected CCSD(T) energi",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:7766,Integrability,message,message,7766,"specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization complete!. As indicated in the following table (printed by the optimizer at the end of the computation and grep-able with ~), the energy decreases with each step, and the maximum force on each atom also decreases with each step (in; principle, these numbers could increase in some iterations, but here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.0000848",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:18022,Integrability,rout,routine,18022,"derstanding about the; interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as computing the interaction energy between two neon atoms at various interatomic distances. One simple but unappealing way to do this is to generate separate geometries for each distance to be studied. Instead, we can leverage Python loops and string formatting to make our lives simpler. Additionally, let’s suppose you want to do counterpoise (CP) correction to compute interaction energies. Counterpoise correction involves; computing the dimer energy and then subtracting out the energies of the two monomers, each evaluated in the dimer basis. Again, each of these computations could be run in a separate input file, but because counterpoise correction is a fairly standard procedure for intermolecular interactions, Psi4 knows about it and has a built-in routine to perform counterpoise correction. It only needs to know what method you want to do the couterpoise correction on (here, let’s consider CCSD(T)), and it needs; to know what’s monomer A and what’s monomer B. This last issue of specifying the monomers separately was already dealt with in the previous SAPT example, where we saw that two dashes in the psi4.geometry() string can be used to separate monomers.; So, we’re going to do counterpoise-corrected CCSD(T) energies for Ne\(_2\) at a series of different interatomic distances. And let’s print out a table of the interatomic distances we’ve considered, and the CP-corrected CCSD(T) interaction energies (in kcal/mol) at each geometry:. [9]:. #! Example potential energy surface scan and CP-correction for Ne2. ne2_geometry = """"""; Ne; --; Ne 1 {0}; """""". Rvals = [2.5, 3.0, 4.0]. psi4.set_options({'freeze_core': 'true'}). # Initialize a blank dictionary ",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:1068,Modifiability,variab,variables,1068,"Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. A PSI4 Tutorial; PsiAPI Tutorial: Using Psi4 as a Python Module. PsiAPI Tutorial: Using Psi4 as a Python Module¶; transcribed by D. A. Sirianni. Note: Psithon and PsiAPI refer to two modes of interacting with Psi4. In Psithon mode, you write an input file in our domain-specific language (not quite Python) where commands don’t have psi4. in front, then submit it to the executable psi4 which processes the Psithon into pure Python and runs it internally. In PsiAPI mode, you write a pure Python script with import psi4 at the top, and commands are behind the psi4. namespace, then submit it to the python interpreter.; Both modes are equally powerful. This tutorial covers the PsiAPI mode. Note: PsiAPI mode has been available since late 2016 and the v1.1 release. While we aim to provide deprecation warnings and upgrade helpers, the API should not be considered completely stable. Most importantly, as we someday deprecate the last of the global variables, options will be added to the method calls (e.g., energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after compilation or How to run Psi4 as a Python module from conda installation for assistance in setting up Psi4. Here, we will explore the basics of using Psi4 in the interactive PsiAPI style where it is loaded directly as a Python module by reproducing the section A Psi4 Tutorial from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your path, feel free to execute each cell as you read along by pressing Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python environment:. [1]:. # Ignore this block -- it's for the documentation build; try:; import os, sys; sys.path.insert(1, os.path.abspath('/home/runner/work/psi4/psi4/code/objdir/stage//usr/local/psi4/lib/')); except ImportError:; pa",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:5457,Modifiability,variab,variables,5457,"r a closed-shell molecule with all electrons paired), or the reference wavefunction to use (restricted Hartree-Fock, or RHF, is usually appropriate for a closed-shell molecule). The program correctly guessed all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not all the electrons are paired. For example, let’s run a computation on methylene (\(\text{CH}_2\)), whose ground electronic state has two unpaired electrons (triplet electronic state, or a spin multiplicity \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is not correct, so we need to tell the program the true value (3). Like many programs, Psi4 can get the charge and multiplicity as the first two; integers in the Z-matrix (note the line with 0 3 at the beginning of the molecule specification below). In this example, we will also specify the bond length and bond angle as variables (\(R\) and \(A\)), whose values are first stored and then inserted into the geometry specification using Python 3 string formatting. [4]:. #! Sample UHF/6-31G** CH2 Computation. R = 1.075; A = 133.93. ch2 = psi4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). [4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options() API, to the input. This function takes a Python dictionary as its argument, which is a key-value list which associates a Psi4 keyword with its user-defined value. For open shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree-Fock, or UHF) or restricted orbitals (restricted open-shell Hartree-Fock, or ROHF). Usually, UHF is a little easier to converge (although it may be more susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analys",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:11564,Modifiability,adapt,adapted,11564,"oordinate. (This information could be used to animate the vibrational frequency using visualization software.); Because the vibrational frequencies are available, a thermodynamics analysis is automatically performed at the end of the computation. You can see this in the next section of the output file output.dat. The vibrational frequencies are sufficient to obtain vibrational contributions to enthalpy (H), entropy (S), and Gibbs free energy (G). Similarly, the molecular geometry is used to obtain rotational constants, which are then used to obtain rotational contributions to H, S, and G.; Note: Psi4 has several synonyms for the functions called in this example. For instance, psi4.frequency() API will compute molecular vibrational frequencies, and psi4.optimize() API will perform a geometry optimization. IV. Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. Psi4 contains code to analyze the nature of intermolecular interactions between two molecules, via symmetry-adapted perturbation theory (SAPT) (Jeziorski:1994:1887). This kind of analysis gives a lot of insight into the nature of intermolecular interactions, and Psi4 makes these computations easier than ever.; For a SAPT computation, the input needs to provide information on two distinct molecules. This is very easy, we just give a Z-matrix or set of Cartesian coordinates for each molecule, and separate the two with two dashes, like this:. [7]:. # Example SAPT computation for ethene*ethyne (*i.e.*, ethylene*acetylene).; # Test case 16 from S22 Database. dimer = psi4.geometry(""""""; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; units angstrom; """"""). Here’s the second half of the input, where we ",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:20188,Modifiability,variab,variable,20188,"s to screen; print(""CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies\n\n""); print("" R [Ang] E_int [kcal/mol] ""); print(""---------------------------------------------------------""); for R in Rvals:; e = ecp[R] * psi4.constants.hartree2kcalmol; print("" {:3.1f} {:1.6f}"".format(R, e)). # Prints to output.dat; psi4.core.print_out(""CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies\n\n""); psi4.core.print_out("" R [Ang] E_int [kcal/mol] \n""); psi4.core.print_out(""---------------------------------------------------------\n""); for R in Rvals:; e = ecp[R] * psi4.constants.hartree2kcalmol; psi4.core.print_out("" {:3.1f} {:1.6f}\n"".format(R, e)). CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies. R [Ang] E_int [kcal/mol]; ---------------------------------------------------------; 2.5 0.758605; 3.0 0.015968; 4.0 -0.016215. First, you can see the geometry string ne2_geometry has a two dashes to separate the monomers from each other. Also note we’ve used a Z-matrix to specify the geometry, and we’ve used a variable (R) as the interatomic distance. We have not specified the value of R in the ne2_geometry string like we normally would. That’s because we are going to vary it during the scan across the potential energy surface, by using a Python loop over the list of interatomic distances Rvals.; Before we are able to pass our molecule to Psi4, we need to do two things. First, we must set the value of the intermolecular separation in our Z-matrix (by using Python 3 string formatting) to the particular value of R. Second, we need to turn the Z-matrix string into a Psi4 molecule, by passing it to `psi4.geometry() <http://psicode.org/psi4manual/master/api/psi4.driver.geometry.html#psi4.driver.geometry>`__. The; argument bsse_type='cp' tells Psi4 to perform counterpoise (CP) correction on the dimer to compute the CCSD(T)/aug-cc-pVDZ interaction energy, which is stored in our ecp dictionary at each iteration of our Python loop. Note that we didn’t need to specify ghost atoms, and",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:1424,Performance,load,loaded,1424,"t have psi4. in front, then submit it to the executable psi4 which processes the Psithon into pure Python and runs it internally. In PsiAPI mode, you write a pure Python script with import psi4 at the top, and commands are behind the psi4. namespace, then submit it to the python interpreter.; Both modes are equally powerful. This tutorial covers the PsiAPI mode. Note: PsiAPI mode has been available since late 2016 and the v1.1 release. While we aim to provide deprecation warnings and upgrade helpers, the API should not be considered completely stable. Most importantly, as we someday deprecate the last of the global variables, options will be added to the method calls (e.g., energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after compilation or How to run Psi4 as a Python module from conda installation for assistance in setting up Psi4. Here, we will explore the basics of using Psi4 in the interactive PsiAPI style where it is loaded directly as a Python module by reproducing the section A Psi4 Tutorial from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your path, feel free to execute each cell as you read along by pressing Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python environment:. [1]:. # Ignore this block -- it's for the documentation build; try:; import os, sys; sys.path.insert(1, os.path.abspath('/home/runner/work/psi4/psi4/code/objdir/stage//usr/local/psi4/lib/')); except ImportError:; pass. # This is the important part; import psi4. Psi4 is now able to be controlled directly from Python. By default, Psi4 will print any output to the screen; this can be changed by giving a file name (with path if not in the current working directory) to the function psi4.core.set_output_file() :psicode:[API] <psi4manual/master/api/psi4.core.set_output_file> , as a string:. [2]:. ",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:6662,Performance,perform,perform,6662,"si4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). [4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options() API, to the input. This function takes a Python dictionary as its argument, which is a key-value list which associates a Psi4 keyword with its user-defined value. For open shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree-Fock, or UHF) or restricted orbitals (restricted open-shell Hartree-Fock, or ROHF). Usually, UHF is a little easier to converge (although it may be more susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as specified by the psi4.energy() API function). Of course there are other kinds of computations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:6688,Performance,optimiz,optimizations,6688,"si4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). [4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options() API, to the input. This function takes a Python dictionary as its argument, which is a key-value list which associates a Psi4 keyword with its user-defined value. For open shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree-Fock, or UHF) or restricted orbitals (restricted open-shell Hartree-Fock, or ROHF). Usually, UHF is a little easier to converge (although it may be more susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as specified by the psi4.energy() API function). Of course there are other kinds of computations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:6807,Performance,optimiz,optimize,6807,". -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options() API, to the input. This function takes a Python dictionary as its argument, which is a key-value list which associates a Psi4 keyword with its user-defined value. For open shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree-Fock, or UHF) or restricted orbitals (restricted open-shell Hartree-Fock, or ROHF). Usually, UHF is a little easier to converge (although it may be more susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as specified by the psi4.energy() API function). Of course there are other kinds of computations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization complete!. As indicated in ",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:6897,Performance,optimiz,optimizing,6897,"-38.92533462887677. Notice the new command, psi4.set_options() API, to the input. This function takes a Python dictionary as its argument, which is a key-value list which associates a Psi4 keyword with its user-defined value. For open shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree-Fock, or UHF) or restricted orbitals (restricted open-shell Hartree-Fock, or ROHF). Usually, UHF is a little easier to converge (although it may be more susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as specified by the psi4.energy() API function). Of course there are other kinds of computations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization complete!. As indicated in the following table (printed by the optimizer at the end of the computation and grep-able with ~),",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:7271,Performance,optimiz,optimization,7271,"r restricted orbitals (restricted open-shell Hartree-Fock, or ROHF). Usually, UHF is a little easier to converge (although it may be more susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as specified by the psi4.energy() API function). Of course there are other kinds of computations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization complete!. As indicated in the following table (printed by the optimizer at the end of the computation and grep-able with ~), the energy decreases with each step, and the maximum force on each atom also decreases with each step (in; principle, these numbers could increase in some iterations, but here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:7355,Performance,optimiz,optimize,7355,"ugh it may be more susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as specified by the psi4.energy() API function). Of course there are other kinds of computations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization complete!. As indicated in the following table (printed by the optimizer at the end of the computation and grep-able with ~), the energy decreases with each step, and the maximum force on each atom also decreases with each step (in; principle, these numbers could increase in some iterations, but here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ -------------------------------",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:7433,Performance,optimiz,optimize,7433,"ization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as specified by the psi4.energy() API function). Of course there are other kinds of computations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization complete!. As indicated in the following table (printed by the optimizer at the end of the computation and grep-able with ~), the energy decreases with each step, and the maximum force on each atom also decreases with each step (in; principle, these numbers could increase in some iterations, but here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~  ",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:7545,Performance,perform,perform,7545,"s (as specified by the psi4.energy() API function). Of course there are other kinds of computations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization complete!. As indicated in the following table (printed by the optimizer at the end of the computation and grep-able with ~), the energy decreases with each step, and the maximum force on each atom also decreases with each step (in; principle, these numbers could increase in some iterations, but here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.0227753",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:7649,Performance,optimiz,optimizer,7649,"mputations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization complete!. As indicated in the following table (printed by the optimizer at the end of the computation and grep-able with ~), the energy decreases with each step, and the maximum force on each atom also decreases with each step (in; principle, these numbers could increase in some iterations, but here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946     ",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:7855,Performance,optimiz,optimizer,7855,"a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization complete!. As indicated in the following table (printed by the optimizer at the end of the computation and grep-able with ~), the energy decreases with each step, and the maximum force on each atom also decreases with each step (in; principle, these numbers could increase in some iterations, but here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s i",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:9200,Performance,optimiz,optimized,9200,"------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s important to keep in mind that the values of the vibrational frequencies are a function of the molecular geometry. Therefore, it’s important to obtain the vibrational frequencies AT THE OPTIMIZED GEOMETRY. Luckily, Psi4 updates the molecule with optimized geometry as it is being optimized. So, the optimized geometry for H\(_2\)O is stored inside the h2o molecule object, which we can access! To compute the frequencies, all we need to do; is to again pass the molecule=h2o argument to the psi4.frequency() API function:. [6]:. scf_e, scf_wfn = psi4.frequency('scf/cc-pvdz', molecule=h2o, return_wfn=True). 6 displacements needed.; 1 2 3 4 5 6. Executing this cell will prompt Psi4 to compute the Hessian (second derivative matrix) of the electronic energy with respect to nuclear displacements. From this, it can obtain the harmonic vibrational frequencies, given below (roundoff errors of around \(0.1\) cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2). The program also print out the normal modes in terms of Cartesian coor",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:9234,Performance,optimiz,optimized,9234,"------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s important to keep in mind that the values of the vibrational frequencies are a function of the molecular geometry. Therefore, it’s important to obtain the vibrational frequencies AT THE OPTIMIZED GEOMETRY. Luckily, Psi4 updates the molecule with optimized geometry as it is being optimized. So, the optimized geometry for H\(_2\)O is stored inside the h2o molecule object, which we can access! To compute the frequencies, all we need to do; is to again pass the molecule=h2o argument to the psi4.frequency() API function:. [6]:. scf_e, scf_wfn = psi4.frequency('scf/cc-pvdz', molecule=h2o, return_wfn=True). 6 displacements needed.; 1 2 3 4 5 6. Executing this cell will prompt Psi4 to compute the Hessian (second derivative matrix) of the electronic energy with respect to nuclear displacements. From this, it can obtain the harmonic vibrational frequencies, given below (roundoff errors of around \(0.1\) cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2). The program also print out the normal modes in terms of Cartesian coor",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:9253,Performance,optimiz,optimized,9253,"----------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s important to keep in mind that the values of the vibrational frequencies are a function of the molecular geometry. Therefore, it’s important to obtain the vibrational frequencies AT THE OPTIMIZED GEOMETRY. Luckily, Psi4 updates the molecule with optimized geometry as it is being optimized. So, the optimized geometry for H\(_2\)O is stored inside the h2o molecule object, which we can access! To compute the frequencies, all we need to do; is to again pass the molecule=h2o argument to the psi4.frequency() API function:. [6]:. scf_e, scf_wfn = psi4.frequency('scf/cc-pvdz', molecule=h2o, return_wfn=True). 6 displacements needed.; 1 2 3 4 5 6. Executing this cell will prompt Psi4 to compute the Hessian (second derivative matrix) of the electronic energy with respect to nuclear displacements. From this, it can obtain the harmonic vibrational frequencies, given below (roundoff errors of around \(0.1\) cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2). The program also print out the normal modes in terms of Cartesian coordinates of each atom. For example, the normal mode at \(1776\) cm\(^{-1}\) is:; Frequency: 1775.65; Force constant: 0.1193; X Y Z mass; O 0.000 0",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:10744,Performance,perform,performed,10744,"h respect to nuclear displacements. From this, it can obtain the harmonic vibrational frequencies, given below (roundoff errors of around \(0.1\) cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2). The program also print out the normal modes in terms of Cartesian coordinates of each atom. For example, the normal mode at \(1776\) cm\(^{-1}\) is:; Frequency: 1775.65; Force constant: 0.1193; X Y Z mass; O 0.000 0.000 -0.068 15.994915; H 0.000 0.416 0.536 1.007825; H 0.000 -0.416 0.536 1.007825. where the table shows the displacements in the X, Y, and Z dimensions for each atom along the normal mode coordinate. (This information could be used to animate the vibrational frequency using visualization software.); Because the vibrational frequencies are available, a thermodynamics analysis is automatically performed at the end of the computation. You can see this in the next section of the output file output.dat. The vibrational frequencies are sufficient to obtain vibrational contributions to enthalpy (H), entropy (S), and Gibbs free energy (G). Similarly, the molecular geometry is used to obtain rotational constants, which are then used to obtain rotational contributions to H, S, and G.; Note: Psi4 has several synonyms for the functions called in this example. For instance, psi4.frequency() API will compute molecular vibrational frequencies, and psi4.optimize() API will perform a geometry optimization. IV. Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. Psi4 contains code to analyze the nature of intermolecular interactions between two molecules, via symmetry-adapted perturbation theory (SAPT) (Jeziorski:1994:1887). This kind of analysis gives a lot of insight into the nature of intermolecular interactions, a",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:11301,Performance,optimiz,optimize,11301," Y Z mass; O 0.000 0.000 -0.068 15.994915; H 0.000 0.416 0.536 1.007825; H 0.000 -0.416 0.536 1.007825. where the table shows the displacements in the X, Y, and Z dimensions for each atom along the normal mode coordinate. (This information could be used to animate the vibrational frequency using visualization software.); Because the vibrational frequencies are available, a thermodynamics analysis is automatically performed at the end of the computation. You can see this in the next section of the output file output.dat. The vibrational frequencies are sufficient to obtain vibrational contributions to enthalpy (H), entropy (S), and Gibbs free energy (G). Similarly, the molecular geometry is used to obtain rotational constants, which are then used to obtain rotational contributions to H, S, and G.; Note: Psi4 has several synonyms for the functions called in this example. For instance, psi4.frequency() API will compute molecular vibrational frequencies, and psi4.optimize() API will perform a geometry optimization. IV. Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. Psi4 contains code to analyze the nature of intermolecular interactions between two molecules, via symmetry-adapted perturbation theory (SAPT) (Jeziorski:1994:1887). This kind of analysis gives a lot of insight into the nature of intermolecular interactions, and Psi4 makes these computations easier than ever.; For a SAPT computation, the input needs to provide information on two distinct molecules. This is very easy, we just give a Z-matrix or set of Cartesian coordinates for each molecule, and separate the two with two dashes, like this:. [7]:. # Example SAPT computation for ethene*ethyne (*i.e.*, ethylene*acetylene).; # Test case 16 from S22 Database. dimer = psi4.geometry(""""""; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.2322",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:11321,Performance,perform,perform,11321," Y Z mass; O 0.000 0.000 -0.068 15.994915; H 0.000 0.416 0.536 1.007825; H 0.000 -0.416 0.536 1.007825. where the table shows the displacements in the X, Y, and Z dimensions for each atom along the normal mode coordinate. (This information could be used to animate the vibrational frequency using visualization software.); Because the vibrational frequencies are available, a thermodynamics analysis is automatically performed at the end of the computation. You can see this in the next section of the output file output.dat. The vibrational frequencies are sufficient to obtain vibrational contributions to enthalpy (H), entropy (S), and Gibbs free energy (G). Similarly, the molecular geometry is used to obtain rotational constants, which are then used to obtain rotational contributions to H, S, and G.; Note: Psi4 has several synonyms for the functions called in this example. For instance, psi4.frequency() API will compute molecular vibrational frequencies, and psi4.optimize() API will perform a geometry optimization. IV. Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. Psi4 contains code to analyze the nature of intermolecular interactions between two molecules, via symmetry-adapted perturbation theory (SAPT) (Jeziorski:1994:1887). This kind of analysis gives a lot of insight into the nature of intermolecular interactions, and Psi4 makes these computations easier than ever.; For a SAPT computation, the input needs to provide information on two distinct molecules. This is very easy, we just give a Z-matrix or set of Cartesian coordinates for each molecule, and separate the two with two dashes, like this:. [7]:. # Example SAPT computation for ethene*ethyne (*i.e.*, ethylene*acetylene).; # Test case 16 from S22 Database. dimer = psi4.geometry(""""""; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.2322",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:11340,Performance,optimiz,optimization,11340," Y Z mass; O 0.000 0.000 -0.068 15.994915; H 0.000 0.416 0.536 1.007825; H 0.000 -0.416 0.536 1.007825. where the table shows the displacements in the X, Y, and Z dimensions for each atom along the normal mode coordinate. (This information could be used to animate the vibrational frequency using visualization software.); Because the vibrational frequencies are available, a thermodynamics analysis is automatically performed at the end of the computation. You can see this in the next section of the output file output.dat. The vibrational frequencies are sufficient to obtain vibrational contributions to enthalpy (H), entropy (S), and Gibbs free energy (G). Similarly, the molecular geometry is used to obtain rotational constants, which are then used to obtain rotational contributions to H, S, and G.; Note: Psi4 has several synonyms for the functions called in this example. For instance, psi4.frequency() API will compute molecular vibrational frequencies, and psi4.optimize() API will perform a geometry optimization. IV. Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. Psi4 contains code to analyze the nature of intermolecular interactions between two molecules, via symmetry-adapted perturbation theory (SAPT) (Jeziorski:1994:1887). This kind of analysis gives a lot of insight into the nature of intermolecular interactions, and Psi4 makes these computations easier than ever.; For a SAPT computation, the input needs to provide information on two distinct molecules. This is very easy, we just give a Z-matrix or set of Cartesian coordinates for each molecule, and separate the two with two dashes, like this:. [7]:. # Example SAPT computation for ethene*ethyne (*i.e.*, ethylene*acetylene).; # Test case 16 from S22 Database. dimer = psi4.geometry(""""""; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.2322",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:13354,Performance,optimiz,optimize,13354,"0000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; units angstrom; """"""). Here’s the second half of the input, where we specify the computation options:. [8]:. psi4.set_options({'scf_type': 'df',; 'freeze_core': 'true'}). psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). [8]:. -0.0022355825227244703. All of the options we have currently set using psi4.set_options() API are “global” options (meaning that they are visible to all parts of the program). Most common Psi4 options can be set like this. If an option needs to be visible only to one part of the program (e.g., we only want to increase the energy convergence in the SCF code, but not the rest of the code), it can be set by with the; psi4.set_module_options() API function, psi4.set_module_options('scf', {'e_convergence': '1e-8'}).; Note: The arguments to the functions we’ve used so far, like psi4.set_options() API, psi4.set_module_options() API, psi4.energy() API, psi4.optimize(); API, psi4.frequency() API, etc., are case-insensitive.; Back to our SAPT example, we have found that for basic-level SAPT computations (i.e., SAPT0), a good error cancellation is found (Hohenstein:2012:WIREs) with the jun-cc-pVDZ basis (this is the usual aug-cc-pVDZ basis, but without diffuse functions on hydrogen and without diffuse \(d\) functions on heavy atoms) (Papajak:2011:10). So,; we’ll use that as our standard basis set. The SAPT code is designed to use density fitting techniques, because they introduce minimal errors while providing much faster computations (Hohenstein:2010:184111,Hohenstein:2010:014101). Since we’re using density fitting for the SAPT, we might as well also use it for the Hartree-Fock; computations that are performed as part of the SAPT. We can specify that by adding 'scf_type': 'df' to the dictionary passed to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that pair with the primary basis set. Fortunately, Psi4 is us",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:14110,Performance,perform,performed,14110,"the rest of the code), it can be set by with the; psi4.set_module_options() API function, psi4.set_module_options('scf', {'e_convergence': '1e-8'}).; Note: The arguments to the functions we’ve used so far, like psi4.set_options() API, psi4.set_module_options() API, psi4.energy() API, psi4.optimize(); API, psi4.frequency() API, etc., are case-insensitive.; Back to our SAPT example, we have found that for basic-level SAPT computations (i.e., SAPT0), a good error cancellation is found (Hohenstein:2012:WIREs) with the jun-cc-pVDZ basis (this is the usual aug-cc-pVDZ basis, but without diffuse functions on hydrogen and without diffuse \(d\) functions on heavy atoms) (Papajak:2011:10). So,; we’ll use that as our standard basis set. The SAPT code is designed to use density fitting techniques, because they introduce minimal errors while providing much faster computations (Hohenstein:2010:184111,Hohenstein:2010:014101). Since we’re using density fitting for the SAPT, we might as well also use it for the Hartree-Fock; computations that are performed as part of the SAPT. We can specify that by adding 'scf_type': 'df' to the dictionary passed to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that pair with the primary basis set. Fortunately, Psi4 is usually smart enough to figure out what auxiliary basis sets are needed for a given computation. In this case, jun-cc-pVDZ is a standard enough basis set (just a simple truncation of the very popular aug-cc-pVDZ basis set) that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the SAPT; procedure.; To speed up the computation a little, we also tell the SAPT procedure to freeze the core electrons by adding 'freeze_core': 'true' to the dictionary passed to psi4.set_options(). The SAPT procedure is invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here, Psi4 knows to automatically run two monomer comput",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:15125,Performance,perform,perform,15125,"ee-Fock; computations that are performed as part of the SAPT. We can specify that by adding 'scf_type': 'df' to the dictionary passed to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that pair with the primary basis set. Fortunately, Psi4 is usually smart enough to figure out what auxiliary basis sets are needed for a given computation. In this case, jun-cc-pVDZ is a standard enough basis set (just a simple truncation of the very popular aug-cc-pVDZ basis set) that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the SAPT; procedure.; To speed up the computation a little, we also tell the SAPT procedure to freeze the core electrons by adding 'freeze_core': 'true' to the dictionary passed to psi4.set_options(). The SAPT procedure is invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here, Psi4 knows to automatically run two monomer computations and a dimer computation and then use these results to perform the SAPT analysis. The various energy components are printed at the end of the output, in addition to; the total SAPT0 interaction energy. An explanation of the various energy components can be found in the review by Jeziorski, Moszynski, and Szalewicz (Jeziorski:1994:1887), and this is discussed in more detail in the SAPT section of the Psi4 manual.; For now, we’ll note that most of the SAPT energy components are negative; this means those are attractive contributions (the zero of energy in a SAPT computation is defined as non-interacting monomers). The exchange contributions are positive (repulsive). In this example, the most attractive contribution between ethylene and acetylene is an electrostatic term of \(-2.12\) kcal/mol (Elst10,r where the 1 indicates the first-order perturbation theory result with respect to the; intermolecular interaction, and the 0 indicates zeroth-order with respect to the intramolecular electron correla",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:18033,Performance,perform,perform,18033,"derstanding about the; interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as computing the interaction energy between two neon atoms at various interatomic distances. One simple but unappealing way to do this is to generate separate geometries for each distance to be studied. Instead, we can leverage Python loops and string formatting to make our lives simpler. Additionally, let’s suppose you want to do counterpoise (CP) correction to compute interaction energies. Counterpoise correction involves; computing the dimer energy and then subtracting out the energies of the two monomers, each evaluated in the dimer basis. Again, each of these computations could be run in a separate input file, but because counterpoise correction is a fairly standard procedure for intermolecular interactions, Psi4 knows about it and has a built-in routine to perform counterpoise correction. It only needs to know what method you want to do the couterpoise correction on (here, let’s consider CCSD(T)), and it needs; to know what’s monomer A and what’s monomer B. This last issue of specifying the monomers separately was already dealt with in the previous SAPT example, where we saw that two dashes in the psi4.geometry() string can be used to separate monomers.; So, we’re going to do counterpoise-corrected CCSD(T) energies for Ne\(_2\) at a series of different interatomic distances. And let’s print out a table of the interatomic distances we’ve considered, and the CP-corrected CCSD(T) interaction energies (in kcal/mol) at each geometry:. [9]:. #! Example potential energy surface scan and CP-correction for Ne2. ne2_geometry = """"""; Ne; --; Ne 1 {0}; """""". Rvals = [2.5, 3.0, 4.0]. psi4.set_options({'freeze_core': 'true'}). # Initialize a blank dictionary ",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:20938,Performance,perform,perform,20938,"st, you can see the geometry string ne2_geometry has a two dashes to separate the monomers from each other. Also note we’ve used a Z-matrix to specify the geometry, and we’ve used a variable (R) as the interatomic distance. We have not specified the value of R in the ne2_geometry string like we normally would. That’s because we are going to vary it during the scan across the potential energy surface, by using a Python loop over the list of interatomic distances Rvals.; Before we are able to pass our molecule to Psi4, we need to do two things. First, we must set the value of the intermolecular separation in our Z-matrix (by using Python 3 string formatting) to the particular value of R. Second, we need to turn the Z-matrix string into a Psi4 molecule, by passing it to `psi4.geometry() <http://psicode.org/psi4manual/master/api/psi4.driver.geometry.html#psi4.driver.geometry>`__. The; argument bsse_type='cp' tells Psi4 to perform counterpoise (CP) correction on the dimer to compute the CCSD(T)/aug-cc-pVDZ interaction energy, which is stored in our ecp dictionary at each iteration of our Python loop. Note that we didn’t need to specify ghost atoms, and we didn’t need to call the monomer and dimer computations separately. Psi4 does it all for us, automatically.; Near the very end of the output file output.dat, the counterpoise correction Python function will print a nice summary of the results of the counterpoise computation (the energies of the dimer, of monomer 1 with the ghost functions of monomer 2, of monomer 2 with the ghost functions of monomer 1, and the overall counterpoise corrected interaction energy):; N-Body: Computing complex (1/2) with fragments (2,) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (2,), basis = (1, 2): -128.70932405488924); ...; N-Body: Computing complex (2/2) with fragments (1,) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (1,), basis = (1, 2): -128.70932405488935); ...; N-Body: Co",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:9340,Security,access,access,9340,"----------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s important to keep in mind that the values of the vibrational frequencies are a function of the molecular geometry. Therefore, it’s important to obtain the vibrational frequencies AT THE OPTIMIZED GEOMETRY. Luckily, Psi4 updates the molecule with optimized geometry as it is being optimized. So, the optimized geometry for H\(_2\)O is stored inside the h2o molecule object, which we can access! To compute the frequencies, all we need to do; is to again pass the molecule=h2o argument to the psi4.frequency() API function:. [6]:. scf_e, scf_wfn = psi4.frequency('scf/cc-pvdz', molecule=h2o, return_wfn=True). 6 displacements needed.; 1 2 3 4 5 6. Executing this cell will prompt Psi4 to compute the Hessian (second derivative matrix) of the electronic energy with respect to nuclear displacements. From this, it can obtain the harmonic vibrational frequencies, given below (roundoff errors of around \(0.1\) cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2). The program also print out the normal modes in terms of Cartesian coordinates of each atom. For example, the normal mode at \(1776\) cm\(^{-1}\) is:; Frequency: 1775.65; Force constant: 0.1193; X Y Z mass; O 0.000 0",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:4284,Usability,simpl,simple,4284,"the cc-pVDZ basis set by passing the method/basis set as a string ('scf/cc-pvdz') into the function psi4.energy(); API:. [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). [3]:. -76.02663273488399. If everything goes well, the computation should complete and should report a final restricted Hartree-Fock energy in the output file output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about \(1.0\times 10^{-6}\), so agreement is only expected for about the first 6 digits after the decimal. If the computation does not complete, there is probably a problem with the compilation or installation of the program (see the installation instructions in the main Psi4 manual section :psicode:[Compiling and Installing from Source] <psi4manual/master/build_planning.html> .; This very simple input is sufficient to run the requested information. Notice we didn’t tell the program some otherwise useful information like the charge of the molecule (0, it’s neutral), the spin multiplicity (1 for a closed-shell molecule with all electrons paired), or the reference wavefunction to use (restricted Hartree-Fock, or RHF, is usually appropriate for a closed-shell molecule). The program correctly guessed all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not all the electrons are paired. For example, let’s run a computation on methylene (\(\text{CH}_2\)), whose ground electronic state has two unpaired electrons (triplet electronic state, or a spin multiplicity \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is not correct, so we need to tell the program the true value (3). Like many programs, Psi4 can get the charge and multiplicity as the first two; integers in the Z-matrix (n",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:6521,Usability,simpl,simple,6521,"red and then inserted into the geometry specification using Python 3 string formatting. [4]:. #! Sample UHF/6-31G** CH2 Computation. R = 1.075; A = 133.93. ch2 = psi4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). [4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options() API, to the input. This function takes a Python dictionary as its argument, which is a key-value list which associates a Psi4 keyword with its user-defined value. For open shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree-Fock, or UHF) or restricted orbitals (restricted open-shell Hartree-Fock, or ROHF). Usually, UHF is a little easier to converge (although it may be more susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as specified by the psi4.energy() API function). Of course there are other kinds of computations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:.",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:14525,Usability,simpl,simple,14525," (this is the usual aug-cc-pVDZ basis, but without diffuse functions on hydrogen and without diffuse \(d\) functions on heavy atoms) (Papajak:2011:10). So,; we’ll use that as our standard basis set. The SAPT code is designed to use density fitting techniques, because they introduce minimal errors while providing much faster computations (Hohenstein:2010:184111,Hohenstein:2010:014101). Since we’re using density fitting for the SAPT, we might as well also use it for the Hartree-Fock; computations that are performed as part of the SAPT. We can specify that by adding 'scf_type': 'df' to the dictionary passed to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that pair with the primary basis set. Fortunately, Psi4 is usually smart enough to figure out what auxiliary basis sets are needed for a given computation. In this case, jun-cc-pVDZ is a standard enough basis set (just a simple truncation of the very popular aug-cc-pVDZ basis set) that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the SAPT; procedure.; To speed up the computation a little, we also tell the SAPT procedure to freeze the core electrons by adding 'freeze_core': 'true' to the dictionary passed to psi4.set_options(). The SAPT procedure is invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here, Psi4 knows to automatically run two monomer computations and a dimer computation and then use these results to perform the SAPT analysis. The various energy components are printed at the end of the output, in addition to; the total SAPT0 interaction energy. An explanation of the various energy components can be found in the review by Jeziorski, Moszynski, and Szalewicz (Jeziorski:1994:1887), and this is discussed in more detail in the SAPT section of the Psi4 manual.; For now, we’ll note that most of the SAPT energy components are negative; this means those are attractive contribut",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:17357,Usability,simpl,simple,17357,"r this example has the acetylene perpendicular to; the ethylene, with the acetylene hydrogen pointing directly at the double bond in ethylene; this will be attractive because the H atoms in acetylene bear a partial positive charge, while the electron rich double bond in ethylene bears a partial negative charge. At the same time, the dispersion interaction should be smaller because the perpendicular geometry does not allow much overlap between the monomers. Hence, the SAPT analysis helps clarify (and quantify) our physical understanding about the; interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as computing the interaction energy between two neon atoms at various interatomic distances. One simple but unappealing way to do this is to generate separate geometries for each distance to be studied. Instead, we can leverage Python loops and string formatting to make our lives simpler. Additionally, let’s suppose you want to do counterpoise (CP) correction to compute interaction energies. Counterpoise correction involves; computing the dimer energy and then subtracting out the energies of the two monomers, each evaluated in the dimer basis. Again, each of these computations could be run in a separate input file, but because counterpoise correction is a fairly standard procedure for intermolecular interactions, Psi4 knows about it and has a built-in routine to perform counterpoise correction. It only needs to know what method you want to do the couterpoise correction on (here, let’s consider CCSD(T)), and it needs; to know what’s monomer A and what’s monomer B. This last issue of specifying the monomers separately was already dealt with in the previous SAPT example, where we saw that two dashes in the psi4.geometry() string can",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psiapi.html:17541,Usability,simpl,simpler,17541,"ing directly at the double bond in ethylene; this will be attractive because the H atoms in acetylene bear a partial positive charge, while the electron rich double bond in ethylene bears a partial negative charge. At the same time, the dispersion interaction should be smaller because the perpendicular geometry does not allow much overlap between the monomers. Hence, the SAPT analysis helps clarify (and quantify) our physical understanding about the; interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as computing the interaction energy between two neon atoms at various interatomic distances. One simple but unappealing way to do this is to generate separate geometries for each distance to be studied. Instead, we can leverage Python loops and string formatting to make our lives simpler. Additionally, let’s suppose you want to do counterpoise (CP) correction to compute interaction energies. Counterpoise correction involves; computing the dimer energy and then subtracting out the energies of the two monomers, each evaluated in the dimer basis. Again, each of these computations could be run in a separate input file, but because counterpoise correction is a fairly standard procedure for intermolecular interactions, Psi4 knows about it and has a built-in routine to perform counterpoise correction. It only needs to know what method you want to do the couterpoise correction on (here, let’s consider CCSD(T)), and it needs; to know what’s monomer A and what’s monomer B. This last issue of specifying the monomers separately was already dealt with in the previous SAPT example, where we saw that two dashes in the psi4.geometry() string can be used to separate monomers.; So, we’re going to do counterpoise-corrected CCSD(T) energies for N",MatchSource.WIKI,psi4manual/1.6.x/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html
https://psicode.org/psi4manual/1.6.x/psimrcc.html:5567,Availability,avail,available,5567,"totally-symmetric state. The FOLLOW_ROOT option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; follow_root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are available to place into; the active space (given by active), which consists of 2 orbitals.; Thus there are two active electrons in two orbitals. In this particular; example, we are using standard ROHF orbitals for the Mk-MRCCSD procedure,; rather than TCSCF orbitals. Nevertheless, with the present code,; these orbitals must be provided through the MCSCF module, as specified in the; set mcscf section above. Orbital ordering and selection of the model space¶; The reference determinants \(\Phi_\mu\) are specified in PSIMRCC; via occupational numbers. PSIMRCC requires that four arrays be specified; for this purpose. Frozen doubly occupied orbitals (FROZEN_DOCC) are doubly; occupied in each reference determinant and are not correlated in the; MRCC procedure.; Doubly occupied orbitals (RESTRICTED_DOCC) are doubly; occupied in each reference determinant and are correlated in the MRCC; procedure.; Active orbitals (ACTIVE) are partially occupied in each; reference determinant.; Frozen virtual orbitals (FROZEN_UOCC) are unoc",MatchSource.WIKI,psi4manual/1.6.x/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psimrcc.html
https://psicode.org/psi4manual/1.6.x/psimrcc.html:2784,Deployability,configurat,configuration,2784,"he Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian,; \(\textrm{H}^{eff}_{\mu \nu}\). \[\sum_\nu \textrm{H}^{eff}_{\mu \nu} c_\nu =E c_\nu\]; where. \[\textrm{H}^{eff}_{\mu \nu} = \left \langle \Phi_\mu \right | \hat{H}e^{\hat{T}^\nu} \left | \Phi_\nu \right \rangle \, \textrm{.}\]; PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCS",MatchSource.WIKI,psi4manual/1.6.x/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psimrcc.html
https://psicode.org/psi4manual/1.6.x/psimrcc.html:3404,Deployability,configurat,configuration,3404,"ch all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with",MatchSource.WIKI,psi4manual/1.6.x/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psimrcc.html
https://psicode.org/psi4manual/1.6.x/psimrcc.html:3497,Deployability,configurat,configuration,3497,"ch all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with",MatchSource.WIKI,psi4manual/1.6.x/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psimrcc.html
https://psicode.org/psi4manual/1.6.x/psimrcc.html:8217,Deployability,update,updated,8217," not correlated in the; MRCC procedure.; Doubly occupied orbitals (RESTRICTED_DOCC) are doubly; occupied in each reference determinant and are correlated in the MRCC; procedure.; Active orbitals (ACTIVE) are partially occupied in each; reference determinant.; Frozen virtual orbitals (FROZEN_UOCC) are unoccupied in; all reference determinants and are excluded from the correlated wave; function. The model space is selected by considering all possible occupations; of the electrons among the orbitals in the active space that result; in determinants with the correct symmetry (WFN_SYM); and the correct \(\textrm{M}_s\) value specified by the keyword; CORR_MULTP. Note that this does not consider the multiplicity; of the wavefunction. Thus, in order to obtain the wavefunction; with a set of \(\textrm{M}_s = 0\) reference determinants for; an open-shell system you should request a CORR_MULTP of; 1 within the PSIMRCC module, and select the root of the effective; Hamiltonian that corresponds to the state of interest. In addition,; the WFN_SYM keyword needs to be specified otherwise the; wavefunction belonging to the all-symmetric irrep will be selected. In; addition, it should be noted that for an open-shell singlet based; on two \(\textrm{M}_s = 0\) determinants the eigenvector is; [\(\frac{1}{\sqrt{2}}\text{,}\frac{1}{\sqrt{2}}\)], which corresponds; to a wavefunction of the following form:. \[\frac{1}{\sqrt{2}} \left( \chi_1 \alpha (1) \chi_2 \beta (2) + \chi_2 \alpha(1) \chi_1 \beta (2) \right)\]; See Appendix PSIMRCC for a complete list of PSIMRCC options. table of contents. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; PSIMRCC Implementation of Mk-MRCC Theory. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psimrcc.html
https://psicode.org/psi4manual/1.6.x/psimrcc.html:756,Energy Efficiency,power,powerful,756,"﻿. PSIMRCC Implementation of Mk-MRCC Theory. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; PSIMRCC Implementation of Mk-MRCC Theory. PSIMRCC Implementation of Mk-MRCC Theory¶; Code author: Francesco A. Evangelista and Andrew C. Simmonett; Section author: Alexander E. Vaughn; Module: Keywords, PSI Variables, PSIMRCC; State-specific Multireference coupled cluster theories provide highly; accurate energies and properties of electronic states that require; a multiconfigurational zeroth-order wavefunction. The PSIMRCC; module contained in PSI4 implements the state-specific; multireference coupled-cluster approach of Mukherjee and co-workers; (Mk-MRCC). This method is implemented and shown to be a powerful tool in; [Evangelista:2006:154113] and [Evangelista:2008:124104]. Mk-MRCC is; based on the Jeziorski-Monkhorst ansatz [Jeziorski:1981:1668] for the; wavefunction, \(\Psi\). \[\left| \Psi \right \rangle = \sum_\mu^d e^{\hat{T}^\mu} \left| \Phi_\mu \right\rangle c_\mu \, \text{,}\]; where \(\Phi_\mu\) are the reference determinants,; \(\hat{T}^\mu\) are reference-specific excitation operators, and; \(c_\mu\) are expansion coefficients obtained through diagonalization; of the Mk-MRCC effective Hamiltonian matrix that allows the various; reference determinants to interact. As an example of how this works; the Mk-MRCCSD excitation operators for each reference is contracted; two-body terms. \[\hat{T}^\mu = \hat{T}^\mu_1 + \hat{T}^\mu_2\]; where. \[\hat{T}^\mu_1 = \sum_i^{\textrm{occ}(\mu)} \sum_a^{\textrm{vir}(\mu)} t_i^a (\mu) \hat{a}^\dagger_a \hat{a}_i\]; and. \[\hat{T}^\mu_2 =\frac{1}{4} \sum_i^{\textrm{occ}(\mu)} \sum_a^{\textrm{vir}(\mu)} t_{ij}^{ab} (\mu) \hat{a}^\dagger_b \hat{a}_j \hat{a}^\dagger_a \hat{a}_i\]; The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian,; \(\textrm{H}^{eff}_{\mu \nu}\). \[\sum_\nu \textrm{H}^{eff}_{\mu \nu} c_\nu =E c_\nu\]; where. \[\textrm{H}^{eff}_{\mu \nu} = \left \",MatchSource.WIKI,psi4manual/1.6.x/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psimrcc.html
https://psicode.org/psi4manual/1.6.x/psimrcc.html:1807,Energy Efficiency,energy,energy,1807,"ool in; [Evangelista:2006:154113] and [Evangelista:2008:124104]. Mk-MRCC is; based on the Jeziorski-Monkhorst ansatz [Jeziorski:1981:1668] for the; wavefunction, \(\Psi\). \[\left| \Psi \right \rangle = \sum_\mu^d e^{\hat{T}^\mu} \left| \Phi_\mu \right\rangle c_\mu \, \text{,}\]; where \(\Phi_\mu\) are the reference determinants,; \(\hat{T}^\mu\) are reference-specific excitation operators, and; \(c_\mu\) are expansion coefficients obtained through diagonalization; of the Mk-MRCC effective Hamiltonian matrix that allows the various; reference determinants to interact. As an example of how this works; the Mk-MRCCSD excitation operators for each reference is contracted; two-body terms. \[\hat{T}^\mu = \hat{T}^\mu_1 + \hat{T}^\mu_2\]; where. \[\hat{T}^\mu_1 = \sum_i^{\textrm{occ}(\mu)} \sum_a^{\textrm{vir}(\mu)} t_i^a (\mu) \hat{a}^\dagger_a \hat{a}_i\]; and. \[\hat{T}^\mu_2 =\frac{1}{4} \sum_i^{\textrm{occ}(\mu)} \sum_a^{\textrm{vir}(\mu)} t_{ij}^{ab} (\mu) \hat{a}^\dagger_b \hat{a}_j \hat{a}^\dagger_a \hat{a}_i\]; The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian,; \(\textrm{H}^{eff}_{\mu \nu}\). \[\sum_\nu \textrm{H}^{eff}_{\mu \nu} c_\nu =E c_\nu\]; where. \[\textrm{H}^{eff}_{\mu \nu} = \left \langle \Phi_\mu \right | \hat{H}e^{\hat{T}^\nu} \left | \Phi_\nu \right \rangle \, \textrm{.}\]; PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; compl",MatchSource.WIKI,psi4manual/1.6.x/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psimrcc.html
https://psicode.org/psi4manual/1.6.x/psimrcc.html:3336,Energy Efficiency,energy,energy,3336,"74107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high",MatchSource.WIKI,psi4manual/1.6.x/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psimrcc.html
https://psicode.org/psi4manual/1.6.x/psimrcc.html:4581,Energy Efficiency,energy,energy,4581,"ecifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with a particular \(M_s\) value. The WFN_SYM; keyword is neccesary if you do not want to compute the energy of the; totally-symmetric state. The FOLLOW_ROOT option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; follow_root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are",MatchSource.WIKI,psi4manual/1.6.x/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psimrcc.html
https://psicode.org/psi4manual/1.6.x/psimrcc.html:4784,Energy Efficiency,energy,energy,4784,"rbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with a particular \(M_s\) value. The WFN_SYM; keyword is neccesary if you do not want to compute the energy of the; totally-symmetric state. The FOLLOW_ROOT option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; follow_root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are available to place into; the active space (given by active), which consists of 2 orbitals.; Thus there are two active electrons in two orbitals. In this particular; example, we are using standard ROHF or",MatchSource.WIKI,psi4manual/1.6.x/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psimrcc.html
https://psicode.org/psi4manual/1.6.x/psimrcc.html:5370,Energy Efficiency,energy,energy,5370,"d matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with a particular \(M_s\) value. The WFN_SYM; keyword is neccesary if you do not want to compute the energy of the; totally-symmetric state. The FOLLOW_ROOT option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; follow_root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are available to place into; the active space (given by active), which consists of 2 orbitals.; Thus there are two active electrons in two orbitals. In this particular; example, we are using standard ROHF orbitals for the Mk-MRCCSD procedure,; rather than TCSCF orbitals. Nevertheless, with the present code,; these orbitals must be provided through the MCSCF module, as specified in the; set mcscf section above. Orbital ordering and selection of the model space¶; The reference determinants \(\Phi_\mu\) are specified in PSIMRCC; via occupational numbers. PSI",MatchSource.WIKI,psi4manual/1.6.x/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psimrcc.html
https://psicode.org/psi4manual/1.6.x/psimrcc.html:1431,Integrability,contract,contracted,1431,"nce coupled cluster theories provide highly; accurate energies and properties of electronic states that require; a multiconfigurational zeroth-order wavefunction. The PSIMRCC; module contained in PSI4 implements the state-specific; multireference coupled-cluster approach of Mukherjee and co-workers; (Mk-MRCC). This method is implemented and shown to be a powerful tool in; [Evangelista:2006:154113] and [Evangelista:2008:124104]. Mk-MRCC is; based on the Jeziorski-Monkhorst ansatz [Jeziorski:1981:1668] for the; wavefunction, \(\Psi\). \[\left| \Psi \right \rangle = \sum_\mu^d e^{\hat{T}^\mu} \left| \Phi_\mu \right\rangle c_\mu \, \text{,}\]; where \(\Phi_\mu\) are the reference determinants,; \(\hat{T}^\mu\) are reference-specific excitation operators, and; \(c_\mu\) are expansion coefficients obtained through diagonalization; of the Mk-MRCC effective Hamiltonian matrix that allows the various; reference determinants to interact. As an example of how this works; the Mk-MRCCSD excitation operators for each reference is contracted; two-body terms. \[\hat{T}^\mu = \hat{T}^\mu_1 + \hat{T}^\mu_2\]; where. \[\hat{T}^\mu_1 = \sum_i^{\textrm{occ}(\mu)} \sum_a^{\textrm{vir}(\mu)} t_i^a (\mu) \hat{a}^\dagger_a \hat{a}_i\]; and. \[\hat{T}^\mu_2 =\frac{1}{4} \sum_i^{\textrm{occ}(\mu)} \sum_a^{\textrm{vir}(\mu)} t_{ij}^{ab} (\mu) \hat{a}^\dagger_b \hat{a}_j \hat{a}^\dagger_a \hat{a}_i\]; The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian,; \(\textrm{H}^{eff}_{\mu \nu}\). \[\sum_\nu \textrm{H}^{eff}_{\mu \nu} c_\nu =E c_\nu\]; where. \[\textrm{H}^{eff}_{\mu \nu} = \left \langle \Phi_\mu \right | \hat{H}e^{\hat{T}^\nu} \left | \Phi_\nu \right \rangle \, \textrm{.}\]; PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4",MatchSource.WIKI,psi4manual/1.6.x/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psimrcc.html
https://psicode.org/psi4manual/1.6.x/psimrcc.html:2784,Modifiability,config,configuration,2784,"he Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian,; \(\textrm{H}^{eff}_{\mu \nu}\). \[\sum_\nu \textrm{H}^{eff}_{\mu \nu} c_\nu =E c_\nu\]; where. \[\textrm{H}^{eff}_{\mu \nu} = \left \langle \Phi_\mu \right | \hat{H}e^{\hat{T}^\nu} \left | \Phi_\nu \right \rangle \, \textrm{.}\]; PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCS",MatchSource.WIKI,psi4manual/1.6.x/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psimrcc.html
https://psicode.org/psi4manual/1.6.x/psimrcc.html:3404,Modifiability,config,configuration,3404,"ch all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with",MatchSource.WIKI,psi4manual/1.6.x/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psimrcc.html
https://psicode.org/psi4manual/1.6.x/psimrcc.html:3497,Modifiability,config,configuration,3497,"ch all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with",MatchSource.WIKI,psi4manual/1.6.x/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psimrcc.html
https://psicode.org/psi4manual/1.6.x/psimrcc.html:3128,Performance,perform,perform,3128,"k-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required ",MatchSource.WIKI,psi4manual/1.6.x/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psimrcc.html
https://psicode.org/psi4manual/1.6.x/psimrcc.html:3144,Performance,optimiz,optimization,3144,"k-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required ",MatchSource.WIKI,psi4manual/1.6.x/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psimrcc.html
https://psicode.org/psi4manual/1.6.x/psimrcc.html:3296,Performance,optimiz,optimized,3296,"74107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high",MatchSource.WIKI,psi4manual/1.6.x/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psimrcc.html
